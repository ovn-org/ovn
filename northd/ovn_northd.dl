/*
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at:
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import OVN_Northbound as nb
import OVN_Southbound as sb
import copp
import ovsdb
import allocate
import ovn
import lswitch
import lrouter
import multicast
import helpers
import ipam
import vec
import set

index Logical_Flow_Index() on sb::Out_Logical_Flow()

/* Meter_Band table */
for (mb in nb::Meter_Band) {
    sb::Out_Meter_Band(._uuid = mb._uuid,
                      .action = mb.action,
                      .rate = mb.rate,
                      .burst_size = mb.burst_size)
}

/* Meter table */
for (meter in &nb::Meter) {
    sb::Out_Meter(._uuid = meter._uuid,
                 .name = meter.name,
                 .unit = meter.unit,
                 .bands = meter.bands)
}
sb::Out_Meter(._uuid = hash128(name),
              .name = name,
              .unit = meter.unit,
              .bands = meter.bands) :-
    ACLWithFairMeter(acl, meter),
    var name = acl_log_meter_name(meter.name, acl._uuid).intern().

/* Proxy table for Out_Datapath_Binding: contains all Datapath_Binding fields,
 * except tunnel id, which is allocated separately (see TunKeyAllocation). */
relation OutProxy_Datapath_Binding (
    _uuid: uuid,
    external_ids: Map<istring,istring>
)

/* Datapath_Binding table */
OutProxy_Datapath_Binding(uuid, external_ids) :-
    &nb::Logical_Switch(._uuid = uuid, .name = name, .external_ids = ids,
                       .other_config = other_config),
    var uuid_str = uuid2str(uuid).intern(),
    var external_ids = {
        var eids = [i"logical-switch" -> uuid_str, i"name" -> name];
        match (ids.get(i"neutron:network_name")) {
            None -> (),
            Some{nnn} -> eids.insert(i"name2", nnn)
        };
        match (other_config.get(i"interconn-ts")) {
            None -> (),
            Some{value} -> eids.insert(i"interconn-ts", value)
        };
        eids
    }.

OutProxy_Datapath_Binding(uuid, external_ids) :-
    lr in nb::Logical_Router(._uuid = uuid, .name = name, .external_ids = ids,
                             .options = options),
    lr.is_enabled(),
    var uuid_str = uuid2str(uuid).intern(),
    var external_ids = {
        var eids = [i"logical-router" -> uuid_str, i"name" -> name];
        match (ids.get(i"neutron:router_name")) {
            None -> (),
            Some{nnn} -> eids.insert(i"name2", nnn)
        };
        match (options.get(i"snat-ct-zone").and_then(parse_dec_u64)) {
            None -> (),
            Some{zone} -> eids.insert(i"snat-ct-zone", i"${zone}")
        };
        var learn_from_arp_request = options.get_bool_def(i"always_learn_from_arp_request", true);
        if (not learn_from_arp_request) {
            eids.insert(i"always_learn_from_arp_request", i"false")
        };
        eids
    }.

sb::Out_Datapath_Binding(uuid, tunkey, load_balancers, external_ids) :-
    OutProxy_Datapath_Binding(uuid, external_ids),
    TunKeyAllocation(uuid, tunkey),
    /* Datapath_Binding.load_balancers is not used anymore, it's still in the
     * schema for compatibility reasons.  Reset it to empty, just in case.
     */
    var load_balancers = set_empty().

function get_requested_chassis(options: Map<istring,istring>) : istring = {
    var requested_chassis = match(options.get(i"requested-chassis")) {
        None -> i"",
        Some{requested_chassis} -> requested_chassis,
    };
    requested_chassis
}

relation RequestedChassis(
    name: istring,
    chassis: uuid,
)
RequestedChassis(name, chassis) :-
    sb::Chassis(._uuid = chassis, .name=name).
RequestedChassis(hostname, chassis) :-
    sb::Chassis(._uuid = chassis, .hostname=hostname).

/* Proxy table for Out_Datapath_Binding: contains all Datapath_Binding fields,
 * except tunnel id, which is allocated separately (see PortTunKeyAllocation). */
relation OutProxy_Port_Binding (
    _uuid: uuid,
    logical_port: istring,
    __type: istring,
    gateway_chassis: Set<uuid>,
    ha_chassis_group: Option<uuid>,
    options: Map<istring,istring>,
    datapath: uuid,
    parent_port: Option<istring>,
    tag: Option<integer>,
    mac: Set<istring>,
    nat_addresses: Set<istring>,
    external_ids: Map<istring,istring>,
    requested_chassis: Option<uuid>
)

/* Case 1a: Create a Port_Binding per logical switch port that is not of type
 * "router" */
OutProxy_Port_Binding(._uuid              = lsp._uuid,
                      .logical_port       = lsp.name,
                      .__type             = lsp.__type,
                      .gateway_chassis    = set_empty(),
                      .ha_chassis_group   = sp.hac_group_uuid,
                      .options            = options,
                      .datapath           = sw._uuid,
                      .parent_port        = lsp.parent_name,
                      .tag                = tag,
                      .mac                = lsp.addresses,
                      .nat_addresses      = set_empty(),
                      .external_ids       = eids,
                      .requested_chassis  = None) :-
    sp in &SwitchPort(.lsp = lsp, .sw = sw),
    SwitchPortNewDynamicTag(lsp._uuid, opt_tag),
    var tag = match (opt_tag) {
        None -> lsp.tag,
        Some{t} -> Some{t}
    },
    lsp.__type != i"router",
    var chassis_name_or_hostname = get_requested_chassis(lsp.options),
    chassis_name_or_hostname == i"",
    var eids = {
        var eids = lsp.external_ids;
        match (lsp.external_ids.get(i"neutron:port_name")) {
            None -> (),
            Some{name} -> eids.insert(i"name", name)
        };
        eids
    },
    var options = {
        var options = lsp.options;
        if (sw.other_config.get(i"vlan-passthru") == Some{i"true"}) {
            options.insert(i"vlan-passthru", i"true")
        };
        options
    }.

/* Case 1b: Create a Port_Binding per logical switch port that is not of type
 * "router" and has options "requested-chassis" pointing at chassis name or
 * hostname. */
OutProxy_Port_Binding(._uuid              = lsp._uuid,
                      .logical_port       = lsp.name,
                      .__type             = lsp.__type,
                      .gateway_chassis    = set_empty(),
                      .ha_chassis_group   = sp.hac_group_uuid,
                      .options            = options,
                      .datapath           = sw._uuid,
                      .parent_port        = lsp.parent_name,
                      .tag                = tag,
                      .mac                = lsp.addresses,
                      .nat_addresses      = set_empty(),
                      .external_ids       = eids,
                      .requested_chassis  = Some{requested_chassis}) :-
    sp in &SwitchPort(.lsp = lsp, .sw = sw),
    SwitchPortNewDynamicTag(lsp._uuid, opt_tag),
    var tag = match (opt_tag) {
        None -> lsp.tag,
        Some{t} -> Some{t}
    },
    lsp.__type != i"router",
    var chassis_name_or_hostname = get_requested_chassis(lsp.options),
    chassis_name_or_hostname != i"",
    RequestedChassis(chassis_name_or_hostname, requested_chassis),
    var eids = {
        var eids = lsp.external_ids;
        match (lsp.external_ids.get(i"neutron:port_name")) {
            None -> (),
            Some{name} -> eids.insert(i"name", name)
        };
        eids
    },
    var options = {
        var options = lsp.options;
        if (sw.other_config.get(i"vlan-passthru") == Some{i"true"}) {
            options.insert(i"vlan-passthru", i"true")
        };
        options
    }.

/* Case 1c: Create a Port_Binding per logical switch port that is not of type
 * "router" and has options "requested-chassis" pointing at non-existent
 * chassis name or hostname. */
OutProxy_Port_Binding(._uuid              = lsp._uuid,
                      .logical_port       = lsp.name,
                      .__type             = lsp.__type,
                      .gateway_chassis    = set_empty(),
                      .ha_chassis_group   = sp.hac_group_uuid,
                      .options            = options,
                      .datapath           = sw._uuid,
                      .parent_port        = lsp.parent_name,
                      .tag                = tag,
                      .mac                = lsp.addresses,
                      .nat_addresses      = set_empty(),
                      .external_ids       = eids,
                      .requested_chassis  = None) :-
    sp in &SwitchPort(.lsp = lsp, .sw = sw),
    SwitchPortNewDynamicTag(lsp._uuid, opt_tag),
    var tag = match (opt_tag) {
        None -> lsp.tag,
        Some{t} -> Some{t}
    },
    lsp.__type != i"router",
    var chassis_name_or_hostname = get_requested_chassis(lsp.options),
    chassis_name_or_hostname != i"",
    not RequestedChassis(chassis_name_or_hostname, _),
    var eids = {
        var eids = lsp.external_ids;
        match (lsp.external_ids.get(i"neutron:port_name")) {
            None -> (),
            Some{name} -> eids.insert(i"name", name)
        };
        eids
    },
    var options = {
        var options = lsp.options;
        if (sw.other_config.get(i"vlan-passthru") == Some{i"true"}) {
            options.insert(i"vlan-passthru", i"true")
        };
        options
    }.

relation SwitchPortLBIPs(
    port: Intern<SwitchPort>,
    lbips: Option<Intern<LogicalRouterLBIPs>>)

SwitchPortLBIPs(.port = port,
                .lbips = Some{lbips}) :-
    port in &SwitchPort(.peer = Some{peer}),
    port.lsp.options.get(i"router-port").is_some(),
    lbips in &LogicalRouterLBIPs(.lr = peer.router._uuid).

SwitchPortLBIPs(.port = port,
                .lbips = None) :-
    port in &SwitchPort(.peer = peer),
    peer.is_none() or port.lsp.options.get(i"router-port").is_none().

/* Case 2: Create a Port_Binding per logical switch port of type "router" */
OutProxy_Port_Binding(._uuid              = lsp._uuid,
                      .logical_port       = lsp.name,
                      .__type             = __type,
                      .gateway_chassis    = set_empty(),
                      .ha_chassis_group   = None,
                      .options            = options,
                      .datapath           = sw._uuid,
                      .parent_port        = lsp.parent_name,
                      .tag                = None,
                      .mac                = lsp.addresses,
                      .nat_addresses      = nat_addresses,
                      .external_ids       = eids,
                      .requested_chassis  = None) :-
    SwitchPortLBIPs(.port = &SwitchPort{.lsp = lsp, .sw = sw, .peer = peer},
                    .lbips = lbips),
    var eids = {
        var eids = lsp.external_ids;
        match (lsp.external_ids.get(i"neutron:port_name")) {
            None -> (),
            Some{name} -> eids.insert(i"name", name)
        };
        eids
    },
    Some{var router_port} = lsp.options.get(i"router-port"),
    var opt_chassis = peer.and_then(|p| p.router.options.get(i"chassis")),
    var l3dgw_port = peer.and_then(|p| p.router.l3dgw_ports.nth(0)),
    (var __type, var options) = {
        var options = [i"peer" -> router_port];
        match (opt_chassis) {
            None -> {
                (i"patch", options)
            },
            Some{chassis} -> {
                options.insert(i"l3gateway-chassis", chassis);
                (i"l3gateway", options)
            }
        }
    },
    var base_nat_addresses = {
        match (lsp.options.get(i"nat-addresses")) {
            None -> { set_empty() },
            Some{nat_addresses} -> {
                if (nat_addresses == i"router") {
                    match ((l3dgw_port, opt_chassis, peer)) {
                       (None, None, _) -> set_empty(),
                       (_, _, None) -> set_empty(),
                       (_, _, Some{rport}) -> get_nat_addresses(rport, lbips.unwrap_or_default(), false)
                    }
                } else {
                    /* Only accept manual specification of ethernet address
                     * followed by IPv4 addresses on type "l3gateway" ports. */
                    if (opt_chassis.is_some()) {
                        match (extract_lsp_addresses(nat_addresses.ival())) {
                            None -> {
                                warn("Error extracting nat-addresses.");
                                set_empty()
                            },
                            Some{_} -> { set_singleton(nat_addresses) }
                        }
                    } else { set_empty() }
                }
            }
        }
    },
    /* Add the router mac and IPv4 addresses to
     * Port_Binding.nat_addresses so that GARP is sent for these
     * IPs by the ovn-controller on which the distributed gateway
     * router port resides if:
     *
     * 1. The peer has 'reside-on-redirect-chassis' set and the
     *    the logical router datapath has distributed router port.
     *
     * 2. The peer is distributed gateway router port.
     *
     * 3. The peer's router is a gateway router and the port has a localnet
     *    port.
     *
     * Note: Port_Binding.nat_addresses column is also used for
     * sending the GARPs for the router port IPs.
     * */
    var garp_nat_addresses = match (peer) {
        Some{rport} -> match (
            (rport.lrp.options.get_bool_def(i"reside-on-redirect-chassis", false)
             and l3dgw_port.is_some()) or
            rport.is_redirect or
            (rport.router.options.contains_key(i"chassis") and
             not sw.localnet_ports.is_empty())) {
            false -> set_empty(),
            true -> set_singleton(get_garp_nat_addresses(rport).intern())
        },
        None -> set_empty()
    },
    var nat_addresses = set_union(base_nat_addresses, garp_nat_addresses).

/* Case 3: Port_Binding per logical router port */
OutProxy_Port_Binding(._uuid              = lrp._uuid,
                      .logical_port       = lrp.name,
                      .__type             = __type,
                      .gateway_chassis    = set_empty(),
                      .ha_chassis_group   = None,
                      .options            = options,
                      .datapath           = router._uuid,
                      .parent_port        = None,
                      .tag                = None, // always empty for router ports
                      .mac                = set_singleton(i"${lrp.mac} ${lrp.networks.map(ival).to_vec().join(\" \")}"),
                      .nat_addresses      = set_empty(),
                      .external_ids       = lrp.external_ids,
                      .requested_chassis  = None) :-
    rp in &RouterPort(.lrp = lrp, .router = router, .peer = peer),
    RouterPortRAOptionsComplete(lrp._uuid, options0),
    (var __type, var options1) = match (router.options.get(i"chassis")) {
        /* TODO: derived ports */
        None -> (i"patch", map_empty()),
        Some{lrchassis} -> (i"l3gateway", [i"l3gateway-chassis" -> lrchassis])
    },
    var options2 = match (router_peer_name(peer)) {
        None -> map_empty(),
        Some{peer_name} -> [i"peer" -> peer_name]
    },
    var options3 = match ((peer, rp.networks.ipv6_addrs.is_empty())) {
        (PeerSwitch{_, _}, false) -> {
            var enabled = lrp.is_enabled();
            var pd = lrp.options.get_bool_def(i"prefix_delegation", false);
            var p = lrp.options.get_bool_def(i"prefix", false);
            [i"ipv6_prefix_delegation" -> i"${pd and enabled}",
             i"ipv6_prefix" -> i"${p and enabled}"]
        },
        _ -> map_empty()
    },
    PreserveIPv6RAPDList(lrp._uuid, ipv6_ra_pd_list),
    var options4 = match (ipv6_ra_pd_list) {
        None -> map_empty(),
        Some{value} -> [i"ipv6_ra_pd_list" -> value]
    },
    RouterPortIsRedirect(lrp._uuid, is_redirect),
    var options5 = match (is_redirect) {
        false -> map_empty(),
        true -> [i"chassis-redirect-port" -> chassis_redirect_name(lrp.name).intern()]
    },
    var options = options0.union(options1).union(options2).union(options3).union(options4).union(options5),
    var eids = {
        var eids = lrp.external_ids;
        match (lrp.external_ids.get(i"neutron:port_name")) {
            None -> (),
            Some{name} -> eids.insert(i"name", name)
        };
        eids
    }.
/*
*/
function get_router_load_balancer_ips(lbips: Intern<LogicalRouterLBIPs>,
                                      routable_only: bool) :
    (Set<istring>, Set<istring>) =
{
    if (routable_only) {
        (lbips.lb_ipv4s_routable, lbips.lb_ipv6s_routable)
    } else {
        (union(lbips.lb_ipv4s_routable, lbips.lb_ipv4s_unroutable),
         union(lbips.lb_ipv6s_routable, lbips.lb_ipv6s_unroutable))
    }
}

/* Returns an array of strings, each consisting of a MAC address followed
 * by one or more IP addresses, and if the port is a distributed gateway
 * port, followed by 'is_chassis_resident("LPORT_NAME")', where the
 * LPORT_NAME is the name of the L3 redirect port or the name of the
 * logical_port specified in a NAT rule.  These strings include the
 * external IP addresses of all NAT rules defined on that router, and all
 * of the IP addresses used in load balancer VIPs defined on that router.
 */
function get_nat_addresses(rport: Intern<RouterPort>, lbips: Intern<LogicalRouterLBIPs>, routable_only: bool): Set<istring> =
{
    var addresses = set_empty();
    var has_redirect = not rport.router.l3dgw_ports.is_empty();
    match (eth_addr_from_string(rport.lrp.mac.ival())) {
        None -> addresses,
        Some{mac} -> {
            var c_addresses = "${mac}";
            var central_ip_address = false;

            /* Get NAT IP addresses. */
            for (nat in rport.router.nats) {
                if (routable_only and
                    (nat.nat.__type == i"snat" or
                     not nat.nat.options.get_bool_def(i"add_route", false))) {
                    continue;
                };
                /* Determine whether this NAT rule satisfies the conditions for
                 * distributed NAT processing. */
                if (has_redirect and nat.nat.__type == i"dnat_and_snat" and
                    nat.nat.logical_port.is_some() and nat.external_mac.is_some()) {
                    /* Distributed NAT rule. */
                    var logical_port = nat.nat.logical_port.unwrap_or_default();
                    var external_mac = nat.external_mac.unwrap_or_default();
                    addresses.insert(i"${external_mac} ${nat.external_ip} "
                                      "is_chassis_resident(${json_escape(logical_port)})")
                } else {
                    /* Centralized NAT rule, either on gateway router or distributed
                     * router.
                     * Check if external_ip is same as router ip. If so, then there
                     * is no need to add this to the nat_addresses. The router IPs
                     * will be added separately. */
                    var is_router_ip = false;
                    match (nat.external_ip) {
                        IPv4{ei} -> {
                            for (ipv4 in rport.networks.ipv4_addrs) {
                                if (ei == ipv4.addr) {
                                    is_router_ip = true;
                                    break
                                }
                            }
                        },
                        IPv6{ei} -> {
                            for (ipv6 in rport.networks.ipv6_addrs) {
                                if (ei == ipv6.addr) {
                                    is_router_ip = true;
                                    break
                                }
                            }
                        }
                    };
                    if (not is_router_ip) {
                        c_addresses = c_addresses ++ " ${nat.external_ip}";
                        central_ip_address = true
                    }
                }
            };

            /* A set to hold all load-balancer vips. */
            (var all_ips_v4, var all_ips_v6) = get_router_load_balancer_ips(lbips, routable_only);

            for (ip_address in set_union(all_ips_v4, all_ips_v6)) {
                c_addresses = c_addresses ++ " ${ip_address}";
                central_ip_address = true
            };

            if (central_ip_address) {
                /* Gratuitous ARP for centralized NAT rules on distributed gateway
                 * ports should be restricted to the gateway chassis. */
                if (has_redirect) {
                    c_addresses = c_addresses ++ match (rport.router.l3dgw_ports.nth(0)) {
                        None -> "",
                        Some {var gw_port} -> " is_chassis_resident(${json_escape(chassis_redirect_name(gw_port.name))})"
                    }
                } else ();

                addresses.insert(c_addresses.intern())
            } else ();
            addresses
        }
    }
}

function get_garp_nat_addresses(rport: Intern<RouterPort>): string = {
    var garp_info = ["${rport.networks.ea}"];
    for (ipv4_addr in rport.networks.ipv4_addrs) {
        garp_info.push("${ipv4_addr.addr}")
    };
    match (rport.router.l3dgw_ports.nth(0)) {
        None -> (),
        Some {var gw_port} -> garp_info.push(
            "is_chassis_resident(${json_escape(chassis_redirect_name(gw_port.name))})")
    };
    garp_info.join(" ")
}

/* Extra options computed for router ports by the logical flow generation code */
relation RouterPortRAOptions(lrp: uuid, options: Map<istring, istring>)

relation RouterPortRAOptionsComplete(lrp: uuid, options: Map<istring, istring>)

RouterPortRAOptionsComplete(lrp, options) :-
    RouterPortRAOptions(lrp, options).
RouterPortRAOptionsComplete(lrp, map_empty()) :-
    &nb::Logical_Router_Port(._uuid = lrp),
    not RouterPortRAOptions(lrp, _).

function has_distributed_nat(nats: Vec<NAT>): bool {
    for (nat in nats) {
        if (nat.nat.__type == i"dnat_and_snat") {
            return true
        }
    };
    return false
}

/*
 * Create derived port for Logical_Router_Ports with non-empty 'gateway_chassis' column.
 */

/* Create derived ports */
OutProxy_Port_Binding(._uuid              = cr_lrp_uuid,
                      .logical_port       = chassis_redirect_name(lrp.name).intern(),
                      .__type             = i"chassisredirect",
                      .gateway_chassis    = set_empty(),
                      .ha_chassis_group   = Some{hacg_uuid},
                      .options            = options,
                      .datapath           = lr_uuid,
                      .parent_port        = None,
                      .tag                = None,  //always empty for router ports
                      .mac                = set_singleton(i"${lrp.mac} ${lrp.networks.map(ival).to_vec().join(\" \")}"),
                      .nat_addresses      = set_empty(),
                      .external_ids       = lrp.external_ids,
                      .requested_chassis  = None) :-
    DistributedGatewayPort(lrp, lr_uuid, cr_lrp_uuid),
    DistributedGatewayPortHAChassisGroup(lrp, hacg_uuid),
    var redirect_type = match (lrp.options.get(i"redirect-type")) {
        Some{var value} -> [i"redirect-type" -> value],
        _ -> map_empty()
    },
    LogicalRouterNATs(lr_uuid, nats),
    var always_redirect = if (has_distributed_nat(nats) or
                              lrp.options.get(i"redirect-type") == Some{i"bridged"}) {
        map_empty()
    } else {
        [i"always-redirect" -> i"true"]
    },
    var options = redirect_type.union(always_redirect).insert_imm(i"distributed-port", lrp.name).

/*
 * We want to preserve 'up' (set by ovn-controller) for Port_Binding rows.
 * We need to set set 'up' in new rows to Some{false}; if we don't set
 * it at all, ovn-controller will never update it.
 */
relation PortBindingUp0(pb_uuid: uuid, up: bool)
PortBindingUp0(pb_uuid, up) :- sb::Port_Binding(._uuid = pb_uuid, .up = Some{up}).

relation PortBindingUp(pb_uuid: uuid, up: bool)
PortBindingUp(pb_uuid, up) :- PortBindingUp0(pb_uuid, up).
PortBindingUp(pb_uuid, false) :-
    OutProxy_Port_Binding(._uuid = pb_uuid),
    not PortBindingUp0(pb_uuid, _).

/* Add allocated qdisc_queue_id and tunnel key to Port_Binding.
 */
sb::Out_Port_Binding(._uuid              = pbinding._uuid,
                    .logical_port       = pbinding.logical_port,
                    .__type             = pbinding.__type,
                    .gateway_chassis    = pbinding.gateway_chassis,
                    .ha_chassis_group   = pbinding.ha_chassis_group,
                    .options            = options0,
                    .datapath           = pbinding.datapath,
                    .tunnel_key         = tunkey,
                    .parent_port        = pbinding.parent_port,
                    .tag                = pbinding.tag,
                    .mac                = pbinding.mac,
                    .nat_addresses      = pbinding.nat_addresses,
                    .external_ids       = pbinding.external_ids,
                    .up                 = Some{up},
                    .requested_chassis  = pbinding.requested_chassis) :-
    pbinding in OutProxy_Port_Binding(),
    PortTunKeyAllocation(pbinding._uuid, tunkey),
    QueueIDAllocation(pbinding._uuid, qid),
    PortBindingUp(pbinding._uuid, up),
    var options0 = match (qid) {
        None -> pbinding.options,
        Some{id} -> pbinding.options.insert_imm(i"qdisc_queue_id", i"${id}")
    }.

/* Referenced chassis.
 *
 * These tables track the sb::Chassis that a packet that traverses logical
 * router 'lr_uuid' can end up at (or start from).  This is used for
 * sb::Out_HA_Chassis_Group's ref_chassis column.
 *
 * Only HA Chassis Groups with more than 1 chassis need to maintain the
 * referenced chassis.
 *
 * RefChassisSet0 has a row for each logical router that actually references a
 * chassis.  RefChassisSet has a row for every logical router. */
relation RefChassis(lr_uuid: uuid, chassis_uuid: uuid)
RefChassis(lr_uuid, chassis_uuid) :-
    DistributedGatewayPortHAChassisGroup(lrp, hacg_uuid),
    HAChassis(.hacg_uuid = hacg_uuid, .hac_uuid = hac_uuid),
    var hacg_size = hac_uuid.group_by(hacg_uuid).to_set().size(),
    hacg_size > 1,
    DistributedGatewayPort(lrp, lr_uuid, _),
    ConnectedLogicalRouter[(lr_uuid, set_uuid)],
    ConnectedLogicalRouter[(lr2_uuid, set_uuid)],
    FirstHopLogicalRouter(lr2_uuid, ls_uuid),
    LogicalSwitchPort(lsp_uuid, ls_uuid),
    &nb::Logical_Switch_Port(._uuid = lsp_uuid, .name = lsp_name),
    sb::Port_Binding(.logical_port = lsp_name, .chassis = chassis_uuids),
    Some{var chassis_uuid} = chassis_uuids.
relation RefChassisSet0(lr_uuid: uuid, chassis_uuids: Set<uuid>)
RefChassisSet0(lr_uuid, chassis_uuids) :-
    RefChassis(lr_uuid, chassis_uuid),
    var chassis_uuids = chassis_uuid.group_by(lr_uuid).to_set().
relation RefChassisSet(lr_uuid: uuid, chassis_uuids: Set<uuid>)
RefChassisSet(lr_uuid, chassis_uuids) :-
    RefChassisSet0(lr_uuid, chassis_uuids).
RefChassisSet(lr_uuid, set_empty()) :-
    nb::Logical_Router(._uuid = lr_uuid),
    not RefChassisSet0(lr_uuid, _).

/* Referenced chassis for an HA chassis group.
 *
 * Multiple logical routers can reference an HA chassis group so we merge the
 * referenced chassis across all of them.
 */
relation HAChassisGroupRefChassisSet(hacg_uuid: uuid,
                                     chassis_uuids: Set<uuid>)
HAChassisGroupRefChassisSet(hacg_uuid, chassis_uuids) :-
    DistributedGatewayPortHAChassisGroup(lrp, hacg_uuid),
    DistributedGatewayPort(lrp, lr_uuid, _),
    RefChassisSet(lr_uuid, chassis_uuids),
    var chassis_uuids = chassis_uuids.group_by(hacg_uuid).union().

/* HA_Chassis_Group and HA_Chassis. */
sb::Out_HA_Chassis_Group(hacg_uuid, hacg_name, ha_chassis, ref_chassis, eids) :-
    HAChassis(hacg_uuid, hac_uuid, chassis_name, _, _),
    var chassis_uuid = ha_chassis_uuid(chassis_name.ival(), hac_uuid),
    var ha_chassis = chassis_uuid.group_by(hacg_uuid).to_set(),
    HAChassisGroup(hacg_uuid, hacg_name, eids),
    HAChassisGroupRefChassisSet(hacg_uuid, ref_chassis).

sb::Out_HA_Chassis(ha_chassis_uuid(chassis_name.ival(), hac_uuid), chassis, priority, eids) :-
    HAChassis(_, hac_uuid, chassis_name, priority, eids),
    chassis_rec in sb::Chassis(.name = chassis_name),
    var chassis = Some{chassis_rec._uuid}.
sb::Out_HA_Chassis(ha_chassis_uuid(chassis_name.ival(), hac_uuid), None, priority, eids) :-
    HAChassis(_, hac_uuid, chassis_name, priority, eids),
    not chassis_rec in sb::Chassis(.name = chassis_name).

relation HAChassisToChassis(name: istring, chassis: Option<uuid>)
HAChassisToChassis(name, Some{chassis}) :-
    sb::Chassis(._uuid = chassis, .name = name).
HAChassisToChassis(name, None) :-
    nb::HA_Chassis(.chassis_name = name),
    not sb::Chassis(.name = name).
sb::Out_HA_Chassis(ha_chassis_uuid(ha_chassis.chassis_name.ival(), hac_uuid), chassis, priority, eids) :-
    sp in &SwitchPort(),
    sp.lsp.__type == i"external",
    Some{var ha_chassis_group_uuid} = sp.lsp.ha_chassis_group,
    ha_chassis_group in nb::HA_Chassis_Group(._uuid = ha_chassis_group_uuid),
    var hac_uuid = FlatMap(ha_chassis_group.ha_chassis),
    ha_chassis in nb::HA_Chassis(._uuid = hac_uuid, .priority = priority, .external_ids = eids),
    HAChassisToChassis(ha_chassis.chassis_name, chassis).
sb::Out_HA_Chassis_Group(_uuid, name, ha_chassis, set_empty() /* XXX? */, eids) :-
    sp in &SwitchPort(),
    sp.lsp.__type == i"external",
    var ls_uuid = sp.sw._uuid,
    Some{var ha_chassis_group_uuid} = sp.lsp.ha_chassis_group,
    ha_chassis_group in nb::HA_Chassis_Group(._uuid = ha_chassis_group_uuid, .name = name,
                                            .external_ids = eids),
    var hac_uuid = FlatMap(ha_chassis_group.ha_chassis),
    ha_chassis in nb::HA_Chassis(._uuid = hac_uuid),
    var ha_chassis_uuid_name = ha_chassis_uuid(ha_chassis.chassis_name.ival(), hac_uuid),
    var ha_chassis = ha_chassis_uuid_name.group_by((ls_uuid, name, eids)).to_set(),
    var _uuid = ha_chassis_group_uuid(ls_uuid).

/*
 * SB_Global: copy nb_cfg and options from NB.
 * If NB_Global does not exist yet, just keep the current value of SB_Global,
 * if any.
 */
for (nb_global in nb::NB_Global) {
    sb::Out_SB_Global(._uuid          = nb_global._uuid,
                     .nb_cfg         = nb_global.nb_cfg,
                     .options        = nb_global.options,
                     .ipsec          = nb_global.ipsec)
}

sb::Out_SB_Global(._uuid          = sb_global._uuid,
                 .nb_cfg         = sb_global.nb_cfg,
                 .options        = sb_global.options,
                 .ipsec          = sb_global.ipsec) :-
    sb_global in sb::SB_Global(),
    not nb::NB_Global().

/* sb::Chassis_Private joined with is_remote from sb::Chassis,
 * including a record even for a null Chassis ref. */
relation ChassisPrivate(
    cp: sb::Chassis_Private,
    is_remote: bool)
ChassisPrivate(cp, c.other_config.get_bool_def(i"is-remote", false)) :-
    cp in sb::Chassis_Private(.chassis = Some{uuid}),
    c in sb::Chassis(._uuid = uuid).
ChassisPrivate(cp, false),
Warning["Chassis not exist for Chassis_Private record, name: ${cp.name}"] :-
    cp in sb::Chassis_Private(.chassis = Some{uuid}),
    not sb::Chassis(._uuid = uuid).
ChassisPrivate(cp, false),
Warning["Chassis not exist for Chassis_Private record, name: ${cp.name}"] :-
    cp in sb::Chassis_Private(.chassis = None).

/* Track minimum hv_cfg across all the (non-remote) chassis. */
relation HvCfg0(hv_cfg: integer)
HvCfg0(hv_cfg) :-
    ChassisPrivate(.cp = sb::Chassis_Private{.nb_cfg = chassis_cfg}, .is_remote = false),
    var hv_cfg = chassis_cfg.group_by(()).min().
relation HvCfg(hv_cfg: integer)
HvCfg(hv_cfg) :- HvCfg0(hv_cfg).
HvCfg(hv_cfg) :-
    nb::NB_Global(.nb_cfg = hv_cfg),
    not HvCfg0().

/* Track maximum nb_cfg_timestamp among all the (non-remote) chassis
 * that have the minimum nb_cfg. */
relation HvCfgTimestamp0(hv_cfg_timestamp: integer)
HvCfgTimestamp0(hv_cfg_timestamp) :-
    HvCfg(hv_cfg),
    ChassisPrivate(.cp = sb::Chassis_Private{.nb_cfg = hv_cfg,
                                             .nb_cfg_timestamp = chassis_cfg_timestamp},
                   .is_remote = false),
    var hv_cfg_timestamp = chassis_cfg_timestamp.group_by(()).max().
relation HvCfgTimestamp(hv_cfg_timestamp: integer)
HvCfgTimestamp(hv_cfg_timestamp) :- HvCfgTimestamp0(hv_cfg_timestamp).
HvCfgTimestamp(hv_cfg_timestamp) :-
    nb::NB_Global(.hv_cfg_timestamp = hv_cfg_timestamp),
    not HvCfgTimestamp0().

/*
 * nb::Out_NB_Global.
 *
 * OutNBGlobal0 generates the new record in the common case.
 * OutNBGlobal1 generates the new record as a copy of nb::NB_Global, if sb::SB_Global is missing.
 * nb::Out_NB_Global makes sure we have only a single record in the relation.
 *
 * (We don't generate an NB_Global output record if there isn't
 * one in the input.  We don't have enough entropy available to
 * generate a random _uuid.  Doesn't seem like a big deal, because
 * OVN probably hasn't really been initialized yet.)
 */
relation OutNBGlobal0[nb::Out_NB_Global]
OutNBGlobal0[nb::Out_NB_Global{._uuid         = _uuid,
                               .sb_cfg        = sb_cfg,
                               .hv_cfg        = hv_cfg,
                               .nb_cfg_timestamp = nb_cfg_timestamp,
                               .hv_cfg_timestamp = hv_cfg_timestamp,
                               .ipsec         = ipsec,
                               .options       = options}] :-
    NbCfgTimestamp[nb_cfg_timestamp],
    HvCfgTimestamp(hv_cfg_timestamp),
    nbg in nb::NB_Global(._uuid = _uuid, .ipsec = ipsec),
    sb::SB_Global(.nb_cfg = sb_cfg),
    HvCfg(hv_cfg),
    HvCfgTimestamp(hv_cfg_timestamp),
    MacPrefix(mac_prefix),
    SvcMonitorMac(svc_monitor_mac),
    OvnMaxDpKeyLocal[max_tunid],
    var options = {
        var options = nbg.options;
        options.put_mac_prefix(mac_prefix);
        options.put_svc_monitor_mac(svc_monitor_mac);
        options.insert(i"max_tunid", i"${max_tunid}");
        options.insert(i"northd_internal_version", ovn_internal_version().intern());
        options
    }.

relation OutNBGlobal1[nb::Out_NB_Global]
OutNBGlobal1[x] :- OutNBGlobal0[x].
OutNBGlobal1[nb::Out_NB_Global{._uuid         = nbg._uuid,
                               .sb_cfg        = nbg.sb_cfg,
                               .hv_cfg        = nbg.hv_cfg,
                               .ipsec         = nbg.ipsec,
                               .options       = nbg.options,
                               .nb_cfg_timestamp = nbg.nb_cfg_timestamp,
                               .hv_cfg_timestamp = nbg.hv_cfg_timestamp}] :-
    Unit(),
    not OutNBGlobal0[_],
    nbg in nb::NB_Global().

nb::Out_NB_Global[y] :-
    OutNBGlobal1[x],
    var y = x.group_by(()).group_first().

// Tracks the value that should go into NB_Global's 'nb_cfg_timestamp' column.
// ovn-northd-ddlog.c pushes the current time directly into this relation.
input relation NbCfgTimestamp[integer]

output relation SbCfg[integer]
SbCfg[sb_cfg] :- nb::Out_NB_Global(.sb_cfg = sb_cfg).

output relation Northd_Probe_Interval[s64]
Northd_Probe_Interval[interval] :-
    nb in nb::NB_Global(),
    var interval = nb.options.get(i"northd_probe_interval").and_then(parse_dec_i64).unwrap_or(-1).

relation CheckLspIsUp[bool]
CheckLspIsUp[check_lsp_is_up] :-
    nb in nb::NB_Global(),
    var check_lsp_is_up = not nb.options.get_bool_def(i"ignore_lsp_down", true).
CheckLspIsUp[true] :-
    Unit(),
    not nb in nb::NB_Global().

/*
 * Address_Set: copy from NB + additional records generated from NB Port_Group (two records for each
 * Port_Group for IPv4 and IPv6 addresses).
 *
 * There can be name collisions between the two types of Address_Set records.  User-defined records
 * take precedence.
 */
sb::Out_Address_Set(._uuid     = nb_as._uuid,
                    .name      = nb_as.name,
                    .addresses = nb_as.addresses) :-
    nb_as in &nb::Address_Set().

sb::Out_Address_Set(._uuid = hash128("svc_monitor_mac"),
                   .name = i"svc_monitor_mac",
                   .addresses = set_singleton(i"${svc_monitor_mac}")) :-
    SvcMonitorMac(svc_monitor_mac).

sb::Out_Address_Set(hash128(as_name), as_name, pg_ip4addrs.union()) :-
    PortGroupPort(.pg_name = pg_name, .port = port_uuid),
    var as_name = i"${pg_name}_ip4",
    // avoid name collisions with user-defined Address_Sets
    not &nb::Address_Set(.name = as_name),
    PortStaticAddresses(.lsport = port_uuid, .ip4addrs = stat),
    SwitchPortNewDynamicAddress(&SwitchPort{.lsp = &nb::Logical_Switch_Port{._uuid = port_uuid}},
                                dyn_addr),
    var dynamic = match (dyn_addr) {
        None -> set_empty(),
        Some{lpaddress} -> match (lpaddress.ipv4_addrs.nth(0)) {
            None -> set_empty(),
            Some{addr} -> set_singleton(i"${addr.addr}")
        }
    },
    //PortDynamicAddresses(.lsport = port_uuid, .ip4addrs = dynamic),
    var port_ip4addrs = stat.union(dynamic),
    var pg_ip4addrs = port_ip4addrs.group_by(as_name).to_vec().

sb::Out_Address_Set(hash128(as_name), as_name, set_empty()) :-
    nb::Port_Group(.ports = set_empty(), .name = pg_name),
    var as_name = i"${pg_name}_ip4",
    // avoid name collisions with user-defined Address_Sets
    not &nb::Address_Set(.name = as_name).

sb::Out_Address_Set(hash128(as_name), as_name, pg_ip6addrs.union()) :-
    PortGroupPort(.pg_name = pg_name, .port = port_uuid),
    var as_name = i"${pg_name}_ip6",
    // avoid name collisions with user-defined Address_Sets
    not &nb::Address_Set(.name = as_name),
    PortStaticAddresses(.lsport = port_uuid, .ip6addrs = stat),
    SwitchPortNewDynamicAddress(&SwitchPort{.lsp = &nb::Logical_Switch_Port{._uuid = port_uuid}},
                                dyn_addr),
    var dynamic = match (dyn_addr) {
        None -> set_empty(),
        Some{lpaddress} -> match (lpaddress.ipv6_addrs.nth(0)) {
            None -> set_empty(),
            Some{addr} -> set_singleton(i"${addr.addr}")
        }
    },
    //PortDynamicAddresses(.lsport = port_uuid, .ip6addrs = dynamic),
    var port_ip6addrs = stat.union(dynamic),
    var pg_ip6addrs = port_ip6addrs.group_by(as_name).to_vec().

sb::Out_Address_Set(hash128(as_name), as_name, set_empty()) :-
    nb::Port_Group(.ports = set_empty(), .name = pg_name),
    var as_name = i"${pg_name}_ip6",
    // avoid name collisions with user-defined Address_Sets
    not &nb::Address_Set(.name = as_name).

/*
 * Port_Group
 *
 * Create one SB Port_Group record for every datapath that has ports
 * referenced by the NB Port_Group.ports field. In order to maintain the
 * SB Port_Group.name uniqueness constraint, ovn-northd populates the field
 * with the value: <SB.Logical_Datapath.tunnel_key>_<NB.Port_Group.name>.
 */

relation PortGroupPort(
    pg_uuid: uuid,
    pg_name: istring,
    port: uuid)

PortGroupPort(pg_uuid, pg_name, port) :-
    nb::Port_Group(._uuid = pg_uuid, .name = pg_name, .ports = pg_ports),
    var port = FlatMap(pg_ports).

sb::Out_Port_Group(._uuid = hash128(sb_name), .name = sb_name, .ports = port_names) :-
    PortGroupPort(.pg_uuid = _uuid, .pg_name = nb_name, .port = port_uuid),
    &SwitchPort(.lsp = lsp@&nb::Logical_Switch_Port{._uuid = port_uuid,
                                                    .name = port_name},
                .sw = &Switch{._uuid = ls_uuid}),
    TunKeyAllocation(.datapath = ls_uuid, .tunkey = tunkey),
    var sb_name = i"${tunkey}_${nb_name}",
    var port_names = port_name.group_by((_uuid, sb_name)).to_set().

/*
 * Multicast_Group:
 * - three static rows per logical switch: one for flooding, one for packets
 *   with unknown destinations, one for flooding IP multicast known traffic to
 *   mrouters.
 * - dynamically created rows based on IGMP groups learned by controllers.
 */

function mC_FLOOD():         (istring, integer) =
    (i"_MC_flood", 32768)

function mC_UNKNOWN():       (istring, integer) =
    (i"_MC_unknown", 32769)

function mC_MROUTER_FLOOD(): (istring, integer) =
    (i"_MC_mrouter_flood", 32770)

function mC_MROUTER_STATIC(): (istring, integer) =
    (i"_MC_mrouter_static", 32771)

function mC_STATIC(): (istring, integer) =
    (i"_MC_static", 32772)

function mC_FLOOD_L2(): (istring, integer) =
    (i"_MC_flood_l2", 32773)

function mC_IP_MCAST_MIN():  (istring, integer) =
    (i"_MC_ip_mcast_min", 32774)

function mC_IP_MCAST_MAX():  (istring, integer) =
    (i"_MC_ip_mcast_max", 65535)


// TODO: check that Multicast_Group.ports should not include derived ports

/* Proxy table for Out_Multicast_Group: contains all Multicast_Group fields,
 * except `_uuid`, which will be computed by hashing the remaining fields,
 * and tunnel key, which case it is allocated separately (see
 * MulticastGroupTunKeyAllocation). */
relation OutProxy_Multicast_Group (
    datapath: uuid,
    name: istring,
    ports: Set<uuid>
)

/* Only create flood group if the switch has enabled ports */
sb::Out_Multicast_Group (._uuid      = hash128((datapath,name)),
                        .datapath   = datapath,
                        .name       = name,
                        .tunnel_key = tunnel_key,
                        .ports      = port_ids) :-
    &SwitchPort(.lsp = lsp, .sw = sw),
    lsp.is_enabled(),
    var datapath = sw._uuid,
    var port_ids = lsp._uuid.group_by((datapath)).to_set(),
    (var name, var tunnel_key) = mC_FLOOD().

/* Create a multicast group to flood to all switch ports except router ports.
 */
sb::Out_Multicast_Group (._uuid      = hash128((datapath,name)),
                        .datapath   = datapath,
                        .name       = name,
                        .tunnel_key = tunnel_key,
                        .ports      = port_ids) :-
    &SwitchPort(.lsp = lsp, .sw = sw),
    lsp.is_enabled(),
    lsp.__type != i"router",
    var datapath = sw._uuid,
    var port_ids = lsp._uuid.group_by((datapath)).to_set(),
    (var name, var tunnel_key) = mC_FLOOD_L2().

/* Only create unknown group if the switch has ports with "unknown" address */
sb::Out_Multicast_Group (._uuid      = hash128((ls,name)),
                        .datapath   = ls,
                        .name       = name,
                        .tunnel_key = tunnel_key,
                        .ports      = ports) :-
    LogicalSwitchPortWithUnknownAddress(ls, lsp),
    var ports = lsp.group_by(ls).to_set(),
    (var name, var tunnel_key) = mC_UNKNOWN().

/* Create a multicast group to flood multicast traffic to routers with
 * multicast relay enabled.
 */
sb::Out_Multicast_Group (._uuid    = hash128((sw._uuid,name)),
                        .datapath = sw._uuid,
                        .name = name,
                        .tunnel_key = tunnel_key,
                        .ports = port_ids) :-
    SwitchMcastFloodRelayPorts(sw, port_ids),
    not port_ids.is_empty(),
    (var name, var tunnel_key) = mC_MROUTER_FLOOD().

/* Create a multicast group to flood traffic (no reports) to ports with
 * multicast flood enabled.
 */
sb::Out_Multicast_Group (._uuid    = hash128((sw._uuid,name)),
                        .datapath = sw._uuid,
                        .name = name,
                        .tunnel_key = tunnel_key,
                        .ports = port_ids) :-
    SwitchMcastFloodPorts(sw, port_ids),
    not port_ids.is_empty(),
    (var name, var tunnel_key) = mC_STATIC().

/* Create a multicast group to flood reports to ports with
 * multicast flood_reports enabled.
 */
sb::Out_Multicast_Group (._uuid    = hash128((sw._uuid,name)),
                        .datapath = sw._uuid,
                        .name = name,
                        .tunnel_key = tunnel_key,
                        .ports = port_ids) :-
    SwitchMcastFloodReportPorts(sw, port_ids),
    not port_ids.is_empty(),
    (var name, var tunnel_key) = mC_MROUTER_STATIC().

/* Create a multicast group to flood traffic and reports to router ports with
 * multicast flood enabled.
 */
sb::Out_Multicast_Group (._uuid    = hash128((rtr._uuid,name)),
                        .datapath = rtr._uuid,
                        .name = name,
                        .tunnel_key = tunnel_key,
                        .ports = port_ids) :-
    RouterMcastFloodPorts(rtr, port_ids),
    not port_ids.is_empty(),
    (var name, var tunnel_key) = mC_STATIC().

/* Create a multicast group for each IGMP group learned by a Switch.
 * 'tunnel_key' == 0 triggers an ID allocation later.
 */
OutProxy_Multicast_Group (.datapath   = switch._uuid,
                          .name       = address,
                          .ports      = port_ids) :-
    IgmpSwitchMulticastGroup(address, switch, port_ids).

/* Create a multicast group for each IGMP group learned by a Router.
 * 'tunnel_key' == 0 triggers an ID allocation later.
 */
OutProxy_Multicast_Group (.datapath   = router._uuid,
                          .name       = address,
                          .ports      = port_ids) :-
    IgmpRouterMulticastGroup(address, router, port_ids).

/* Allocate a 'tunnel_key' for dynamic multicast groups. */
sb::Out_Multicast_Group(._uuid    = hash128((mcgroup.datapath,mcgroup.name)),
                       .datapath = mcgroup.datapath,
                       .name = mcgroup.name,
                       .tunnel_key = tunnel_key,
                       .ports = mcgroup.ports) :-
    mcgroup in OutProxy_Multicast_Group(),
    MulticastGroupTunKeyAllocation(mcgroup.datapath, mcgroup.name, tunnel_key).

/*
 * MAC binding: records inserted by hypervisors; northd removes records for deleted logical ports and datapaths.
 */
sb::Out_MAC_Binding (._uuid        = mb._uuid,
                    .logical_port = mb.logical_port,
                    .ip           = mb.ip,
                    .mac          = mb.mac,
                    .datapath     = mb.datapath) :-
    sb::MAC_Binding[mb],
    sb::Out_Port_Binding(.logical_port = mb.logical_port),
    sb::Out_Datapath_Binding(._uuid = mb.datapath).

/*
 * DHCP options: fixed table
 */
sb::Out_DHCP_Options (
    ._uuid  = 128'h7d9d898a_179b_4898_8382_b73bec391f23,
    .name   = i"offerip",
    .code   = 0,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hea5e7d14_fd97_491c_8004_a120bdbc4306,
    .name   = i"netmask",
    .code   = 1,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hdab5e39b_6702_4245_9573_6c142aa3724c,
    .name   = i"router",
    .code   = 3,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h340b4bc5_c5c3_43d1_ae77_564da69c8fcc,
    .name   = i"dns_server",
    .code   = 6,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hcd1ab302_cbb2_4eab_9ec5_ec1c8541bd82,
    .name   = i"log_server",
    .code   = 7,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h1c7ea6a0_fe6b_48c1_a920_302583c1ff08,
    .name   = i"lpr_server",
    .code   = 9,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hae312373_2261_41b5_a2c4_186f426dd929,
    .name   = i"hostname",
    .code   = 12,
    .__type = i"str"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hae35e575_226a_4ab5_a1c4_166f426dd999,
    .name   = i"domain_name",
    .code   = 15,
    .__type = i"str"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'had0ec3e0_8be9_4c77_bceb_f8954a34c7ba,
    .name   = i"swap_server",
    .code   = 16,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h884c2e02_6e99_4d12_aef7_8454ebf8a3b7,
    .name   = i"policy_filter",
    .code   = 21,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h57cc2c61_fd2a_41c6_b6b1_6ce9a8901f86,
    .name   = i"router_solicitation",
    .code   = 32,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h48249097_03f0_46c1_a32a_2dd57cd4d0f8,
    .name   = i"nis_server",
    .code   = 41,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h333fe07e_bdd1_4371_aa4f_a412bc60f3a2,
    .name   = i"ntp_server",
    .code   = 42,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h6207109c_49d0_4348_8238_dd92afb69bf0,
    .name   = i"server_id",
    .code   = 54,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h2090b783_26d3_4c1d_830c_54c1b6c5d846,
    .name   = i"tftp_server",
    .code   = 66,
    .__type = i"host_id"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'ha18ff399_caea_406e_af7e_321c6f74e581,
    .name   = i"classless_static_route",
    .code   = 121,
    .__type = i"static_routes"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hb81ad7b4_62f0_40c7_a9a3_f96677628767,
    .name   = i"ms_classless_static_route",
    .code   = 249,
    .__type = i"static_routes"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h0c2e144e_4b5f_4e21_8978_0e20bac9a6ea,
    .name   = i"ip_forward_enable",
    .code   = 19,
    .__type = i"bool"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h6feb1926_9469_4b40_bfbf_478b9888cd3a,
    .name   = i"router_discovery",
    .code   = 31,
    .__type = i"bool"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hcb776249_e8b1_4502_b33b_fa294d44077d,
    .name   = i"ethernet_encap",
    .code   = 36,
    .__type = i"bool"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'ha2df9eaa_aea9_497f_b339_0c8ec3e39a07,
    .name   = i"default_ttl",
    .code   = 23,
    .__type = i"uint8"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hb44b45a9_5004_4ef5_8e6a_aa8629e1afb1,
    .name   = i"tcp_ttl",
    .code   = 37,
    .__type = i"uint8"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h50f01ca7_c650_46f0_8f50_39a67ec657da,
    .name   = i"mtu",
    .code   = 26,
    .__type = i"uint16"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h9d31c057_6085_4810_96af_eeac7d3c5308,
    .name   = i"lease_time",
    .code   = 51,
    .__type = i"uint32"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hea1e2e7a_9585_46ee_ad49_adfdefc0c4ef,
    .name   = i"T1",
    .code   = 58,
    .__type = i"uint32"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hbc83a233_554b_453a_afca_1eadf76810d2,
    .name   = i"T2",
    .code   = 59,
    .__type = i"uint32"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h1ab3eeca_0523_4101_9076_eea77d0232f4,
    .name   = i"bootfile_name",
    .code   = 67,
    .__type = i"str"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'ha5c20b69_f7f3_4fa8_b550_8697aec6cbb7,
    .name   = i"wpad",
    .code   = 252,
    .__type = i"str"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h1516bcb6_cc93_4233_a63f_bd29c8601831,
    .name   = i"path_prefix",
    .code   = 210,
    .__type = i"str"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hc98e13cd_f653_473c_85c1_850dcad685fc,
    .name   = i"tftp_server_address",
    .code   = 150,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hfbe06e70_b43d_4dd9_9b21_2f27eb5da5df,
    .name   = i"arp_cache_timeout",
    .code   = 35,
    .__type = i"uint32"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h2af54a3c_545c_4104_ae1c_432caa3e085e,
    .name   = i"tcp_keepalive_interval",
    .code   = 38,
    .__type = i"uint32"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h4b2144e8_8d3f_4d96_9032_fe23c1866cd4,
    .name   = i"domain_search_list",
    .code   = 119,
    .__type = i"domains"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'hb7236164_eea4_4bf2_9306_8619a9e3ad1d,
    .name   = i"broadcast_address",
    .code   = 28,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h32224b72_1561_4279_b430_982423b62a69,
    .name   = i"netbios_name_server",
    .code   = 44,
    .__type = i"ipv4"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h691db4ae_624e_43e2_9f4a_5ed9de58f0e5,
    .name   = i"netbios_node_type",
    .code   = 46,
    .__type = i"uint8"
).

sb::Out_DHCP_Options (
    ._uuid  = 128'h2d738583_96f4_4a78_99a1_f8f7fe328f3f,
    .name   = i"bootfile_name_alt",
    .code   = 254,
    .__type = i"str"
).


/*
 * DHCPv6 options: fixed table
 */
sb::Out_DHCPv6_Options (
    ._uuid  = 128'h100b2659_0ec0_4da7_9ec3_25997f92dc00,
    .name   = i"server_id",
    .code   = 2,
    .__type = i"mac"
).

sb::Out_DHCPv6_Options (
    ._uuid  = 128'h53f49b50_db75_4b0d_83df_50d31009ca9c,
    .name   = i"ia_addr",
    .code   = 5,
    .__type = i"ipv6"
).

sb::Out_DHCPv6_Options (
    ._uuid  = 128'he3619685_d4f7_42ad_936b_4f4440b7eeb4,
    .name   = i"dns_server",
    .code   = 23,
    .__type = i"ipv6"
).

sb::Out_DHCPv6_Options (
    ._uuid  = 128'hcb8a4e7f_a312_4cb1_a846_e474d9f0c531,
    .name   = i"domain_search",
    .code   = 24,
    .__type = i"str"
).


/*
 * DNS: copied from NB + datapaths column pointer to LS datapaths that use the record
 */

function map_to_lowercase(m_in: Map<istring,istring>): Map<istring,istring> {
    var m_out = map_empty();
    for ((k, v) in m_in) {
        m_out.insert(k.to_lowercase().intern(), v.to_lowercase().intern())
    };
    m_out
}

sb::Out_DNS(._uuid       = hash128(nbdns._uuid),
           .records      = map_to_lowercase(nbdns.records),
           .datapaths    = datapaths,
           .external_ids = nbdns.external_ids.insert_imm(i"dns_id", uuid2str(nbdns._uuid).intern())) :-
    nb::DNS[nbdns],
    LogicalSwitchDNS(ls_uuid, nbdns._uuid),
    var datapaths = ls_uuid.group_by(nbdns).to_set().

/*
 * RBAC_Permission: fixed
 */

sb::Out_RBAC_Permission (
    ._uuid          = 128'h7df3749a_1754_4a78_afa4_3abf526fe510,
    .table          = i"Chassis",
    .authorization  = set_singleton(i"name"),
    .insert_delete  = true,
    .update         = [i"nb_cfg", i"external_ids", i"encaps",
                       i"vtep_logical_switches", i"other_config",
                       i"transport_zones"].to_set()
).

sb::Out_RBAC_Permission (
    ._uuid          = 128'h07e623f7_137c_4a11_9084_3b3f89cb4a54,
    .table          = i"Chassis_Private",
    .authorization  = set_singleton(i"name"),
    .insert_delete  = true,
    .update         = [i"nb_cfg", i"nb_cfg_timestamp", i"chassis", i"external_ids"].to_set()
).

sb::Out_RBAC_Permission (
    ._uuid          = 128'h94bec860_431e_4d95_82e7_3b75d8997241,
    .table          = i"Encap",
    .authorization  = set_singleton(i"chassis_name"),
    .insert_delete  = true,
    .update         = [i"type", i"options", i"ip"].to_set()
).

sb::Out_RBAC_Permission (
    ._uuid          = 128'hd8ceff1a_2b11_48bd_802f_4a991aa4e908,
    .table          = i"Port_Binding",
    .authorization  = set_singleton(i""),
    .insert_delete  = false,
    .update         = [i"chassis", i"encap", i"up", i"virtual_parent"].to_set()
).

sb::Out_RBAC_Permission (
    ._uuid          = 128'h6ffdc696_8bfb_4d82_b620_a00d39270b2f,
    .table          = i"MAC_Binding",
    .authorization  = set_singleton(i""),
    .insert_delete  = true,
    .update         = [i"logical_port", i"ip", i"mac", i"datapath"].to_set()
).

sb::Out_RBAC_Permission (
    ._uuid          = 128'h39231c7e_4bf1_41d0_ada4_1d8a319c0da3,
    .table          = i"Service_Monitor",
    .authorization  = set_singleton(i""),
    .insert_delete  = false,
    .update         = set_singleton(i"status")
).

sb::Out_RBAC_Permission (
    ._uuid          = 128'h5256f48e_172c_4d85_8f04_e199fa817633,
    .table          = i"IGMP_Group",
    .authorization  = set_singleton(i""),
    .insert_delete  = true,
    .update         = [i"address", i"chassis", i"datapath", i"ports"].to_set()
).

sb::Out_RBAC_Permission (
    ._uuid          = 128'h2e5cbf3d_26f6_4f8a_9926_d6f77f61654f,
    .table          = i"Controller_Event",
    .authorization  = set_singleton(i""),
    .insert_delete  = true,
    .update         = [i"chassis", i"event_info", i"event_type",
                       i"seq_num"].to_set()
).

sb::Out_RBAC_Permission (
    ._uuid          = 128'hb70964fc_322f_4ae5_aee4_ff6afadcc126,
    .table          = i"FDB",
    .authorization  = set_singleton(i""),
    .insert_delete  = true,
    .update         = [i"dp_key", i"mac", i"port_key"].to_set()
).

/*
 * RBAC_Role: fixed
 */
sb::Out_RBAC_Role (
    ._uuid       = 128'ha406b472_5de8_4456_9f38_bf344c911b22,
    .name        = i"ovn-controller",
    .permissions = [
        i"Chassis" -> 128'h7df3749a_1754_4a78_afa4_3abf526fe510,
        i"Chassis_Private" -> 128'h07e623f7_137c_4a11_9084_3b3f89cb4a54,
        i"Controller_Event" -> 128'h2e5cbf3d_26f6_4f8a_9926_d6f77f61654f,
        i"Encap" -> 128'h94bec860_431e_4d95_82e7_3b75d8997241,
        i"FDB" -> 128'hb70964fc_322f_4ae5_aee4_ff6afadcc126,
        i"IGMP_Group" -> 128'h5256f48e_172c_4d85_8f04_e199fa817633,
        i"Port_Binding" -> 128'hd8ceff1a_2b11_48bd_802f_4a991aa4e908,
        i"MAC_Binding" -> 128'h6ffdc696_8bfb_4d82_b620_a00d39270b2f,
        i"Service_Monitor"-> 128'h39231c7e_4bf1_41d0_ada4_1d8a319c0da3]

).

/* Output modified Logical_Switch_Port table with dynamic address updated */
nb::Out_Logical_Switch_Port(._uuid                  = lsp._uuid,
                           .tag                    = tag,
                           .dynamic_addresses      = dynamic_addresses,
                           .up                     = Some{up}) :-
    SwitchPortNewDynamicAddress(&SwitchPort{.lsp = lsp, .up = up}, opt_dyn_addr),
    var dynamic_addresses = opt_dyn_addr.and_then(|a| Some{i"${a}"}),
    SwitchPortNewDynamicTag(lsp._uuid, opt_tag),
    var tag = match (opt_tag) {
        None -> lsp.tag,
        Some{t} -> Some{t}
    }.

relation LRPIPv6Prefix0(lrp_uuid: uuid, ipv6_prefix: istring)
LRPIPv6Prefix0(lrp._uuid, ipv6_prefix.intern()) :-
    lrp in &nb::Logical_Router_Port(),
    lrp.options.get_bool_def(i"prefix", false),
    sb::Port_Binding(.logical_port = lrp.name, .options = options),
    Some{var ipv6_ra_pd_list} = options.get(i"ipv6_ra_pd_list"),
    var parts = ipv6_ra_pd_list.split(","),
    Some{var ipv6_prefix} = parts.nth(1).

relation LRPIPv6Prefix(lrp_uuid: uuid, ipv6_prefix: Option<istring>)
LRPIPv6Prefix(lrp_uuid, Some{ipv6_prefix}) :-
    LRPIPv6Prefix0(lrp_uuid, ipv6_prefix).
LRPIPv6Prefix(lrp_uuid, None) :-
    &nb::Logical_Router_Port(._uuid = lrp_uuid),
    not LRPIPv6Prefix0(lrp_uuid, _).

nb::Out_Logical_Router_Port(._uuid = _uuid,
                           .ipv6_prefix = to_set(ipv6_prefix)) :-
    &nb::Logical_Router_Port(._uuid = _uuid, .name = name),
    LRPIPv6Prefix(_uuid, ipv6_prefix).

typedef Pipeline = Ingress | Egress

typedef Stage = Stage {
    pipeline    : Pipeline,
    table_id    : bit<8>,
    table_name  : istring
}

/* Logical switch ingress stages. */
function s_SWITCH_IN_PORT_SEC_L2():     Intern<Stage> { Stage{Ingress,  0, i"ls_in_port_sec_l2"}.intern() }
function s_SWITCH_IN_PORT_SEC_IP():     Intern<Stage> { Stage{Ingress,  1, i"ls_in_port_sec_ip"}.intern() }
function s_SWITCH_IN_PORT_SEC_ND():     Intern<Stage> { Stage{Ingress,  2, i"ls_in_port_sec_nd"}.intern() }
function s_SWITCH_IN_LOOKUP_FDB():      Intern<Stage> { Stage{Ingress,  3, i"ls_in_lookup_fdb"}.intern() }
function s_SWITCH_IN_PUT_FDB():         Intern<Stage> { Stage{Ingress,  4, i"ls_in_put_fdb"}.intern() }
function s_SWITCH_IN_PRE_ACL():         Intern<Stage> { Stage{Ingress,  5, i"ls_in_pre_acl"}.intern() }
function s_SWITCH_IN_PRE_LB():          Intern<Stage> { Stage{Ingress,  6, i"ls_in_pre_lb"}.intern() }
function s_SWITCH_IN_PRE_STATEFUL():    Intern<Stage> { Stage{Ingress,  7, i"ls_in_pre_stateful"}.intern() }
function s_SWITCH_IN_ACL_HINT():        Intern<Stage> { Stage{Ingress,  8, i"ls_in_acl_hint"}.intern() }
function s_SWITCH_IN_ACL():             Intern<Stage> { Stage{Ingress,  9, i"ls_in_acl"}.intern() }
function s_SWITCH_IN_QOS_MARK():        Intern<Stage> { Stage{Ingress, 10, i"ls_in_qos_mark"}.intern() }
function s_SWITCH_IN_QOS_METER():       Intern<Stage> { Stage{Ingress, 11, i"ls_in_qos_meter"}.intern() }
function s_SWITCH_IN_STATEFUL():        Intern<Stage> { Stage{Ingress, 12, i"ls_in_stateful"}.intern() }
function s_SWITCH_IN_PRE_HAIRPIN():     Intern<Stage> { Stage{Ingress, 13, i"ls_in_pre_hairpin"}.intern() }
function s_SWITCH_IN_NAT_HAIRPIN():     Intern<Stage> { Stage{Ingress, 14, i"ls_in_nat_hairpin"}.intern() }
function s_SWITCH_IN_HAIRPIN():         Intern<Stage> { Stage{Ingress, 15, i"ls_in_hairpin"}.intern() }
function s_SWITCH_IN_ARP_ND_RSP():      Intern<Stage> { Stage{Ingress, 16, i"ls_in_arp_rsp"}.intern() }
function s_SWITCH_IN_DHCP_OPTIONS():    Intern<Stage> { Stage{Ingress, 17, i"ls_in_dhcp_options"}.intern() }
function s_SWITCH_IN_DHCP_RESPONSE():   Intern<Stage> { Stage{Ingress, 18, i"ls_in_dhcp_response"}.intern() }
function s_SWITCH_IN_DNS_LOOKUP():      Intern<Stage> { Stage{Ingress, 19, i"ls_in_dns_lookup"}.intern() }
function s_SWITCH_IN_DNS_RESPONSE():    Intern<Stage> { Stage{Ingress, 20, i"ls_in_dns_response"}.intern() }
function s_SWITCH_IN_EXTERNAL_PORT():   Intern<Stage> { Stage{Ingress, 21, i"ls_in_external_port"}.intern() }
function s_SWITCH_IN_L2_LKUP():         Intern<Stage> { Stage{Ingress, 22, i"ls_in_l2_lkup"}.intern() }
function s_SWITCH_IN_L2_UNKNOWN():      Intern<Stage> { Stage{Ingress, 23, i"ls_in_l2_unknown"}.intern() }

/* Logical switch egress stages. */
function s_SWITCH_OUT_PRE_LB():         Intern<Stage> { Stage{ Egress,  0, i"ls_out_pre_lb"}.intern() }
function s_SWITCH_OUT_PRE_ACL():        Intern<Stage> { Stage{ Egress,  1, i"ls_out_pre_acl"}.intern() }
function s_SWITCH_OUT_PRE_STATEFUL():   Intern<Stage> { Stage{ Egress,  2, i"ls_out_pre_stateful"}.intern() }
function s_SWITCH_OUT_ACL_HINT():       Intern<Stage> { Stage{ Egress,  3, i"ls_out_acl_hint"}.intern() }
function s_SWITCH_OUT_ACL():            Intern<Stage> { Stage{ Egress,  4, i"ls_out_acl"}.intern() }
function s_SWITCH_OUT_QOS_MARK():       Intern<Stage> { Stage{ Egress,  5, i"ls_out_qos_mark"}.intern() }
function s_SWITCH_OUT_QOS_METER():      Intern<Stage> { Stage{ Egress,  6, i"ls_out_qos_meter"}.intern() }
function s_SWITCH_OUT_STATEFUL():       Intern<Stage> { Stage{ Egress,  7, i"ls_out_stateful"}.intern() }
function s_SWITCH_OUT_PORT_SEC_IP():    Intern<Stage> { Stage{ Egress,  8, i"ls_out_port_sec_ip"}.intern() }
function s_SWITCH_OUT_PORT_SEC_L2():    Intern<Stage> { Stage{ Egress,  9, i"ls_out_port_sec_l2"}.intern() }

/* Logical router ingress stages. */
function s_ROUTER_IN_ADMISSION():       Intern<Stage> { Stage{Ingress,  0, i"lr_in_admission"}.intern() }
function s_ROUTER_IN_LOOKUP_NEIGHBOR(): Intern<Stage> { Stage{Ingress,  1, i"lr_in_lookup_neighbor"}.intern() }
function s_ROUTER_IN_LEARN_NEIGHBOR():  Intern<Stage> { Stage{Ingress,  2, i"lr_in_learn_neighbor"}.intern() }
function s_ROUTER_IN_IP_INPUT():        Intern<Stage> { Stage{Ingress,  3, i"lr_in_ip_input"}.intern() }
function s_ROUTER_IN_UNSNAT():          Intern<Stage> { Stage{Ingress,  4, i"lr_in_unsnat"}.intern() }
function s_ROUTER_IN_DEFRAG():          Intern<Stage> { Stage{Ingress,  5, i"lr_in_defrag"}.intern() }
function s_ROUTER_IN_DNAT():            Intern<Stage> { Stage{Ingress,  6, i"lr_in_dnat"}.intern() }
function s_ROUTER_IN_ECMP_STATEFUL():   Intern<Stage> { Stage{Ingress,  7, i"lr_in_ecmp_stateful"}.intern() }
function s_ROUTER_IN_ND_RA_OPTIONS():   Intern<Stage> { Stage{Ingress,  8, i"lr_in_nd_ra_options"}.intern() }
function s_ROUTER_IN_ND_RA_RESPONSE():  Intern<Stage> { Stage{Ingress,  9, i"lr_in_nd_ra_response"}.intern() }
function s_ROUTER_IN_IP_ROUTING():      Intern<Stage> { Stage{Ingress, 10, i"lr_in_ip_routing"}.intern() }
function s_ROUTER_IN_IP_ROUTING_ECMP(): Intern<Stage> { Stage{Ingress, 11, i"lr_in_ip_routing_ecmp"}.intern() }
function s_ROUTER_IN_POLICY():          Intern<Stage> { Stage{Ingress, 12, i"lr_in_policy"}.intern() }
function s_ROUTER_IN_POLICY_ECMP():     Intern<Stage> { Stage{Ingress, 13, i"lr_in_policy_ecmp"}.intern() }
function s_ROUTER_IN_ARP_RESOLVE():     Intern<Stage> { Stage{Ingress, 14, i"lr_in_arp_resolve"}.intern() }
function s_ROUTER_IN_CHK_PKT_LEN():     Intern<Stage> { Stage{Ingress, 15, i"lr_in_chk_pkt_len"}.intern() }
function s_ROUTER_IN_LARGER_PKTS():     Intern<Stage> { Stage{Ingress, 16, i"lr_in_larger_pkts"}.intern() }
function s_ROUTER_IN_GW_REDIRECT():     Intern<Stage> { Stage{Ingress, 17, i"lr_in_gw_redirect"}.intern() }
function s_ROUTER_IN_ARP_REQUEST():     Intern<Stage> { Stage{Ingress, 18, i"lr_in_arp_request"}.intern() }

/* Logical router egress stages. */
function s_ROUTER_OUT_UNDNAT():         Intern<Stage> { Stage{ Egress,  0, i"lr_out_undnat"}.intern() }
function s_ROUTER_OUT_POST_UNDNAT():    Intern<Stage> { Stage{ Egress,  1, i"lr_out_post_undnat"}.intern() }
function s_ROUTER_OUT_SNAT():           Intern<Stage> { Stage{ Egress,  2, i"lr_out_snat"}.intern() }
function s_ROUTER_OUT_EGR_LOOP():       Intern<Stage> { Stage{ Egress,  3, i"lr_out_egr_loop"}.intern() }
function s_ROUTER_OUT_DELIVERY():       Intern<Stage> { Stage{ Egress,  4, i"lr_out_delivery"}.intern() }

/*
 * OVS register usage:
 *
 * Logical Switch pipeline:
 * +----+----------------------------------------------+---+------------------+
 * | R0 |     REGBIT_{CONNTRACK/DHCP/DNS}              |   |                  |
 * |    |     REGBIT_{HAIRPIN/HAIRPIN_REPLY}           |   |                  |
 * |    |     REGBIT_ACL_LABEL                         | X |                  |
 * +----+----------------------------------------------+ X |                  |
 * | R1 |         ORIG_DIP_IPV4 (>= IN_STATEFUL)       | R |                  |
 * +----+----------------------------------------------+ E |                  |
 * | R2 |         ORIG_TP_DPORT (>= IN_STATEFUL)       | G |                  |
 * +----+----------------------------------------------+ 0 |                  |
 * | R3 |                   ACL_LABEL                  |   |                  |
 * +----+----------------------------------------------+---+------------------+
 * | R4 |                   UNUSED                     |   |                  |
 * +----+----------------------------------------------+ X |   ORIG_DIP_IPV6  |
 * | R5 |                   UNUSED                     | X | (>= IN_STATEFUL) |
 * +----+----------------------------------------------+ R |                  |
 * | R6 |                   UNUSED                     | E |                  |
 * +----+----------------------------------------------+ G |                  |
 * | R7 |                   UNUSED                     | 1 |                  |
 * +----+----------------------------------------------+---+------------------+
 * | R8 |                   UNUSED                     |
 * +----+----------------------------------------------+
 * | R9 |                   UNUSED                     |
 * +----+----------------------------------------------+
 *
 * Logical Router pipeline:
 * +-----+--------------------------+---+-----------------+---+---------------+
 * | R0  | REGBIT_ND_RA_OPTS_RESULT |   |                 |   |               |
 * |     |   (= IN_ND_RA_OPTIONS)   | X |                 |   |               |
 * |     |      NEXT_HOP_IPV4       | R |                 |   |               |
 * |     |      (>= IP_INPUT)       | E | INPORT_ETH_ADDR | X |               |
 * +-----+--------------------------+ G |   (< IP_INPUT)  | X |               |
 * | R1  |   SRC_IPV4 for ARP-REQ   | 0 |                 | R |               |
 * |     |      (>= IP_INPUT)       |   |                 | E | NEXT_HOP_IPV6 |
 * +-----+--------------------------+---+-----------------+ G | (>= DEFRAG)   |
 * | R2  |        UNUSED            | X |                 | 0 |               |
 * |     |                          | R |                 |   |               |
 * +-----+--------------------------+ E |     UNUSED      |   |               |
 * | R3  |        UNUSED            | G |                 |   |               |
 * |     |                          | 1 |                 |   |               |
 * +-----+--------------------------+---+-----------------+---+---------------+
 * | R4  |        UNUSED            | X |                 |   |               |
 * |     |                          | R |                 |   |               |
 * +-----+--------------------------+ E |     UNUSED      | X |               |
 * | R5  |        UNUSED            | G |                 | X |               |
 * |     |                          | 2 |                 | R |SRC_IPV6 for NS|
 * +-----+--------------------------+---+-----------------+ E | (>=           |
 * | R6  |        UNUSED            | X |                 | G | IN_IP_ROUTING)|
 * |     |                          | R |                 | 1 |               |
 * +-----+--------------------------+ E |     UNUSED      |   |               |
 * | R7  |        UNUSED            | G |                 |   |               |
 * |     |                          | 3 |                 |   |               |
 * +-----+--------------------------+---+-----------------+---+---------------+
 * | R8  |     ECMP_GROUP_ID        |   |                 |
 * |     |     ECMP_MEMBER_ID       | X |                 |
 * +-----+--------------------------+ R |                 |
 * |     | REGBIT_{                 | E |                 |
 * |     |   EGRESS_LOOPBACK/       | G |     UNUSED      |
 * | R9  |   PKT_LARGER/            | 4 |                 |
 * |     |   LOOKUP_NEIGHBOR_RESULT/|   |                 |
 * |     |   SKIP_LOOKUP_NEIGHBOR}  |   |                 |
 * |     |                          |   |                 |
 * |     | REG_ORIG_TP_DPORT_ROUTER |   |                 |
 * |     |                          |   |                 |
 * +-----+--------------------------+---+-----------------+
 *
 */

/* Register definitions specific to routers. */
function rEG_NEXT_HOP(): istring = i"reg0" /* reg0 for IPv4, xxreg0 for IPv6 */
function rEG_SRC(): istring = i"reg1"      /* reg1 for IPv4, xxreg1 for IPv6 */

/* Register definitions specific to switches. */
function rEGBIT_CONNTRACK_DEFRAG() : istring = i"reg0[0]"
function rEGBIT_CONNTRACK_COMMIT() : istring = i"reg0[1]"
function rEGBIT_CONNTRACK_NAT()    : istring = i"reg0[2]"
function rEGBIT_DHCP_OPTS_RESULT() : istring = i"reg0[3]"
function rEGBIT_DNS_LOOKUP_RESULT(): istring = i"reg0[4]"
function rEGBIT_ND_RA_OPTS_RESULT(): istring = i"reg0[5]"
function rEGBIT_HAIRPIN()          : istring = i"reg0[6]"
function rEGBIT_ACL_HINT_ALLOW_NEW(): istring = i"reg0[7]"
function rEGBIT_ACL_HINT_ALLOW()   : istring = i"reg0[8]"
function rEGBIT_ACL_HINT_DROP()    : istring = i"reg0[9]"
function rEGBIT_ACL_HINT_BLOCK()   : istring = i"reg0[10]"
function rEGBIT_LKUP_FDB()         : istring = i"reg0[11]"
function rEGBIT_HAIRPIN_REPLY()    : istring = i"reg0[12]"
function rEGBIT_ACL_LABEL()        : istring = i"reg0[13]"
function rEGBIT_FROM_RAMP()        : istring = i"reg0[14]"

function rEG_ORIG_DIP_IPV4()       : istring = i"reg1"
function rEG_ORIG_DIP_IPV6()       : istring = i"xxreg1"
function rEG_ORIG_TP_DPORT()       : istring = i"reg2[0..15]"

/* Register definitions for switches and routers. */

/* Indicate that this packet has been recirculated using egress
 * loopback.  This allows certain checks to be bypassed, such as a
* logical router dropping packets with source IP address equals
* one of the logical router's own IP addresses. */
function rEGBIT_EGRESS_LOOPBACK()  : istring = i"reg9[0]"
/* Register to store the result of check_pkt_larger action. */
function rEGBIT_PKT_LARGER()       : istring = i"reg9[1]"
function rEGBIT_LOOKUP_NEIGHBOR_RESULT() : istring = i"reg9[2]"
function rEGBIT_LOOKUP_NEIGHBOR_IP_RESULT() : istring = i"reg9[3]"

/* Register to store the eth address associated to a router port for packets
 * received in S_ROUTER_IN_ADMISSION.
 */
function rEG_INPORT_ETH_ADDR() : istring = i"xreg0[0..47]"

/* Register for ECMP bucket selection. */
function rEG_ECMP_GROUP_ID()  : istring = i"reg8[0..15]"
function rEG_ECMP_MEMBER_ID() : istring = i"reg8[16..31]"

function rEG_ORIG_TP_DPORT_ROUTER()  : string = "reg9[16..31]"

/* Register used for setting a label for ACLs in a Logical Switch. */
function rEG_LABEL() : istring = i"reg3"

function fLAGBIT_NOT_VXLAN() : istring = i"flags[1] == 0"

function mFF_N_LOG_REGS()          : bit<32> = 10

/*
 * Generating sb::Logical_Flow and sb::Logical_DP_Group.
 *
 * Some logical flows occur in multiple logical datapaths.  These can
 * be represented two ways: either as multiple Logical_Flow records
 * (each with logical_datapath set appropriately) or as a single
 * Logical_Flow record that points to a Logical_DP_Group record that
 * lists all the datapaths it's in.  (It would be possible to mix or
 * duplicate these methods, but we don't do that.)  We have to support
 * both:
 *
 *    - There's a setting "use_logical_dp_groups" that globally
 *      enables or disables this feature.
 */

relation Flow(
    logical_datapath: uuid,
    stage:            Intern<Stage>,
    priority:         integer,
    __match:          istring,
    actions:          istring,
    io_port:          Option<istring>,
    controller_meter: Option<istring>,
    stage_hint:       bit<32>
)

function stage_hint(_uuid: uuid): bit<32> {
    _uuid[127:96]
}

/* If this option is 'true' northd will combine logical flows that differ by
 * logical datapath only by creating a datapath group. */
relation UseLogicalDatapathGroups[bool]
UseLogicalDatapathGroups[use_logical_dp_groups] :-
    nb in nb::NB_Global(),
    var use_logical_dp_groups = nb.options.get_bool_def(i"use_logical_dp_groups", true).
UseLogicalDatapathGroups[false] :-
    Unit(),
    not nb in nb::NB_Global().

relation AggregatedFlow (
    logical_datapaths: Set<uuid>,
    stage:             Intern<Stage>,
    priority:          integer,
    __match:           istring,
    actions:           istring,
    io_port:           Option<istring>,
    controller_meter:  Option<istring>,
    stage_hint:        bit<32>
)
function make_flow_tags(io_port: Option<istring>): Map<istring,istring> {
    match (io_port) {
        None -> map_empty(),
        Some{s} -> [ i"in_out_port" -> s ]
    }
}
function make_flow_external_ids(stage_hint: bit<32>, stage: Intern<Stage>): Map<istring,istring> {
    if (stage_hint == 0) {
        [i"stage-name" -> stage.table_name]
    } else {
        [i"stage-name" -> stage.table_name,
         i"stage-hint" -> i"${hex(stage_hint)}"]
    }
}
AggregatedFlow(.logical_datapaths = g.to_set(),
               .stage = stage,
               .priority = priority,
               .__match = __match,
               .actions = actions,
               .io_port = io_port,
               .controller_meter = controller_meter,
               .stage_hint = stage_hint) :-
    UseLogicalDatapathGroups[true],
    Flow(logical_datapath, stage, priority, __match, actions, io_port, controller_meter, stage_hint),
    var g = logical_datapath.group_by((stage, priority, __match, actions, io_port, controller_meter, stage_hint)).


AggregatedFlow(.logical_datapaths = set_singleton(logical_datapath),
               .stage = stage,
               .priority = priority,
               .__match = __match,
               .actions = actions,
               .io_port = io_port,
               .controller_meter = controller_meter,
               .stage_hint = stage_hint) :-
    UseLogicalDatapathGroups[false],
    Flow(logical_datapath, stage, priority, __match, actions, io_port, controller_meter, stage_hint).


function to_istring(pipeline: Pipeline): istring {
    if (pipeline == Ingress) {
        i"ingress"
    } else {
        i"egress"
    }
}

for (f in AggregatedFlow()) {
    if (f.logical_datapaths.size() == 1) {
        Some{var dp} = f.logical_datapaths.nth(0) in
        sb::Out_Logical_Flow(
            ._uuid = hash128((dp, f.stage, f.priority, f.__match, f.actions, f.controller_meter, f.io_port, f.stage_hint)),
            .logical_datapath = Some{dp},
            .logical_dp_group = None,
            .pipeline         = f.stage.pipeline.to_istring(),
            .table_id         = f.stage.table_id as integer,
            .priority         = f.priority,
            .controller_meter = f.controller_meter,
            .__match          = f.__match,
            .actions          = f.actions,
            .tags             = make_flow_tags(f.io_port),
            .external_ids     = make_flow_external_ids(f.stage_hint, f.stage))
    } else {
        var group_uuid = hash128(f.logical_datapaths) in {
            sb::Out_Logical_Flow(
                ._uuid = hash128((group_uuid, f.stage, f.priority, f.__match, f.actions, f.controller_meter, f.io_port, f.stage_hint)),
                .logical_datapath = None,
                .logical_dp_group = Some{group_uuid},
                .pipeline         = f.stage.pipeline.to_istring(),
                .table_id         = f.stage.table_id as integer,
                .priority         = f.priority,
                .controller_meter = f.controller_meter,
                .__match          = f.__match,
                .actions          = f.actions,
                .tags             = make_flow_tags(f.io_port),
                .external_ids     = make_flow_external_ids(f.stage_hint, f.stage));
            sb::Out_Logical_DP_Group(._uuid = group_uuid, .datapaths = f.logical_datapaths)
        }
    }
}

/* Logical flows for forwarding groups. */
Flow(.logical_datapath = sw._uuid,
     .stage            = s_SWITCH_IN_ARP_ND_RSP(),
     .priority         = 50,
     .__match          = __match,
     .actions          = actions,
     .stage_hint       = stage_hint(fg_uuid),
     .io_port          = None,
     .controller_meter = None) :-
    sw in &Switch(),
    &nb::Logical_Switch(._uuid = sw._uuid, .forwarding_groups = forwarding_groups),
    var fg_uuid = FlatMap(forwarding_groups),
    fg in nb::Forwarding_Group(._uuid = fg_uuid),
    not fg.child_port.is_empty(),
    var __match = i"arp.tpa == ${fg.vip} && arp.op == 1",
    var actions = i"eth.dst = eth.src; "
                  "eth.src = ${fg.vmac}; "
                  "arp.op = 2; /* ARP reply */ "
                  "arp.tha = arp.sha; "
                  "arp.sha = ${fg.vmac}; "
                  "arp.tpa = arp.spa; "
                  "arp.spa = ${fg.vip}; "
                  "outport = inport; "
                  "flags.loopback = 1; "
                  "output;".

function escape_child_ports(child_port: Set<istring>): string {
    var escaped = vec_with_capacity(child_port.size());
    for (s in child_port) {
        escaped.push(json_escape(s))
    };
    escaped.join(",")
}
Flow(.logical_datapath = sw._uuid,
     .stage            = s_SWITCH_IN_L2_LKUP(),
     .priority         = 50,
     .__match          = __match,
     .actions          = actions.intern(),
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    sw in &Switch(),
    &nb::Logical_Switch(._uuid = sw._uuid, .forwarding_groups = forwarding_groups),
    var fg_uuid = FlatMap(forwarding_groups),
    fg in nb::Forwarding_Group(._uuid = fg_uuid),
    not fg.child_port.is_empty(),
    var __match = i"eth.dst == ${fg.vmac}",
    var actions = "fwd_group(" ++
                  if (fg.liveness) { "liveness=\"true\"," } else { "" } ++
                  "childports=" ++ escape_child_ports(fg.child_port) ++ ");".

/* Logical switch ingress table PORT_SEC_L2: admission control framework
 * (priority 100) */
for (sw in &Switch()) {
    if (not sw.is_vlan_transparent) {
        /* Block logical VLANs. */
        Flow(.logical_datapath = sw._uuid,
             .stage            = s_SWITCH_IN_PORT_SEC_L2(),
             .priority         = 100,
             .__match          = i"vlan.present",
             .actions          = i"drop;",
             .stage_hint       = 0 /*TODO: check*/,
             .io_port          = None,
             .controller_meter = None)
    };

    /* Broadcast/multicast source address is invalid */
    Flow(.logical_datapath = sw._uuid,
         .stage            = s_SWITCH_IN_PORT_SEC_L2(),
         .priority         = 100,
         .__match          = i"eth.src[40]",
         .actions          = i"drop;",
         .stage_hint       = 0 /*TODO: check*/,
         .io_port          = None,
         .controller_meter = None)
    /* Port security flows have priority 50 (see below) and will continue to the next table
       if packet source is acceptable. */
}

// space-separated set of strings
function join(strings: Set<string>, sep: string): string {
    strings.to_vec().join(sep)
}

function build_port_security_ipv6_flow(
    pipeline: Pipeline,
    ea: eth_addr,
    ipv6_addrs: Vec<ipv6_netaddr>): string =
{
    var ip6_addrs = vec_empty();

    /* Allow link-local address. */
    ip6_addrs.push(ea.to_ipv6_lla().string_mapped());

    /* Allow ip6.dst=ff00::/8 for multicast packets */
    if (pipeline == Egress) {
        ip6_addrs.push("ff00::/8")
    };
    for (addr in ipv6_addrs) {
        ip6_addrs.push(addr.match_network())
    };

    var dir = if (pipeline == Ingress) { "src" } else { "dst" };
    " && ip6.${dir} == {" ++ ip6_addrs.join(", ") ++ "}"
}

function build_port_security_ipv6_nd_flow(
    ea: eth_addr,
    ipv6_addrs: Vec<ipv6_netaddr>): string =
{
    var __match = " && ip6 && nd && ((nd.sll == ${eth_addr_zero()} || "
                  "nd.sll == ${ea}) || ((nd.tll == ${eth_addr_zero()} || "
                  "nd.tll == ${ea})";
    if (ipv6_addrs.is_empty()) {
        __match ++ "))"
    } else {
        __match = __match ++ " && (nd.target == ${ea.to_ipv6_lla()}";

        for(addr in ipv6_addrs) {
            __match = __match ++ " || nd.target == ${addr.match_network()}"
        };
        __match ++ ")))"
    }
}

/* Pre-ACL */
for (&Switch(._uuid =ls_uuid)) {
    /* Ingress and Egress Pre-ACL Table (Priority 0): Packets are
     * allowed by default. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_ACL(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_ACL(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_ACL(),
         .priority         = 110,
         .__match          = i"eth.dst == $svc_monitor_mac",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_ACL(),
         .priority         = 110,
         .__match          = i"eth.src == $svc_monitor_mac",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* stateless filters always take precedence over stateful ACLs. */
for (&SwitchACL(.sw = sw@&Switch{._uuid = ls_uuid}, .acl = acl, .has_fair_meter = fair_meter)) {
    if (sw.has_stateful_acl) {
        if (acl.action == i"allow-stateless") {
            if (acl.direction == i"from-lport") {
                Flow(.logical_datapath = ls_uuid,
                     .stage            = s_SWITCH_IN_PRE_ACL(),
                     .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                     .__match          = acl.__match,
                     .actions          = i"next;",
                     .stage_hint       = stage_hint(acl._uuid),
                     .io_port          = None,
                     .controller_meter = None)
            } else {
                Flow(.logical_datapath = ls_uuid,
                     .stage            = s_SWITCH_OUT_PRE_ACL(),
                     .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                     .__match          = acl.__match,
                     .actions          = i"next;",
                     .stage_hint       = stage_hint(acl._uuid),
                     .io_port          = None,
                     .controller_meter = None)
            }
        }
    }
}

/* If there are any stateful ACL rules in this datapath, we must
 * send all IP packets through the conntrack action, which handles
 * defragmentation, in order to match L4 headers. */

for (&SwitchPort(.lsp = lsp@&nb::Logical_Switch_Port{.__type = i"router"},
                 .json_name = lsp_name,
                 .sw = &Switch{._uuid = ls_uuid, .has_stateful_acl = true})) {
    /* Can't use ct() for router ports. Consider the
     * following configuration: lp1(10.0.0.2) on
     * hostA--ls1--lr0--ls2--lp2(10.0.1.2) on hostB, For a
     * ping from lp1 to lp2, First, the response will go
     * through ct() with a zone for lp2 in the ls2 ingress
     * pipeline on hostB.  That ct zone knows about this
     * connection. Next, it goes through ct() with the zone
     * for the router port in the egress pipeline of ls2 on
     * hostB.  This zone does not know about the connection,
     * as the icmp request went through the logical router
     * on hostA, not hostB. This would only work with
     * distributed conntrack state across all chassis. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_ACL(),
         .priority         = 110,
         .__match          = i"ip && inport == ${lsp_name}",
         .actions          = i"next;",
         .stage_hint       = stage_hint(lsp._uuid),
         .io_port          = Some{lsp.name},
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_ACL(),
         .priority         = 110,
         .__match          = i"ip && outport == ${lsp_name}",
         .actions          = i"next;",
         .stage_hint       = stage_hint(lsp._uuid),
         .io_port          = Some{lsp.name},
         .controller_meter = None)
}

for (&SwitchPort(.lsp = lsp@&nb::Logical_Switch_Port{.__type = i"localnet"},
                 .json_name = lsp_name,
                 .sw = &Switch{._uuid = ls_uuid, .has_stateful_acl = true})) {
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_ACL(),
         .priority         = 110,
         .__match          = i"ip && inport == ${lsp_name}",
         .actions          = i"next;",
         .stage_hint       = stage_hint(lsp._uuid),
         .io_port          = Some{lsp.name},
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_ACL(),
         .priority         = 110,
         .__match          = i"ip && outport == ${lsp_name}",
         .actions          = i"next;",
         .stage_hint       = stage_hint(lsp._uuid),
         .io_port          = Some{lsp.name},
         .controller_meter = None)
}

for (&Switch(._uuid = ls_uuid, .has_stateful_acl = true)) {
    /* Ingress and Egress Pre-ACL Table (Priority 110).
     *
     * Not to do conntrack on ND and ICMP destination
     * unreachable packets. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_ACL(),
         .priority         = 110,
         .__match          = i"nd || nd_rs || nd_ra || mldv1 || mldv2 || "
                             "(udp && udp.src == 546 && udp.dst == 547)",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_ACL(),
         .priority         = 110,
         .__match          = i"nd || nd_rs || nd_ra || mldv1 || mldv2 || "
                             "(udp && udp.src == 546 && udp.dst == 547)",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* Do not send coming from RAMP switch packets to conntrack. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_ACL(),
         .priority         = 110,
         .__match          = i"${rEGBIT_FROM_RAMP()} == 1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* Ingress and Egress Pre-ACL Table (Priority 100).
     *
     * Regardless of whether the ACL is "from-lport" or "to-lport",
     * we need rules in both the ingress and egress table, because
     * the return traffic needs to be followed.
     *
     * 'REGBIT_CONNTRACK_DEFRAG' is set to let the pre-stateful table send
     * it to conntrack for tracking and defragmentation. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_ACL(),
         .priority         = 100,
         .__match          = i"ip",
         .actions          = i"${rEGBIT_CONNTRACK_DEFRAG()} = 1; next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_ACL(),
         .priority         = 100,
         .__match          = i"ip",
         .actions          = i"${rEGBIT_CONNTRACK_DEFRAG()} = 1; next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Pre-LB */
for (&Switch(._uuid = ls_uuid)) {
    /* Do not send ND packets to conntrack */
    var __match = i"nd || nd_rs || nd_ra || mldv1 || mldv2" in {
        Flow(.logical_datapath = ls_uuid,
             .stage            = s_SWITCH_IN_PRE_LB(),
             .priority         = 110,
             .__match          = __match,
             .actions          = i"next;",
             .stage_hint       = 0,
             .io_port          = None,
             .controller_meter = None);
        Flow(.logical_datapath = ls_uuid,
             .stage            = s_SWITCH_OUT_PRE_LB(),
             .priority         = 110,
             .__match          = __match,
             .actions          = i"next;",
             .stage_hint       = 0,
             .io_port          = None,
             .controller_meter = None)
    };

    /* Do not send service monitor packets to conntrack. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_LB(),
         .priority         = 110,
         .__match          = i"eth.dst == $svc_monitor_mac",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_LB(),
         .priority         = 110,
         .__match          = i"eth.src == $svc_monitor_mac",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* Do not send coming from RAMP switch packets to conntrack. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_LB(),
         .priority         = 110,
         .__match          = i"${rEGBIT_FROM_RAMP()} == 1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* Allow all packets to go to next tables by default. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_LB(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_LB(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

for (&SwitchPort(.lsp = lsp, .json_name = lsp_name, .sw = &Switch{._uuid = ls_uuid}))
if (lsp.__type == i"router" or lsp.__type == i"localnet") {
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_LB(),
         .priority         = 110,
         .__match          = i"ip && inport == ${lsp_name}",
         .actions          = i"next;",
         .stage_hint       = stage_hint(lsp._uuid),
         .io_port          = Some{lsp.name},
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_LB(),
         .priority         = 110,
         .__match          = i"ip && outport == ${lsp_name}",
         .actions          = i"next;",
         .stage_hint       = stage_hint(lsp._uuid),
         .io_port          = Some{lsp.name},
         .controller_meter = None)
}

/* Empty LoadBalancer Controller event */
function build_empty_lb_event_flow(key: istring, lb: Intern<nb::Load_Balancer>): Option<(istring, istring)> {
    (var ip, var port) = match (ip_address_and_port_from_lb_key(key.ival())) {
        Some{(ip, port)} -> (ip, port),
        _ -> return None
    };

    var protocol = if (lb.protocol == Some{i"tcp"}) { "tcp" } else { "udp" };
    var vip = match (port) {
        0 -> "${ip}",
        _ -> "${ip.to_bracketed_string()}:${port}"
    };

    var __match = vec_with_capacity(2);
    __match.push("${ip.ipX()}.dst == ${ip}");
    if (port != 0) {
        __match.push("${protocol}.dst == ${port}");
    };

    var action = i"trigger_event("
                 "event = \"empty_lb_backends\", "
                 "vip = \"${vip}\", "
                 "protocol = \"${protocol}\", "
                 "load_balancer = \"${uuid2str(lb._uuid)}\");";

    Some{(__match.join(" && ").intern(), action)}
}

/* Contains the load balancers for which an event should be sent each time it
 * runs out of backends.
 *
 * The preferred way to do this by setting an individual Load_Balancer's
 * options:event=true.
 *
 * The deprecated way is to set nb::NB_Global options:controller_event=true,
 * which enables events for every load balancer.
 */
relation LoadBalancerEmptyEvents(lb_uuid: uuid)
LoadBalancerEmptyEvents(lb_uuid) :-
    nb::NB_Global(.options = global_options),
    var global_events = global_options.get_bool_def(i"controller_event", false),
    &nb::Load_Balancer(._uuid = lb_uuid, .options = local_options),
    var local_events = local_options.get_bool_def(i"event", false),
    global_events or local_events.

Flow(.logical_datapath = sw._uuid,
     .stage            = s_SWITCH_IN_PRE_LB(),
     .priority         = 130,
     .__match          = __match,
     .actions          = __action,
     .io_port          = None,
     .controller_meter = sw.copp.get(cOPP_EVENT_ELB()),
     .stage_hint       = stage_hint(lb._uuid)) :-
    SwitchLBVIP(.sw_uuid = sw_uuid, .lb = lb, .vip = vip, .backends = backends),
    LoadBalancerEmptyEvents(lb._uuid),
    not lb.options.get_bool_def(i"reject", false),
    sw in &Switch(._uuid = sw_uuid),
    backends == i"",
    Some {(var __match, var __action)} = build_empty_lb_event_flow(vip, lb).

/* 'REGBIT_CONNTRACK_NAT' is set to let the pre-stateful table send
 * packet to conntrack for defragmentation.
 *
 * Send all the packets to conntrack in the ingress pipeline if the
 * logical switch has a load balancer with VIP configured. Earlier
 * we used to set the REGBIT_CONNTRACK_DEFRAG flag in the ingress pipeline
 * if the IP destination matches the VIP. But this causes few issues when
 * a logical switch has no ACLs configured with allow-related.
 * To understand the issue, lets a take a TCP load balancer -
 * 10.0.0.10:80=10.0.0.3:80.
 * If a logical port - p1 with IP - 10.0.0.5 opens a TCP connection with
 * the VIP - 10.0.0.10, then the packet in the ingress pipeline of 'p1'
 * is sent to the p1's conntrack zone id and the packet is load balanced
 * to the backend - 10.0.0.3. For the reply packet from the backend lport,
 * it is not sent to the conntrack of backend lport's zone id. This is fine
 * as long as the packet is valid. Suppose the backend lport sends an
 *  invalid TCP packet (like incorrect sequence number), the packet gets
 * delivered to the lport 'p1' without unDNATing the packet to the
 * VIP - 10.0.0.10. And this causes the connection to be reset by the
 * lport p1's VIF.
 *
 * We can't fix this issue by adding a logical flow to drop ct.inv packets
 * in the egress pipeline since it will drop all other connections not
 * destined to the load balancers.
 *
 * To fix this issue, we send all the packets to the conntrack in the
 * ingress pipeline if a load balancer is configured. We can now
 * add a lflow to drop ct.inv packets.
 */
for (sw in &Switch(.has_lb_vip = true)) {
    Flow(.logical_datapath = sw._uuid,
         .stage            = s_SWITCH_IN_PRE_LB(),
         .priority         = 100,
         .__match          = i"ip",
         .actions          = i"${rEGBIT_CONNTRACK_NAT()} = 1; next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = sw._uuid,
         .stage            = s_SWITCH_OUT_PRE_LB(),
         .priority         = 100,
         .__match          = i"ip",
         .actions          = i"${rEGBIT_CONNTRACK_NAT()} = 1; next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Pre-stateful */
relation LbProtocol[string]
LbProtocol["tcp"].
LbProtocol["udp"].
LbProtocol["sctp"].
for (&Switch(._uuid = ls_uuid)) {
    /* Ingress and Egress pre-stateful Table (Priority 0): Packets are
     * allowed by default. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_STATEFUL(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_STATEFUL(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* If rEGBIT_CONNTRACK_NAT() is set as 1, then packets should just be sent
     * through nat (without committing).
     *
     * rEGBIT_CONNTRACK_COMMIT() is set for new connections and
     * rEGBIT_CONNTRACK_NAT() is set for established connections. So they
     * don't overlap.
     *
     * In the ingress pipeline, also store the original destination IP and
     * transport port to be used when detecting hairpin packets.
     */
    for (LbProtocol[protocol]) {
        Flow(.logical_datapath = ls_uuid,
             .stage            = s_SWITCH_IN_PRE_STATEFUL(),
             .priority         = 120,
             .__match          = i"${rEGBIT_CONNTRACK_NAT()} == 1 && ip4 && ${protocol}",
             .actions          = i"${rEG_ORIG_DIP_IPV4()} = ip4.dst; "
                                 "${rEG_ORIG_TP_DPORT()} = ${protocol}.dst; ct_lb;",
             .stage_hint       = 0,
             .io_port          = None,
             .controller_meter = None);
        Flow(.logical_datapath = ls_uuid,
             .stage            = s_SWITCH_IN_PRE_STATEFUL(),
             .priority         = 120,
             .__match          = i"${rEGBIT_CONNTRACK_NAT()} == 1 && ip6 && ${protocol}",
             .actions          = i"${rEG_ORIG_DIP_IPV6()} = ip6.dst; "
                                 "${rEG_ORIG_TP_DPORT()} = ${protocol}.dst; ct_lb;",
             .stage_hint       = 0,
             .io_port          = None,
             .controller_meter = None)
    };

    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_STATEFUL(),
         .priority         = 110,
         .__match          = i"${rEGBIT_CONNTRACK_NAT()} == 1",
         .actions          = i"ct_lb;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_STATEFUL(),
         .priority         = 110,
         .__match          = i"${rEGBIT_CONNTRACK_NAT()} == 1",
         .actions          = i"ct_lb;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* If rEGBIT_CONNTRACK_DEFRAG() is set as 1, then the packets should be
     * sent to conntrack for tracking and defragmentation. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PRE_STATEFUL(),
         .priority         = 100,
         .__match          = i"${rEGBIT_CONNTRACK_DEFRAG()} == 1",
         .actions          = i"ct_next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PRE_STATEFUL(),
         .priority         = 100,
         .__match          = i"${rEGBIT_CONNTRACK_DEFRAG()} == 1",
         .actions          = i"ct_next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

function acl_log_meter_name(meter_name: istring, acl_uuid: uuid): string =
{
    "${meter_name}__${uuid2str(acl_uuid)}"
}

function build_acl_log(acl: Intern<nb::ACL>, fair_meter: bool): string =
{
    if (not acl.log) {
        ""
    } else {
        var strs = vec_empty();
        match (acl.name) {
            None -> (),
            Some{name} -> strs.push("name=${json_escape(name)}")
        };
        /* If a severity level isn't specified, default to "info". */
        match (acl.severity) {
            None -> strs.push("severity=info"),
            Some{severity} -> strs.push("severity=${severity}")
        };
        match (acl.action.ival()) {
            "drop" -> {
                strs.push("verdict=drop")
            },
            "reject" -> {
                strs.push("verdict=reject")
            },
            "allow" -> {
                strs.push("verdict=allow")
            },
            "allow-related" -> {
                strs.push("verdict=allow")
            },
            "allow-stateless" -> {
                strs.push("verdict=allow")
            },
            _ -> ()
        };
        match (acl.meter) {
            Some{meter} -> {
                var name = match (fair_meter) {
                    true -> acl_log_meter_name(meter, acl._uuid),
                    false -> meter.ival()
                };
                strs.push("meter=${json_escape(name)}")
            },
            None -> ()
        };
        "log(${strs.join(\", \")}); "
    }
}

/* Due to various hard-coded priorities need to implement ACLs, the
 * northbound database supports a smaller range of ACL priorities than
 * are available to logical flows.  This value is added to an ACL
 * priority to determine the ACL's logical flow priority. */
function oVN_ACL_PRI_OFFSET(): integer = 1000

/* Intermediate relation that stores reject ACLs.
 * The following rules generate logical flows for these ACLs.
 */
relation Reject(
    lsuuid: uuid,
    pipeline: Pipeline,
    stage: Intern<Stage>,
    acl: Intern<nb::ACL>,
    fair_meter: bool,
    controller_meter: Option<istring>,
    extra_match: istring,
    extra_actions: istring)

/* build_reject_acl_rules() */
function next_to_stage(stage: Intern<Stage>): string {
    var pipeline = match (stage.pipeline) {
        Ingress -> "ingress",
        Egress -> "egress"
    };
    "next(pipeline=${pipeline},table=${stage.table_id})"
}
for (Reject(lsuuid, pipeline, stage, acl, fair_meter, controller_meter,
            extra_match_, extra_actions_)) {
    var extra_match = if (extra_match_ == i"") { "" } else { "(${extra_match_}) && " } in
    var extra_actions = if (extra_actions_ == i"") { "" } else { "${extra_actions_} " } in
    var next_stage = match (pipeline) {
        Ingress  -> s_SWITCH_OUT_QOS_MARK(),
        Egress -> s_SWITCH_IN_L2_LKUP()
    } in
    var acl_log = build_acl_log(acl, fair_meter) in
    var __match = extra_match ++ acl.__match in
    var actions = acl_log ++ extra_actions ++ "reg0 = 0; "
                  "reject { "
                  "/* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ "
                  "outport <-> inport; ${next_to_stage(next_stage)}; };" in
    Flow(.logical_datapath = lsuuid,
         .stage            = stage,
         .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
         .__match          = __match.intern(),
         .actions          = actions.intern(),
         .io_port          = None,
         .controller_meter = controller_meter,
         .stage_hint       = stage_hint(acl._uuid))
}

/* build_acls */
for (UseCtInvMatch[use_ct_inv_match]) {
    (var ct_inv_or, var and_not_ct_inv) = match (use_ct_inv_match) {
        true -> ("ct.inv || ", "&& !ct.inv "),
        false -> ("", ""),
    } in
    for (sw in &Switch(._uuid = ls_uuid))
    var has_stateful = sw.has_stateful_acl or sw.has_lb_vip in
    {
        /* Ingress and Egress ACL Table (Priority 0): Packets are allowed by
         * default.  If the logical switch has no ACLs or no load balancers,
         * then add 65535-priority flow to advance the packet to next
         * stage.
         *
         * A related rule at priority 1 is added below if there
         * are any stateful ACLs in this datapath. */
        var priority = if (not sw.has_acls and not sw.has_lb_vip) { 65535 } else { 0 }
        in
        {
            Flow(.logical_datapath = ls_uuid,
                .stage            = s_SWITCH_IN_ACL(),
                .priority         = priority,
                .__match          = i"1",
                .actions          = i"next;",
                .stage_hint       = 0,
                .io_port          = None,
                .controller_meter = None);
            Flow(.logical_datapath = ls_uuid,
                .stage            = s_SWITCH_OUT_ACL(),
                .priority         = priority,
                .__match          = i"1",
                .actions          = i"next;",
                .stage_hint       = 0,
                .io_port          = None,
                .controller_meter = None)
        };

        if (has_stateful) {
            /* Ingress and Egress ACL Table (Priority 1).
             *
             * By default, traffic is allowed.  This is partially handled by
             * the Priority 0 ACL flows added earlier, but we also need to
             * commit IP flows.  This is because, while the initiater's
             * direction may not have any stateful rules, the server's may
             * and then its return traffic would not have an associated
             * conntrack entry and would return "+invalid".
             *
             * We use "ct_commit" for a connection that is not already known
             * by the connection tracker.  Once a connection is committed,
             * subsequent packets will hit the flow at priority 0 that just
             * uses "next;"
             *
             * We also check for established connections that have ct_label.blocked
             * set on them.  That's a connection that was disallowed, but is
             * now allowed by policy again since it hit this default-allow flow.
             * We need to set ct_label.blocked=0 to let the connection continue,
             * which will be done by ct_commit() in the "stateful" stage.
             * Subsequent packets will hit the flow at priority 0 that just
             * uses "next;". */
            Flow(.logical_datapath = ls_uuid,
                 .stage            = s_SWITCH_IN_ACL(),
                 .priority         = 1,
                 .__match          = i"ip && (!ct.est || (ct.est && ct_label.blocked == 1))",
                 .actions          = i"${rEGBIT_CONNTRACK_COMMIT()} = 1; next;",
                 .stage_hint       = 0,
                 .io_port          = None,
                 .controller_meter = None);
            Flow(.logical_datapath = ls_uuid,
                 .stage            = s_SWITCH_OUT_ACL(),
                 .priority         = 1,
                 .__match          = i"ip && (!ct.est || (ct.est && ct_label.blocked == 1))",
                 .actions          = i"${rEGBIT_CONNTRACK_COMMIT()} = 1; next;",
                 .stage_hint       = 0,
                 .io_port          = None,
                 .controller_meter = None);

            /* Ingress and Egress ACL Table (Priority 65532).
             *
             * Always drop traffic that's in an invalid state.  Also drop
             * reply direction packets for connections that have been marked
             * for deletion (bit 0 of ct_label is set).
             *
             * This is enforced at a higher priority than ACLs can be defined. */
            var __match = (ct_inv_or ++ "(ct.est && ct.rpl && ct_label.blocked == 1)").intern() in {
                Flow(.logical_datapath = ls_uuid,
                     .stage            = s_SWITCH_IN_ACL(),
                     .priority         = 65532,
                     .__match          = __match,
                     .actions          = i"drop;",
                     .stage_hint       = 0,
                     .io_port          = None,
                     .controller_meter = None);
                Flow(.logical_datapath = ls_uuid,
                     .stage            = s_SWITCH_OUT_ACL(),
                     .priority         = 65532,
                     .__match          = __match,
                     .actions          = i"drop;",
                     .stage_hint       = 0,
                     .io_port          = None,
                     .controller_meter = None)
            };

            /* Ingress and Egress ACL Table (Priority 65532).
             *
             * Allow reply traffic that is part of an established
             * conntrack entry that has not been marked for deletion
             * (bit 0 of ct_label).  We only match traffic in the
             * reply direction because we want traffic in the request
             * direction to hit the currently defined policy from ACLs.
             *
             * This is enforced at a higher priority than ACLs can be defined. */
            var __match = ("ct.est && !ct.rel && !ct.new " ++ and_not_ct_inv ++
                           "&& ct.rpl && ct_label.blocked == 0").intern() in {
                Flow(.logical_datapath = ls_uuid,
                     .stage            = s_SWITCH_IN_ACL(),
                     .priority         = 65532,
                     .__match          = __match,
                     .actions          = i"next;",
                     .stage_hint       = 0,
                     .io_port          = None,
                     .controller_meter = None);
                Flow(.logical_datapath = ls_uuid,
                     .stage            = s_SWITCH_OUT_ACL(),
                     .priority         = 65532,
                     .__match          = __match,
                     .actions          = i"next;",
                     .stage_hint       = 0,
                     .io_port          = None,
                     .controller_meter = None)
            };

            /* Ingress and Egress ACL Table (Priority 65532).
             *
             * Allow traffic that is related to an existing conntrack entry that
             * has not been marked for deletion (bit 0 of ct_label).
             *
             * This is enforced at a higher priority than ACLs can be defined.
             *
             * NOTE: This does not support related data sessions (eg,
             * a dynamically negotiated FTP data channel), but will allow
             * related traffic such as an ICMP Port Unreachable through
             * that's generated from a non-listening UDP port.  */
            var __match = ("!ct.est && ct.rel && !ct.new " ++ and_not_ct_inv ++
                           "&& ct_label.blocked == 0").intern() in {
                Flow(.logical_datapath = ls_uuid,
                     .stage            = s_SWITCH_IN_ACL(),
                     .priority         = 65532,
                     .__match          = __match,
                     .actions          = i"next;",
                     .stage_hint       = 0,
                     .io_port          = None,
                     .controller_meter = None);
                Flow(.logical_datapath = ls_uuid,
                     .stage            = s_SWITCH_OUT_ACL(),
                     .priority         = 65532,
                     .__match          = __match,
                     .actions          = i"next;",
                     .stage_hint       = 0,
                     .io_port          = None,
                     .controller_meter = None)
            };

            /* Ingress and Egress ACL Table (Priority 65532).
             *
             * Not to do conntrack on ND packets. */
            Flow(.logical_datapath = ls_uuid,
                 .stage            = s_SWITCH_IN_ACL(),
                 .priority         = 65532,
                 .__match          = i"nd || nd_ra || nd_rs || mldv1 || mldv2",
                 .actions          = i"next;",
                 .stage_hint       = 0,
                 .io_port          = None,
                 .controller_meter = None);
            Flow(.logical_datapath = ls_uuid,
                 .stage            = s_SWITCH_OUT_ACL(),
                 .priority         = 65532,
                 .__match          = i"nd || nd_ra || nd_rs || mldv1 || mldv2",
                 .actions          = i"next;",
                 .stage_hint       = 0,
                 .io_port          = None,
                 .controller_meter = None)
        };

        /* Add a 34000 priority flow to advance the DNS reply from ovn-controller,
         * if the CMS has configured DNS records for the datapath.
         */
        if (sw.has_dns_records) {
            Flow(.logical_datapath = ls_uuid,
                 .stage            = s_SWITCH_OUT_ACL(),
                 .priority         = 34000,
                 .__match          = i"udp.src == 53",
                 .actions          = if has_stateful i"ct_commit; next;" else i"next;",
                 .stage_hint       = 0,
                 .io_port          = None,
                 .controller_meter = None)
        };

        if (sw.has_acls or sw.has_lb_vip) {
            /* Add a 34000 priority flow to advance the service monitor reply
             * packets to skip applying ingress ACLs. */
            Flow(.logical_datapath = ls_uuid,
                 .stage            = s_SWITCH_IN_ACL(),
                 .priority         = 34000,
                 .__match          = i"eth.dst == $svc_monitor_mac",
                 .actions          = i"next;",
                 .stage_hint       = 0,
                 .io_port          = None,
                 .controller_meter = None);
            Flow(.logical_datapath = ls_uuid,
                 .stage            = s_SWITCH_OUT_ACL(),
                 .priority         = 34000,
                 .__match          = i"eth.src == $svc_monitor_mac",
                 .actions          = i"next;",
                 .stage_hint       = 0,
                 .io_port          = None,
                 .controller_meter = None)
        }
    }
}

/* This stage builds hints for the IN/OUT_ACL stage. Based on various
 * combinations of ct flags packets may hit only a subset of the logical
 * flows in the IN/OUT_ACL stage.
 *
 * Populating ACL hints first and storing them in registers simplifies
 * the logical flow match expressions in the IN/OUT_ACL stage and
 * generates less openflows.
 *
 * Certain combinations of ct flags might be valid matches for multiple
 * types of ACL logical flows (e.g., allow/drop). In such cases hints
 * corresponding to all potential matches are set.
 */
input relation AclHintStages[Intern<Stage>]
AclHintStages[s_SWITCH_IN_ACL_HINT()].
AclHintStages[s_SWITCH_OUT_ACL_HINT()].
for (sw in &Switch(._uuid = ls_uuid)) {
    for (AclHintStages[stage]) {
        /* In any case, advance to the next stage. */
        var priority = if (not sw.has_acls and not sw.has_lb_vip) { 65535 } else { 0 } in
        Flow(ls_uuid, stage, priority, i"1", i"next;", None, None, 0)
    };

    for (AclHintStages[stage])
    if (sw.has_stateful_acl or sw.has_lb_vip) {
        /* New, not already established connections, may hit either allow
         * or drop ACLs. For allow ACLs, the connection must also be committed
         * to conntrack so we set REGBIT_ACL_HINT_ALLOW_NEW.
         */
        Flow(ls_uuid, stage, 7, i"ct.new && !ct.est",
             i"${rEGBIT_ACL_HINT_ALLOW_NEW()} = 1; "
             "${rEGBIT_ACL_HINT_DROP()} = 1; "
             "next;", None, None, 0);

        /* Already established connections in the "request" direction that
         * are already marked as "blocked" may hit either:
         * - allow ACLs for connections that were previously allowed by a
         *   policy that was deleted and is being readded now. In this case
         *   the connection should be recommitted so we set
         *   REGBIT_ACL_HINT_ALLOW_NEW.
         * - drop ACLs.
         */
        Flow(ls_uuid, stage, 6, i"!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1",
             i"${rEGBIT_ACL_HINT_ALLOW_NEW()} = 1; "
             "${rEGBIT_ACL_HINT_DROP()} = 1; "
             "next;", None, None, 0);

        /* Not tracked traffic can either be allowed or dropped. */
        Flow(ls_uuid, stage, 5, i"!ct.trk",
             i"${rEGBIT_ACL_HINT_ALLOW()} = 1; "
             "${rEGBIT_ACL_HINT_DROP()} = 1; "
             "next;", None, None, 0);

        /* Already established connections in the "request" direction may hit
         * either:
         * - allow ACLs in which case the traffic should be allowed so we set
         *   REGBIT_ACL_HINT_ALLOW.
         * - drop ACLs in which case the traffic should be blocked and the
         *   connection must be committed with ct_label.blocked set so we set
         *   REGBIT_ACL_HINT_BLOCK.
         */
        Flow(ls_uuid, stage, 4, i"!ct.new && ct.est && !ct.rpl && ct_label.blocked == 0",
             i"${rEGBIT_ACL_HINT_ALLOW()} = 1; "
             "${rEGBIT_ACL_HINT_BLOCK()} = 1; "
             "next;", None, None, 0);

        /* Not established or established and already blocked connections may
         * hit drop ACLs.
         */
        Flow(ls_uuid, stage, 3, i"!ct.est",
             i"${rEGBIT_ACL_HINT_DROP()} = 1; "
             "next;", None, None, 0);
        Flow(ls_uuid, stage, 2, i"ct.est && ct_label.blocked == 1",
             i"${rEGBIT_ACL_HINT_DROP()} = 1; "
             "next;", None, None, 0);

        /* Established connections that were previously allowed might hit
         * drop ACLs in which case the connection must be committed with
         * ct_label.blocked set.
         */
        Flow(ls_uuid, stage, 1, i"ct.est && ct_label.blocked == 0",
             i"${rEGBIT_ACL_HINT_BLOCK()} = 1; "
             "next;", None, None, 0)
    }
}

/* Ingress or Egress ACL Table (Various priorities). */
for (&SwitchACL(.sw = sw, .acl = acl, .has_fair_meter = fair_meter)) {
    /* consider_acl */
    var has_stateful = sw.has_stateful_acl or sw.has_lb_vip in
    var ingress = acl.direction == i"from-lport" in
    var stage = if (ingress) { s_SWITCH_IN_ACL() } else { s_SWITCH_OUT_ACL() } in
    var pipeline = if ingress Ingress else Egress in
    var stage_hint = stage_hint(acl._uuid) in
    var acl_log = build_acl_log(acl, fair_meter) in
    var acl_match = acl.__match.intern() in
    if (acl.action == i"allow" or acl.action == i"allow-related") {
        /* If there are any stateful flows, we must even commit "allow"
         * actions.  This is because, while the initiater's
         * direction may not have any stateful rules, the server's
         * may and then its return traffic would not have an
         * associated conntrack entry and would return "+invalid". */
        if (not has_stateful) {
            Flow(.logical_datapath = sw._uuid,
                 .stage            = stage,
                 .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                 .__match          = acl.__match,
                 .actions          = i"${acl_log}next;",
                 .stage_hint       = stage_hint,
                 .io_port          = None,
                 .controller_meter = None)
        } else {
            /* Commit the connection tracking entry if it's a new
             * connection that matches this ACL.  After this commit,
             * the reply traffic is allowed by a flow we create at
             * priority 65535, defined earlier.
             *
             * It's also possible that a known connection was marked for
             * deletion after a policy was deleted, but the policy was
             * re-added while that connection is still known.  We catch
             * that case here and un-set ct_label.blocked (which will be done
             * by ct_commit in the "stateful" stage) to indicate that the
             * connection should be allowed to resume.
             * If the ACL has a label, then load REG_LABEL with the label and
             * set the REGBIT_ACL_LABEL field.
             */
            var __action = if (acl.label != 0) {
                i"${rEGBIT_CONNTRACK_COMMIT()} = 1; ${rEGBIT_ACL_LABEL()} = 1; "
                "${rEG_LABEL()} = ${acl.label}; ${acl_log}next;"
            } else {
                i"${rEGBIT_CONNTRACK_COMMIT()} = 1; ${acl_log}next;"
            } in Flow(.logical_datapath = sw._uuid,
                      .stage            = stage,
                      .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                      .__match          = i"${rEGBIT_ACL_HINT_ALLOW_NEW()} == 1 && (${acl.__match})",
                      .actions          = __action,
                      .stage_hint       = stage_hint,
                      .io_port          = None,
                      .controller_meter = None);

            /* Match on traffic in the request direction for an established
             * connection tracking entry that has not been marked for
             * deletion. We use this to ensure that this
             * connection is still allowed by the currently defined
             * policy. Match untracked packets too.
             * Commit the connection only if the ACL has a label. This is done to
             * update the connection tracking entry label in case the ACL
             * allowing the connection changes.
             */
            var __action = if (acl.label != 0) {
                i"${rEGBIT_CONNTRACK_COMMIT()} = 1; ${rEGBIT_ACL_LABEL()} = 1; "
                "${rEG_LABEL()} = ${acl.label}; ${acl_log}next;"
            } else {
                i"${acl_log}next;"
            } in Flow(.logical_datapath = sw._uuid,
                      .stage            = stage,
                      .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                      .__match          = i"${rEGBIT_ACL_HINT_ALLOW()} == 1 && (${acl.__match})",
                      .actions          = __action,
                      .stage_hint       = stage_hint,
                      .io_port          = None,
                      .controller_meter = None)
        }
    } else if (acl.action == i"allow-stateless") {
        Flow(.logical_datapath = sw._uuid,
             .stage            = stage,
             .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
             .__match          = acl.__match,
             .actions          = i"${acl_log}next;",
             .stage_hint       = stage_hint,
             .io_port          = None,
             .controller_meter = None)
    } else if (acl.action == i"drop" or acl.action == i"reject") {
        /* The implementation of "drop" differs if stateful ACLs are in
         * use for this datapath.  In that case, the actions differ
         * depending on whether the connection was previously committed
         * to the connection tracker with ct_commit. */
        var controller_meter = sw.copp.get(cOPP_REJECT()) in
        if (has_stateful) {
            /* If the packet is not tracked or not part of an established
             * connection, then we can simply reject/drop it. */
            var __match = "${rEGBIT_ACL_HINT_DROP()} == 1" in
            if (acl.action == i"reject") {
                Reject(sw._uuid, pipeline, stage, acl, fair_meter, controller_meter, __match.intern(), i"")
            } else {
                Flow(.logical_datapath = sw._uuid,
                     .stage            = stage,
                     .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                     .__match          = (__match ++ " && (${acl.__match})").intern(),
                     .actions          = i"${acl_log}/* drop */",
                     .stage_hint       = stage_hint,
                     .io_port          = None,
                     .controller_meter = None)
            };
            /* For an existing connection without ct_label set, we've
             * encountered a policy change. ACLs previously allowed
             * this connection and we committed the connection tracking
             * entry.  Current policy says that we should drop this
             * connection.  First, we set bit 0 of ct_label to indicate
             * that this connection is set for deletion.  By not
             * specifying "next;", we implicitly drop the packet after
             * updating conntrack state.  We would normally defer
             * ct_commit() to the "stateful" stage, but since we're
             * rejecting/dropping the packet, we go ahead and do it here.
             */
            var __match = "${rEGBIT_ACL_HINT_BLOCK()} == 1" in
            var actions = "ct_commit { ct_label.blocked = 1; }; " in
            if (acl.action == i"reject") {
                Reject(sw._uuid, pipeline, stage, acl, fair_meter, controller_meter, __match.intern(), actions.intern())
            } else {
                Flow(.logical_datapath = sw._uuid,
                     .stage            = stage,
                     .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                     .__match          = (__match ++ " && (${acl.__match})").intern(),
                     .actions          = i"${actions}${acl_log}/* drop */",
                     .stage_hint       = stage_hint,
                     .io_port          = None,
                     .controller_meter = None)
            }
        } else {
            /* There are no stateful ACLs in use on this datapath,
             * so a "reject/drop" ACL is simply the "reject/drop"
             * logical flow action in all cases. */
            if (acl.action == i"reject") {
                Reject(sw._uuid, pipeline, stage, acl, fair_meter, controller_meter, i"", i"")
            } else {
                Flow(.logical_datapath = sw._uuid,
                     .stage            = stage,
                     .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                     .__match          = acl.__match,
                     .actions          = i"${acl_log}/* drop */",
                     .stage_hint       = stage_hint,
                     .io_port          = None,
                     .controller_meter = None)
            }
        }
    }
}

/* Add 34000 priority flow to allow DHCP reply from ovn-controller to all
 * logical ports of the datapath if the CMS has configured DHCPv4 options.
 * */
for (SwitchPortDHCPv4Options(.port = &SwitchPort{.lsp = lsp, .sw = sw},
                             .dhcpv4_options = dhcpv4_options@&nb::DHCP_Options{.options = options})
     if lsp.__type != i"external") {
    (Some{var server_id}, Some{var server_mac}, Some{var lease_time}) =
        (options.get(i"server_id"), options.get(i"server_mac"), options.get(i"lease_time")) in
    var has_stateful = sw.has_stateful_acl or sw.has_lb_vip in
    Flow(.logical_datapath = sw._uuid,
         .stage            = s_SWITCH_OUT_ACL(),
         .priority         = 34000,
         .__match          = i"outport == ${json_escape(lsp.name)} "
                             "&& eth.src == ${server_mac} "
                             "&& ip4.src == ${server_id} && udp && udp.src == 67 "
                             "&& udp.dst == 68",
         .actions          = if (has_stateful) i"ct_commit; next;" else i"next;",
         .stage_hint       = stage_hint(dhcpv4_options._uuid),
         .io_port          = Some{lsp.name},
         .controller_meter = None)
}

for (SwitchPortDHCPv6Options(.port = &SwitchPort{.lsp = lsp, .sw = sw},
                             .dhcpv6_options = dhcpv6_options@&nb::DHCP_Options{.options=options} )
     if lsp.__type != i"external") {
    Some{var server_mac} = options.get(i"server_id") in
    Some{var ea} = eth_addr_from_string(server_mac.ival()) in
    var server_ip = ea.to_ipv6_lla() in
    /* Get the link local IP of the DHCPv6 server from the
     * server MAC. */
    var has_stateful = sw.has_stateful_acl or sw.has_lb_vip in
    Flow(.logical_datapath = sw._uuid,
         .stage            = s_SWITCH_OUT_ACL(),
         .priority         = 34000,
         .__match          = i"outport == ${json_escape(lsp.name)} "
                             "&& eth.src == ${server_mac} "
                             "&& ip6.src == ${server_ip} && udp && udp.src == 547 "
                             "&& udp.dst == 546",
         .actions          = if (has_stateful) i"ct_commit; next;" else i"next;",
         .stage_hint       = stage_hint(dhcpv6_options._uuid),
         .io_port          = Some{lsp.name},
         .controller_meter = None)
}

relation QoSAction(qos: uuid, key_action: istring, value_action: integer)

QoSAction(qos, k, v) :-
    &nb::QoS(._uuid = qos, .action = actions),
    (var k, var v) = FlatMap(actions).

/* QoS rules */
for (&Switch(._uuid = ls_uuid)) {
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_QOS_MARK(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_QOS_MARK(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_QOS_METER(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_QOS_METER(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

for (SwitchQoS(.sw = sw, .qos = qos)) {
    var ingress = if (qos.direction == i"from-lport") true else false in
    var pipeline = if ingress "ingress" else "egress" in {
        var stage = if (ingress) { s_SWITCH_IN_QOS_MARK() } else { s_SWITCH_OUT_QOS_MARK() } in
        /* FIXME: Can value_action be negative? */
        for (QoSAction(qos._uuid, key_action, value_action)) {
            if (key_action == i"dscp") {
                Flow(.logical_datapath = sw._uuid,
                     .stage            = stage,
                     .priority         = qos.priority,
                     .__match          = qos.__match,
                     .actions          = i"ip.dscp = ${value_action}; next;",
                     .stage_hint       = stage_hint(qos._uuid),
                     .io_port          = None,
                     .controller_meter = None)
            }
        };

        (var burst, var rate) = {
            var rate = 0;
            var burst = 0;
            for ((key_bandwidth, value_bandwidth) in qos.bandwidth) {
                /* FIXME: Can value_bandwidth be negative? */
                if (key_bandwidth == i"rate") {
                    rate = value_bandwidth
                } else if (key_bandwidth == i"burst") {
                    burst = value_bandwidth
                } else ()
            };
            (burst, rate)
        } in
        if (rate != 0) {
            var stage = if (ingress) { s_SWITCH_IN_QOS_METER() } else { s_SWITCH_OUT_QOS_METER() } in
            var meter_action = if (burst != 0) {
                    i"set_meter(${rate}, ${burst}); next;"
                } else {
                    i"set_meter(${rate}); next;"
                } in
            /* Ingress and Egress QoS Meter Table.
             *
             * We limit the bandwidth of this flow by adding a meter table.
             */
            Flow(.logical_datapath = sw._uuid,
                 .stage            = stage,
                 .priority         = qos.priority,
                 .__match          = qos.__match,
                 .actions          = meter_action,
                 .stage_hint       = stage_hint(qos._uuid),
                 .io_port          = None,
                 .controller_meter = None)
        }
    }
}

/* stateful rules */
for (&Switch(._uuid = ls_uuid)) {
    /* Ingress and Egress stateful Table (Priority 0): Packets are
     * allowed by default. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_STATEFUL(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_STATEFUL(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* If REGBIT_CONNTRACK_COMMIT is set as 1 and REGBIT_CONNTRACK_SET_LABEL
     * is set to 1, then the packets should be
     * committed to conntrack. We always set ct_label.blocked to 0 here as
     * any packet that makes it this far is part of a connection we
     * want to allow to continue. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_STATEFUL(),
         .priority         = 100,
         .__match          = i"${rEGBIT_CONNTRACK_COMMIT()} == 1 && ${rEGBIT_ACL_LABEL()} == 1",
         .actions          = i"ct_commit { ct_label.blocked = 0; ct_label.label = ${rEG_LABEL()}; }; next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_STATEFUL(),
         .priority         = 100,
         .__match          = i"${rEGBIT_CONNTRACK_COMMIT()} == 1 && ${rEGBIT_ACL_LABEL()} == 1",
         .actions          = i"ct_commit { ct_label.blocked = 0; ct_label.label = ${rEG_LABEL()}; }; next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* If REGBIT_CONNTRACK_COMMIT is set as 1, then the packets should be
     * committed to conntrack. We always set ct_label.blocked to 0 here as
     * any packet that makes it this far is part of a connection we
     * want to allow to continue. */
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_STATEFUL(),
         .priority         = 100,
         .__match          = i"${rEGBIT_CONNTRACK_COMMIT()} == 1 && ${rEGBIT_ACL_LABEL()} == 0",
         .actions          = i"ct_commit { ct_label.blocked = 0; }; next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_STATEFUL(),
         .priority         = 100,
         .__match          = i"${rEGBIT_CONNTRACK_COMMIT()} == 1 && ${rEGBIT_ACL_LABEL()} == 0",
         .actions          = i"ct_commit { ct_label.blocked = 0; }; next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Load balancing rules for new connections get committed to conntrack
 * table.  So even if REGBIT_CONNTRACK_COMMIT is set in a previous table
 * a higher priority rule for load balancing below also commits the
 * connection, so it is okay if we do not hit the above match on
 * REGBIT_CONNTRACK_COMMIT. */
function get_match_for_lb_key(ip_address: v46_ip,
                              port: bit<16>,
                              protocol: Option<istring>,
                              redundancy: bool,
                              use_nexthop_reg: bool,
                              use_dest_tp_reg: bool): string = {
    var port_match = if (port != 0) {
        var proto = if (protocol == Some{i"udp"}) {
            "udp"
        } else {
            "tcp"
        };
        if (redundancy) { " && ${proto}" } else { "" } ++
        if (use_dest_tp_reg) {
            " && ${rEG_ORIG_TP_DPORT_ROUTER()} == ${port}"
        } else {
            " && ${proto}.dst == ${port}"
        }
    } else {
        ""
    };

    var ip_match = match (ip_address) {
        IPv4{ipv4} ->
            if (use_nexthop_reg) {
                "${rEG_NEXT_HOP()} == ${ipv4}"
            } else {
                "ip4.dst == ${ipv4}"
            },
        IPv6{ipv6} ->
            if (use_nexthop_reg) {
                "xx${rEG_NEXT_HOP()} == ${ipv6}"
            } else {
                "ip6.dst == ${ipv6}"
            }
    };

    var ipx = match (ip_address) {
        IPv4{ipv4} -> "ip4",
        IPv6{ipv6} -> "ip6",
    };

    if (redundancy) { ipx ++ " && " } else { "" } ++ ip_match ++ port_match
}
/* New connections in Ingress table. */

function ct_lb(backends: istring,
               selection_fields: Set<istring>, protocol: Option<istring>): string {
    var args = vec_with_capacity(2);
    args.push("backends=${backends}");

    if (not selection_fields.is_empty()) {
        var hash_fields = vec_with_capacity(selection_fields.size());
        for (sf in selection_fields) {
            var hf = match ((sf.ival(), protocol)) {
                ("tp_src", Some{p}) -> "${p}_src",
                ("tp_dst", Some{p}) -> "${p}_dst",
                _ -> sf.ival()
            };
            hash_fields.push(hf);
        };
        hash_fields.sort();
        args.push("hash_fields=" ++ json_escape(hash_fields.join(",")));
    };

    "ct_lb(" ++ args.join("; ") ++ ");"
}
function build_lb_vip_actions(lbvip: Intern<LBVIP>,
                              up_backends: istring,
                              stage: Intern<Stage>,
                              actions0: string): (string, bool) {
    if (up_backends == i"") {
        if (lbvip.lb.options.get_bool_def(i"reject", false)) {
            return ("reg0 = 0; reject { outport <-> inport; ${next_to_stage(stage)};};", true)
        } else if (lbvip.health_check.is_some()) {
            return ("drop;", false)
        } // else fall through
    };

    var actions = ct_lb(up_backends, lbvip.lb.selection_fields, lbvip.lb.protocol);
    (actions0 ++ actions, false)
}
Flow(.logical_datapath = sw._uuid,
     .stage            = s_SWITCH_IN_STATEFUL(),
     .priority         = priority,
     .__match          = __match,
     .actions          = actions,
     .io_port          = None,
     .controller_meter = meter,
     .stage_hint       = 0) :-
    LBVIPWithStatus(lbvip@&LBVIP{.lb = lb}, up_backends),
    var priority = if (lbvip.vip_port != 0) { 120 } else { 110 },
    (var actions0, var reject) = {
        /* Store the original destination IP to be used when generating
         * hairpin flows.
         */
        var actions0 = match (lbvip.vip_addr) {
            IPv4{ipv4} -> "${rEG_ORIG_DIP_IPV4()} = ${ipv4}; ",
            IPv6{ipv6} -> "${rEG_ORIG_DIP_IPV6()} = ${ipv6}; "
        };

        /* Store the original destination port to be used when generating
         * hairpin flows.
         */
        var actions1 = if (lbvip.vip_port != 0) {
            "${rEG_ORIG_TP_DPORT()} = ${lbvip.vip_port}; "
        } else {
            ""
        };

        build_lb_vip_actions(lbvip, up_backends, s_SWITCH_OUT_QOS_MARK(), actions0 ++ actions1)
    },
    var actions = actions0.intern(),
    var __match = ("ct.new && " ++ get_match_for_lb_key(lbvip.vip_addr, lbvip.vip_port, lb.protocol, false, false, false)).intern(),
    SwitchLB(sw, lb._uuid),
    var meter = if (reject) {
        sw.copp.get(cOPP_REJECT())
    } else {
        None
    }.

/* Ingress Pre-Hairpin/Nat-Hairpin/Hairpin tabled (Priority 0).
 * Packets that don't need hairpinning should continue processing.
 */
Flow(.logical_datapath = ls_uuid,
     .stage = stage,
     .priority = 0,
     .__match = i"1",
     .actions = i"next;",
     .stage_hint = 0,
     .io_port          = None,
     .controller_meter = None) :-
     &Switch(._uuid = ls_uuid),
     var stages = [s_SWITCH_IN_PRE_HAIRPIN(),
                   s_SWITCH_IN_NAT_HAIRPIN(),
                   s_SWITCH_IN_HAIRPIN()],
     var stage = FlatMap(stages).

for (&Switch(._uuid = ls_uuid, .has_lb_vip = true)) {
    /* Check if the packet needs to be hairpinned.
     * Set REGBIT_HAIRPIN in the original direction and
     * REGBIT_HAIRPIN_REPLY in the reply direction.
     */
    Flow(.logical_datapath = ls_uuid,
         .stage = s_SWITCH_IN_PRE_HAIRPIN(),
         .priority = 100,
         .__match = i"ip && ct.trk",
         .actions = i"${rEGBIT_HAIRPIN()} = chk_lb_hairpin(); "
                    "${rEGBIT_HAIRPIN_REPLY()} = chk_lb_hairpin_reply(); "
                    "next;",
         .stage_hint = stage_hint(ls_uuid),
         .io_port = None,
         .controller_meter = None);

    /* If packet needs to be hairpinned, snat the src ip with the VIP
     * for new sessions. */
    Flow(.logical_datapath = ls_uuid,
         .stage = s_SWITCH_IN_NAT_HAIRPIN(),
         .priority = 100,
         .__match = i"ip && ct.new && ct.trk && ${rEGBIT_HAIRPIN()} == 1",
         .actions = i"ct_snat_to_vip; next;",
         .stage_hint = stage_hint(ls_uuid),
         .io_port = None,
         .controller_meter = None);

    /* If packet needs to be hairpinned, for established sessions there
     * should already be an SNAT conntrack entry.
     */
    Flow(.logical_datapath = ls_uuid,
         .stage = s_SWITCH_IN_NAT_HAIRPIN(),
         .priority = 100,
         .__match = i"ip && ct.est && ct.trk && ${rEGBIT_HAIRPIN()} == 1",
         .actions = i"ct_snat;",
         .stage_hint = stage_hint(ls_uuid),
         .io_port = None,
         .controller_meter = None);

    /* For the reply of hairpinned traffic, snat the src ip to the VIP. */
    Flow(.logical_datapath = ls_uuid,
         .stage = s_SWITCH_IN_NAT_HAIRPIN(),
         .priority = 90,
         .__match = i"ip && ${rEGBIT_HAIRPIN_REPLY()} == 1",
         .actions = i"ct_snat;",
         .stage_hint = stage_hint(ls_uuid),
         .io_port = None,
         .controller_meter = None);

    /* Ingress Hairpin table.
    * - Priority 1: Packets that were SNAT-ed for hairpinning should be
    *   looped back (i.e., swap ETH addresses and send back on inport).
    */
    Flow(.logical_datapath = ls_uuid,
         .stage = s_SWITCH_IN_HAIRPIN(),
         .priority = 1,
         .__match = i"(${rEGBIT_HAIRPIN()} == 1 || ${rEGBIT_HAIRPIN_REPLY()} == 1)",
         .actions = i"eth.dst <-> eth.src; outport = inport; flags.loopback = 1; output;",
         .stage_hint = stage_hint(ls_uuid),
         .io_port = None,
         .controller_meter = None)
}

/* Logical switch ingress table PORT_SEC_L2: ingress port security - L2 (priority 50)
                  ingress table PORT_SEC_IP: ingress port security - IP (priority 90 and 80)
                  ingress table PORT_SEC_ND: ingress port security - ND (priority 90 and 80) */
for (&SwitchPort(.lsp = lsp, .sw = sw, .json_name = json_name, .ps_eth_addresses = ps_eth_addresses)
     if lsp.is_enabled() and lsp.__type != i"external") {
     for (pbinding in sb::Out_Port_Binding(.logical_port = lsp.name)) {
        var __match = if (ps_eth_addresses.is_empty()) {
                i"inport == ${json_name}"
            } else {
                i"inport == ${json_name} && eth.src == {${ps_eth_addresses.join(\" \")}}"
            } in
        var actions = {
            var ramp = if (lsp.__type == i"vtep") {
                i"${rEGBIT_FROM_RAMP()} = 1; "
            } else {
                i""
            };
            var queue = match (pbinding.options.get(i"qdisc_queue_id")) {
                None -> i"next;",
                Some{id} -> i"set_queue(${id}); next;"
            };
            i"${ramp}${queue}"
        } in
        Flow(.logical_datapath = sw._uuid,
             .stage            = s_SWITCH_IN_PORT_SEC_L2(),
             .priority         = 50,
             .__match          = __match,
             .actions          = actions,
             .stage_hint       = stage_hint(lsp._uuid),
             .io_port          = Some{lsp.name},
             .controller_meter = None)
    }
}

/**
* Build port security constraints on IPv4 and IPv6 src and dst fields
* and add logical flows to S_SWITCH_(IN/OUT)_PORT_SEC_IP stage.
*
* For each port security of the logical port, following
* logical flows are added
*   - If the port security has IPv4 addresses,
*     - Priority 90 flow to allow IPv4 packets for known IPv4 addresses
*
*   - If the port security has IPv6 addresses,
*     - Priority 90 flow to allow IPv6 packets for known IPv6 addresses
*
*   - If the port security has IPv4 addresses or IPv6 addresses or both
*     - Priority 80 flow to drop all IPv4 and IPv6 traffic
*/
for (SwitchPortPSAddresses(.port = port@&SwitchPort{.sw = sw}, .ps_addrs = ps)
     if port.is_enabled() and
        (ps.ipv4_addrs.len() > 0 or ps.ipv6_addrs.len() > 0) and
        port.lsp.__type != i"external")
{
    if (ps.ipv4_addrs.len() > 0) {
        var dhcp_match = i"inport == ${port.json_name}"
                         " && eth.src == ${ps.ea}"
                         " && ip4.src == 0.0.0.0"
                         " && ip4.dst == 255.255.255.255"
                         " && udp.src == 68 && udp.dst == 67" in {
            Flow(.logical_datapath = sw._uuid,
                 .stage            = s_SWITCH_IN_PORT_SEC_IP(),
                 .priority         = 90,
                 .__match          = dhcp_match,
                 .actions          = i"next;",
                 .stage_hint       = stage_hint(port.lsp._uuid),
                 .io_port          = Some{port.lsp.name},
                 .controller_meter = None)
        };
        var addrs = {
            var addrs = vec_empty();
            for (addr in ps.ipv4_addrs) {
                /* When the netmask is applied, if the host portion is
                 * non-zero, the host can only use the specified
                 * address.  If zero, the host is allowed to use any
                 * address in the subnet.
                 */
                addrs.push(addr.match_host_or_network())
            };
            addrs
        } in
        var __match =
            "inport == ${port.json_name} && eth.src == ${ps.ea} && ip4.src == {" ++
            addrs.join(", ") ++ "}" in
        {
            Flow(.logical_datapath = sw._uuid,
                 .stage         = s_SWITCH_IN_PORT_SEC_IP(),
                 .priority         = 90,
                 .__match          = __match.intern(),
                 .actions          = i"next;",
                 .stage_hint       = stage_hint(port.lsp._uuid),
                 .io_port          = Some{port.lsp.name},
                 .controller_meter = None)
        }
    };
    if (ps.ipv6_addrs.len() > 0) {
        var dad_match = i"inport == ${port.json_name}"
                        " && eth.src == ${ps.ea}"
                        " && ip6.src == ::"
                        " && ip6.dst == ff02::/16"
                        " && icmp6.type == {131, 135, 143}" in
        {
            Flow(.logical_datapath = sw._uuid,
                 .stage            = s_SWITCH_IN_PORT_SEC_IP(),
                 .priority         = 90,
                 .__match          = dad_match,
                 .actions          = i"next;",
                 .stage_hint       = stage_hint(port.lsp._uuid),
                 .io_port          = None,
                 .controller_meter = None)
        };
        var __match = "inport == ${port.json_name} && eth.src == ${ps.ea}" ++
                      build_port_security_ipv6_flow(Ingress, ps.ea, ps.ipv6_addrs) in
        {
            Flow(.logical_datapath = sw._uuid,
                 .stage            = s_SWITCH_IN_PORT_SEC_IP(),
                 .priority         = 90,
                 .__match          = __match.intern(),
                 .actions          = i"next;",
                 .stage_hint       = stage_hint(port.lsp._uuid),
                 .io_port          = Some{port.lsp.name},
                 .controller_meter = None)
        }
    };
    var __match = i"inport == ${port.json_name} && eth.src == ${ps.ea} && ip" in
    {
        Flow(.logical_datapath = sw._uuid,
             .stage            = s_SWITCH_IN_PORT_SEC_IP(),
             .priority         = 80,
             .__match          = __match,
             .actions          = i"drop;",
             .stage_hint       = stage_hint(port.lsp._uuid),
             .io_port          = Some{port.lsp.name},
             .controller_meter = None)
    }
}

/**
 * Build port security constraints on ARP and IPv6 ND fields
 * and add logical flows to S_SWITCH_IN_PORT_SEC_ND stage.
 *
 * For each port security of the logical port, following
 * logical flows are added
 *   - If the port security has no IP (both IPv4 and IPv6) or
 *     if it has IPv4 address(es)
 *      - Priority 90 flow to allow ARP packets for known MAC addresses
 *        in the eth.src and arp.spa fields. If the port security
 *        has IPv4 addresses, allow known IPv4 addresses in the arp.tpa field.
 *
 *   - If the port security has no IP (both IPv4 and IPv6) or
 *     if it has IPv6 address(es)
 *     - Priority 90 flow to allow IPv6 ND packets for known MAC addresses
 *       in the eth.src and nd.sll/nd.tll fields. If the port security
 *       has IPv6 addresses, allow known IPv6 addresses in the nd.target field
 *       for IPv6 Neighbor Advertisement packet.
 *
 *   - Priority 80 flow to drop ARP and IPv6 ND packets.
 */
for (SwitchPortPSAddresses(.port = port@&SwitchPort{.sw = sw}, .ps_addrs = ps)
     if port.is_enabled() and port.lsp.__type != i"external")
{
    var no_ip = ps.ipv4_addrs.is_empty() and ps.ipv6_addrs.is_empty() in
    {
        if (not ps.ipv4_addrs.is_empty() or no_ip) {
            var __match = {
                var prefix = "inport == ${port.json_name} && eth.src == ${ps.ea} && arp.sha == ${ps.ea}";
                if (not ps.ipv4_addrs.is_empty()) {
                    var spas = vec_empty();
                    for (addr in ps.ipv4_addrs) {
                        spas.push(addr.match_host_or_network())
                    };
                    prefix ++ " && arp.spa == {${spas.join(\", \")}}"
                } else {
                    prefix
                }
            } in {
                Flow(.logical_datapath = sw._uuid,
                     .stage            = s_SWITCH_IN_PORT_SEC_ND(),
                     .priority         = 90,
                     .__match          = __match.intern(),
                     .actions          = i"next;",
                     .stage_hint       = stage_hint(port.lsp._uuid),
                     .io_port          = Some{port.lsp.name},
                     .controller_meter = None)
            }
        };
        if (not ps.ipv6_addrs.is_empty() or no_ip) {
            var __match = "inport == ${port.json_name} && eth.src == ${ps.ea}" ++
                          build_port_security_ipv6_nd_flow(ps.ea, ps.ipv6_addrs) in
            {
                Flow(.logical_datapath = sw._uuid,
                     .stage            = s_SWITCH_IN_PORT_SEC_ND(),
                     .priority         = 90,
                     .__match          = __match.intern(),
                     .actions          = i"next;",
                     .stage_hint       = stage_hint(port.lsp._uuid),
                     .io_port          = Some{port.lsp.name},
                     .controller_meter = None)
            }
        };
        Flow(.logical_datapath = sw._uuid,
             .stage            = s_SWITCH_IN_PORT_SEC_ND(),
             .priority         = 80,
             .__match          = i"inport == ${port.json_name} && (arp || nd)",
             .actions          = i"drop;",
             .stage_hint       = stage_hint(port.lsp._uuid),
             .io_port          = Some{port.lsp.name},
             .controller_meter = None)
    }
}

/* Ingress table PORT_SEC_ND and PORT_SEC_IP: Port security - IP and ND, by
 * default goto next.  (priority 0)*/
for (&Switch(._uuid = ls_uuid)) {
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PORT_SEC_ND(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_PORT_SEC_IP(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Ingress table ARP_ND_RSP: ARP/ND responder, skip requests coming from
 * localnet and vtep ports. (priority 100); see ovn-northd.8.xml for the
 * rationale. */
for (&SwitchPort(.lsp = lsp, .sw = sw, .json_name = json_name)
     if lsp.is_enabled() and
        (lsp.__type == i"localnet" or lsp.__type == i"vtep"))
{
    Flow(.logical_datapath = sw._uuid,
         .stage            = s_SWITCH_IN_ARP_ND_RSP(),
         .priority         = 100,
         .__match          = i"inport == ${json_name}",
         .actions          = i"next;",
         .stage_hint       = stage_hint(lsp._uuid),
         .io_port          = Some{lsp.name},
         .controller_meter = None)
}

function lsp_is_up(lsp: Intern<nb::Logical_Switch_Port>): bool = {
    lsp.up == Some{true}
}

/* Ingress table ARP_ND_RSP: ARP/ND responder, reply for known IPs.
 * (priority 50). */
/* Handle
 *  - GARPs for virtual ip which belongs to a logical port
 *    of type 'virtual' and bind that port.
 *
 *  - ARP reply from the virtual ip which belongs to a logical
 *    port of type 'virtual' and bind that port.
 * */
 Flow(.logical_datapath = sp.sw._uuid,
      .stage            = s_SWITCH_IN_ARP_ND_RSP(),
      .priority         = 100,
      .__match          = i"inport == ${vp.json_name} && "
                          "((arp.op == 1 && arp.spa == ${virtual_ip} && arp.tpa == ${virtual_ip}) || "
                          "(arp.op == 2 && arp.spa == ${virtual_ip}))",
      .actions          = i"bind_vport(${sp.json_name}, inport); next;",
      .stage_hint       = stage_hint(lsp._uuid),
      .io_port          = Some{vp.lsp.name},
      .controller_meter = None) :-
    sp in &SwitchPort(.lsp = lsp@&nb::Logical_Switch_Port{.__type = i"virtual"}),
    Some{var virtual_ip} = lsp.options.get(i"virtual-ip"),
    Some{var virtual_parents} = lsp.options.get(i"virtual-parents"),
    Some{var ip} = ip_parse(virtual_ip.ival()),
    var vparent = FlatMap(virtual_parents.split(",")),
    vp in &SwitchPort(.lsp = &nb::Logical_Switch_Port{.name = vparent.intern()}),
    vp.sw == sp.sw.

/*
 * Add ARP/ND reply flows if either the
 *  - port is up and it doesn't have 'unknown' address defined or
 *  - port type is router or
 *  - port type is localport
 */
for (CheckLspIsUp[check_lsp_is_up]) {
    for (SwitchPortIPv4Address(.port = &SwitchPort{.lsp = lsp, .sw = sw, .json_name = json_name},
                               .ea = ea, .addr = addr)
         if lsp.is_enabled() and
            ((lsp_is_up(lsp) or not check_lsp_is_up)
             or lsp.__type == i"router" or lsp.__type == i"localport") and
            lsp.__type != i"external" and lsp.__type != i"virtual" and
            not lsp.addresses.contains(i"unknown") and
            not sw.is_vlan_transparent)
    {
        var __match = "arp.tpa == ${addr.addr} && arp.op == 1" in
        {
            var actions = i"eth.dst = eth.src; "
                          "eth.src = ${ea}; "
                          "arp.op = 2; /* ARP reply */ "
                          "arp.tha = arp.sha; "
                          "arp.sha = ${ea}; "
                          "arp.tpa = arp.spa; "
                          "arp.spa = ${addr.addr}; "
                          "outport = inport; "
                          "flags.loopback = 1; "
                          "output;" in
            Flow(.logical_datapath = sw._uuid,
                 .stage            = s_SWITCH_IN_ARP_ND_RSP(),
                 .priority         = 50,
                 .__match          = __match.intern(),
                 .actions          = actions,
                 .stage_hint       = stage_hint(lsp._uuid),
                 .io_port          = None,
                 .controller_meter = None);

            /* Do not reply to an ARP request from the port that owns the
             * address (otherwise a DHCP client that ARPs to check for a
             * duplicate address will fail).  Instead, forward it the usual
             * way.
             *
             * (Another alternative would be to simply drop the packet.  If
             * everything is working as it is configured, then this would
             * produce equivalent results, since no one should reply to the
             * request.  But ARPing for one's own IP address is intended to
             * detect situations where the network is not working as
             * configured, so dropping the request would frustrate that
             * intent.) */
            Flow(.logical_datapath = sw._uuid,
                 .stage            = s_SWITCH_IN_ARP_ND_RSP(),
                 .priority         = 100,
                 .__match          = i"${__match} && inport == ${json_name}",
                 .actions          = i"next;",
                 .stage_hint       = stage_hint(lsp._uuid),
                 .io_port          = Some{lsp.name},
                 .controller_meter = None)
        }
    }
}

Flow(.logical_datapath = sw._uuid,
         .stage            = s_SWITCH_IN_ARP_ND_RSP(),
         .priority         = 50,
         .__match          = __match.intern(),
         .actions          = __actions,
         .stage_hint       = stage_hint(sp.lsp._uuid),
         .io_port          = None,
         .controller_meter = None) :-

    sp in &SwitchPort(.sw = sw, .peer = Some{rp}),
    rp.is_enabled(),
    var proxy_ips = {
        match (sp.lsp.options.get(i"arp_proxy")) {
            None -> "",
            Some {addresses} -> {
                match (extract_ip_addresses(addresses.ival())) {
                    None -> "",
                    Some{addr} -> {
                        var ip4_addrs = vec_empty();
                        for (ip4 in addr.ipv4_addrs) {
                            ip4_addrs.push("${ip4.addr}")
                        };
                        string_join(ip4_addrs, ",")
                    }
                }
            }
        }
    },
    proxy_ips != "",
    var __match = "arp.op == 1 && arp.tpa == {" ++ proxy_ips ++ "}",
    var __actions = i"eth.dst = eth.src; "
                    "eth.src = ${rp.networks.ea}; "
                    "arp.op = 2; /* ARP reply */ "
                    "arp.tha = arp.sha; "
                    "arp.sha = ${rp.networks.ea}; "
                    "arp.tpa <-> arp.spa; "
                    "outport = inport; "
                    "flags.loopback = 1; "
                    "output;".

/* For ND solicitations, we need to listen for both the
 * unicast IPv6 address and its all-nodes multicast address,
 * but always respond with the unicast IPv6 address. */
for (SwitchPortIPv6Address(.port = &SwitchPort{.lsp = lsp, .json_name = json_name, .sw = sw},
                           .ea = ea, .addr = addr)
     if lsp.is_enabled() and
        (lsp_is_up(lsp) or lsp.__type == i"router" or lsp.__type == i"localport") and
        lsp.__type != i"external" and lsp.__type != i"virtual" and
        not sw.is_vlan_transparent)
{
    var __match = "nd_ns && ip6.dst == {${addr.addr}, ${addr.solicited_node()}} && nd.target == ${addr.addr}" in
    var actions = i"${if (lsp.__type == i\"router\") \"nd_na_router\" else \"nd_na\"} { "
                  "eth.src = ${ea}; "
                  "ip6.src = ${addr.addr}; "
                  "nd.target = ${addr.addr}; "
                  "nd.tll = ${ea}; "
                  "outport = inport; "
                  "flags.loopback = 1; "
                  "output; "
                  "};" in
    {
        Flow(.logical_datapath = sw._uuid,
             .stage            = s_SWITCH_IN_ARP_ND_RSP(),
             .priority         = 50,
             .__match          = __match.intern(),
             .actions          = actions,
             .io_port          = None,
             .controller_meter = sw.copp.get(cOPP_ND_NA()),
             .stage_hint       = stage_hint(lsp._uuid));

        /* Do not reply to a solicitation from the port that owns the
         * address (otherwise DAD detection will fail). */
        Flow(.logical_datapath = sw._uuid,
             .stage            = s_SWITCH_IN_ARP_ND_RSP(),
             .priority         = 100,
             .__match          = i"${__match} && inport == ${json_name}",
             .actions          = i"next;",
             .stage_hint       = stage_hint(lsp._uuid),
             .io_port          = Some{lsp.name},
             .controller_meter = None)
    }
}

/* Ingress table ARP_ND_RSP: ARP/ND responder, by default goto next.
 * (priority 0)*/
for (ls in &nb::Logical_Switch) {
    Flow(.logical_datapath = ls._uuid,
         .stage            = s_SWITCH_IN_ARP_ND_RSP(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Ingress table ARP_ND_RSP: ARP/ND responder for service monitor source ip.
 * (priority 110)*/
Flow(.logical_datapath = sp.sw._uuid,
     .stage            = s_SWITCH_IN_ARP_ND_RSP(),
     .priority         = 110,
     .__match          = i"arp.tpa == ${svc_mon_src_ip} && arp.op == 1",
     .actions          = i"eth.dst = eth.src; "
                         "eth.src = ${svc_monitor_mac}; "
                         "arp.op = 2; /* ARP reply */ "
                         "arp.tha = arp.sha; "
                         "arp.sha = ${svc_monitor_mac}; "
                         "arp.tpa = arp.spa; "
                         "arp.spa = ${svc_mon_src_ip}; "
                         "outport = inport; "
                         "flags.loopback = 1; "
                         "output;",
     .stage_hint       = stage_hint(lbvip.lb._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    LBVIP[lbvip],
    var lbvipbackend = FlatMap(lbvip.backends),
    Some{var svc_monitor} = lbvipbackend.svc_monitor,
    sp in &SwitchPort(
        .lsp = &nb::Logical_Switch_Port{.name = svc_monitor.port_name}),
    var svc_mon_src_ip = svc_monitor.src_ip,
    SvcMonitorMac(svc_monitor_mac).

function build_dhcpv4_action(
    lsp_json_key: string,
    dhcpv4_options: Intern<nb::DHCP_Options>,
    offer_ip: in_addr,
    lsp_options: Map<istring,istring>) : Option<(istring, istring, string)> =
{
    match (ip_parse_masked(dhcpv4_options.cidr.ival())) {
        Left{err} -> {
            /* cidr defined is invalid */
            None
        },
        Right{(var host_ip, var mask)} -> {
            if (not (offer_ip, host_ip).same_network(mask)) {
               /* the offer ip of the logical port doesn't belong to the cidr
                * defined in the DHCPv4 options.
                */
                None
            } else {
                match ((dhcpv4_options.options.get(i"server_id"),
                        dhcpv4_options.options.get(i"server_mac"),
                        dhcpv4_options.options.get(i"lease_time")))
                {
                    (Some{var server_ip}, Some{var server_mac}, Some{var lease_time}) -> {
                        var options_map = dhcpv4_options.options;

                        /* server_mac is not DHCPv4 option, delete it from the smap. */
                        options_map.remove(i"server_mac");
                        options_map.insert(i"netmask", i"${mask}");

                        match (lsp_options.get(i"hostname")) {
                            None -> (),
                            Some{port_hostname} -> options_map.insert(i"hostname", port_hostname)
                        };

                        var options = vec_empty();
                        for (node in options_map) {
                            (var k, var v) = node;
                            options.push("${k} = ${v}")
                        };
                        options.sort();
                        var options_action = "${rEGBIT_DHCP_OPTS_RESULT()} = put_dhcp_opts(offerip = ${offer_ip}, " ++
                                             options.join(", ") ++ "); next;";
                        var response_action = i"eth.dst = eth.src; eth.src = ${server_mac}; "
                                              "ip4.src = ${server_ip}; udp.src = 67; "
                                              "udp.dst = 68; outport = inport; flags.loopback = 1; "
                                              "output;";

                        var ipv4_addr_match = "ip4.src == ${offer_ip} && ip4.dst == {${server_ip}, 255.255.255.255}";
                        Some{(options_action.intern(), response_action, ipv4_addr_match)}
                    },
                    _ -> {
                        /* "server_id", "server_mac" and "lease_time" should be
                         * present in the dhcp_options. */
                        //static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);
                        warn("Required DHCPv4 options not defined for lport - ${lsp_json_key}");
                        None
                    }
                }
            }
        }
    }
}

function build_dhcpv6_action(
    lsp_json_key: string,
    dhcpv6_options: Intern<nb::DHCP_Options>,
    offer_ip: in6_addr): Option<(istring, istring)> =
{
    match (ipv6_parse_masked(dhcpv6_options.cidr.ival())) {
        Left{err} -> {
            /* cidr defined is invalid */
            //warn("cidr is invalid - ${err}");
            None
        },
        Right{(var host_ip, var mask)} -> {
            if (not (offer_ip, host_ip).same_network(mask)) {
                /* offer_ip doesn't belongs to the cidr defined in lport's DHCPv6
                 * options.*/
                //warn("ip does not belong to cidr");
                None
            } else {
                /* "server_id" should be the MAC address. */
                match (dhcpv6_options.options.get(i"server_id")) {
                    None -> {
                        warn("server_id not present in the DHCPv6 options for lport ${lsp_json_key}");
                        None
                    },
                    Some{server_mac} -> {
                        match (eth_addr_from_string(server_mac.ival())) {
                            None -> {
                                warn("server_id not present in the DHCPv6 options for lport ${lsp_json_key}");
                                None
                            },
                            Some{ea} -> {
                                /* Get the link local IP of the DHCPv6 server from the server MAC. */
                                var server_ip = ea.to_ipv6_lla().string_mapped();
                                var ia_addr = offer_ip.string_mapped();
                                var options = vec_empty();

                                /* Check whether the dhcpv6 options should be configured as stateful.
                                 * Only reply with ia_addr option for dhcpv6 stateful address mode. */
                                if (not dhcpv6_options.options.get_bool_def(i"dhcpv6_stateless", false)) {
                                    options.push("ia_addr = ${ia_addr}")
                                } else ();

                                for ((k, v) in dhcpv6_options.options) {
                                    if (k != i"dhcpv6_stateless") {
                                        options.push("${k} = ${v}")
                                    } else ()
                                };
                                options.sort();

                                var options_action = "${rEGBIT_DHCP_OPTS_RESULT()} = put_dhcpv6_opts(" ++
                                                     options.join(", ") ++
                                                     "); next;";
                                var response_action = i"eth.dst = eth.src; eth.src = ${server_mac}; "
                                                      "ip6.dst = ip6.src; ip6.src = ${server_ip}; udp.src = 547; "
                                                       "udp.dst = 546; outport = inport; flags.loopback = 1; "
                                                       "output;";
                                Some{(options_action.intern(), response_action)}
                            }
                        }
                    }
                }
            }
        }
    }
}

/* If 'names' has one element, returns json_escape() for it.
 * Otherwise, returns json_escape() of all of its elements inside "{...}".
 */
function json_escape_vec(names: Vec<string>): string
{
    match ((names.len(), names.nth(0))) {
        (1, Some{name}) -> json_escape(name),
        _ -> {
            var json_names = vec_with_capacity(names.len());
            for (name in names) {
                json_names.push(json_escape(name));
            };
            "{" ++ json_names.join(", ") ++ "}"
        }
    }
}

/*
 * Ordinarily, returns a single match against 'lsp'.
 *
 * If 'lsp' is an external port, returns a match against the localnet port(s) on
 * its switch along with a condition that it only operate if 'lsp' is
 * chassis-resident.  This makes sense as a condition for sending DHCP replies
 * to external ports because only one chassis should send such a reply.
 *
 * Returns a prefix and a suffix string.  There is no reason for this except
 * that it makes it possible to exactly mimic the format used by northd.c
 * so that text-based comparisons do not show differences.  (This fails if
 * there's more than one localnet port since the C version uses multiple flows
 * in that case.)
 */
function match_dhcp_input(lsp: Intern<SwitchPort>): (string, string) =
{
    if (lsp.lsp.__type == i"external" and not lsp.sw.localnet_ports.is_empty()) {
        ("inport == " ++ json_escape_vec(lsp.sw.localnet_ports.map(|x| x.1.ival())) ++ " && ",
         " && is_chassis_resident(${lsp.json_name})")
    } else {
        ("inport == ${lsp.json_name} && ", "")
    }
}

/* Logical switch ingress tables DHCP_OPTIONS and DHCP_RESPONSE: DHCP options
 * and response priority 100 flows. */
for (lsp in &SwitchPort
         /* Don't add the DHCP flows if the port is not enabled or if the
          * port is a router port. */
         if (lsp.is_enabled() and lsp.lsp.__type != i"router")
         /* If it's an external port and there is no localnet port
          * and if it doesn't belong to an HA chassis group ignore it. */
         and (lsp.lsp.__type != i"external"
              or (not lsp.sw.localnet_ports.is_empty()
                  and lsp.lsp.ha_chassis_group.is_some())))
{
    for (lps in LogicalSwitchPort(.lport = lsp.lsp._uuid, .lswitch = lsuuid)) {
        var json_key = json_escape(lsp.lsp.name) in
        (var pfx, var sfx) = match_dhcp_input(lsp) in
        {
            /* DHCPv4 options enabled for this port */
            Some{var dhcpv4_options_uuid} = lsp.lsp.dhcpv4_options in
            {
                for (dhcpv4_options in &nb::DHCP_Options(._uuid = dhcpv4_options_uuid)) {
                    for (SwitchPortIPv4Address(.port = &SwitchPort{.lsp = &nb::Logical_Switch_Port{._uuid = lsp.lsp._uuid}}, .ea = ea, .addr = addr)) {
                        Some{(var options_action, var response_action, var ipv4_addr_match)} =
                            build_dhcpv4_action(json_key, dhcpv4_options, addr.addr, lsp.lsp.options) in
                        {
                            var __match =
                                (pfx ++ "eth.src == ${ea} && "
                                "ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && "
                                "udp.src == 68 && udp.dst == 67" ++ sfx).intern()
                            in
                            Flow(.logical_datapath = lsuuid,
                                 .stage            = s_SWITCH_IN_DHCP_OPTIONS(),
                                 .priority         = 100,
                                 .__match          = __match,
                                 .actions          = options_action,
                                 .io_port          = None,
                                 .controller_meter = lsp.sw.copp.get(cOPP_DHCPV4_OPTS()),
                                 .stage_hint       = stage_hint(lsp.lsp._uuid));

                            /* Allow ip4.src = OFFER_IP and
                             * ip4.dst = {SERVER_IP, 255.255.255.255} for the below
                             * cases
                             *  -  When the client wants to renew the IP by sending
                             *     the DHCPREQUEST to the server ip.
                             *  -  When the client wants to renew the IP by
                             *     broadcasting the DHCPREQUEST.
                             */
                            var __match = pfx ++ "eth.src == ${ea} && "
                                "${ipv4_addr_match} && udp.src == 68 && udp.dst == 67" ++ sfx in
                            Flow(.logical_datapath = lsuuid,
                                 .stage            = s_SWITCH_IN_DHCP_OPTIONS(),
                                 .priority         = 100,
                                 .__match          = __match.intern(),
                                 .actions          = options_action,
                                 .io_port          = None,
                                 .controller_meter = lsp.sw.copp.get(cOPP_DHCPV4_OPTS()),
                                 .stage_hint       = stage_hint(lsp.lsp._uuid));

                            /* If REGBIT_DHCP_OPTS_RESULT is set, it means the
                             * put_dhcp_opts action  is successful. */
                            var __match = pfx ++ "eth.src == ${ea} && "
                                "ip4 && udp.src == 68 && udp.dst == 67 && " ++
                                rEGBIT_DHCP_OPTS_RESULT() ++ sfx in
                            Flow(.logical_datapath = lsuuid,
                                 .stage            = s_SWITCH_IN_DHCP_RESPONSE(),
                                 .priority         = 100,
                                 .__match          = __match.intern(),
                                 .actions          = response_action,
                                 .stage_hint       = stage_hint(lsp.lsp._uuid),
                                 .io_port          = None,
                                 .controller_meter = None)
                            // FIXME: is there a constraint somewhere that guarantees that build_dhcpv4_action
                            // returns Some() for at most 1 address in lsp_addrs? Otherwise, simulate this break
                            // by computing an aggregate that returns the first element of a group.
                            //break;
                        }
                    }
                }
            };

            /* DHCPv6 options enabled for this port */
            Some{var dhcpv6_options_uuid} = lsp.lsp.dhcpv6_options in
            {
                for (dhcpv6_options in &nb::DHCP_Options(._uuid = dhcpv6_options_uuid)) {
                    for (SwitchPortIPv6Address(.port = &SwitchPort{.lsp = &nb::Logical_Switch_Port{._uuid = lsp.lsp._uuid}}, .ea = ea, .addr = addr)) {
                        Some{(var options_action, var response_action)} =
                            build_dhcpv6_action(json_key, dhcpv6_options, addr.addr) in
                        {
                            var __match = pfx ++ "eth.src == ${ea}"
                                " && ip6.dst == ff02::1:2 && udp.src == 546 &&"
                                " udp.dst == 547" ++ sfx in
                            {
                                Flow(.logical_datapath = lsuuid,
                                     .stage            = s_SWITCH_IN_DHCP_OPTIONS(),
                                     .priority         = 100,
                                     .__match          = __match.intern(),
                                     .actions          = options_action,
                                     .io_port          = None,
                                     .controller_meter = lsp.sw.copp.get(cOPP_DHCPV6_OPTS()),
                                     .stage_hint       = stage_hint(lsp.lsp._uuid));

                                /* If REGBIT_DHCP_OPTS_RESULT is set to 1, it means the
                                 * put_dhcpv6_opts action is successful */
                                Flow(.logical_datapath = lsuuid,
                                     .stage            = s_SWITCH_IN_DHCP_RESPONSE(),
                                     .priority         = 100,
                                     .__match          = (__match ++ " && ${rEGBIT_DHCP_OPTS_RESULT()}").intern(),
                                     .actions          = response_action,
                                     .stage_hint       = stage_hint(lsp.lsp._uuid),
                                     .io_port          = None,
                                     .controller_meter = None)
                                // FIXME: is there a constraint somewhere that guarantees that build_dhcpv4_action
                                // returns Some() for at most 1 address in lsp_addrs? Otherwise, simulate this breaks
                                // by computing an aggregate that returns the first element of a group.
                                //break;
                            }
                        }
                    }
                }
            }
        }
    }
}

/* Logical switch ingress tables DNS_LOOKUP and DNS_RESPONSE: DNS lookup and
 * response priority 100 flows.
 */
for (LogicalSwitchHasDNSRecords(ls, true))
{
    Flow(.logical_datapath = ls,
         .stage            = s_SWITCH_IN_DNS_LOOKUP(),
         .priority         = 100,
         .__match          = i"udp.dst == 53",
         .actions          = i"${rEGBIT_DNS_LOOKUP_RESULT()} = dns_lookup(); next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    var action = i"eth.dst <-> eth.src; ip4.src <-> ip4.dst; "
                 "udp.dst = udp.src; udp.src = 53; outport = inport; "
                 "flags.loopback = 1; output;" in
    Flow(.logical_datapath = ls,
         .stage            = s_SWITCH_IN_DNS_RESPONSE(),
         .priority         = 100,
         .__match          = i"udp.dst == 53 && ${rEGBIT_DNS_LOOKUP_RESULT()}",
         .actions          = action,
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    var action = i"eth.dst <-> eth.src; ip6.src <-> ip6.dst; "
                 "udp.dst = udp.src; udp.src = 53; outport = inport; "
                 "flags.loopback = 1; output;" in
    Flow(.logical_datapath = ls,
         .stage            = s_SWITCH_IN_DNS_RESPONSE(),
         .priority         = 100,
         .__match          = i"udp.dst == 53 && ${rEGBIT_DNS_LOOKUP_RESULT()}",
         .actions          = action,
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Ingress table DHCP_OPTIONS and DHCP_RESPONSE: DHCP options and response, by
 * default goto next. (priority 0).
 *
 * Ingress table DNS_LOOKUP and DNS_RESPONSE: DNS lookup and response, by
 * default goto next.  (priority 0).

 * Ingress table EXTERNAL_PORT - External port handling, by default goto next.
 * (priority 0). */
for (ls in &nb::Logical_Switch) {
    Flow(.logical_datapath = ls._uuid,
         .stage            = s_SWITCH_IN_DHCP_OPTIONS(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    Flow(.logical_datapath = ls._uuid,
         .stage            = s_SWITCH_IN_DHCP_RESPONSE(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    Flow(.logical_datapath = ls._uuid,
         .stage            = s_SWITCH_IN_DNS_LOOKUP(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    Flow(.logical_datapath = ls._uuid,
         .stage            = s_SWITCH_IN_DNS_RESPONSE(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    Flow(.logical_datapath = ls._uuid,
         .stage            = s_SWITCH_IN_EXTERNAL_PORT(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

Flow(.logical_datapath = sw._uuid,
     .stage = s_SWITCH_IN_L2_LKUP(),
     .priority = 110,
     .__match = i"eth.dst == $svc_monitor_mac",
     .actions = i"handle_svc_check(inport);",
     .stage_hint = 0,
     .io_port          = None,
     .controller_meter = None) :-
    sw in &Switch().

for (sw in &Switch(._uuid = ls_uuid, .mcast_cfg = mcast_cfg)
        if (mcast_cfg.enabled)) {
    var controller_meter = sw.copp.get(cOPP_IGMP()) in
    for (SwitchMcastFloodRelayPorts(sw, relay_ports)) {
        for (SwitchMcastFloodReportPorts(sw, flood_report_ports)) {
            for (SwitchMcastFloodPorts(sw, flood_ports)) {
                var flood_relay = not relay_ports.is_empty() in
                var flood_reports = not flood_report_ports.is_empty() in
                var flood_static = not flood_ports.is_empty() in
                var igmp_act = {
                    if (flood_reports) {
                        var mrouter_static = json_escape(mC_MROUTER_STATIC().0);
                        i"clone { "
                            "outport = ${mrouter_static}; "
                            "output; "
                        "};igmp;"
                    } else {
                        i"igmp;"
                    }
                } in {
                    /* Punt IGMP traffic to controller. */
                    Flow(.logical_datapath = ls_uuid,
                         .stage            = s_SWITCH_IN_L2_LKUP(),
                         .priority         = 100,
                         .__match          = i"ip4 && ip.proto == 2",
                         .actions          = i"${igmp_act}",
                         .io_port          = None,
                         .controller_meter = controller_meter,
                         .stage_hint       = 0);

                    /* Punt MLD traffic to controller. */
                    Flow(.logical_datapath = ls_uuid,
                         .stage            = s_SWITCH_IN_L2_LKUP(),
                         .priority         = 100,
                         .__match          = i"mldv1 || mldv2",
                         .actions          = igmp_act,
                         .io_port          = None,
                         .controller_meter = controller_meter,
                         .stage_hint       = 0);

                    /* Flood all IP multicast traffic destined to 224.0.0.X to
                     * all ports - RFC 4541, section 2.1.2, item 2.
                     */
                    var flood = json_escape(mC_FLOOD().0) in
                    Flow(.logical_datapath = ls_uuid,
                         .stage            = s_SWITCH_IN_L2_LKUP(),
                         .priority         = 85,
                         .__match          = i"ip4.mcast && ip4.dst == 224.0.0.0/24",
                         .actions          = i"outport = ${flood}; output;",
                         .stage_hint       = 0,
                         .io_port          = None,
                         .controller_meter = None);

                    /* Flood all IPv6 multicast traffic destined to reserved
                     * multicast IPs (RFC 4291, 2.7.1).
                     */
                    var flood = json_escape(mC_FLOOD().0) in
                    Flow(.logical_datapath = ls_uuid,
                         .stage            = s_SWITCH_IN_L2_LKUP(),
                         .priority         = 85,
                         .__match          = i"ip6.mcast_flood",
                         .actions          = i"outport = ${flood}; output;",
                         .stage_hint       = 0,
                         .io_port          = None,
                         .controller_meter = None);

                    /* Forward uregistered IP multicast to routers with relay
                     * enabled and to any ports configured to flood IP
                     * multicast traffic. If configured to flood unregistered
                     * traffic this will be handled by the L2 multicast flow.
                     */
                    if (not mcast_cfg.flood_unreg) {
                        var relay_act = {
                            if (flood_relay) {
                                var rtr_flood = json_escape(mC_MROUTER_FLOOD().0);
                                "clone { "
                                    "outport = ${rtr_flood}; "
                                    "output; "
                                "}; "
                            } else {
                                ""
                            }
                        } in
                        var static_act = {
                            if (flood_static) {
                                var mc_static = json_escape(mC_STATIC().0);
                                "outport =${mc_static}; output;"
                            } else {
                                ""
                            }
                        } in
                        var drop_act = {
                            if (not flood_relay and not flood_static) {
                                "drop;"
                            } else {
                                ""
                            }
                        } in
                        Flow(.logical_datapath = ls_uuid,
                             .stage            = s_SWITCH_IN_L2_LKUP(),
                             .priority         = 80,
                             .__match          = i"ip4.mcast || ip6.mcast",
                             .actions          = i"${relay_act}${static_act}${drop_act}",
                             .stage_hint       = 0,
                             .io_port          = None,
                             .controller_meter = None)
                    }
                }
            }
        }
    }
}

/* Ingress table L2_LKUP: Add IP multicast flows learnt from IGMP/MLD (priority
 * 90). */
for (IgmpSwitchMulticastGroup(.address = address, .switch = sw)) {
    /* RFC 4541, section 2.1.2, item 2: Skip groups in the 224.0.0.X
     * range.
     *
     * RFC 4291, section 2.7.1: Skip groups that correspond to all
     * hosts.
     */
    Some{var ip} = ip46_parse(address.ival()) in
    (var skip_address) = match (ip) {
        IPv4{ipv4} -> ipv4.is_local_multicast(),
        IPv6{ipv6} -> ipv6.is_all_hosts()
    } in
    var ipX = ip.ipX() in
    for (SwitchMcastFloodRelayPorts(sw, relay_ports) if not skip_address) {
        for (SwitchMcastFloodPorts(sw, flood_ports)) {
            var flood_relay = not relay_ports.is_empty() in
            var flood_static = not flood_ports.is_empty() in
            var mc_rtr_flood = json_escape(mC_MROUTER_FLOOD().0) in
            var mc_static = json_escape(mC_STATIC().0) in
            var relay_act = {
                if (flood_relay) {
                    "clone { "
                        "outport = ${mc_rtr_flood}; output; "
                    "};"
                } else {
                    ""
                }
            } in
            var static_act = {
                if (flood_static) {
                    "clone { "
                        "outport =${mc_static}; "
                        "output; "
                    "};"
                } else {
                    ""
                }
            } in
            Flow(.logical_datapath = sw._uuid,
                 .stage            = s_SWITCH_IN_L2_LKUP(),
                 .priority         = 90,
                 .__match          = i"eth.mcast && ${ipX} && ${ipX}.dst == ${address}",
                 .actions          =
                    i"${relay_act} ${static_act} outport = \"${address}\"; "
                    "output;",
                 .stage_hint       = 0,
                 .io_port          = None,
                 .controller_meter = None)
        }
    }
}

/* Table EXTERNAL_PORT: External port. Drop ARP request for router ips from
 * external ports on chassis not binding those ports.  This makes the router
 * pipeline to be run only on the chassis binding the external ports.
 *
 * For an external port X on logical switch LS, if X is not resident on this
 * chassis, drop ARP requests arriving on localnet ports from X's Ethernet
 * address, if the ARP request is asking to translate the IP address of a
 * router port on LS. */
Flow(.logical_datapath = sp.sw._uuid,
     .stage            = s_SWITCH_IN_EXTERNAL_PORT(),
     .priority         = 100,
     .__match          = (i"inport == ${json_escape(localnet_port.1)} && "
                          "eth.src == ${lp_addr.ea} && "
                          "!is_chassis_resident(${sp.json_name}) && "
                          "arp.tpa == ${rp_addr.addr} && arp.op == 1"),
     .actions          = i"drop;",
     .stage_hint       = stage_hint(sp.lsp._uuid),
     .io_port          = Some{localnet_port.1},
     .controller_meter = None) :-
    sp in &SwitchPort(),
    sp.lsp.__type == i"external",
    var localnet_port = FlatMap(sp.sw.localnet_ports),
    var lp_addr = FlatMap(sp.static_addresses),
    rp in &SwitchPort(.sw = sp.sw),
    rp.lsp.__type == i"router",
    SwitchPortIPv4Address(.port = rp, .addr = rp_addr).
Flow(.logical_datapath = sp.sw._uuid,
     .stage            = s_SWITCH_IN_EXTERNAL_PORT(),
     .priority         = 100,
     .__match          = (i"inport == ${json_escape(localnet_port.1)} && "
                          "eth.src == ${lp_addr.ea} && "
                          "!is_chassis_resident(${sp.json_name}) && "
                          "nd_ns && ip6.dst == {${rp_addr.addr}, ${rp_addr.solicited_node()}} && "
                          "nd.target == ${rp_addr.addr}"),
     .actions          = i"drop;",
     .stage_hint       = stage_hint(sp.lsp._uuid),
     .io_port          = Some{localnet_port.1},
     .controller_meter = None) :-
    sp in &SwitchPort(),
    sp.lsp.__type == i"external",
    var localnet_port = FlatMap(sp.sw.localnet_ports),
    var lp_addr = FlatMap(sp.static_addresses),
    rp in &SwitchPort(.sw = sp.sw),
    rp.lsp.__type == i"router",
    SwitchPortIPv6Address(.port = rp, .addr = rp_addr).
Flow(.logical_datapath = sp.sw._uuid,
     .stage            = s_SWITCH_IN_EXTERNAL_PORT(),
     .priority         = 100,
     .__match          = (i"inport == ${json_escape(localnet_port.1)} && "
                          "eth.src == ${lp_addr.ea} && "
                          "eth.dst == ${ea} && "
                          "!is_chassis_resident(${sp.json_name})"),
     .actions          = i"drop;",
     .stage_hint       = stage_hint(sp.lsp._uuid),
     .io_port          = Some{localnet_port.1},
     .controller_meter = None) :-
    sp in &SwitchPort(),
    sp.lsp.__type == i"external",
    var localnet_port = FlatMap(sp.sw.localnet_ports),
    var lp_addr = FlatMap(sp.static_addresses),
    rp in &SwitchPort(.sw = sp.sw),
    rp.lsp.__type == i"router",
    SwitchPortAddresses(.port = rp, .addrs = LPortAddress{.ea = ea}).

/* Ingress table L2_LKUP: Destination lookup, broadcast and multicast handling
 * (priority 100). */
for (ls in &nb::Logical_Switch) {
    var mc_flood = json_escape(mC_FLOOD().0) in
    Flow(.logical_datapath = ls._uuid,
         .stage            = s_SWITCH_IN_L2_LKUP(),
         .priority         = 70,
         .__match          = i"eth.mcast",
         .actions          = i"outport = ${mc_flood}; output;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Ingress table L2_LKUP: Destination lookup, unicast handling (priority 50).
*/
for (SwitchPortStaticAddresses(.port = &SwitchPort{.lsp = lsp, .json_name = json_name, .sw = sw},
                               .addrs = addrs)
     if lsp.__type != i"external") {
    Flow(.logical_datapath = sw._uuid,
         .stage            = s_SWITCH_IN_L2_LKUP(),
         .priority         = 50,
         .__match          = i"eth.dst == ${addrs.ea}",
         .actions          = i"outport = ${json_name}; output;",
         .stage_hint       = stage_hint(lsp._uuid),
         .io_port          = None,
         .controller_meter = None)
}

/*
 * Ingress table L2_LKUP: Flows that flood self originated ARP/ND packets in the
 * switching domain.
 */
/* Self originated ARP requests/ND need to be flooded to the L2 domain
 * (except on router ports).  Determine that packets are self originated
 * by also matching on source MAC. Matching on ingress port is not
 * reliable in case this is a VLAN-backed network.
 * Priority: 75.
 */

/* Returns 'true' if the IP 'addr' is on the same subnet with one of the
 * IPs configured on the router port.
 */
function lrouter_port_ip_reachable(rp: Intern<RouterPort>, addr: v46_ip): bool {
    match (addr) {
        IPv4{ipv4} -> {
            for (na in rp.networks.ipv4_addrs) {
                if ((ipv4, na.addr).same_network(na.netmask())) {
                    return true
                }
            }
        },
        IPv6{ipv6} -> {
            for (na in rp.networks.ipv6_addrs) {
                if ((ipv6, na.addr).same_network(na.netmask())) {
                    return true
                }
            }
        }
    };
    false
}
Flow(.logical_datapath = sw._uuid,
     .stage            = s_SWITCH_IN_L2_LKUP(),
     .priority         = 75,
     .__match          = __match,
     .actions          = actions,
     .stage_hint       = stage_hint(sp.lsp._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    sp in &SwitchPort(.sw = sw@&Switch{.has_non_router_port = true}, .peer = Some{rp}),
    rp.is_enabled(),
    var eth_src_set = {
        var eth_src_set = set_singleton(i"${rp.networks.ea}");
        for (nat in rp.router.nats) {
            match (nat.nat.external_mac) {
                Some{mac} ->
                    if (lrouter_port_ip_reachable(rp, nat.external_ip)) {
                        eth_src_set.insert(mac)
                    } else (),
                _ -> ()
            }
        };
        eth_src_set
    },
    var eth_src = "{" ++ eth_src_set.to_vec().join(", ") ++ "}",
    var __match = i"eth.src == ${eth_src} && (arp.op == 1 || nd_ns)",
    var mc_flood_l2 = json_escape(mC_FLOOD_L2().0),
    var actions = i"outport = ${mc_flood_l2}; output;".

/* Forward ARP requests for owned IP addresses (L3, VIP, NAT) only to this
 * router port.
 * Priority: 80.
 */
function get_arp_forward_ips(rp: Intern<RouterPort>, lbips: Intern<LogicalRouterLBIPs>):
    (Set<istring>, Set<istring>, Set<istring>, Set<istring>) =
{
    var reachable_ips_v4 = set_empty();
    var reachable_ips_v6 = set_empty();
    var unreachable_ips_v4 = set_empty();
    var unreachable_ips_v6 = set_empty();

    (var lb_ips_v4, var lb_ips_v6)
        = get_router_load_balancer_ips(lbips, false);
    for (a in lb_ips_v4) {
        /* Check if the ovn port has a network configured on which we could
         * expect ARP requests for the LB VIP.
         */
        match (ip_parse(a.ival())) {
            Some{ipv4} -> if (lrouter_port_ip_reachable(rp, IPv4{ipv4})) {
                reachable_ips_v4.insert(a)
            } else {
                unreachable_ips_v4.insert(a)
            },
            _ -> ()
        }
    };
    for (a in lb_ips_v6) {
        /* Check if the ovn port has a network configured on which we could
         * expect NS requests for the LB VIP.
         */
        match (ipv6_parse(a.ival())) {
            Some{ipv6} -> if (lrouter_port_ip_reachable(rp, IPv6{ipv6})) {
                reachable_ips_v6.insert(a)
            } else {
                unreachable_ips_v6.insert(a)
            },
            _ -> ()
        }
    };

    for (nat in rp.router.nats) {
        if (nat.nat.__type != i"snat") {
            /* Check if the ovn port has a network configured on which we could
             * expect ARP requests/NS for the DNAT external_ip.
             */
            if (lrouter_port_ip_reachable(rp, nat.external_ip)) {
                match (nat.external_ip) {
                    IPv4{_} -> reachable_ips_v4.insert(nat.nat.external_ip),
                    IPv6{_} -> reachable_ips_v6.insert(nat.nat.external_ip)
                }
            } else {
                match (nat.external_ip) {
                    IPv4{_} -> unreachable_ips_v4.insert(nat.nat.external_ip),
                    IPv6{_} -> unreachable_ips_v6.insert(nat.nat.external_ip),
                }
            }
        }
    };

    for (a in rp.networks.ipv4_addrs) {
        reachable_ips_v4.insert(i"${a.addr}")
    };
    for (a in rp.networks.ipv6_addrs) {
        reachable_ips_v6.insert(i"${a.addr}")
    };

    (reachable_ips_v4, reachable_ips_v6, unreachable_ips_v4, unreachable_ips_v6)
}

relation &SwitchPortARPForwards(
    port: Intern<SwitchPort>,
    reachable_ips_v4: Set<istring>,
    reachable_ips_v6: Set<istring>,
    unreachable_ips_v4: Set<istring>,
    unreachable_ips_v6: Set<istring>
)

&SwitchPortARPForwards(.port = port,
                       .reachable_ips_v4 = reachable_ips_v4,
                       .reachable_ips_v6 = reachable_ips_v6,
                       .unreachable_ips_v4 = unreachable_ips_v4,
                       .unreachable_ips_v6 = unreachable_ips_v6) :-
    port in &SwitchPort(.peer = Some{rp@&RouterPort{.enabled = true}}),
    lbips in &LogicalRouterLBIPs(.lr = rp.router._uuid),
    (var reachable_ips_v4, var reachable_ips_v6, var unreachable_ips_v4, var unreachable_ips_v6) = get_arp_forward_ips(rp, lbips).

/* Packets received from VXLAN tunnels have already been through the
 * router pipeline so we should skip them. Normally this is done by the
 * multicast_group implementation (VXLAN packets skip table 32 which
 * delivers to patch ports) but we're bypassing multicast_groups.
 * (This is why we match against fLAGBIT_NOT_VXLAN() here.)
 */
Flow(.logical_datapath = sw._uuid,
     .stage            = s_SWITCH_IN_L2_LKUP(),
     .priority         = 80,
     .__match          = i"${fLAGBIT_NOT_VXLAN()} && arp.op == 1 && arp.tpa == ${ipv4}",
     .actions          = if (sw.has_non_router_port) {
                             i"clone {outport = ${sp.json_name}; output; }; "
                             "outport = ${mc_flood_l2}; output;"
                         } else {
                             i"outport = ${sp.json_name}; output;"
                         },
     .stage_hint       = stage_hint(sp.lsp._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    var mc_flood_l2 = json_escape(mC_FLOOD_L2().0),
    &SwitchPortARPForwards(.port = sp@&SwitchPort{.sw = sw}, .reachable_ips_v4 = ips_v4),
    var ipv4 = FlatMap(ips_v4).
Flow(.logical_datapath = sw._uuid,
     .stage            = s_SWITCH_IN_L2_LKUP(),
     .priority         = 80,
     .__match          = i"${fLAGBIT_NOT_VXLAN()} && nd_ns && nd.target == ${ipv6}",
     .actions          = if (sw.has_non_router_port) {
                             i"clone {outport = ${sp.json_name}; output; }; "
                             "outport = ${mc_flood_l2}; output;"
                         } else {
                             i"outport = ${sp.json_name}; output;"
                         },
     .stage_hint       = stage_hint(sp.lsp._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    var mc_flood_l2 = json_escape(mC_FLOOD_L2().0),
    &SwitchPortARPForwards(.port = sp@&SwitchPort{.sw = sw}, .reachable_ips_v6 = ips_v6),
    var ipv6 = FlatMap(ips_v6).

Flow(.logical_datapath = sw._uuid,
     .stage            = s_SWITCH_IN_L2_LKUP(),
     .priority         = 90,
     .__match          = i"${fLAGBIT_NOT_VXLAN()} && arp.op == 1 && arp.tpa == ${ipv4}",
     .actions          = actions,
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    var actions = i"outport = ${json_escape(mC_FLOOD().0)}; output;",
    &SwitchPortARPForwards(.port = sp@&SwitchPort{.sw = sw}, .unreachable_ips_v4 = ips_v4),
    var ipv4 = FlatMap(ips_v4).
Flow(.logical_datapath = sw._uuid,
     .stage            = s_SWITCH_IN_L2_LKUP(),
     .priority         = 90,
     .__match          = i"${fLAGBIT_NOT_VXLAN()} && nd_ns && nd.target == ${ipv6}",
     .actions          = actions,
     .stage_hint       = stage_hint(sp.lsp._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    var actions = i"outport = ${json_escape(mC_FLOOD().0)}; output;",
    &SwitchPortARPForwards(.port = sp@&SwitchPort{.sw = sw}, .unreachable_ips_v6 = ips_v6),
    var ipv6 = FlatMap(ips_v6).

for (SwitchPortNewDynamicAddress(.port = &SwitchPort{.lsp = lsp, .json_name = json_name, .sw = sw},
                                 .address = Some{addrs})
     if lsp.__type != i"external") {
    Flow(.logical_datapath = sw._uuid,
         .stage            = s_SWITCH_IN_L2_LKUP(),
         .priority         = 50,
         .__match          = i"eth.dst == ${addrs.ea}",
         .actions          = i"outport = ${json_name}; output;",
         .stage_hint       = stage_hint(lsp._uuid),
         .io_port          = None,
         .controller_meter = None)
}

for (&SwitchPort(.lsp = lsp,
                 .json_name = json_name,
                 .sw = sw,
                 .peer = Some{&RouterPort{.lrp = lrp,
                                          .is_redirect = is_redirect,
                                          .router = &Router{._uuid = lr_uuid,
                                                            .l3dgw_ports = l3dgw_ports}}})
     if (lsp.addresses.contains(i"router") and lsp.__type != i"external"))
{
    Some{var mac} = scan_eth_addr(lrp.mac.ival()) in {
        var add_chassis_resident_check =
            not sw.localnet_ports.is_empty() and
            (/* The peer of this port represents a distributed
              * gateway port. The destination lookup flow for the
              * router's distributed gateway port MAC address should
              * only be programmed on the "redirect-chassis". */
             is_redirect or
             /* Check if the option 'reside-on-redirect-chassis'
              * is set to true on the peer port. If set to true
              * and if the logical switch has a localnet port, it
              * means the router pipeline for the packets from
              * this logical switch should be run on the chassis
              * hosting the gateway port.
              */
              lrp.options.get_bool_def(i"reside-on-redirect-chassis", false)) in
        var __match = if (add_chassis_resident_check) {
            var redirect_port_name = if (is_redirect) {
                json_escape(chassis_redirect_name(lrp.name))
            } else {
                match (l3dgw_ports.nth(0)) {
                    Some {var gw_port} -> json_escape(chassis_redirect_name(gw_port.name)),
                    None -> ""
                }
            };
            /* The destination lookup flow for the router's
             * distributed gateway port MAC address should only be
             * programmed on the "redirect-chassis". */
            i"eth.dst == ${mac} && is_chassis_resident(${redirect_port_name})"
        } else {
            i"eth.dst == ${mac}"
        } in
        Flow(.logical_datapath = sw._uuid,
             .stage            = s_SWITCH_IN_L2_LKUP(),
             .priority         = 50,
             .__match          = __match,
             .actions          = i"outport = ${json_name}; output;",
             .stage_hint       = stage_hint(lsp._uuid),
             .io_port          = None,
             .controller_meter = None);

        /* Add ethernet addresses specified in NAT rules on
         * distributed logical routers. */
        if (is_redirect) {
            for (LogicalRouterNAT(.lr = lr_uuid, .nat = nat)) {
                if (nat.nat.__type == i"dnat_and_snat") {
                    Some{var lport} = nat.nat.logical_port in
                    Some{var emac} = nat.nat.external_mac in
                    Some{var nat_mac} = eth_addr_from_string(emac.ival()) in
                    var __match = i"eth.dst == ${nat_mac} && is_chassis_resident(${json_escape(lport)})" in
                    Flow(.logical_datapath = sw._uuid,
                         .stage            = s_SWITCH_IN_L2_LKUP(),
                         .priority         = 50,
                         .__match          = __match,
                         .actions          = i"outport = ${json_name}; output;",
                         .stage_hint       = stage_hint(nat.nat._uuid),
                         .io_port          = None,
                         .controller_meter = None)
                }
            }
        }
    }
}
// FIXME: do we care about this?
/*        } else {
            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);

            VLOG_INFO_RL(&rl,
                         "%s: invalid syntax '%s' in addresses column",
                         op->nbsp->name, op->nbsp->addresses[i]);
        }*/

/* Ingress table L2_LKUP and L2_UNKNOWN: Destination lookup for unknown MACs (priority 0). */
for (sw in &Switch(._uuid = ls_uuid)) {
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_L2_LKUP(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"outport = get_fdb(eth.dst); next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_L2_UNKNOWN(),
         .priority         = 50,
         .__match          = i"outport == \"none\"",
         .actions          = if (sw.has_unknown_ports) {
                                 var mc_unknown = json_escape(mC_UNKNOWN().0);
                                 i"outport = ${mc_unknown}; output;"
                             } else {
                                 i"drop;"
                             },
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_IN_L2_UNKNOWN(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"output;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Egress tables PORT_SEC_IP: Egress port security - IP (priority 0)
 * Egress table PORT_SEC_L2: Egress port security L2 - multicast/broadcast (priority 100). */
for (&Switch(._uuid = ls_uuid)) {
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PORT_SEC_IP(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = ls_uuid,
         .stage            = s_SWITCH_OUT_PORT_SEC_L2(),
         .priority         = 100,
         .__match          = i"eth.mcast",
         .actions          = i"output;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

Flow(.logical_datapath = ls_uuid,
     .stage = s_SWITCH_IN_LOOKUP_FDB(),
     .priority = 100,
     .__match = i"inport == ${sp.json_name}",
     .actions = i"$[rEGBIT_LKUP_FDB()} = lookup_fdb(inport, eth.src); next;",
     .stage_hint = stage_hint(lsp_uuid),
     .io_port = Some{sp.lsp.name},
     .controller_meter = None),
Flow(.logical_datapath = ls_uuid,
     .stage = s_SWITCH_IN_LOOKUP_FDB(),
     .priority = 100,
     .__match = i"inport == ${sp.json_name} && ${rEGBIT_LKUP_FDB()} == 0",
     .actions = i"put_fdb(inport, eth.src); next;",
     .stage_hint = stage_hint(lsp_uuid),
     .io_port = Some{sp.lsp.name},
     .controller_meter = None) :-
    LogicalSwitchPortWithUnknownAddress(ls_uuid, lsp_uuid),
    sp in &SwitchPort(.lsp = &nb::Logical_Switch_Port{._uuid = lsp_uuid, .__type = i""},
                      .ps_addresses = vec_empty()).

Flow(.logical_datapath = ls_uuid,
     .stage            = s_SWITCH_IN_LOOKUP_FDB(),
     .priority         = 0,
     .__match          = i"1",
     .actions          = i"next;",
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None),
Flow(.logical_datapath = ls_uuid,
     .stage            = s_SWITCH_IN_PUT_FDB(),
     .priority         = 0,
     .__match          = i"1",
     .actions          = i"next;",
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    &Switch(._uuid = ls_uuid).

/* Egress table PORT_SEC_IP: Egress port security - IP (priorities 90 and 80)
 * if port security enabled.
 *
 * Egress table PORT_SEC_L2: Egress port security - L2 (priorities 50 and 150).
 *
 * Priority 50 rules implement port security for enabled logical port.
 *
 * Priority 150 rules drop packets to disabled logical ports, so that they
 * don't even receive multicast or broadcast packets. */
Flow(.logical_datapath = sw._uuid,
     .stage            = s_SWITCH_OUT_PORT_SEC_L2(),
     .priority         = 50,
     .__match          = __match,
     .actions          = i"${queue_action}output;",
     .stage_hint       = stage_hint(lsp._uuid),
     .io_port          = Some{lsp.name},
     .controller_meter = None) :-
    &SwitchPort(.sw = sw, .lsp = lsp, .json_name = json_name, .ps_eth_addresses = ps_eth_addresses),
    lsp.is_enabled(),
    lsp.__type != i"external",
    var __match = if (ps_eth_addresses.is_empty()) {
            i"outport == ${json_name}"
        } else {
            i"outport == ${json_name} && eth.dst == {${ps_eth_addresses.join(\" \")}}"
        },
    pbinding in sb::Out_Port_Binding(.logical_port = lsp.name),
    var queue_action = match ((lsp.__type.ival(),
                               pbinding.options.get(i"qdisc_queue_id"))) {
        ("localnet", Some{queue_id}) -> "set_queue(${queue_id});",
        _ -> ""
    }.

for (&SwitchPort(.lsp = lsp, .json_name = json_name, .sw = sw)) {
    if (not lsp.is_enabled() and lsp.__type != i"external") {
        Flow(.logical_datapath = sw._uuid,
             .stage            = s_SWITCH_OUT_PORT_SEC_L2(),
             .priority         = 150,
             .__match          = i"outport == {$json_name}",
             .actions          = i"drop;",
             .stage_hint       = stage_hint(lsp._uuid),
             .io_port          = Some{lsp.name},
             .controller_meter = None)
    }
}

for (SwitchPortPSAddresses(.port = &SwitchPort{.lsp = lsp, .json_name = json_name, .sw = sw},
                           .ps_addrs = ps)
     if (ps.ipv4_addrs.len() > 0 or ps.ipv6_addrs.len() > 0)
         and lsp.__type != i"external")
{
    if (ps.ipv4_addrs.len() > 0) {
        var addrs = {
            var addrs = vec_empty();
            for (addr in ps.ipv4_addrs) {
                /* When the netmask is applied, if the host portion is
                 * non-zero, the host can only use the specified
                 * address.  If zero, the host is allowed to use any
                 * address in the subnet.
                 */
                addrs.push(addr.match_host_or_network());
                if (addr.plen < 32 and not addr.host().is_zero()) {
                    addrs.push("${addr.bcast()}")
                }
            };
            addrs
        } in
        var __match =
            "outport == ${json_name} && eth.dst == ${ps.ea} && ip4.dst == {255.255.255.255, 224.0.0.0/4, " ++
            addrs.join(", ") ++ "}" in
        Flow(.logical_datapath = sw._uuid,
             .stage            = s_SWITCH_OUT_PORT_SEC_IP(),
             .priority         = 90,
             .__match          = __match.intern(),
             .actions          = i"next;",
             .stage_hint       = stage_hint(lsp._uuid),
             .io_port          = Some{lsp.name},
             .controller_meter = None)
    };
    if (ps.ipv6_addrs.len() > 0) {
        var __match = "outport == ${json_name} && eth.dst == ${ps.ea}" ++
                      build_port_security_ipv6_flow(Egress, ps.ea, ps.ipv6_addrs) in
        Flow(.logical_datapath = sw._uuid,
             .stage            = s_SWITCH_OUT_PORT_SEC_IP(),
             .priority         = 90,
             .__match          = __match.intern(),
             .actions          = i"next;",
             .stage_hint       = stage_hint(lsp._uuid),
             .io_port          = Some{lsp.name},
             .controller_meter = None)
    };
    var __match = i"outport == ${json_name} && eth.dst == ${ps.ea} && ip" in
    Flow(.logical_datapath = sw._uuid,
         .stage            = s_SWITCH_OUT_PORT_SEC_IP(),
         .priority         = 80,
         .__match          = __match,
         .actions          = i"drop;",
         .stage_hint       = stage_hint(lsp._uuid),
         .io_port          = Some{lsp.name},
         .controller_meter = None)
}

/* Logical router ingress table ADMISSION: Admission control framework. */
for (&Router(._uuid = lr_uuid)) {
    /* Logical VLANs not supported.
     * Broadcast/multicast source address is invalid. */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_ADMISSION(),
         .priority         = 100,
         .__match          = i"vlan.present || eth.src[40]",
         .actions          = i"drop;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Logical router ingress table ADMISSION: match (priority 50). */
for (&RouterPort(.lrp = lrp,
                 .json_name = json_name,
                 .networks = lrp_networks,
                 .router = router,
                 .is_redirect = is_redirect)
     /* Drop packets from disabled logical ports (since logical flow
      * tables are default-drop). */
     if lrp.is_enabled())
{
    //if (op->derived) {
    //    /* No ingress packets should be received on a chassisredirect
    //     * port. */
    //    continue;
    //}

    /* Store the ethernet address of the port receiving the packet.
     * This will save us from having to match on inport further down in
     * the pipeline.
     */
    var gw_mtu = lrp.options.get_int_def(i"gateway_mtu", 0) in
    var mtu = gw_mtu + vLAN_ETH_HEADER_LEN() in
    var actions = if (gw_mtu > 0) {
        "${rEGBIT_PKT_LARGER()} = check_pkt_larger(${mtu}); "
    } else {
        ""
    } ++ "${rEG_INPORT_ETH_ADDR()} = ${lrp_networks.ea}; next;" in {
        Flow(.logical_datapath = router._uuid,
             .stage            = s_ROUTER_IN_ADMISSION(),
             .priority         = 50,
             .__match          = i"eth.mcast && inport == ${json_name}",
             .actions          = actions.intern(),
             .stage_hint       = stage_hint(lrp._uuid),
             .io_port          = None,
             .controller_meter = None);

        var __match =
            "eth.dst == ${lrp_networks.ea} && inport == ${json_name}" ++
            if is_redirect {
                /* Traffic with eth.dst = l3dgw_port->lrp_networks.ea
                 * should only be received on the "redirect-chassis". */
                " && is_chassis_resident(${json_escape(chassis_redirect_name(lrp.name))})"
            } else { "" } in
        Flow(.logical_datapath = router._uuid,
             .stage            = s_ROUTER_IN_ADMISSION(),
             .priority         = 50,
             .__match          = __match.intern(),
             .actions          = actions.intern(),
             .stage_hint       = stage_hint(lrp._uuid),
             .io_port          = None,
             .controller_meter = None)
    }
}


/* Logical router ingress table LOOKUP_NEIGHBOR and
 * table LEARN_NEIGHBOR. */
/* Learn MAC bindings from ARP/IPv6 ND.
 *
 * For ARP packets, table LOOKUP_NEIGHBOR does a lookup for the
 * (arp.spa, arp.sha) in the mac binding table using the 'lookup_arp'
 * action and stores the result in REGBIT_LOOKUP_NEIGHBOR_RESULT bit.
 * If "always_learn_from_arp_request" is set to false, it will also
 * lookup for the (arp.spa) in the mac binding table using the
 * "lookup_arp_ip" action for ARP request packets, and stores the
 * result in REGBIT_LOOKUP_NEIGHBOR_IP_RESULT bit; or set that bit
 * to "1" directly for ARP response packets.
 *
 * For IPv6 ND NA packets, table LOOKUP_NEIGHBOR does a lookup
 * for the (nd.target, nd.tll) in the mac binding table using the
 * 'lookup_nd' action and stores the result in
 * REGBIT_LOOKUP_NEIGHBOR_RESULT bit. If
 * "always_learn_from_arp_request" is set to false,
 * REGBIT_LOOKUP_NEIGHBOR_IP_RESULT bit is set.
 *
 * For IPv6 ND NS packets, table LOOKUP_NEIGHBOR does a lookup
 * for the (ip6.src, nd.sll) in the mac binding table using the
 * 'lookup_nd' action and stores the result in
 * REGBIT_LOOKUP_NEIGHBOR_RESULT bit. If
 * "always_learn_from_arp_request" is set to false, it will also lookup
 * for the (ip6.src) in the mac binding table using the "lookup_nd_ip"
 * action and stores the result in REGBIT_LOOKUP_NEIGHBOR_IP_RESULT
 * bit.
 *
 * Table LEARN_NEIGHBOR learns the mac-binding using the action
 * - 'put_arp/put_nd'. Learning mac-binding is skipped if
 *   REGBIT_LOOKUP_NEIGHBOR_RESULT bit is set or
 *   REGBIT_LOOKUP_NEIGHBOR_IP_RESULT is not set.
 *
 * */

/* Flows for LOOKUP_NEIGHBOR. */
for (&Router(._uuid = lr_uuid,
             .learn_from_arp_request = learn_from_arp_request,
             .copp = copp))
var rLNR = rEGBIT_LOOKUP_NEIGHBOR_RESULT() in
var rLNIR = rEGBIT_LOOKUP_NEIGHBOR_IP_RESULT() in
{
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_LOOKUP_NEIGHBOR(),
         .priority         = 100,
         .__match          = i"arp.op == 2",
         .actions          =
             ("${rLNR} = lookup_arp(inport, arp.spa, arp.sha); " ++
              { if (learn_from_arp_request) "" else "${rLNIR} = 1; " } ++
              "next;").intern(),
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_LOOKUP_NEIGHBOR(),
         .priority         = 100,
         .__match          = i"nd_na",
         .actions          =
             ("${rLNR} = lookup_nd(inport, nd.target, nd.tll); " ++
              { if (learn_from_arp_request) "" else "${rLNIR} = 1; " } ++
              "next;").intern(),
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_LOOKUP_NEIGHBOR(),
         .priority         = 100,
         .__match          = i"nd_ns",
         .actions          =
             ("${rLNR} = lookup_nd(inport, ip6.src, nd.sll); " ++
              { if (learn_from_arp_request) "" else
                "${rLNIR} = lookup_nd_ip(inport, ip6.src); " } ++
              "next;").intern(),
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* For other packet types, we can skip neighbor learning.
     * So set REGBIT_LOOKUP_NEIGHBOR_RESULT to 1. */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_LOOKUP_NEIGHBOR(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"${rLNR} = 1; next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* Flows for LEARN_NEIGHBOR. */
    /* Skip Neighbor learning if not required. */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_LEARN_NEIGHBOR(),
         .priority         = 100,
         .__match          =
             ("${rLNR} == 1" ++
              { if (learn_from_arp_request) "" else " || ${rLNIR} == 0" }).intern(),
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_LEARN_NEIGHBOR(),
         .priority         = 90,
         .__match          = i"arp",
         .actions          = i"put_arp(inport, arp.spa, arp.sha); next;",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_ARP()),
         .stage_hint       = 0);
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_LEARN_NEIGHBOR(),
         .priority         = 90,
         .__match          = i"nd_na",
         .actions          = i"put_nd(inport, nd.target, nd.tll); next;",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_ND_NA()),
         .stage_hint       = 0);
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_LEARN_NEIGHBOR(),
         .priority         = 90,
         .__match          = i"nd_ns",
         .actions          = i"put_nd(inport, ip6.src, nd.sll); next;",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_ND_NS()),
         .stage_hint       = 0)
}

/* Check if we need to learn mac-binding from ARP requests. */
for (RouterPortNetworksIPv4Addr(rp@&RouterPort{.router = router}, addr)) {
    var chassis_residence = match (rp.is_redirect) {
        true -> " && is_chassis_resident(${json_escape(chassis_redirect_name(rp.lrp.name))})",
        false -> ""
    } in
    var rLNR = rEGBIT_LOOKUP_NEIGHBOR_RESULT() in
    var rLNIR = rEGBIT_LOOKUP_NEIGHBOR_IP_RESULT() in
    var match0 = "inport == ${rp.json_name} && "
                 "arp.spa == ${addr.match_network()}" in
    var match1 = "arp.op == 1" ++ chassis_residence in
    var learn_from_arp_request = router.learn_from_arp_request in {
       if (not learn_from_arp_request) {
            /* ARP request to this address should always get learned,
             * so add a priority-110 flow to set
             * REGBIT_LOOKUP_NEIGHBOR_IP_RESULT to 1. */
            var __match = [match0, "arp.tpa == ${addr.addr}", match1] in
            var actions = i"${rLNR} = lookup_arp(inport, arp.spa, arp.sha); "
                          "${rLNIR} = 1; "
                          "next;" in
            Flow(.logical_datapath = router._uuid,
                 .stage            = s_ROUTER_IN_LOOKUP_NEIGHBOR(),
                 .priority         = 110,
                 .__match          = __match.join(" && ").intern(),
                 .actions          = actions,
                 .stage_hint       = stage_hint(rp.lrp._uuid),
                 .io_port          = None,
                 .controller_meter = None)
        };

        var actions = "${rLNR} = lookup_arp(inport, arp.spa, arp.sha); " ++
                      { if (learn_from_arp_request) "" else
                        "${rLNIR} = lookup_arp_ip(inport, arp.spa); " } ++
                      "next;" in
        Flow(.logical_datapath = router._uuid,
             .stage            = s_ROUTER_IN_LOOKUP_NEIGHBOR(),
             .priority         = 100,
             .__match          = i"${match0} && ${match1}",
             .actions          = actions.intern(),
             .stage_hint       = stage_hint(rp.lrp._uuid),
             .io_port          = None,
             .controller_meter = None)
    }
}


/* Logical router ingress table IP_INPUT: IP Input. */
for (router in &Router(._uuid = lr_uuid, .mcast_cfg = mcast_cfg)) {
    /* L3 admission control: drop multicast and broadcast source, localhost
     * source or destination, and zero network source or destination
     * (priority 100). */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 100,
         .__match          = i"ip4.src_mcast ||"
         "ip4.src == 255.255.255.255 || "
         "ip4.src == 127.0.0.0/8 || "
         "ip4.dst == 127.0.0.0/8 || "
         "ip4.src == 0.0.0.0/8 || "
         "ip4.dst == 0.0.0.0/8",
         .actions          = i"drop;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

   /* Drop ARP packets (priority 85). ARP request packets for router's own
    * IPs are handled with priority-90 flows.
    * Drop IPv6 ND packets (priority 85). ND NA packets for router's own
    * IPs are handled with priority-90 flows.
    */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 85,
         .__match          = i"arp || nd",
         .actions          = i"drop;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* Allow IPv6 multicast traffic that's supposed to reach the
     * router pipeline (e.g., router solicitations).
     */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 84,
         .__match          = i"nd_rs || nd_ra",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* Drop other reserved multicast. */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 83,
         .__match          = i"ip6.mcast_rsvd",
         .actions          = i"drop;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* Allow other multicast if relay enabled (priority 82). */
    var mcast_action = { if (mcast_cfg.relay) { i"next;" } else { i"drop;" } } in
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 82,
         .__match          = i"ip4.mcast || ip6.mcast",
         .actions          = mcast_action,
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* Drop Ethernet local broadcast.  By definition this traffic should
     * not be forwarded.*/
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 50,
         .__match          = i"eth.bcast",
         .actions          = i"drop;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* TTL discard */
    Flow(
        .logical_datapath = lr_uuid,
        .stage            = s_ROUTER_IN_IP_INPUT(),
        .priority         = 30,
        .__match          = i"ip4 && ip.ttl == {0, 1}",
        .actions          = i"drop;",
        .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    /* Pass other traffic not already handled to the next table for
     * routing. */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

function format_v4_networks(networks: lport_addresses, add_bcast: bool): string =
{
    var addrs = vec_empty();
    for (addr in networks.ipv4_addrs) {
        addrs.push("${addr.addr}");
        if (add_bcast) {
            addrs.push("${addr.bcast()}")
        } else ()
    };
    if (addrs.len() == 1) {
        addrs.join(", ")
    } else {
        "{" ++ addrs.join(", ") ++ "}"
    }
}

function format_v6_networks(networks: lport_addresses): string =
{
    var addrs = vec_empty();
    for (addr in networks.ipv6_addrs) {
        addrs.push("${addr.addr}")
    };
    if (addrs.len() == 1) {
        addrs.join(", ")
    } else {
        "{" ++ addrs.join(", ") ++ "}"
    }
}

/* The following relation is used in ARP reply flow generation to determine whether
 * the is_chassis_resident check must be added to the flow.
 */
relation AddChassisResidentCheck_(lrp: uuid, add_check: bool)

AddChassisResidentCheck_(lrp._uuid, res) :-
    &SwitchPort(.peer = Some{&RouterPort{.lrp = lrp, .router = router, .is_redirect = is_redirect}},
                .sw = sw),
    not router.l3dgw_ports.is_empty(),
    not sw.localnet_ports.is_empty(),
    var res = if (is_redirect) {
        /* Traffic with eth.src = l3dgw_port->lrp_networks.ea
         * should only be sent from the "redirect-chassis", so that
         * upstream MAC learning points to the "redirect-chassis".
         * Also need to avoid generation of multiple ARP responses
         * from different chassis. */
        true
    } else {
        /* Check if the option 'reside-on-redirect-chassis'
         * is set to true on the router port. If set to true
         * and if peer's logical switch has a localnet port, it
         * means the router pipeline for the packets from
         * peer's logical switch is be run on the chassis
         * hosting the gateway port and it should reply to the
         * ARP requests for the router port IPs.
         */
        lrp.options.get_bool_def(i"reside-on-redirect-chassis", false)
    }.


relation AddChassisResidentCheck(lrp: uuid, add_check: bool)

AddChassisResidentCheck(lrp, add_check) :-
    AddChassisResidentCheck_(lrp, add_check).

AddChassisResidentCheck(lrp, false) :-
    &nb::Logical_Router_Port(._uuid = lrp),
    not AddChassisResidentCheck_(lrp, _).


/* Logical router ingress table IP_INPUT: IP Input for IPv4. */
for (&RouterPort(.router = router, .networks = networks, .lrp = lrp)
     if (not networks.ipv4_addrs.is_empty()))
{
    /* L3 admission control: drop packets that originate from an
     * IPv4 address owned by the router or a broadcast address
     * known to the router (priority 100). */
    var __match = "ip4.src == "                                  ++
                   format_v4_networks(networks, true)            ++
                   " && ${rEGBIT_EGRESS_LOOPBACK()} == 0" in
    Flow(.logical_datapath = router._uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 100,
         .__match          = __match.intern(),
         .actions          = i"drop;",
         .stage_hint       = stage_hint(lrp._uuid),
         .io_port          = None,
         .controller_meter = None);

    /* ICMP echo reply.  These flows reply to ICMP echo requests
     * received for the router's IP address. Since packets only
     * get here as part of the logical router datapath, the inport
     * (i.e. the incoming locally attached net) does not matter.
     * The ip.ttl also does not matter (RFC1812 section 4.2.2.9) */
    var __match = "ip4.dst == "                                  ++
                  format_v4_networks(networks, false)            ++
                  " && icmp4.type == 8 && icmp4.code == 0" in
    Flow(.logical_datapath = router._uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 90,
         .__match          = __match.intern(),
         .actions          = i"ip4.dst <-> ip4.src; "
                             "ip.ttl = 255; "
                             "icmp4.type = 0; "
                             "flags.loopback = 1; "
                             "next; ",
         .stage_hint       = stage_hint(lrp._uuid),
         .io_port          = None,
         .controller_meter = None)
}

/* Priority-90-92 flows handle ARP requests and ND packets. Most are
 * per logical port but DNAT addresses can be handled per datapath
 * for non gateway router ports.
 *
 * Priority 91 and 92 flows are added for each gateway router
 * port to handle the special cases. In case we get the packet
 * on a regular port, just reply with the port's ETH address.
 */
LogicalRouterNatArpNdFlow(router, nat) :-
    router in &Router(._uuid = lr),
    LogicalRouterNAT(.lr = lr, .nat = nat@NAT{.nat = &nb::NAT{.__type = __type}}),
    /* Skip SNAT entries for now, we handle unique SNAT IPs separately
     * below.
     */
    __type != i"snat".
/* Now handle SNAT entries too, one per unique SNAT IP. */
LogicalRouterNatArpNdFlow(router, nat) :-
    router in &Router(.snat_ips = snat_ips),
    var snat_ip = FlatMap(snat_ips),
    (var ip, var nats) = snat_ip,
    Some{var nat} = nats.nth(0).

relation LogicalRouterNatArpNdFlow(router: Intern<Router>, nat: NAT)
LogicalRouterArpNdFlow(router, nat, None, rEG_INPORT_ETH_ADDR(), None, false, 90) :-
    LogicalRouterNatArpNdFlow(router, nat).

/* ARP / ND handling for external IP addresses.
 *
 * DNAT and SNAT IP addresses are external IP addresses that need ARP
 * handling.
 *
 * These are already taken care globally, per router. The only
 * exception is on the l3dgw_port where we might need to use a
 * different ETH address.
 */
LogicalRouterPortNatArpNdFlow(router, nat, l3dgw_port) :-
    router in &Router(._uuid = lr_uuid, .l3dgw_ports = l3dgw_ports),
    Some {var l3dgw_port} = l3dgw_ports.nth(0),
    LogicalRouterNAT(lr_uuid, nat),
    /* Skip SNAT entries for now, we handle unique SNAT IPs separately
     * below.
     */
    nat.nat.__type != i"snat".
/* Now handle SNAT entries too, one per unique SNAT IP. */
LogicalRouterPortNatArpNdFlow(router, nat, l3dgw_port) :-
    router in &Router(.l3dgw_ports = l3dgw_ports, .snat_ips = snat_ips),
    Some {var l3dgw_port} = l3dgw_ports.nth(0),
    var snat_ip = FlatMap(snat_ips),
    (var ip, var nats) = snat_ip,
    Some{var nat} = nats.nth(0).

/* Respond to ARP/NS requests on the chassis that binds the gw
 * port. Drop the ARP/NS requests on other chassis.
 */
relation LogicalRouterPortNatArpNdFlow(router: Intern<Router>, nat: NAT, lrp: Intern<nb::Logical_Router_Port>)
LogicalRouterArpNdFlow(router, nat, Some{lrp}, mac, Some{extra_match}, false, 92),
LogicalRouterArpNdFlow(router, nat, Some{lrp}, mac, None, true, 91) :-
    LogicalRouterPortNatArpNdFlow(router, nat, lrp),
    (var mac, var extra_match) = match ((nat.external_mac, nat.nat.logical_port)) {
        (Some{external_mac}, Some{logical_port}) -> (
            /* distributed NAT case, use nat->external_mac */
            external_mac.to_string().intern(),
            /* Traffic with eth.src = nat->external_mac should only be
             * sent from the chassis where nat->logical_port is
             * resident, so that upstream MAC learning points to the
             * correct chassis.  Also need to avoid generation of
             * multiple ARP responses from different chassis. */
            i"is_chassis_resident(${json_escape(logical_port)})"
        ),
        _ -> (
            rEG_INPORT_ETH_ADDR(),
            /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s
             * should only be sent from the gateway chassis, so that
             * upstream MAC learning points to the gateway chassis.
             * Also need to avoid generation of multiple ARP responses
             * from different chassis. */
            match (router.l3dgw_ports.nth(0)) {
                None -> i"",
                Some {var gw_port} -> i"is_chassis_resident(${json_escape(chassis_redirect_name(gw_port.name))})"
            }
        )
    }.

/* Now divide the ARP/ND flows into ARP and ND. */
relation LogicalRouterArpNdFlow(
    router: Intern<Router>,
    nat: NAT,
    lrp: Option<Intern<nb::Logical_Router_Port>>,
    mac: istring,
    extra_match: Option<istring>,
    drop: bool,
    priority: integer)
LogicalRouterArpFlow(router, lrp, i"${ipv4}", mac, extra_match, drop, priority,
                     stage_hint(nat.nat._uuid)) :-
    LogicalRouterArpNdFlow(router, nat@NAT{.external_ip = IPv4{ipv4}}, lrp,
                           mac, extra_match, drop, priority).
LogicalRouterNdFlow(router, lrp, i"nd_na", ipv6, true, mac, extra_match, drop, priority,
                    stage_hint(nat.nat._uuid)) :-
    LogicalRouterArpNdFlow(router, nat@NAT{.external_ip = IPv6{ipv6}}, lrp,
                           mac, extra_match, drop, priority).

relation LogicalRouterNdFlowLB(
    lr: Intern<Router>,
    lrp: Option<Intern<nb::Logical_Router_Port>>,
    ip: istring,
    mac: istring,
    extra_match: Option<istring>,
    stage_hint: bit<32>)
Flow(.logical_datapath = lr._uuid,
     .stage = s_ROUTER_IN_IP_INPUT(),
     .priority = 90,
     .__match = __match.intern(),
     .actions = actions,
     .stage_hint = stage_hint,
     .io_port = None,
     .controller_meter = lr.copp.get(cOPP_ND_NA())) :-
    LogicalRouterNdFlowLB(.lr = lr, .lrp = lrp, .ip = ip,
                          .mac = mac, .extra_match = extra_match,
                          .stage_hint = stage_hint),
    var __match = {
        var clauses = vec_with_capacity(4);
        match (lrp) {
            Some{p} -> clauses.push(i"inport == ${json_escape(p.name)}"),
            None -> ()
        };
        clauses.push(i"nd_ns && nd.target == ${ip}");
        clauses.append(extra_match.to_vec());
        clauses.join(" && ")
    },
    var actions =
        i"nd_na { "
           "eth.src = ${mac}; "
           "ip6.src = nd.target; "
           "nd.tll = ${mac}; "
           "outport = inport; "
           "flags.loopback = 1; "
           "output; "
         "};".

relation LogicalRouterArpFlow(
    lr: Intern<Router>,
    lrp: Option<Intern<nb::Logical_Router_Port>>,
    ip: istring,
    mac: istring,
    extra_match: Option<istring>,
    drop: bool,
    priority: integer,
    stage_hint: bit<32>)
Flow(.logical_datapath = lr._uuid,
     .stage = s_ROUTER_IN_IP_INPUT(),
     .priority = priority,
     .__match = __match.intern(),
     .actions = actions,
     .stage_hint = stage_hint,
     .io_port          = None,
     .controller_meter = None) :-
    LogicalRouterArpFlow(.lr = lr, .lrp = lrp, .ip = ip, .mac = mac,
                         .extra_match = extra_match, .drop = drop,
                         .priority = priority, .stage_hint = stage_hint),
    var __match = {
        var clauses = vec_with_capacity(3);
        match (lrp) {
            Some{p} -> clauses.push(i"inport == ${json_escape(p.name)}"),
            None -> ()
        };
        clauses.push(i"arp.op == 1 && arp.tpa == ${ip}");
        clauses.append(extra_match.to_vec());
        clauses.join(" && ")
    },
    var actions = if (drop) {
       i"drop;"
    } else {
        i"eth.dst = eth.src; "
        "eth.src = ${mac}; "
        "arp.op = 2; /* ARP reply */ "
        "arp.tha = arp.sha; "
        "arp.sha = ${mac}; "
        "arp.tpa <-> arp.spa; "
        "outport = inport; "
        "flags.loopback = 1; "
        "output;"
    }.

relation LogicalRouterNdFlow(
    lr: Intern<Router>,
    lrp: Option<Intern<nb::Logical_Router_Port>>,
    action: istring,
    ip: in6_addr,
    sn_ip: bool,
    mac: istring,
    extra_match: Option<istring>,
    drop: bool,
    priority: integer,
    stage_hint: bit<32>)
Flow(.logical_datapath = lr._uuid,
     .stage = s_ROUTER_IN_IP_INPUT(),
     .priority = priority,
     .__match = __match.intern(),
     .actions = actions,
     .io_port = None,
     .controller_meter = controller_meter,
     .stage_hint = stage_hint) :-
    LogicalRouterNdFlow(.lr = lr, .lrp = lrp, .action = action, .ip = ip,
                        .sn_ip = sn_ip, .mac = mac, .extra_match = extra_match,
                        .drop = drop, .priority = priority,
                        .stage_hint = stage_hint),
    var __match = {
        var clauses = vec_with_capacity(4);
        match (lrp) {
            Some{p} -> clauses.push(i"inport == ${json_escape(p.name)}"),
            None -> ()
        };
        if (sn_ip) {
            clauses.push(i"ip6.dst == {${ip}, ${ip.solicited_node()}}")
        };
        clauses.push(i"nd_ns && nd.target == ${ip}");
        clauses.append(extra_match.to_vec());
        clauses.join(" && ")
    },
    (var actions, var controller_meter) = if (drop) {
        (i"drop;", None)
    } else {
        (i"${action} { "
           "eth.src = ${mac}; "
           "ip6.src = nd.target; "
           "nd.tll = ${mac}; "
           "outport = inport; "
           "flags.loopback = 1; "
           "output; "
         "};",
         lr.copp.get(cOPP_ND_NA()))
    }.

/* ICMP time exceeded */
for (RouterPortNetworksIPv4Addr(.port = &RouterPort{.lrp = lrp,
                                                    .json_name = json_name,
                                                    .router = router,
                                                    .networks = networks,
                                                    .is_redirect = is_redirect},
                                .addr = addr))
{
    Flow(.logical_datapath = router._uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 40,
         .__match          = i"inport == ${json_name} && ip4 && "
                             "ip.ttl == {0, 1} && !ip.later_frag",
         .actions          = i"icmp4 {"
                             "eth.dst <-> eth.src; "
                             "icmp4.type = 11; /* Time exceeded */ "
                             "icmp4.code = 0; /* TTL exceeded in transit */ "
                             "ip4.dst = ip4.src; "
                             "ip4.src = ${addr.addr}; "
                             "ip.ttl = 255; "
                             "next; };",
         .stage_hint       = stage_hint(lrp._uuid),
         .io_port          = None,
         .controller_meter = None);

    /* ARP reply.  These flows reply to ARP requests for the router's own
     * IP address. */
    for (AddChassisResidentCheck(lrp._uuid, add_chassis_resident_check)) {
        var __match =
            "arp.spa == ${addr.match_network()}" ++
            if (add_chassis_resident_check) {
                var redirect_port_name = if (is_redirect) {
                    json_escape(chassis_redirect_name(lrp.name))
                } else {
                    match (router.l3dgw_ports.nth(0)) {
                        None -> "",
                        Some {var gw_port} -> json_escape(chassis_redirect_name(gw_port.name))
                    }
                };
                " && is_chassis_resident(${redirect_port_name})"
            } else "" in
        LogicalRouterArpFlow(.lr = router,
                             .lrp = Some{lrp},
                             .ip = i"${addr.addr}",
                             .mac = rEG_INPORT_ETH_ADDR(),
                             .extra_match = Some{__match.intern()},
                             .drop = false,
                             .priority = 90,
                             .stage_hint = stage_hint(lrp._uuid))
    }
}

LogicalRouterNdFlow(.lr = r,
                    .lrp = Some{lrp},
                    .action = i"nd_na",
                    .ip = ip,
                    .sn_ip = false,
                    .mac = rEG_INPORT_ETH_ADDR(),
                    .extra_match = residence_check,
                    .drop = false,
                    .priority = 90,
                    .stage_hint = 0) :-
    &LBVIP(.vip_addr = IPv6{ip}, .lb = lb),
    RouterLB(r, lb._uuid),
    &RouterPort(.router = r, .lrp = lrp, .is_redirect = is_redirect),
    var residence_check = match (is_redirect) {
        true -> Some{i"is_chassis_resident(${json_escape(chassis_redirect_name(lrp.name))})"},
        false -> None
    }.

for (&RouterPort(.lrp = lrp,
                 .router = router@&Router{._uuid = lr_uuid},
                 .json_name = json_name,
                 .networks = networks,
                 .is_redirect = is_redirect)) {
    for (lbips in &LogicalRouterLBIPs(.lr = lr_uuid)) {
        var residence_check = match (is_redirect) {
            true -> Some{i"is_chassis_resident(${json_escape(chassis_redirect_name(lrp.name))})"},
            false -> None
        } in {
            var all_ipv4s = union(lbips.lb_ipv4s_routable, lbips.lb_ipv4s_unroutable) in
            not all_ipv4s.is_empty() in
            LogicalRouterArpFlow(.lr = router,
                                 .lrp = Some{lrp},
                                 .ip = i"{ ${all_ipv4s.to_vec().join(\", \")} }",
                                 .mac = rEG_INPORT_ETH_ADDR(),
                                 .extra_match = residence_check,
                                 .drop = false,
                                 .priority = 90,
                                 .stage_hint = 0);

            var all_ipv6s = union(lbips.lb_ipv6s_routable, lbips.lb_ipv6s_unroutable) in
            not all_ipv6s.is_empty() in
            LogicalRouterNdFlowLB(.lr = router,
                                  .lrp = Some{lrp},
                                  .ip = ("{ " ++ all_ipv6s.to_vec().join(", ") ++ " }").intern(),
                                  .mac = rEG_INPORT_ETH_ADDR(),
                                  .extra_match = residence_check,
                                  .stage_hint = 0)
        }
    }
}

/* Drop IP traffic destined to router owned IPs except if the IP is
 * also a SNAT IP. Those are dropped later, in stage
 * "lr_in_arp_resolve", if unSNAT was unsuccessful.
 *
 * Priority 60.
 */
Flow(.logical_datapath = lr_uuid,
     .stage = s_ROUTER_IN_IP_INPUT(),
     .priority = 60,
     .__match = ("ip4.dst == {" ++ match_ips.join(", ") ++ "}").intern(),
     .actions = i"drop;",
     .stage_hint = stage_hint(lrp_uuid),
     .io_port          = None,
     .controller_meter = None) :-
    &RouterPort(.lrp = &nb::Logical_Router_Port{._uuid = lrp_uuid},
                .router = &Router{.snat_ips = snat_ips,
                                  .force_lb_snat = false,
                                  ._uuid = lr_uuid},
                .networks = networks),
    var addr = FlatMap(networks.ipv4_addrs),
    not snat_ips.contains_key(IPv4{addr.addr}),
    var match_ips = "${addr.addr}".group_by((lr_uuid, lrp_uuid)).to_vec().
Flow(.logical_datapath = lr_uuid,
     .stage = s_ROUTER_IN_IP_INPUT(),
     .priority = 60,
     .__match = ("ip6.dst == {" ++ match_ips.join(", ") ++ "}").intern(),
     .actions = i"drop;",
     .stage_hint = stage_hint(lrp_uuid),
     .io_port          = None,
     .controller_meter = None) :-
    &RouterPort(.lrp = &nb::Logical_Router_Port{._uuid = lrp_uuid},
                .router = &Router{.snat_ips = snat_ips,
                                  .force_lb_snat = false,
                                  ._uuid = lr_uuid},
                .networks = networks),
    var addr = FlatMap(networks.ipv6_addrs),
    not snat_ips.contains_key(IPv6{addr.addr}),
    var match_ips = "${addr.addr}".group_by((lr_uuid, lrp_uuid)).to_vec().

for (RouterPortNetworksIPv4Addr(
        .port = &RouterPort{
            .router = &Router{._uuid = lr_uuid,
                              .l3dgw_ports = vec_empty(),
                              .is_gateway = false,
                              .copp = copp},
            .lrp = lrp},
         .addr = addr))
{
    /* UDP/TCP/SCTP port unreachable. */
    var __match = i"ip4 && ip4.dst == ${addr.addr} && !ip.later_frag && udp" in
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 80,
         .__match          = __match,
         .actions          = i"icmp4 {"
                             "eth.dst <-> eth.src; "
                             "ip4.dst <-> ip4.src; "
                             "ip.ttl = 255; "
                             "icmp4.type = 3; "
                             "icmp4.code = 3; "
                             "next; };",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_ICMP4_ERR()),
         .stage_hint       = stage_hint(lrp._uuid));

    var __match = i"ip4 && ip4.dst == ${addr.addr} && !ip.later_frag && tcp" in
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 80,
         .__match          = __match,
         .actions          = i"tcp_reset {"
                             "eth.dst <-> eth.src; "
                             "ip4.dst <-> ip4.src; "
                             "next; };",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_TCP_RESET()),
         .stage_hint       = stage_hint(lrp._uuid));

    var __match = i"ip4 && ip4.dst == ${addr.addr} && !ip.later_frag && sctp" in
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 80,
         .__match          = __match,
         .actions          = i"sctp_abort {"
                             "eth.dst <-> eth.src; "
                             "ip4.dst <-> ip4.src; "
                             "next; };",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_TCP_RESET()),
         .stage_hint       = stage_hint(lrp._uuid));

    var __match = i"ip4 && ip4.dst == ${addr.addr} && !ip.later_frag" in
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 70,
         .__match          = __match,
         .actions          = i"icmp4 {"
                             "eth.dst <-> eth.src; "
                             "ip4.dst <-> ip4.src; "
                             "ip.ttl = 255; "
                             "icmp4.type = 3; "
                             "icmp4.code = 2; "
                             "next; };",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_ICMP4_ERR()),
         .stage_hint       = stage_hint(lrp._uuid))
}

/* DHCPv6 reply handling */
Flow(.logical_datapath = rp.router._uuid,
     .stage            = s_ROUTER_IN_IP_INPUT(),
     .priority         = 100,
     .__match          = i"ip6.dst == ${ipv6_addr.addr} "
                         "&& udp.src == 547 && udp.dst == 546",
     .actions          = i"reg0 = 0; handle_dhcpv6_reply;",
     .stage_hint       = stage_hint(rp.lrp._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    rp in &RouterPort(),
    var ipv6_addr = FlatMap(rp.networks.ipv6_addrs).

/* Logical router ingress table IP_INPUT: IP Input for IPv6. */
for (&RouterPort(.router = router, .networks = networks, .lrp = lrp)
     if (not networks.ipv6_addrs.is_empty()))
{
    //if (op->derived) {
    //    /* No ingress packets are accepted on a chassisredirect
    //     * port, so no need to program flows for that port. */
    //    continue;
    //}

    /* ICMPv6 echo reply.  These flows reply to echo requests
     * received for the router's IP address. */
    var __match = "ip6.dst == "                   ++
                  format_v6_networks(networks)    ++
                  " && icmp6.type == 128 && icmp6.code == 0" in
    Flow(.logical_datapath = router._uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 90,
         .__match          = __match.intern(),
         .actions          = i"ip6.dst <-> ip6.src; "
         "ip.ttl = 255; "
         "icmp6.type = 129; "
         "flags.loopback = 1; "
         "next; ",
         .stage_hint       = stage_hint(lrp._uuid),
         .io_port          = None,
         .controller_meter = None)
}

/* ND reply.  These flows reply to ND solicitations for the
 * router's own IP address. */
for (RouterPortNetworksIPv6Addr(.port = &RouterPort{.lrp = lrp,
                                                    .is_redirect = is_redirect,
                                                    .router = router,
                                                    .networks = networks,
                                                    .json_name = json_name},
                                .addr = addr))
{
    var extra_match = if (is_redirect) {
        /* Traffic with eth.src = l3dgw_port->lrp_networks.ea
         * should only be sent from the gateway chassis, so that
         * upstream MAC learning points to the gateway chassis.
         * Also need to avoid generation of multiple ND replies
         * from different chassis. */
        Some{i"is_chassis_resident(${json_escape(chassis_redirect_name(lrp.name))})"}
    } else None in
    LogicalRouterNdFlow(.lr = router,
                        .lrp = Some{lrp},
                        .action = i"nd_na_router",
                        .ip = addr.addr,
                        .sn_ip = true,
                        .mac = rEG_INPORT_ETH_ADDR(),
                        .extra_match = extra_match,
                        .drop = false,
                        .priority = 90,
                        .stage_hint = stage_hint(lrp._uuid))
}

/* UDP/TCP/SCTP port unreachable */
for (RouterPortNetworksIPv6Addr(
        .port = &RouterPort{.router = &Router{._uuid = lr_uuid,
                                              .l3dgw_ports = vec_empty(),
                                              .is_gateway = false,
                                              .copp = copp},
                            .lrp = lrp,
                            .json_name = json_name},
        .addr = addr))
{
    var __match = i"ip6 && ip6.dst == ${addr.addr} && !ip.later_frag && tcp" in
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 80,
         .__match          = __match,
         .actions          = i"tcp_reset {"
                             "eth.dst <-> eth.src; "
                             "ip6.dst <-> ip6.src; "
                             "next; };",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_TCP_RESET()),
         .stage_hint       = stage_hint(lrp._uuid));

    var __match = i"ip6 && ip6.dst == ${addr.addr} && !ip.later_frag && sctp" in
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 80,
         .__match          = __match,
         .actions          = i"sctp_abort {"
                             "eth.dst <-> eth.src; "
                             "ip6.dst <-> ip6.src; "
                             "next; };",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_TCP_RESET()),
         .stage_hint       = stage_hint(lrp._uuid));

    var __match = i"ip6 && ip6.dst == ${addr.addr} && !ip.later_frag && udp" in
    Flow(.logical_datapath = lr_uuid,
        .stage            = s_ROUTER_IN_IP_INPUT(),
        .priority         = 80,
        .__match          = __match,
        .actions          = i"icmp6 {"
                            "eth.dst <-> eth.src; "
                            "ip6.dst <-> ip6.src; "
                            "ip.ttl = 255; "
                            "icmp6.type = 1; "
                            "icmp6.code = 4; "
                            "next; };",
        .io_port          = None,
        .controller_meter = copp.get(cOPP_ICMP6_ERR()),
        .stage_hint       = stage_hint(lrp._uuid));

    var __match = i"ip6 && ip6.dst == ${addr.addr} && !ip.later_frag" in
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 70,
         .__match          = __match,
         .actions          = i"icmp6 {"
                             "eth.dst <-> eth.src; "
                             "ip6.dst <-> ip6.src; "
                             "ip.ttl = 255; "
                             "icmp6.type = 1; "
                             "icmp6.code = 3; "
                             "next; };",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_ICMP6_ERR()),
         .stage_hint       = stage_hint(lrp._uuid))
}

/* ICMPv6 time exceeded */
for (RouterPortNetworksIPv6Addr(.port = &RouterPort{.router = router,
                                                    .lrp = lrp,
                                                    .json_name = json_name},
                                .addr = addr)
     /* skip link-local address */
     if (not addr.is_lla()))
{
    var __match = i"inport == ${json_name} && ip6 && "
                  "ip6.src == ${addr.match_network()} && "
                  "ip.ttl == {0, 1} && !ip.later_frag" in
    var actions = i"icmp6 {"
                  "eth.dst <-> eth.src; "
                  "ip6.dst = ip6.src; "
                  "ip6.src = ${addr.addr}; "
                  "ip.ttl = 255; "
                  "icmp6.type = 3; /* Time exceeded */ "
                  "icmp6.code = 0; /* TTL exceeded in transit */ "
                  "next; };" in
    Flow(.logical_datapath = router._uuid,
         .stage            = s_ROUTER_IN_IP_INPUT(),
         .priority         = 40,
         .__match          = __match,
         .actions          = actions,
         .io_port          = None,
         .controller_meter = router.copp.get(cOPP_ICMP6_ERR()),
         .stage_hint       = stage_hint(lrp._uuid))
}

/* NAT, Defrag and load balancing. */

function default_allow_flow(datapath: uuid, stage: Intern<Stage>): Flow {
    Flow{.logical_datapath = datapath,
         .stage            = stage,
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .io_port          = None,
         .controller_meter = None,
         .stage_hint       = 0}
}
for (r in &Router(._uuid = lr_uuid)) {
    /* Packets are allowed by default. */
    Flow[default_allow_flow(lr_uuid, s_ROUTER_IN_DEFRAG())];
    Flow[default_allow_flow(lr_uuid, s_ROUTER_IN_UNSNAT())];
    Flow[default_allow_flow(lr_uuid, s_ROUTER_OUT_SNAT())];
    Flow[default_allow_flow(lr_uuid, s_ROUTER_IN_DNAT())];
    Flow[default_allow_flow(lr_uuid, s_ROUTER_OUT_UNDNAT())];
    Flow[default_allow_flow(lr_uuid, s_ROUTER_OUT_POST_UNDNAT())];
    Flow[default_allow_flow(lr_uuid, s_ROUTER_OUT_EGR_LOOP())];
    Flow[default_allow_flow(lr_uuid, s_ROUTER_IN_ECMP_STATEFUL())];

    /* Send the IPv6 NS packets to next table. When ovn-controller
     * generates IPv6 NS (for the action - nd_ns{}), the injected
     * packet would go through conntrack - which is not required. */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_OUT_SNAT(),
         .priority         = 120,
         .__match          = i"nd_ns",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

for (r in &Router(._uuid = lr_uuid,
                  .l3dgw_ports = l3dgw_ports,
                  .is_gateway = is_gateway,
                  .nat = nat)) {
    for (LogicalRouterLBs(lr_uuid, lbs)) {
        if ((l3dgw_ports.len() > 0 or is_gateway) and (not is_empty(nat) or not is_empty(lbs))) {
            /* If the router has load balancer or DNAT rules, re-circulate every packet
             * through the DNAT zone so that packets that need to be unDNATed in the
             * reverse direction get unDNATed.
             *
             * We also commit newly initiated connections in the reply direction to the
             * DNAT zone. This ensures that these flows are tracked. If the flow was
             * not committed, it would produce ongoing datapath flows with the ct.new
             * flag set. Some NICs are unable to offload these flows.
             */
            Flow(.logical_datapath = lr_uuid,
                .stage            = s_ROUTER_OUT_POST_UNDNAT(),
                .priority         = 50,
                .__match          = i"ip && ct.new",
                .actions          = i"ct_commit { } ; next; ",
                .stage_hint       = 0,
                .io_port          = None,
                .controller_meter = None);

            Flow(.logical_datapath = lr_uuid,
                .stage            = s_ROUTER_OUT_UNDNAT(),
                .priority         = 50,
                .__match          = i"ip",
                .actions          = i"flags.loopback = 1; ct_dnat;",
                .stage_hint       = 0,
                .io_port          = None,
                .controller_meter = None)
        }
    }
}

Flow(.logical_datapath = lr,
     .stage            = s_ROUTER_OUT_SNAT(),
     .priority         = 120,
     .__match          = i"flags.skip_snat_for_lb == 1 && ip",
     .actions          = i"next;",
     .stage_hint       = stage_hint(lb.lb._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    LogicalRouterLB(lr, lb),
    lb.lb.options.get_bool_def(i"skip_snat", false)
    .

function lrouter_nat_is_stateless(nat: NAT): bool = {
    Some{i"true"} == nat.nat.options.get(i"stateless")
}

/* Handles the match criteria and actions in logical flow
 * based on external ip based NAT rule filter.
 *
 * For ALLOWED_EXT_IPs, we will add an additional match criteria
 * of comparing ip*.src/dst with the allowed external ip address set.
 *
 * For EXEMPTED_EXT_IPs, we will have an additional logical flow
 * where we compare ip*.src/dst with the exempted external ip address set
 * and action says "next" instead of ct*.
 */
function lrouter_nat_add_ext_ip_match(
    router: Intern<Router>,
    nat: NAT,
    __match: string,
    ipX: string,
    is_src: bool,
    mask: v46_ip): (string, Option<Flow>)
{
    var dir = if (is_src) "src" else "dst";
    match (nat.exceptional_ext_ips) {
        None -> ("", None),
        Some{AllowedExtIps{__as}} -> (" && ${ipX}.${dir} == $${__as.name}", None),
        Some{ExemptedExtIps{__as}} -> {
            /* Priority of logical flows corresponding to exempted_ext_ips is
             * +1 of the corresponding regular NAT rule.
             * For example, if we have following NAT rule and we associate
             * exempted external ips to it:
             * "ovn-nbctl lr-nat-add router dnat_and_snat 10.15.24.139 50.0.0.11"
             *
             * And now we associate exempted external ip address set to it.
             * Now corresponding to above rule we will have following logical
             * flows:
             * lr_out_snat...priority=162, match=(..ip4.dst == $exempt_range),
             *                             action=(next;)
             * lr_out_snat...priority=161, match=(..), action=(ct_snat(....);)
             *
             */
            var priority = match (is_src) {
                true -> {
                    /* S_ROUTER_IN_DNAT uses priority 100 */
                    100 + 1
                },
                false -> {
                    /* S_ROUTER_OUT_SNAT uses priority (mask + 1 + 128 + 1) */
                    var is_gw_router = router.l3dgw_ports.is_empty();
                    var mask_1bits = mask.cidr_bits().unwrap_or(8'd0) as integer;
                    mask_1bits + 2 + { if (not is_gw_router) 128 else 0 }
                }
            };

            ("",
             Some{Flow{.logical_datapath = router._uuid,
                       .stage = if (is_src) { s_ROUTER_IN_DNAT() } else { s_ROUTER_OUT_SNAT() },
                       .priority = priority,
                       .__match = i"${__match} && ${ipX}.${dir} == $${__as.name}",
                       .actions = i"next;",
                       .stage_hint = stage_hint(nat.nat._uuid),
                       .io_port = None,
                       .controller_meter = None}})
        }
    }
}

relation LogicalRouterForceSnatFlows(
    logical_router: uuid,
    ips: Set<v46_ip>,
    context: string)
Flow(.logical_datapath = logical_router,
     .stage = s_ROUTER_IN_UNSNAT(),
     .priority = 110,
     .__match = i"${ipX} && ${ipX}.dst == ${ip}",
     .actions = i"ct_snat;",
     .stage_hint = 0,
     .io_port          = None,
     .controller_meter = None),
/* Higher priority rules to force SNAT with the IP addresses
 * configured in the Gateway router.  This only takes effect
 * when the packet has already been DNATed or load balanced once. */
Flow(.logical_datapath = logical_router,
     .stage = s_ROUTER_OUT_SNAT(),
     .priority = 100,
     .__match = i"flags.force_snat_for_${context} == 1 && ${ipX}",
     .actions = i"ct_snat(${ip});",
     .stage_hint = 0,
     .io_port = None,
     .controller_meter = None) :-
    LogicalRouterForceSnatFlows(.logical_router = logical_router,
                                .ips = ips,
                                .context = context),
    var ip = FlatMap(ips),
    var ipX = ip.ipX().

/* Higher priority rules to force SNAT with the router port ip.
 * This only takes effect when the packet has already been
 * load balanced once. */
for (rp in &RouterPort(.router = &Router{._uuid = lr_uuid, .options = lr_options}, .lrp = lrp)) {
    if (lb_force_snat_router_ip(lr_options) and rp.peer != PeerNone) {
        Some{var ipv4} = rp.networks.ipv4_addrs.nth(0) in {
            Flow(.logical_datapath = lr_uuid,
                 .stage = s_ROUTER_IN_UNSNAT(),
                 .priority = 110,
                 .__match = i"inport == ${rp.json_name} && ip4.dst == ${ipv4.addr}",
                 .actions = i"ct_snat;",
                 .stage_hint = 0,
                 .io_port = None,
                 .controller_meter = None);

            Flow(.logical_datapath = lr_uuid,
                 .stage = s_ROUTER_OUT_SNAT(),
                 .priority = 110,
                 .__match = i"flags.force_snat_for_lb == 1 && ip4 && outport == ${rp.json_name}",
                 .actions = i"ct_snat(${ipv4.addr});",
                 .stage_hint = 0,
                 .io_port = None,
                 .controller_meter = None);

            if (rp.networks.ipv4_addrs.len() > 1) {
                Warning["Logical router port ${rp.json_name} is configured with multiple IPv4 "
                        "addresses.  Only the first IP [${ipv4.addr}] is considered as SNAT for "
                        "load balancer"]
            }
        };

        /* op->lrp_networks.ipv6_addrs will always have LLA and that will be
         * last in the list. So add the flows only if n_ipv6_addrs > 1. */
        if (rp.networks.ipv6_addrs.len() > 1) {
            Some{var ipv6} = rp.networks.ipv6_addrs.nth(0) in {
                Flow(.logical_datapath = lr_uuid,
                     .stage = s_ROUTER_IN_UNSNAT(),
                     .priority = 110,
                     .__match = i"inport == ${rp.json_name} && ip6.dst == ${ipv6.addr}",
                     .actions = i"ct_snat;",
                     .stage_hint = 0,
                     .io_port = None,
                     .controller_meter = None);

                Flow(.logical_datapath = lr_uuid,
                     .stage = s_ROUTER_OUT_SNAT(),
                     .priority = 110,
                     .__match = i"flags.force_snat_for_lb == 1 && ip6 && outport == ${rp.json_name}",
                     .actions = i"ct_snat(${ipv6.addr});",
                     .stage_hint = 0,
                     .io_port = None,
                     .controller_meter = None);

                if (rp.networks.ipv6_addrs.len() > 2) {
                    Warning["Logical router port ${rp.json_name} is configured with multiple IPv6 "
                            "addresses.  Only the first IP [${ipv6.addr}] is considered as SNAT for "
                            "load balancer"]
                }
            }
        }
    }
}

relation VirtualLogicalPort(logical_port: Option<istring>)
VirtualLogicalPort(Some{logical_port}) :-
    lsp in &nb::Logical_Switch_Port(.name = logical_port, .__type = i"virtual").

/* NAT rules are only valid on Gateway routers and routers with
 * l3dgw_port (router has a port with "redirect-chassis"
 * specified). */
for (r in &Router(._uuid = lr_uuid,
                  .l3dgw_ports = l3dgw_ports,
                  .is_gateway = is_gateway)
     if not l3dgw_ports.is_empty() or is_gateway)
{
    for (LogicalRouterNAT(.lr = lr_uuid, .nat = nat)) {
        var ipX = nat.external_ip.ipX() in
        var xx = nat.external_ip.xxreg() in
        /* Check the validity of nat->logical_ip. 'logical_ip' can
         * be a subnet when the type is "snat". */
        Some{(_, var mask)} = ip46_parse_masked(nat.nat.logical_ip.ival()) in
        true == match ((mask.is_all_ones(), nat.nat.__type.ival())) {
            (_, "snat") -> true,
            (false, _) -> {
                warn("bad ip ${nat.nat.logical_ip} for dnat in router ${uuid2str(lr_uuid)}");
                false
            },
            _ -> true
        } in
        /* For distributed router NAT, determine whether this NAT rule
         * satisfies the conditions for distributed NAT processing. */
        var mac = match ((not l3dgw_ports.is_empty() and nat.nat.__type == i"dnat_and_snat",
                          nat.nat.logical_port, nat.external_mac)) {
            (true, Some{_}, Some{mac}) -> Some{mac},
            _ -> None
        } in
        var stateless = (lrouter_nat_is_stateless(nat)
                         and nat.nat.__type == i"dnat_and_snat") in
        {
            /* Ingress UNSNAT table: It is for already established connections'
             * reverse traffic. i.e., SNAT has already been done in egress
             * pipeline and now the packet has entered the ingress pipeline as
             * part of a reply. We undo the SNAT here.
             *
             * Undoing SNAT has to happen before DNAT processing.  This is
             * because when the packet was DNATed in ingress pipeline, it did
             * not know about the possibility of eventual additional SNAT in
             * egress pipeline. */
            if (nat.nat.__type == i"snat" or nat.nat.__type == i"dnat_and_snat") {
                if (l3dgw_ports.is_empty()) {
                    /* Gateway router. */
                    var actions = if (stateless) {
                        i"${ipX}.dst=${nat.nat.logical_ip}; next;"
                    } else {
                        i"ct_snat;"
                    } in
                    Flow(.logical_datapath = lr_uuid,
                         .stage            = s_ROUTER_IN_UNSNAT(),
                         .priority         = 90,
                         .__match          = i"ip && ${ipX}.dst == ${nat.nat.external_ip}",
                         .actions          = actions,
                         .stage_hint       = stage_hint(nat.nat._uuid),
                         .io_port          = None,
                         .controller_meter = None)
                };
                Some {var gwport} = l3dgw_ports.nth(0) in {
                    /* Distributed router. */

                    /* Traffic received on l3dgw_port is subject to NAT. */
                    var __match =
                        "ip && ${ipX}.dst == ${nat.nat.external_ip}"
                        " && inport == ${json_escape(gwport.name)}" ++
                        if (mac == None) {
                            /* Flows for NAT rules that are centralized are only
                             * programmed on the "redirect-chassis". */
                            " && is_chassis_resident(${json_escape(chassis_redirect_name(gwport.name))})"
                        } else { "" } in
                    var actions = if (stateless) {
                        i"${ipX}.dst=${nat.nat.logical_ip}; next;"
                    } else {
                        i"ct_snat;"
                    } in
                    Flow(.logical_datapath = lr_uuid,
                         .stage            = s_ROUTER_IN_UNSNAT(),
                         .priority         = 100,
                         .__match          = __match.intern(),
                         .actions          = actions,
                         .stage_hint       = stage_hint(nat.nat._uuid),
                         .io_port          = None,
                         .controller_meter = None)
                }
            };

            /* Ingress DNAT table: Packets enter the pipeline with destination
             * IP address that needs to be DNATted from a external IP address
             * to a logical IP address. */
            var ip_and_ports = "${nat.nat.logical_ip}" ++
                               if (nat.nat.external_port_range != i"") {
                                   " ${nat.nat.external_port_range}"
                               } else {
                                   ""
                               } in
            if (nat.nat.__type == i"dnat" or nat.nat.__type == i"dnat_and_snat") {
                l3dgw_ports.is_empty() in
                var __match = "ip && ${ipX}.dst == ${nat.nat.external_ip}" in
                (var ext_ip_match, var ext_flow) = lrouter_nat_add_ext_ip_match(
                    r, nat, __match, ipX, true, mask) in
                {
                    /* Gateway router. */
                    /* Packet when it goes from the initiator to destination.
                     * We need to set flags.loopback because the router can
                     * send the packet back through the same interface. */
                    Some{var f} = ext_flow in Flow[f];

                    var flag_action =
                        if (has_force_snat_ip(r.options, i"dnat")) {
                            /* Indicate to the future tables that a DNAT has taken
                             * place and a force SNAT needs to be done in the
                             * Egress SNAT table. */
                            "flags.force_snat_for_dnat = 1; "
                        } else { "" } in
                    var nat_actions = if (stateless) {
                        "${ipX}.dst=${nat.nat.logical_ip}; next;"
                    } else {
                        "flags.loopback = 1; "
                        "ct_dnat(${ip_and_ports});"
                    } in
                    Flow(.logical_datapath = lr_uuid,
                         .stage            = s_ROUTER_IN_DNAT(),
                         .priority         = 100,
                         .__match          = (__match ++ ext_ip_match).intern(),
                         .actions          = (flag_action ++ nat_actions).intern(),
                         .stage_hint       = stage_hint(nat.nat._uuid),
                         .io_port          = None,
                         .controller_meter = None)
                };

                Some {var gwport} = l3dgw_ports.nth(0) in
                var __match =
                    "ip && ${ipX}.dst == ${nat.nat.external_ip}"
                    " && inport == ${json_escape(gwport.name)}" ++
                    if (mac == None) {
                        /* Flows for NAT rules that are centralized are only
                         * programmed on the "redirect-chassis". */
                        " && is_chassis_resident(${json_escape(chassis_redirect_name(gwport.name))})"
                    } else { "" } in
                (var ext_ip_match, var ext_flow) = lrouter_nat_add_ext_ip_match(
                    r, nat, __match, ipX, true, mask) in
                {
                    /* Distributed router. */
                    /* Traffic received on l3dgw_port is subject to NAT. */
                    Some{var f} = ext_flow in Flow[f];

                    var actions = if (stateless) {
                        i"${ipX}.dst=${nat.nat.logical_ip}; next;"
                    } else {
                        i"ct_dnat(${ip_and_ports});"
                    } in
                    Flow(.logical_datapath = lr_uuid,
                         .stage            = s_ROUTER_IN_DNAT(),
                         .priority         = 100,
                         .__match          = (__match ++ ext_ip_match).intern(),
                         .actions          = actions,
                         .stage_hint       = stage_hint(nat.nat._uuid),
                         .io_port          = None,
                         .controller_meter = None)
                }
            };

            /* ARP resolve for NAT IPs. */
            Some {var gwport} = l3dgw_ports.nth(0) in {
            var gwport_name = json_escape(gwport.name) in {
                if (nat.nat.__type == i"snat") {
                    var __match = i"inport == ${gwport_name} && "
                                  "${ipX}.src == ${nat.nat.external_ip}" in
                    Flow(.logical_datapath = lr_uuid,
                         .stage            = s_ROUTER_IN_IP_INPUT(),
                         .priority         = 120,
                         .__match          = __match,
                         .actions          = i"next;",
                         .stage_hint       = stage_hint(nat.nat._uuid),
                         .io_port          = None,
                         .controller_meter = None)
                };

                var nexthop_reg = "${xx}${rEG_NEXT_HOP()}" in
                var __match = i"outport == ${gwport_name} && "
                              "${nexthop_reg} == ${nat.nat.external_ip}" in
                var dst_mac = match (mac) {
                    Some{value} -> i"${value}",
                    None -> gwport.mac
                } in
                Flow(.logical_datapath = lr_uuid,
                     .stage            = s_ROUTER_IN_ARP_RESOLVE(),
                     .priority         = 100,
                     .__match          = __match,
                     .actions          = i"eth.dst = ${dst_mac}; next;",
                     .stage_hint       = stage_hint(nat.nat._uuid),
                     .io_port          = None,
                     .controller_meter = None)
                }
            };

            /* Egress UNDNAT table: It is for already established connections'
             * reverse traffic. i.e., DNAT has already been done in ingress
             * pipeline and now the packet has entered the egress pipeline as
             * part of a reply. We undo the DNAT here.
             *
             * Note that this only applies for NAT on a distributed router.
             */
            if ((nat.nat.__type == i"dnat" or nat.nat.__type == i"dnat_and_snat")) {
                Some {var gwport} = l3dgw_ports.nth(0) in
                var __match =
                    "ip && ${ipX}.src == ${nat.nat.logical_ip}"
                    " && outport == ${json_escape(gwport.name)}" ++
                    if (mac == None) {
                        /* Flows for NAT rules that are centralized are only
                         * programmed on the "redirect-chassis". */
                        " && is_chassis_resident(${json_escape(chassis_redirect_name(gwport.name))})"
                    } else { "" } in
                var actions =
                    match (mac) {
                        Some{mac_addr} -> "eth.src = ${mac_addr}; ",
                        None -> ""
                    } ++
                    if (stateless) {
                        "${ipX}.src=${nat.nat.external_ip}; next;"
                    } else {
                        "ct_dnat;"
                    } in
                Flow(.logical_datapath = lr_uuid,
                     .stage            = s_ROUTER_OUT_UNDNAT(),
                     .priority         = 100,
                     .__match          = __match.intern(),
                     .actions          = actions.intern(),
                     .stage_hint       = stage_hint(nat.nat._uuid),
                     .io_port          = None,
                     .controller_meter = None)
            };

            /* Egress SNAT table: Packets enter the egress pipeline with
             * source ip address that needs to be SNATted to a external ip
             * address. */
            var ip_and_ports = "${nat.nat.external_ip}" ++
                               if (nat.nat.external_port_range != i"") {
                                   " ${nat.nat.external_port_range}"
                               } else {
                                   ""
                               } in
            if (nat.nat.__type == i"snat" or nat.nat.__type == i"dnat_and_snat") {
                l3dgw_ports.is_empty() in
                var __match = "ip && ${ipX}.src == ${nat.nat.logical_ip}" in
                (var ext_ip_match, var ext_flow) = lrouter_nat_add_ext_ip_match(
                    r, nat, __match, ipX, false, mask) in
                {
                    /* Gateway router. */
                    Some{var f} = ext_flow in Flow[f];

                    /* The priority here is calculated such that the
                     * nat->logical_ip with the longest mask gets a higher
                     * priority. */
                    var actions = if (stateless) {
                        i"${ipX}.src=${nat.nat.external_ip}; next;"
                    } else {
                        i"ct_snat(${ip_and_ports});"
                    } in
                    Some{var plen} = mask.cidr_bits() in
                    Flow(.logical_datapath = lr_uuid,
                         .stage            = s_ROUTER_OUT_SNAT(),
                         .priority         = plen as bit<64> + 1,
                         .__match          = (__match ++ ext_ip_match).intern(),
                         .actions          = actions,
                         .stage_hint       = stage_hint(nat.nat._uuid),
                         .io_port          = None,
                         .controller_meter = None)
                };

                Some {var gwport} = l3dgw_ports.nth(0) in
                var __match =
                    "ip && ${ipX}.src == ${nat.nat.logical_ip}"
                    " && outport == ${json_escape(gwport.name)}" ++
                    if (mac == None) {
                        /* Flows for NAT rules that are centralized are only
                         * programmed on the "redirect-chassis". */
                        " && is_chassis_resident(${json_escape(chassis_redirect_name(gwport.name))})"
                    } else { "" } in
                (var ext_ip_match, var ext_flow) = lrouter_nat_add_ext_ip_match(
                    r, nat, __match, ipX, false, mask) in
                {
                    /* Distributed router. */
                    Some{var f} = ext_flow in Flow[f];

                    var actions =
                        match (mac) {
                            Some{mac_addr} -> "eth.src = ${mac_addr}; ",
                            _ -> ""
                        } ++ if (stateless) {
                            "${ipX}.src=${nat.nat.external_ip}; next;"
                        } else {
                            "ct_snat(${ip_and_ports});"
                        } in
                    /* The priority here is calculated such that the
                     * nat->logical_ip with the longest mask gets a higher
                     * priority. */
                    Some{var plen} = mask.cidr_bits() in
                    var priority = (plen as bit<64>) + 1 in
                    var centralized_boost = if (mac == None) 128 else 0 in
                    Flow(.logical_datapath = lr_uuid,
                         .stage            = s_ROUTER_OUT_SNAT(),
                         .priority         = priority + centralized_boost,
                         .__match          = (__match ++ ext_ip_match).intern(),
                         .actions          = actions.intern(),
                         .stage_hint       = stage_hint(nat.nat._uuid),
                         .io_port          = None,
                         .controller_meter = None)
                }
            };

            /* Logical router ingress table ADMISSION:
             * For NAT on a distributed router, add rules allowing
             * ingress traffic with eth.dst matching nat->external_mac
             * on the l3dgw_port instance where nat->logical_port is
             * resident. */
            Some{var mac_addr} = mac in
            Some{var gwport} = l3dgw_ports.nth(0) in
            Some{var logical_port} = nat.nat.logical_port in
            var __match =
                i"eth.dst == ${mac_addr} && inport == ${json_escape(gwport.name)}"
                " && is_chassis_resident(${json_escape(logical_port)})" in
            /* Store the ethernet address of the port receiving the packet.
             * This will save us from having to match on inport further
             * down in the pipeline.
             */
            var actions = i"${rEG_INPORT_ETH_ADDR()} = ${gwport.mac}; next;" in
            Flow(.logical_datapath = lr_uuid,
                 .stage            = s_ROUTER_IN_ADMISSION(),
                 .priority         = 50,
                 .__match          = __match,
                 .actions          = actions,
                 .stage_hint       = stage_hint(nat.nat._uuid),
                 .io_port          = None,
                 .controller_meter = None);

            /* Ingress Gateway Redirect Table: For NAT on a distributed
             * router, add flows that are specific to a NAT rule.  These
             * flows indicate the presence of an applicable NAT rule that
             * can be applied in a distributed manner.
             * In particulr the IP src register and eth.src are set to NAT external IP and
             * NAT external mac so the ARP request generated in the following
             * stage is sent out with proper IP/MAC src addresses
             */
            Some{var mac_addr} = mac in
            Some{var gwport} = l3dgw_ports.nth(0) in
            Some{var logical_port} = nat.nat.logical_port in
            Some{var external_mac} = nat.nat.external_mac in
            var __match =
                i"${ipX}.src == ${nat.nat.logical_ip} && "
                "outport == ${json_escape(gwport.name)} && "
                "is_chassis_resident(${json_escape(logical_port)})" in
            var actions =
                i"eth.src = ${external_mac}; "
                "${xx}${rEG_SRC()} = ${nat.nat.external_ip}; "
                "next;" in
            Flow(.logical_datapath = lr_uuid,
                 .stage            = s_ROUTER_IN_GW_REDIRECT(),
                 .priority         = 100,
                 .__match          = __match,
                 .actions          = actions,
                 .stage_hint       = stage_hint(nat.nat._uuid),
                 .io_port          = None,
                 .controller_meter = None);

            for (VirtualLogicalPort(nat.nat.logical_port)) {
                Some{var gwport} = l3dgw_ports.nth(0) in
                Flow(.logical_datapath = lr_uuid,
                     .stage            = s_ROUTER_IN_GW_REDIRECT(),
                    .priority         = 80,
                    .__match          = i"${ipX}.src == ${nat.nat.logical_ip} && "
                                        "outport == ${json_escape(gwport.name)}",
                    .actions          = i"drop;",
                    .stage_hint       = stage_hint(nat.nat._uuid),
                    .io_port          = None,
                    .controller_meter = None)
            };

            /* Egress Loopback table: For NAT on a distributed router.
             * If packets in the egress pipeline on the distributed
             * gateway port have ip.dst matching a NAT external IP, then
             * loop a clone of the packet back to the beginning of the
             * ingress pipeline with inport = outport. */
            Some{var gwport} = l3dgw_ports.nth(0) in
            /* Distributed router. */
            Some{var port} = match (mac) {
                Some{_} -> match (nat.nat.logical_port) {
                               Some{name} -> Some{json_escape(name)},
                               None -> None: Option<string>
                           },
                None -> Some{json_escape(chassis_redirect_name(gwport.name))}
            } in
            var __match = i"${ipX}.dst == ${nat.nat.external_ip} && outport == ${json_escape(gwport.name)} && is_chassis_resident(${port})" in
            var regs = {
                var regs = vec_empty();
                for (j in range_vec(0, mFF_N_LOG_REGS(), 01)) {
                    regs.push("reg${j} = 0; ")
                };
                regs
            } in
            var actions =
                "clone { ct_clear; "
                "inport = outport; outport = \"\"; "
                "eth.dst <-> eth.src; "
                "flags = 0; flags.loopback = 1; " ++
                regs.join("") ++
                "${rEGBIT_EGRESS_LOOPBACK()} = 1; "
                "next(pipeline=ingress, table=0); };" in
            Flow(.logical_datapath = lr_uuid,
                 .stage            = s_ROUTER_OUT_EGR_LOOP(),
                 .priority         = 100,
                 .__match          = __match,
                 .actions          = actions.intern(),
                 .stage_hint       = stage_hint(nat.nat._uuid),
                 .io_port          = None,
                 .controller_meter = None)
        }
    };

    /* Handle force SNAT options set in the gateway router. */
    if (l3dgw_ports.is_empty()) {
        var dnat_force_snat_ips = get_force_snat_ip(r.options, i"dnat") in
        if (not dnat_force_snat_ips.is_empty())
        LogicalRouterForceSnatFlows(.logical_router = lr_uuid,
                                    .ips = dnat_force_snat_ips,
                                    .context = "dnat");

        var lb_force_snat_ips = get_force_snat_ip(r.options, i"lb") in
        if (not lb_force_snat_ips.is_empty())
        LogicalRouterForceSnatFlows(.logical_router = lr_uuid,
                                    .ips = lb_force_snat_ips,
                                    .context = "lb")
    }
}

function nats_contain_vip(nats: Vec<NAT>, vip: v46_ip): bool {
    for (nat in nats) {
        if (nat.external_ip == vip) {
            return true
        }
    };
    return false
}

/* If there are any load balancing rules, we should send
 * the packet to conntrack for defragmentation and
 * tracking.  This helps with two things.
 *
 * 1. With tracking, we can send only new connections to
 *    pick a DNAT ip address from a group.
 * 2. If there are L4 ports in load balancing rules, we
 *    need the defragmentation to match on L4 ports.
 *
 * One of these flows must be created for each unique LB VIP address.
 * We create one for each VIP:port pair; flows with the same IP and
 * different port numbers will produce identical flows that will
 * get merged by DDlog. */
Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_DEFRAG(),
     .priority         = prio,
     .__match          = __match,
     .actions          = __actions,
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    &LBVIP(.vip_addr = ip, .vip_port = port, .lb = lb),
    var prio = if (port != 0) { 110 } else { 100 },
    var proto = match (lb.protocol) {
        Some{proto} -> proto,
        _ -> i"tcp"
    },
    var proto_match = if (port != 0) { " && ${proto}" } else { "" },
    var __match = ("ip && ${ip.ipX()}.dst == ${ip}" ++ proto_match).intern(),
    var actions1 = "${ip.xxreg()}${rEG_NEXT_HOP()} = ${ip}; ",
    var actions2 =
        if (port != 0) {
            "${rEG_ORIG_TP_DPORT_ROUTER()} = ${proto}.dst; ct_dnat;"
        } else {
            "ct_dnat;"
        },
    var __actions = (actions1 ++ actions2).intern(),
    GWRouterLB(r, lb._uuid).

/* Higher priority rules are added for load-balancing in DNAT
 * table.  For every match (on a VIP[:port]), we add two flows
 * via add_router_lb_flow().  One flow is for specific matching
 * on ct.new with an action of "ct_lb($targets);".  The other
 * flow is for ct.est with an action of "ct_dnat;". */
Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_DNAT(),
     .priority         = prio,
     .__match          = __match,
     .actions          = actions,
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    lbvip in &LBVIP(.vip_addr = ip, .vip_port = port, .lb = lb),
    var proto = match (lb.protocol) {
        Some{proto} -> proto,
        _ -> i"tcp"
    },
    var match1 = "${ip.ipX()} && ${ip.xxreg()}${rEG_NEXT_HOP()} == ${ip}",
    var match2 = if (port != 0) {
        " && ${proto} && ${rEG_ORIG_TP_DPORT_ROUTER()} == ${port}"
    } else {
        ""
    },
    var prio = if (port != 0) { 120 } else { 110 },
    var match0 = ("ct.est && " ++ match1 ++ match2 ++ " && ct_label.natted == 1").intern(),
    GWRouterLB(r, lb._uuid),
    var __match = match ((r.l3dgw_ports.nth(0), lbvip.backend_ips != i"" or lb.options.get_bool_def(i"reject", false))) {
            (Some {var gw_port}, true) -> i"${match0} && is_chassis_resident(${json_escape(chassis_redirect_name(gw_port.name))})",
            _ -> match0
        },
    var actions = match (snat_for_lb(r.options, lb)) {
        SkipSNAT -> i"flags.skip_snat_for_lb = 1; next;",
        ForceSNAT -> i"flags.force_snat_for_lb = 1; next;",
        _ -> i"next;"
    }.

/* The load balancer vip is also present in the NAT entries.
 * So add a high priority lflow to advance the the packet
 * destined to the vip (and the vip port if defined)
 * in the S_ROUTER_IN_UNSNAT stage.
 * There seems to be an issue with ovs-vswitchd. When the new
 * connection packet destined for the lb vip is received,
 * it is dnat'ed in the S_ROUTER_IN_DNAT stage in the dnat
 * conntrack zone. For the next packet, if it goes through
 * unsnat stage, the conntrack flags are not set properly, and
 * it doesn't hit the established state flows in
 * S_ROUTER_IN_DNAT stage. */
Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_UNSNAT(),
     .priority         = 120,
     .__match          = __match,
     .actions          = i"next;",
     .stage_hint       = stage_hint(lb._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    &LBVIP(.vip_addr = ip, .vip_port = port, .lb = lb),
    var proto = match (lb.protocol) {
        Some{proto} -> proto,
        _ -> i"tcp"
    },
    var port_match = if (port != 0) { " && ${proto}.dst == ${port}" } else { "" },
    var __match = ("${ip.ipX()} && ${ip.ipX()}.dst == ${ip} && ${proto}" ++
                   port_match).intern(),
    GWRouterLB(r, lb._uuid),
    nats_contain_vip(r.nats, ip).

/* Add logical flows to UNDNAT the load balanced reverse traffic in
 * the router egress pipleine stage - S_ROUTER_OUT_UNDNAT if the logical
 * router has a gateway router port associated.
 */
Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_OUT_UNDNAT(),
     .priority         = 120,
     .__match          = __match,
     .actions          = action,
     .stage_hint       = stage_hint(lb._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    &LBVIP(.vip_addr = ip, .vip_port = port, .lb = lb, .backends = backends),
    var proto = match (lb.protocol) {
        Some{proto} -> proto,
        _ -> i"tcp"
    },
    var conds = backends.map(|b| {
        var port_match = if (b.port != 0) {
            " && ${proto}.src == ${b.port}"
        } else {
            ""
        };
        "(${b.ip.ipX()}.src == ${b.ip}" ++ port_match ++ ")"
    }).join(" || "),
    conds != "",
    RouterLB(r, lb._uuid),
    Some{var gwport} = r.l3dgw_ports.nth(0),
    var __match =
        i"${ip.ipX()} && (${conds}) && "
        "outport == ${json_escape(gwport.name)} && "
        "is_chassis_resident(${json_escape(chassis_redirect_name(gwport.name))})",
    var action = match (snat_for_lb(r.options, lb)) {
            SkipSNAT -> i"flags.skip_snat_for_lb = 1; ct_dnat;",
            ForceSNAT -> i"flags.force_snat_for_lb = 1; ct_dnat;",
            _ -> i"ct_dnat;"
        }.

Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_DNAT(),
     .priority         = 130,
     .__match          = __match,
     .actions          = __action,
     .io_port          = None,
     .controller_meter = r.copp.get(cOPP_EVENT_ELB()),
     .stage_hint       = stage_hint(lb._uuid)) :-
    &LBVIP(.vip_key = lb_key, .lb = lb, .backend_ips = i""),
    not lb.options.get_bool_def(i"reject", false),
    LoadBalancerEmptyEvents(lb._uuid),
    Some {(var __match, var __action)} = build_empty_lb_event_flow(lb_key, lb),
    GWRouterLB(r, lb._uuid).

/* Higher priority rules are added for load-balancing in DNAT
 * table.  For every match (on a VIP[:port]), we add two flows
 * via add_router_lb_flow().  One flow is for specific matching
 * on ct.new with an action of "ct_lb($targets);".  The other
 * flow is for ct.est with an action of "ct_dnat;". */
Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_DNAT(),
     .priority         = priority,
     .__match          = __match,
     .actions          = actions,
     .io_port          = None,
     .controller_meter = meter,
     .stage_hint       = 0) :-
    LBVIPWithStatus(lbvip@&LBVIP{.lb = lb}, up_backends),
    var priority = if (lbvip.vip_port != 0) 120 else 110,
    (var actions0, var reject) = build_lb_vip_actions(lbvip, up_backends, s_ROUTER_OUT_SNAT(), ""),
    var actions1 = actions0.intern(),
    var match0 = "ct.new && " ++
        get_match_for_lb_key(lbvip.vip_addr, lbvip.vip_port, lb.protocol, true, true, true),
    var match1 = match0.intern(),
    GWRouterLB(r, lb._uuid),
    var actions = match ((reject, snat_for_lb(r.options, lb))) {
        (false, SkipSNAT) -> i"flags.skip_snat_for_lb = 1; ${actions1}",
        (false, ForceSNAT) -> i"flags.force_snat_for_lb = 1; ${actions1}",
        _ -> actions1
    },
    var __match = match (r.l3dgw_ports.nth(0)) {
        Some{gw_port} -> i"${match1} && is_chassis_resident(${json_escape(chassis_redirect_name(gw_port.name))})",
        _ -> match1
    },
    var meter = if (reject) {
        r.copp.get(cOPP_REJECT())
    } else {
        None
    }.


/* Defaults based on MaxRtrInterval and MinRtrInterval from RFC 4861 section
 * 6.2.1
 */
function nD_RA_MAX_INTERVAL_DEFAULT(): integer = 600
function nD_RA_MAX_INTERVAL_RANGE(): (integer, integer) { (4, 1800) }

function nd_ra_min_interval_default(max: integer): integer =
{
    if (max >= 9) { max / 3 } else { max * 3 / 4 }
}

function nD_RA_MIN_INTERVAL_RANGE(max: integer): (integer, integer) = (3, ((max * 3) / 4))

function nD_MTU_DEFAULT(): integer = 0

function copy_ra_to_sb(port: RouterPort, address_mode: istring): Map<istring, istring> =
{
    var options = port.sb_options;

    options.insert(i"ipv6_ra_send_periodic", i"true");
    options.insert(i"ipv6_ra_address_mode", address_mode);

    var max_interval = port.lrp.ipv6_ra_configs
        .get_int_def(i"max_interval", nD_RA_MAX_INTERVAL_DEFAULT())
        .clamp(nD_RA_MAX_INTERVAL_RANGE());
    options.insert(i"ipv6_ra_max_interval", i"${max_interval}");

    var min_interval = port.lrp.ipv6_ra_configs
        .get_int_def(i"min_interval", nd_ra_min_interval_default(max_interval))
        .clamp(nD_RA_MIN_INTERVAL_RANGE(max_interval));
    options.insert(i"ipv6_ra_min_interval", i"${min_interval}");

    var mtu = port.lrp.ipv6_ra_configs.get_int_def(i"mtu", nD_MTU_DEFAULT());

    /* RFC 2460 requires the MTU for IPv6 to be at least 1280 */
    if (mtu != 0 and mtu >= 1280) {
        options.insert(i"ipv6_ra_mtu", i"${mtu}")
    };

    var prefixes = vec_empty();
    for (addr in port.networks.ipv6_addrs) {
        if (addr.is_lla()) {
            options.insert(i"ipv6_ra_src_addr", i"${addr.addr}")
        } else {
            prefixes.push(addr.match_network())
        }
    };
    match (port.sb_options.get(i"ipv6_ra_pd_list")) {
        Some{value} -> prefixes.push(value.ival()),
        _ -> ()
    };
    options.insert(i"ipv6_ra_prefixes", prefixes.join(" ").intern());

    match (port.lrp.ipv6_ra_configs.get(i"rdnss")) {
        Some{value} -> options.insert(i"ipv6_ra_rdnss", value),
        _ -> ()
    };

    match (port.lrp.ipv6_ra_configs.get(i"dnssl")) {
        Some{value} -> options.insert(i"ipv6_ra_dnssl", value),
        _ -> ()
    };

    options.insert(i"ipv6_ra_src_eth", i"${port.networks.ea}");

    var prf = match (port.lrp.ipv6_ra_configs.get(i"router_preference")) {
        Some{prf} -> if (prf == i"HIGH" or prf == i"LOW") prf else i"MEDIUM",
        _ -> i"MEDIUM"
    };
    options.insert(i"ipv6_ra_prf", prf);

    match (port.lrp.ipv6_ra_configs.get(i"route_info")) {
        Some{s} -> options.insert(i"ipv6_ra_route_info", s),
        _ -> ()
    };

    options
}

/* Logical router ingress table ND_RA_OPTIONS and ND_RA_RESPONSE: IPv6 Router
 * Adv (RA) options and response. */
// FIXME: do these rules apply to derived ports?
for (&RouterPort[port@RouterPort{.lrp = lrp@&nb::Logical_Router_Port{.peer = None},
                                 .router = router,
                                 .json_name = json_name,
                                 .networks = networks,
                                 .peer = PeerSwitch{}}]
     if (not networks.ipv6_addrs.is_empty()))
{
    Some{var address_mode} = lrp.ipv6_ra_configs.get(i"address_mode") in
    /* FIXME: we need a nicer wat to write this */
    true ==
        if ((address_mode != i"slaac") and
            (address_mode != i"dhcpv6_stateful") and
            (address_mode != i"dhcpv6_stateless")) {
            warn("Invalid address mode [${address_mode}] defined");
            false
        } else { true } in
    {
        if (lrp.ipv6_ra_configs.get_bool_def(i"send_periodic", false)) {
            RouterPortRAOptions(lrp._uuid, copy_ra_to_sb(port, address_mode))
        };

        (true, var prefix) =
            {
                var add_rs_response_flow = false;
                var prefix = "";
                for (addr in networks.ipv6_addrs) {
                    if (not addr.is_lla()) {
                        prefix = prefix ++ ", prefix = ${addr.match_network()}";
                        add_rs_response_flow = true
                    } else ()
                };
                (add_rs_response_flow, prefix)
            } in
        {
            var __match = i"inport == ${json_name} && ip6.dst == ff02::2 && nd_rs" in
            /* As per RFC 2460, 1280 is minimum IPv6 MTU. */
            var mtu = match(lrp.ipv6_ra_configs.get(i"mtu")) {
                    Some{mtu_s} -> {
                        match (parse_dec_u64(mtu_s)) {
                            None -> 0,
                            Some{mtu} -> if (mtu >= 1280) mtu else 0
                        }
                    },
                    None -> 0
                } in
            var actions0 =
                "${rEGBIT_ND_RA_OPTS_RESULT()} = put_nd_ra_opts("
                "addr_mode = ${json_escape(address_mode)}, "
                "slla = ${networks.ea}" ++
                if (mtu > 0) { ", mtu = ${mtu}" } else { "" } in
            var router_preference = match (lrp.ipv6_ra_configs.get(i"router_preference")) {
                    Some{prf} -> if (prf == i"MEDIUM") { "" } else { ", router_preference = \"${prf}\"" },
                    None -> ""
                } in
            var actions = actions0 ++ router_preference ++ prefix ++ "); next;" in
            Flow(.logical_datapath = router._uuid,
                 .stage            = s_ROUTER_IN_ND_RA_OPTIONS(),
                 .priority         = 50,
                 .__match          = __match,
                 .actions          = actions.intern(),
                 .io_port          = None,
                 .controller_meter = router.copp.get(cOPP_ND_RA_OPTS()),
                 .stage_hint       = stage_hint(lrp._uuid));

            var __match = i"inport == ${json_name} && ip6.dst == ff02::2 && "
                          "nd_ra && ${rEGBIT_ND_RA_OPTS_RESULT()}" in
            var ip6_str = networks.ea.to_ipv6_lla().string_mapped() in
            var actions = i"eth.dst = eth.src; eth.src = ${networks.ea}; "
                          "ip6.dst = ip6.src; ip6.src = ${ip6_str}; "
                          "outport = inport; flags.loopback = 1; "
                          "output;" in
            Flow(.logical_datapath = router._uuid,
                 .stage            = s_ROUTER_IN_ND_RA_RESPONSE(),
                 .priority         = 50,
                 .__match          = __match,
                 .actions          = actions,
                 .stage_hint       = stage_hint(lrp._uuid),
                 .io_port          = None,
                 .controller_meter = None)
        }
    }
}


/* Logical router ingress table ND_RA_OPTIONS, ND_RA_RESPONSE: RS responder, by
 * default goto next.  (priority 0)*/
for (&Router(._uuid = lr_uuid))
{
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_ND_RA_OPTIONS(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_ND_RA_RESPONSE(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Proxy table that stores per-port routes.
 * There routes get converted into logical flows by
 * the following rule.
 */
relation Route(key:         route_key,       // matching criteria
               port:        Intern<RouterPort>, // output port
               src_ip:      v46_ip,          // source IP address for output
               gateway:     Option<v46_ip>) // next hop (unless being delivered)

function build_route_match(key: route_key) : (string, bit<32>) =
{
    var ipX = key.ip_prefix.ipX();

    /* The priority here is calculated to implement longest-prefix-match
     * routing. */
    (var dir, var priority) = match (key.policy) {
        SrcIp -> ("src", key.plen * 2),
        DstIp -> ("dst", (key.plen * 2) + 1)
    };

    var network = key.ip_prefix.network(key.plen);
    var __match = "${ipX}.${dir} == ${network}/${key.plen}";

    (__match, priority)
}
for (Route(.port        = port,
           .key         = key,
           .src_ip      = src_ip,
           .gateway     = gateway))
{
    var ipX = key.ip_prefix.ipX() in
    var xx = key.ip_prefix.xxreg() in
    /* IPv6 link-local addresses must be scoped to the local router port. */
    var inport_match = match (key.ip_prefix) {
        IPv6{prefix} -> if (prefix.is_lla()) {
                            "inport == ${port.json_name} && "
                        } else "",
        _ -> ""
    } in
    (var ip_match, var priority) = build_route_match(key) in
    var __match = inport_match ++ ip_match in
    var nexthop = match (gateway) {
        Some{gw} -> "${gw}",
        None     -> "${ipX}.dst"
    } in
    var actions =
        i"${rEG_ECMP_GROUP_ID()} = 0; "
        "${xx}${rEG_NEXT_HOP()} = ${nexthop}; "
        "${xx}${rEG_SRC()} = ${src_ip}; "
        "eth.src = ${port.networks.ea}; "
        "outport = ${port.json_name}; "
        "flags.loopback = 1; "
        "next;" in
    {
        Flow(.logical_datapath = port.router._uuid,
             .stage            = s_ROUTER_IN_IP_ROUTING(),
             .priority         = priority as integer,
             .__match          = __match.intern(),
             .actions          = i"ip.ttl--; ${actions}",
             .stage_hint       = stage_hint(port.lrp._uuid),
             .io_port          = None,
             .controller_meter = None);

        if (port.has_bfd) {
            Flow(.logical_datapath = port.router._uuid,
                 .stage            = s_ROUTER_IN_IP_ROUTING(),
                 .priority         = priority as integer + 1,
                 .__match          = i"${__match} && udp.dst == 3784",
                 .actions          = actions,
                 .stage_hint       = stage_hint(port.lrp._uuid),
                 .io_port          = None,
                 .controller_meter = None)
        }
    }
}

/* Install drop routes for all the static routes with nexthop = "discard" */
Flow(.logical_datapath = router._uuid,
     .stage            = s_ROUTER_IN_IP_ROUTING(),
     .priority         = priority as integer,
     .__match          = ip_match.intern(),
     .actions          = i"drop;",
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    r in RouterDiscardRoute_(.router = router, .key = key),
    (var ip_match, var priority) = build_route_match(r.key).

/* Logical router ingress table IP_ROUTING & IP_ROUTING_ECMP: IP Routing.
 *
 * A packet that arrives at this table is an IP packet that should be
 * routed to the address in 'ip[46].dst'.
 *
 * For regular routes without ECMP, table IP_ROUTING sets outport to the
 * correct output port, eth.src to the output port's MAC address, and
 * '[xx]${rEG_NEXT_HOP()}' to the next-hop IP address (leaving 'ip[46].dst', the
 * packets final destination, unchanged), and advances to the next table.
 *
 * For ECMP routes, i.e. multiple routes with same policy and prefix, table
 * IP_ROUTING remembers ECMP group id and selects a member id, and advances
 * to table IP_ROUTING_ECMP, which sets outport, eth.src, and the appropriate
 * next-hop register for the selected ECMP member.
 * */
Route(key, port, src_ip, None) :-
    RouterPortNetworksIPv4Addr(.port = port, .addr = addr),
    var key = RouteKey{DstIp, IPv4{addr.addr}, addr.plen},
    var src_ip = IPv4{addr.addr}.

Route(key, port, src_ip, None) :-
    RouterPortNetworksIPv6Addr(.port = port, .addr = addr),
    var key = RouteKey{DstIp, IPv6{addr.addr}, addr.plen},
    var src_ip = IPv6{addr.addr}.

Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_IP_ROUTING_ECMP(),
     .priority         = 150,
     .__match          = i"${rEG_ECMP_GROUP_ID()} == 0",
     .actions          = i"next;",
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    r in &Router().

/* Convert the static routes to flows. */
Route(key, dst.port, dst.src_ip, Some{dst.nexthop}) :-
    RouterStaticRoute(.router = router, .key = key, .dsts = dsts),
    dsts.size() == 1,
    Some{var dst} = dsts.nth(0).

Route(key, dst.port, dst.src_ip, None) :-
    RouterStaticRouteEmptyNextHop(.router = router, .key = key, .dsts = dsts),
    dsts.size() == 1,
    Some{var dst} = dsts.nth(0).

/* Create routes from peer to port's routable addresses */
Route(key, peer, src_ip, None) :-
    RouterPortRoutableAddresses(port, addresses),
    FirstHopRouterPortRoutableAddresses(port, peer_uuid),
    peer_lrp in &nb::Logical_Router_Port(._uuid = peer_uuid),
    peer in &RouterPort(.lrp = peer_lrp, .networks = networks),
    Some{var src} = networks.ipv4_addrs.first(),
    var src_ip = IPv4{src.addr},
    var addr = FlatMap(addresses),
    var ip4_addr = FlatMap(addr.ipv4_addrs),
    var key = RouteKey{DstIp, IPv4{ip4_addr.addr}, ip4_addr.plen}.

/* This relation indicates that logical router port "port" has routable
 * addresses (i.e. DNAT and Load Balancer VIPs) and that logical router
 * port "peer" is reachable via a hop across a single logical switch.
 */
relation FirstHopRouterPortRoutableAddresses(
    port: uuid,
    peer: uuid)
FirstHopRouterPortRoutableAddresses(port_uuid, peer_uuid) :-
    FirstHopLogicalRouter(r1, ls),
    FirstHopLogicalRouter(r2, ls),
    r1 != r2,
    LogicalRouterPort(port_uuid, r1),
    LogicalRouterPort(peer_uuid, r2),
    RouterPortRoutableAddresses(.rport = port_uuid),
    lrp in &nb::Logical_Router_Port(._uuid = port_uuid),
    peer_lrp in &nb::Logical_Router_Port(._uuid = peer_uuid),
    LogicalSwitchRouterPort(_, lrp.name, ls),
    LogicalSwitchRouterPort(_, peer_lrp.name, ls).

relation RouterPortRoutableAddresses(
    rport: uuid,
    addresses: Set<lport_addresses>)
RouterPortRoutableAddresses(port.lrp._uuid, addresses) :-
    port in &RouterPort(.is_redirect = true),
    lbips in &LogicalRouterLBIPs(.lr = port.router._uuid),
    var addresses = get_nat_addresses(port, lbips, true).filter_map(|addrs| addrs.ival().extract_addresses()),
    addresses != set_empty().

/* Return a vector of pairs (1, set[0]), ... (n, set[n - 1]). */
function numbered_vec(set: Set<'A>) : Vec<(bit<16>, 'A)> = {
    var vec = vec_with_capacity(set.size());
    var i = 1;
    for (x in set) {
        vec.push((i, x));
        i = i + 1
    };
    vec
}

relation EcmpGroup(
    group_id: bit<16>,
    router: Intern<Router>,
    key: route_key,
    dsts: Set<route_dst>,
    route_match: string,        // This is build_route_match(key).0
    route_priority: integer)    // This is build_route_match(key).1

EcmpGroup(group_id, router, key, dsts, route_match, route_priority) :-
    r in RouterStaticRoute(.router = router, .key = key, .dsts = dsts),
    dsts.size() > 1,
    var groups = (router, key, dsts).group_by(()).to_set(),
    var group_id_and_group = FlatMap(numbered_vec(groups)),
    (var group_id, (var router, var key, var dsts)) = group_id_and_group,
    (var route_match, var route_priority0) = build_route_match(key),
    var route_priority = route_priority0 as integer.

Flow(.logical_datapath = router._uuid,
     .stage            = s_ROUTER_IN_IP_ROUTING(),
     .priority         = route_priority,
     .__match          = route_match.intern(),
     .actions          = actions,
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    EcmpGroup(group_id, router, key, dsts, route_match, route_priority),
    var all_member_ids = {
        var member_ids = vec_with_capacity(dsts.size());
        for (i in range_vec(1, dsts.size()+1, 1)) {
            member_ids.push("${i}")
        };
        member_ids.join(", ")
    },
    var actions =
        i"ip.ttl--; "
        "flags.loopback = 1; "
        "${rEG_ECMP_GROUP_ID()} = ${group_id}; " /* XXX */
        "${rEG_ECMP_MEMBER_ID()} = select(${all_member_ids});".

Flow(.logical_datapath = router._uuid,
     .stage            = s_ROUTER_IN_IP_ROUTING_ECMP(),
     .priority         = 100,
     .__match          = __match,
     .actions          = actions,
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    EcmpGroup(group_id, router, key, dsts, _, _),
    var member_id_and_dst = FlatMap(numbered_vec(dsts)),
    (var member_id, var dst) = member_id_and_dst,
    var xx = dst.nexthop.xxreg(),
    var __match = i"${rEG_ECMP_GROUP_ID()} == ${group_id} && "
                  "${rEG_ECMP_MEMBER_ID()} == ${member_id}",
    var actions = i"${xx}${rEG_NEXT_HOP()} = ${dst.nexthop}; "
                  "${xx}${rEG_SRC()} = ${dst.src_ip}; "
                  "eth.src = ${dst.port.networks.ea}; "
                  "outport = ${dst.port.json_name}; "
                  "next;".

/* If symmetric ECMP replies are enabled, then packets that arrive over
 * an ECMP route need to go through conntrack.
 */
relation EcmpSymmetricReply(
    router: Intern<Router>,
    dst: route_dst,
    route_match: string,
    tunkey: integer)
EcmpSymmetricReply(router, dst, route_match, tunkey) :-
    EcmpGroup(.router = router, .dsts = dsts, .route_match = route_match),
    router.is_gateway,
    var dst = FlatMap(dsts),
    dst.ecmp_symmetric_reply,
    PortTunKeyAllocation(.port = dst.port.lrp._uuid, .tunkey = tunkey).

Flow(.logical_datapath = router._uuid,
     .stage = s_ROUTER_IN_DEFRAG(),
     .priority = 100,
     .__match = __match,
     .actions = i"ct_next;",
     .stage_hint = 0,
     .io_port          = None,
     .controller_meter = None) :-
    EcmpSymmetricReply(router, dst, route_match, _),
    var __match = i"inport == ${dst.port.json_name} && ${route_match}".

/* And packets that go out over an ECMP route need conntrack.
   XXX this seems to exactly duplicate the above flow? */

/* Save src eth and inport in ct_label for packets that arrive over
 * an ECMP route.
 */
Flow(.logical_datapath = router._uuid,
     .stage = s_ROUTER_IN_ECMP_STATEFUL(),
     .priority = 100,
     .__match = __match,
     .actions = actions,
     .stage_hint = 0,
     .io_port          = None,
     .controller_meter = None) :-
    EcmpSymmetricReply(router, dst, route_match, tunkey),
    var __match = i"inport == ${dst.port.json_name} && ${route_match} && "
                  "(ct.new && !ct.est)",
    var actions = i"ct_commit { ct_label.ecmp_reply_eth = eth.src;"
                  " ct_label.ecmp_reply_port = ${tunkey};}; next;".

/* Bypass ECMP selection if we already have ct_label information
 * for where to route the packet.
 */
Flow(.logical_datapath = router._uuid,
     .stage = s_ROUTER_IN_IP_ROUTING(),
     .priority = 300,
     .__match = i"${ecmp_reply} && ${route_match}",
     .actions = i"ip.ttl--; "
                "flags.loopback = 1; "
                "eth.src = ${dst.port.networks.ea}; "
                "${xx}reg1 = ${dst.src_ip}; "
                "outport = ${dst.port.json_name}; "
                "next;",
     .stage_hint = 0,
     .io_port          = None,
     .controller_meter = None),
/* Egress reply traffic for symmetric ECMP routes skips router policies. */
Flow(.logical_datapath = router._uuid,
     .stage = s_ROUTER_IN_POLICY(),
     .priority = 65535,
     .__match = ecmp_reply,
     .actions = i"next;",
     .stage_hint = 0,
     .io_port          = None,
     .controller_meter = None),
Flow(.logical_datapath = router._uuid,
     .stage = s_ROUTER_IN_ARP_RESOLVE(),
     .priority = 200,
     .__match = ecmp_reply,
     .actions = i"eth.dst = ct_label.ecmp_reply_eth; next;",
     .stage_hint = 0,
     .io_port          = None,
     .controller_meter = None) :-
    EcmpSymmetricReply(router, dst, route_match, tunkey),
    var ecmp_reply = i"ct.rpl && ct_label.ecmp_reply_port == ${tunkey}",
    var xx = dst.nexthop.xxreg().


/* IP Multicast lookup. Here we set the output port, adjust TTL and advance
 * to next table (priority 500).
 */
/* Drop IPv6 multicast traffic that shouldn't be forwarded,
 * i.e., router solicitation and router advertisement.
 */
Flow(.logical_datapath = router._uuid,
     .stage            = s_ROUTER_IN_IP_ROUTING(),
     .priority         = 550,
     .__match          = i"nd_rs || nd_ra",
     .actions          = i"drop;",
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    router in &Router().

for (IgmpRouterMulticastGroup(address, rtr, ports)) {
    for (RouterMcastFloodPorts(rtr, flood_ports) if rtr.mcast_cfg.relay) {
        var flood_static = not flood_ports.is_empty() in
        var mc_static = json_escape(mC_STATIC().0) in
        var static_act = {
            if (flood_static) {
                "clone { "
                    "outport = ${mc_static}; "
                    "ip.ttl--; "
                    "next; "
                "}; "
            } else {
                ""
            }
        } in
        Some{var ip} = ip46_parse(address.ival()) in
        var ipX = ip.ipX() in
        Flow(.logical_datapath = rtr._uuid,
             .stage            = s_ROUTER_IN_IP_ROUTING(),
             .priority         = 500,
             .__match          = i"${ipX} && ${ipX}.dst == ${address} ",
             .actions          =
                i"${static_act}outport = ${json_escape(address)}; "
                "ip.ttl--; next;",
             .stage_hint       = 0,
             .io_port          = None,
             .controller_meter = None)
    }
}

/* If needed, flood unregistered multicast on statically configured ports.
 * Priority 450. Otherwise drop any multicast traffic.
 */
for (RouterMcastFloodPorts(rtr, flood_ports) if rtr.mcast_cfg.relay) {
    var mc_static = json_escape(mC_STATIC().0) in
    var flood_static = not flood_ports.is_empty() in
    var actions = if (flood_static) {
        i"clone { "
            "outport = ${mc_static}; "
            "ip.ttl--; "
            "next; "
        "};"
    } else {
        i"drop;"
    } in
    Flow(.logical_datapath = rtr._uuid,
         .stage            = s_ROUTER_IN_IP_ROUTING(),
         .priority         = 450,
         .__match          = i"ip4.mcast || ip6.mcast",
         .actions          = actions,
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Logical router ingress table POLICY: Policy.
 *
 * A packet that arrives at this table is an IP packet that should be
 * permitted/denied/rerouted to the address in the rule's nexthop.
 * This table sets outport to the correct out_port,
 * eth.src to the output port's MAC address,
 * the appropriate register to the next-hop IP address (leaving
 * 'ip[46].dst', the packets final destination, unchanged), and
 * advances to the next table for ARP/ND resolution. */
for (&Router(._uuid = lr_uuid)) {
    /* This is a catch-all rule. It has the lowest priority (0)
     * does a match-all("1") and pass-through (next) */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_POLICY(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"${rEG_ECMP_GROUP_ID()} = 0; next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);

    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_POLICY_ECMP(),
         .priority         = 150,
         .__match          = i"${rEG_ECMP_GROUP_ID()} == 0",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Convert routing policies to flows. */
function pkt_mark_policy(options: Map<istring,istring>): string {
    var pkt_mark = options.get(i"pkt_mark").and_then(parse_dec_u64).unwrap_or(0);
    if (pkt_mark > 0 and pkt_mark < (1 << 32)) {
        "pkt.mark = ${pkt_mark}; "
    } else {
        ""
    }
}
Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_POLICY(),
     .priority         = policy.priority,
     .__match          = policy.__match,
     .actions          = actions.intern(),
     .stage_hint       = stage_hint(policy._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    r in &Router(),
    var policy_uuid = FlatMap(r.policies),
    policy in nb::Logical_Router_Policy(._uuid = policy_uuid),
    policy.action == i"reroute",
    Some{var nexthop_s} = match (policy.nexthops.size()) {
        0 -> policy.nexthop,
        1 -> policy.nexthops.nth(0),
        _ -> None       /* >1 nexthops handled separately as ECMP. */
    },
    Some{var nexthop} = ip46_parse(nexthop_s.ival()),
    out_port in &RouterPort(.router = r),
    Some{var src_ip} = find_lrp_member_ip(out_port.networks, nexthop),
    /*
    None:
    VLOG_WARN_RL(&rl, "lrp_addr not found for routing policy "
                 " priority %"PRId64" nexthop %s",
                 rule->priority, rule->nexthop);
    */
    var xx = src_ip.xxreg(),
    var actions = (pkt_mark_policy(policy.options) ++
                   "${xx}${rEG_NEXT_HOP()} = ${nexthop}; "
                   "${xx}${rEG_SRC()} = ${src_ip}; "
                   "eth.src = ${out_port.networks.ea}; "
                   "outport = ${out_port.json_name}; "
                   "flags.loopback = 1; "
                   "${rEG_ECMP_GROUP_ID()} = 0; "
                   "next;").

/* Returns true if the addresses in 'addrs' are all IPv4 or all IPv6,
   false if they are a mix. */
function all_same_addr_family(addrs: Set<istring>): bool {
    var addr_families = set_empty();
    for (a in addrs) {
        addr_families.insert(a.contains("."))
    };
    addr_families.size() <= 1
}

relation EcmpReroutePolicy(
    r: Intern<Router>,
    policy: nb::Logical_Router_Policy,
    ecmp_group_id: usize
)
EcmpReroutePolicy(r, policy, ecmp_group_id) :-
    r in &Router(),
    var policy_uuid = FlatMap(r.policies),
    policy in nb::Logical_Router_Policy(._uuid = policy_uuid),
    policy.action == i"reroute",
    policy.nexthops.size() > 1,
    var policies = policy.group_by(r).to_vec().map(|x| (x.nexthop, x)).sort_imm().map(|x| x.1),
    var ecmp_group_ids = range_vec(1, policies.len() + 1, 1),
    var numbered_policies = policies.zip(ecmp_group_ids),
    var pair = FlatMap(numbered_policies),
    (var policy, var ecmp_group_id) = pair,
    all_same_addr_family(policy.nexthops).
Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_POLICY_ECMP(),
     .priority         = 100,
     .__match          = __match,
     .actions          = actions.intern(),
     .stage_hint       = stage_hint(policy._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    EcmpReroutePolicy(r, policy, ecmp_group_id),
    var member_ids = range_vec(1, policy.nexthops.size() + 1, 1),
    var numbered_nexthops = policy.nexthops.map(ival).to_vec().zip(member_ids),
    var pair = FlatMap(numbered_nexthops),
    (var nexthop_s, var member_id) = pair,
    Some{var nexthop} = ip46_parse(nexthop_s),
    out_port in &RouterPort(.router = r),
    Some{var src_ip} = find_lrp_member_ip(out_port.networks, nexthop), // or warn
    var xx = src_ip.xxreg(),
    var actions = (pkt_mark_policy(policy.options) ++
                   "${xx}${rEG_NEXT_HOP()} = ${nexthop}; "
                   "${xx}${rEG_SRC()} = ${src_ip}; "
                   "eth.src = ${out_port.networks.ea}; "
                   "outport = ${out_port.json_name}; "
                   "flags.loopback = 1; "
                   "next;"),
    var __match = i"${rEG_ECMP_GROUP_ID()} == ${ecmp_group_id} && "
                  "${rEG_ECMP_MEMBER_ID()} == ${member_id}".
Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_POLICY(),
     .priority         = policy.priority,
     .__match          = policy.__match,
     .actions          = actions,
     .stage_hint       = stage_hint(policy._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    EcmpReroutePolicy(r, policy, ecmp_group_id),
    var member_ids = {
        var n = policy.nexthops.size();
        var member_ids = vec_with_capacity(n);
        for (i in range_vec(1, n + 1, 1)) {
            member_ids.push("${i}")
        };
        member_ids.join(", ")
    },
    var actions = i"${rEG_ECMP_GROUP_ID()} = ${ecmp_group_id}; "
                  "${rEG_ECMP_MEMBER_ID()} = select(${member_ids});".

Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_POLICY(),
     .priority         = policy.priority,
     .__match          = policy.__match,
     .actions          = i"drop;",
     .stage_hint       = stage_hint(policy._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    r in &Router(),
    var policy_uuid = FlatMap(r.policies),
    policy in nb::Logical_Router_Policy(._uuid = policy_uuid),
    policy.action == i"drop".
Flow(.logical_datapath = r._uuid,
     .stage            = s_ROUTER_IN_POLICY(),
     .priority         = policy.priority,
     .__match          = policy.__match,
     .actions          = (pkt_mark_policy(policy.options) ++ "${rEG_ECMP_GROUP_ID()} = 0; next;").intern(),
     .stage_hint       = stage_hint(policy._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    r in &Router(),
    var policy_uuid = FlatMap(r.policies),
    policy in nb::Logical_Router_Policy(._uuid = policy_uuid),
    policy.action == i"allow".


/* XXX destination unreachable */

/* Local router ingress table ARP_RESOLVE: ARP Resolution.
 *
 * Multicast packets already have the outport set so just advance to next
 * table (priority 500).
 */
for (&Router(._uuid = lr_uuid)) {
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_ARP_RESOLVE(),
         .priority         = 500,
         .__match          = i"ip4.mcast || ip6.mcast",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Local router ingress table ARP_RESOLVE: ARP Resolution.
 *
 * Any packet that reaches this table is an IP packet whose next-hop IP
 * address is in the next-hop register. (ip4.dst is the final destination.) This table
 * resolves the IP address in the next-hop register into an output port in outport and an
 * Ethernet address in eth.dst. */
// FIXME: does this apply to redirect ports?
for (rp in &RouterPort(.peer = PeerRouter{peer_port, _},
                       .router = router,
                       .networks = networks))
{
    for (&RouterPort(.lrp = &nb::Logical_Router_Port{._uuid = peer_port},
                     .json_name = peer_json_name,
                     .router = peer_router))
    {
        /* This is a logical router port. If next-hop IP address in
         * the next-hop register matches IP address of this router port, then
         * the packet is intended to eventually be sent to this
         * logical port. Set the destination mac address using this
         * port's mac address.
         *
         * The packet is still in peer's logical pipeline. So the match
         * should be on peer's outport. */
        if (not networks.ipv4_addrs.is_empty()) {
            var __match = "outport == ${peer_json_name} && "
                          "${rEG_NEXT_HOP()} == " ++
                          format_v4_networks(networks, false) in
            Flow(.logical_datapath = peer_router._uuid,
                 .stage            = s_ROUTER_IN_ARP_RESOLVE(),
                 .priority         = 100,
                 .__match          = __match.intern(),
                 .actions          = i"eth.dst = ${networks.ea}; next;",
                 .stage_hint       = stage_hint(rp.lrp._uuid),
                 .io_port          = None,
                 .controller_meter = None)
        };

        if (not networks.ipv6_addrs.is_empty()) {
            var __match = "outport == ${peer_json_name} && "
                          "xx${rEG_NEXT_HOP()} == " ++
                          format_v6_networks(networks) in
            Flow(.logical_datapath = peer_router._uuid,
                 .stage            = s_ROUTER_IN_ARP_RESOLVE(),
                 .priority         = 100,
                 .__match          = __match.intern(),
                 .actions          = i"eth.dst = ${networks.ea}; next;",
                 .stage_hint       = stage_hint(rp.lrp._uuid),
                 .io_port          = None,
                 .controller_meter = None)
        }
    }
}

/* Packet is on a non gateway chassis and
 * has an unresolved ARP on a network behind gateway
 * chassis attached router port. Since, redirect type
 * is "bridged", instead of calling "get_arp"
 * on this node, we will redirect the packet to gateway
 * chassis, by setting destination mac router port mac.*/
Flow(.logical_datapath = router._uuid,
     .stage            = s_ROUTER_IN_ARP_RESOLVE(),
     .priority         = 50,
     .__match          = i"outport == ${rp.json_name} && "
                         "!is_chassis_resident(${json_escape(chassis_redirect_name(l3dgw_port.name))})",
     .actions          = i"eth.dst = ${rp.networks.ea}; next;",
     .stage_hint       = stage_hint(lrp._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    rp in &RouterPort(.lrp = lrp, .router = router),
    Some{var l3dgw_port} = router.l3dgw_ports.nth(0),
    Some{i"bridged"} == lrp.options.get(i"redirect-type").


/* Drop IP traffic destined to router owned IPs. Part of it is dropped
 * in stage "lr_in_ip_input" but traffic that could have been unSNATed
 * but didn't match any existing session might still end up here.
 *
 * Priority 1.
 */
Flow(.logical_datapath = lr_uuid,
     .stage = s_ROUTER_IN_ARP_RESOLVE(),
     .priority = 1,
     .__match = ("ip4.dst == {" ++ match_ips.join(", ") ++ "}").intern(),
     .actions = i"drop;",
     .stage_hint = stage_hint(lrp_uuid),
     .io_port          = None,
     .controller_meter = None) :-
    &RouterPort(.lrp = &nb::Logical_Router_Port{._uuid = lrp_uuid},
                .router = &Router{.snat_ips = snat_ips,
                                  ._uuid = lr_uuid},
                .networks = networks),
    var addr = FlatMap(networks.ipv4_addrs),
    snat_ips.contains_key(IPv4{addr.addr}),
    var match_ips = "${addr.addr}".group_by((lr_uuid, lrp_uuid)).to_vec().
Flow(.logical_datapath = lr_uuid,
     .stage = s_ROUTER_IN_ARP_RESOLVE(),
     .priority = 1,
     .__match = ("ip6.dst == {" ++ match_ips.join(", ") ++ "}").intern(),
     .actions = i"drop;",
     .stage_hint = stage_hint(lrp_uuid),
     .io_port          = None,
     .controller_meter = None) :-
    &RouterPort(.lrp = &nb::Logical_Router_Port{._uuid = lrp_uuid},
                .router = &Router{.snat_ips = snat_ips,
                                  ._uuid = lr_uuid},
                .networks = networks),
    var addr = FlatMap(networks.ipv6_addrs),
    snat_ips.contains_key(IPv6{addr.addr}),
    var match_ips = "${addr.addr}".group_by((lr_uuid, lrp_uuid)).to_vec().

/* Create ARP resolution flows for NAT and LB addresses for first hop
 * logical routers
 */
Flow(.logical_datapath = peer.router._uuid,
     .stage = s_ROUTER_IN_ARP_RESOLVE(),
     .priority = 100,
     .__match = ("outport == ${peer.json_name} && " ++ rEG_NEXT_HOP() ++ " == {${ips}}").intern(),
     .actions = i"eth.dst = ${addr.ea}; next;",
     .stage_hint = stage_hint(lrp._uuid),
     .io_port          = None,
     .controller_meter = None) :-
     RouterPortRoutableAddresses(port, addresses),
     FirstHopRouterPortRoutableAddresses(port, peer_uuid),
     peer in &RouterPort(.lrp = lrp),
     lrp._uuid == peer_uuid,
     not peer.router.options.get_bool_def(i"dynamic_neigh_routers", false),
     var addr = FlatMap(addresses),
     var ips = addr.ipv4_addrs.map(|a| a.addr.to_string()).join(", ").

/* This is a logical switch port that backs a VM or a container.
 * Extract its addresses. For each of the address, go through all
 * the router ports attached to the switch (to which this port
 * connects) and if the address in question is reachable from the
 * router port, add an ARP/ND entry in that router's pipeline. */
for (SwitchPortIPv4Address(
        .port = &SwitchPort{.lsp = lsp, .sw = sw},
        .ea = ea,
        .addr = addr)
     if lsp.__type != i"router" and lsp.__type != i"virtual" and lsp.is_enabled())
{
    for (&SwitchPort(.sw = &Switch{._uuid = sw._uuid},
                     .peer = Some{peer@&RouterPort{.router = peer_router}}))
    {
        Some{_} = find_lrp_member_ip(peer.networks, IPv4{addr.addr}) in
        Flow(.logical_datapath = peer_router._uuid,
             .stage            = s_ROUTER_IN_ARP_RESOLVE(),
             .priority         = 100,
             .__match          = i"outport == ${peer.json_name} && "
                                 "${rEG_NEXT_HOP()} == ${addr.addr}",
             .actions          = i"eth.dst = ${ea}; next;",
             .stage_hint       = stage_hint(lsp._uuid),
             .io_port          = None,
             .controller_meter = None)
    }
}

for (SwitchPortIPv6Address(
        .port = &SwitchPort{.lsp = lsp, .sw = sw},
        .ea = ea,
        .addr = addr)
     if lsp.__type != i"router" and lsp.__type != i"virtual" and lsp.is_enabled())
{
    for (&SwitchPort(.sw = &Switch{._uuid = sw._uuid},
                     .peer = Some{peer@&RouterPort{.router = peer_router}}))
    {
        Some{_} = find_lrp_member_ip(peer.networks, IPv6{addr.addr}) in
        Flow(.logical_datapath = peer_router._uuid,
             .stage            = s_ROUTER_IN_ARP_RESOLVE(),
             .priority         = 100,
             .__match          = i"outport == ${peer.json_name} && "
                                 "xx${rEG_NEXT_HOP()} == ${addr.addr}",
             .actions          = i"eth.dst = ${ea}; next;",
             .stage_hint       = stage_hint(lsp._uuid),
             .io_port          = None,
             .controller_meter = None)
    }
}

/* True if 's' is an empty set or a set that contains just an empty string,
 * false otherwise.
 *
 * This is meant for sets of 0 or 1 elements, like the OVSDB integration
 * with DDlog uses. */
function is_empty_set_or_string(s: Option<istring>): bool = {
    match (s) {
        None -> true,
        Some{s} -> s == i""
    }
}

/* This is a virtual port. Add ARP replies for the virtual ip with
 * the mac of the present active virtual parent.
 * If the logical port doesn't have virtual parent set in
 * Port_Binding table, then add the flow to set eth.dst to
 * 00:00:00:00:00:00 and advance to next table so that ARP is
 * resolved by router pipeline using the arp{} action.
 * The MAC_Binding entry for the virtual ip might be invalid. */
Flow(.logical_datapath = peer.router._uuid,
     .stage            = s_ROUTER_IN_ARP_RESOLVE(),
     .priority         = 100,
     .__match          = i"outport == ${peer.json_name} && "
                         "${rEG_NEXT_HOP()} == ${virtual_ip}",
     .actions          = i"eth.dst = 00:00:00:00:00:00; next;",
     .stage_hint       = stage_hint(sp.lsp._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    sp in &SwitchPort(.lsp = lsp@&nb::Logical_Switch_Port{.__type = i"virtual"}),
    Some{var virtual_ip_s} = lsp.options.get(i"virtual-ip"),
    Some{var virtual_parents} = lsp.options.get(i"virtual-parents"),
    Some{var virtual_ip} = ip_parse(virtual_ip_s.ival()),
    pb in sb::Port_Binding(.logical_port = sp.lsp.name),
    is_empty_set_or_string(pb.virtual_parent) or pb.chassis == None,
    sp2 in &SwitchPort(.sw = sp.sw, .peer = Some{peer}),
    Some{_} = find_lrp_member_ip(peer.networks, IPv4{virtual_ip}).
Flow(.logical_datapath = peer.router._uuid,
     .stage            = s_ROUTER_IN_ARP_RESOLVE(),
     .priority         = 100,
     .__match          = i"outport == ${peer.json_name} && "
                         "${rEG_NEXT_HOP()} == ${virtual_ip}",
     .actions          = i"eth.dst = ${address.ea}; next;",
     .stage_hint       = stage_hint(sp.lsp._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    sp in &SwitchPort(.lsp = lsp@&nb::Logical_Switch_Port{.__type = i"virtual"}),
    Some{var virtual_ip_s} = lsp.options.get(i"virtual-ip"),
    Some{var virtual_parents} = lsp.options.get(i"virtual-parents"),
    Some{var virtual_ip} = ip_parse(virtual_ip_s.ival()),
    pb in sb::Port_Binding(.logical_port = sp.lsp.name),
    not (is_empty_set_or_string(pb.virtual_parent) or pb.chassis == None),
    Some{var virtual_parent} = pb.virtual_parent,
    vp in &SwitchPort(.lsp = &nb::Logical_Switch_Port{.name = virtual_parent}),
    var address = FlatMap(vp.static_addresses),
    sp2 in &SwitchPort(.sw = sp.sw, .peer = Some{peer}),
    Some{_} = find_lrp_member_ip(peer.networks, IPv4{virtual_ip}).

/* This is a logical switch port that connects to a router. */

/* The peer of this switch port is the router port for which
 * we need to add logical flows such that it can resolve
 * ARP entries for all the other router ports connected to
 * the switch in question. */
for (&SwitchPort(.lsp = lsp1,
                 .peer = Some{peer1@&RouterPort{.router = peer_router}},
                 .sw = sw)
     if lsp1.is_enabled() and
        not peer_router.options.get_bool_def(i"dynamic_neigh_routers", false))
{
    for (&SwitchPort(.lsp = lsp2, .peer = Some{peer2},
                     .sw = &Switch{._uuid = sw._uuid})
         /* Skip the router port under consideration. */
         if peer2.lrp._uuid != peer1.lrp._uuid)
    {
        if (not peer2.networks.ipv4_addrs.is_empty()) {
            Flow(.logical_datapath = peer_router._uuid,
                 .stage            = s_ROUTER_IN_ARP_RESOLVE(),
                 .priority         = 100,
                 .__match          = i"outport == ${peer1.json_name} && "
                                     "${rEG_NEXT_HOP()} == ${format_v4_networks(peer2.networks, false)}",
                 .actions          = i"eth.dst = ${peer2.networks.ea}; next;",
                 .stage_hint       = stage_hint(lsp1._uuid),
                 .io_port          = None,
                 .controller_meter = None)
        };

        if (not peer2.networks.ipv6_addrs.is_empty()) {
            Flow(.logical_datapath = peer_router._uuid,
                 .stage            = s_ROUTER_IN_ARP_RESOLVE(),
                 .priority         = 100,
                 .__match          = i"outport == ${peer1.json_name} && "
                                     "xx${rEG_NEXT_HOP()} == ${format_v6_networks(peer2.networks)}",
                 .actions          = i"eth.dst = ${peer2.networks.ea}; next;",
                 .stage_hint       = stage_hint(lsp1._uuid),
                 .io_port          = None,
                 .controller_meter = None)
        }
    }
}

for (&Router(._uuid = lr_uuid))
{
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_ARP_RESOLVE(),
         .priority         = 0,
         .__match          = i"ip4",
         .actions          = i"get_arp(outport, ${rEG_NEXT_HOP()}); next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None);
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_ARP_RESOLVE(),
         .priority         = 0,
         .__match          = i"ip6",
         .actions          = i"get_nd(outport, xx${rEG_NEXT_HOP()}); next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Local router ingress table CHK_PKT_LEN: Check packet length.
 *
 * Any IPv4 or IPv6 packet with outport set to a router port that has
 * gateway_mtu > 0 configured, check the packet length and store the result in
 * the 'REGBIT_PKT_LARGER' register bit.
 *
 * Local router ingress table LARGER_PKTS: Handle larger packets.
 *
 * Any IPv4 or IPv6 packet with outport set to a router port that has
 * gatway_mtu > 0 configured and the 'REGBIT_PKT_LARGER' register bit is set,
 * generate an ICMPv4/ICMPv6 packet with type 3/2 (Destination
 * Unreachable/Packet Too Big) and code 4/0 (Fragmentation needed).
 */
Flow(.logical_datapath = lr_uuid,
     .stage            = s_ROUTER_IN_CHK_PKT_LEN(),
     .priority         = 0,
     .__match          = i"1",
     .actions          = i"next;",
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    &Router(._uuid = lr_uuid).
Flow(.logical_datapath = lr_uuid,
     .stage            = s_ROUTER_IN_LARGER_PKTS(),
     .priority         = 0,
     .__match          = i"1",
     .actions          = i"next;",
     .stage_hint       = 0,
     .io_port          = None,
     .controller_meter = None) :-
    &Router(._uuid = lr_uuid).
Flow(.logical_datapath = lr_uuid,
     .stage            = s_ROUTER_IN_CHK_PKT_LEN(),
     .priority         = 50,
     .__match          = i"outport == ${gw_mtu_rp.json_name}",
     .actions          = i"${rEGBIT_PKT_LARGER()} = check_pkt_larger(${mtu}); "
                         "next;",
     .stage_hint       = stage_hint(gw_mtu_rp.lrp._uuid),
     .io_port          = None,
     .controller_meter = None) :-
    r in &Router(._uuid = lr_uuid),
    gw_mtu_rp in &RouterPort(.router = r),
    var gw_mtu = gw_mtu_rp.lrp.options.get_int_def(i"gateway_mtu", 0),
    gw_mtu > 0,
    var mtu = gw_mtu + vLAN_ETH_HEADER_LEN().
Flow(.logical_datapath = lr_uuid,
     .stage            = s_ROUTER_IN_LARGER_PKTS(),
     .priority         = 150,
     .__match          = i"inport == ${rp.json_name} && outport == ${gw_mtu_rp.json_name} && ip4 && "
                         "${rEGBIT_PKT_LARGER()} && ${rEGBIT_EGRESS_LOOPBACK()} == 0",
     .actions          = i"icmp4_error {"
                         "${rEGBIT_EGRESS_LOOPBACK()} = 1; "
                         "${rEGBIT_PKT_LARGER()} = 0; "
                         "eth.dst = ${rp.networks.ea}; "
                         "ip4.dst = ip4.src; "
                         "ip4.src = ${first_ipv4.addr}; "
                         "ip.ttl = 255; "
                         "icmp4.type = 3; /* Destination Unreachable. */ "
                         "icmp4.code = 4; /* Frag Needed and DF was Set. */ "
                         /* Set icmp4.frag_mtu to gw_mtu */
                         "icmp4.frag_mtu = ${gw_mtu}; "
                         "next(pipeline=ingress, table=0); "
                         "};",
     .io_port          = None,
     .controller_meter = r.copp.get(cOPP_ICMP4_ERR()),
     .stage_hint       = stage_hint(rp.lrp._uuid)) :-
    r in &Router(._uuid = lr_uuid),
    gw_mtu_rp in &RouterPort(.router = r),
    var gw_mtu = gw_mtu_rp.lrp.options.get_int_def(i"gateway_mtu", 0),
    gw_mtu > 0,
    var mtu = gw_mtu + vLAN_ETH_HEADER_LEN(),
    rp in &RouterPort(.router = r),
    rp.lrp != gw_mtu_rp.lrp,
    Some{var first_ipv4} = rp.networks.ipv4_addrs.nth(0).

Flow(.logical_datapath = lr_uuid,
     .stage            = s_ROUTER_IN_IP_INPUT(),
     .priority         = 150,
     .__match          = i"inport == ${rp.json_name} && ip4 && "
                         "${rEGBIT_PKT_LARGER()} && ${rEGBIT_EGRESS_LOOPBACK()} == 0",
     .actions          = i"icmp4_error {"
                         "${rEGBIT_EGRESS_LOOPBACK()} = 1; "
                         "${rEGBIT_PKT_LARGER()} = 0; "
                         "eth.dst = ${rp.networks.ea}; "
                         "ip4.dst = ip4.src; "
                         "ip4.src = ${first_ipv4.addr}; "
                         "ip.ttl = 255; "
                         "icmp4.type = 3; /* Destination Unreachable. */ "
                         "icmp4.code = 4; /* Frag Needed and DF was Set. */ "
                         /* Set icmp4.frag_mtu to gw_mtu */
                         "icmp4.frag_mtu = ${gw_mtu}; "
                         "next(pipeline=ingress, table=0); "
                         "};",
     .io_port          = None,
     .controller_meter = r.copp.get(cOPP_ICMP4_ERR()),
     .stage_hint       = stage_hint(rp.lrp._uuid)) :-
    r in &Router(._uuid = lr_uuid),
    gw_mtu_rp in &RouterPort(.router = r),
    var gw_mtu = gw_mtu_rp.lrp.options.get_int_def(i"gateway_mtu", 0),
    gw_mtu > 0,
    var mtu = gw_mtu + vLAN_ETH_HEADER_LEN(),
    rp in &RouterPort(.router = r),
    rp.lrp == gw_mtu_rp.lrp,
    Some{var first_ipv4} = rp.networks.ipv4_addrs.nth(0).

Flow(.logical_datapath = lr_uuid,
     .stage            = s_ROUTER_IN_LARGER_PKTS(),
     .priority         = 150,
     .__match          = i"inport == ${rp.json_name} && outport == ${gw_mtu_rp.json_name} && ip6 && "
                         "${rEGBIT_PKT_LARGER()} && ${rEGBIT_EGRESS_LOOPBACK()} == 0",
     .actions          = i"icmp6_error {"
                         "${rEGBIT_EGRESS_LOOPBACK()} = 1; "
                         "${rEGBIT_PKT_LARGER()} = 0; "
                         "eth.dst = ${rp.networks.ea}; "
                         "ip6.dst = ip6.src; "
                         "ip6.src = ${first_ipv6.addr}; "
                         "ip.ttl = 255; "
                         "icmp6.type = 2; /* Packet Too Big. */ "
                         "icmp6.code = 0; "
                         /* Set icmp6.frag_mtu to gw_mtu */
                         "icmp6.frag_mtu = ${gw_mtu}; "
                         "next(pipeline=ingress, table=0); "
                         "};",
     .io_port          = None,
     .controller_meter = r.copp.get(cOPP_ICMP6_ERR()),
     .stage_hint       = stage_hint(rp.lrp._uuid)) :-
    r in &Router(._uuid = lr_uuid),
    gw_mtu_rp in &RouterPort(.router = r),
    var gw_mtu = gw_mtu_rp.lrp.options.get_int_def(i"gateway_mtu", 0),
    gw_mtu > 0,
    var mtu = gw_mtu + vLAN_ETH_HEADER_LEN(),
    rp in &RouterPort(.router = r),
    rp.lrp != gw_mtu_rp.lrp,
    Some{var first_ipv6} = rp.networks.ipv6_addrs.nth(0).

Flow(.logical_datapath = lr_uuid,
     .stage            = s_ROUTER_IN_IP_INPUT(),
     .priority         = 150,
     .__match          = i"inport == ${rp.json_name} && ip6 && "
                         "${rEGBIT_PKT_LARGER()} && ${rEGBIT_EGRESS_LOOPBACK()} == 0",
     .actions          = i"icmp6_error {"
                         "${rEGBIT_EGRESS_LOOPBACK()} = 1; "
                         "${rEGBIT_PKT_LARGER()} = 0; "
                         "eth.dst = ${rp.networks.ea}; "
                         "ip6.dst = ip6.src; "
                         "ip6.src = ${first_ipv6.addr}; "
                         "ip.ttl = 255; "
                         "icmp6.type = 2; /* Packet Too Big. */ "
                         "icmp6.code = 0; "
                         /* Set icmp6.frag_mtu to gw_mtu */
                         "icmp6.frag_mtu = ${gw_mtu}; "
                         "next(pipeline=ingress, table=0); "
                         "};",
     .io_port          = None,
     .controller_meter = r.copp.get(cOPP_ICMP6_ERR()),
     .stage_hint       = stage_hint(rp.lrp._uuid)) :-
    r in &Router(._uuid = lr_uuid),
    gw_mtu_rp in &RouterPort(.router = r),
    var gw_mtu = gw_mtu_rp.lrp.options.get_int_def(i"gateway_mtu", 0),
    gw_mtu > 0,
    var mtu = gw_mtu + vLAN_ETH_HEADER_LEN(),
    rp in &RouterPort(.router = r),
    rp.lrp == gw_mtu_rp.lrp,
    Some{var first_ipv6} = rp.networks.ipv6_addrs.nth(0).

/* Logical router ingress table GW_REDIRECT: Gateway redirect.
 *
 * For traffic with outport equal to the l3dgw_port
 * on a distributed router, this table redirects a subset
 * of the traffic to the l3redirect_port which represents
 * the central instance of the l3dgw_port.
 */
for (&Router(._uuid = lr_uuid))
{
    /* For traffic with outport == l3dgw_port, if the
     * packet did not match any higher priority redirect
     * rule, then the traffic is redirected to the central
     * instance of the l3dgw_port. */
    for (DistributedGatewayPort(lrp, lr_uuid, _)) {
        Flow(.logical_datapath = lr_uuid,
             .stage            = s_ROUTER_IN_GW_REDIRECT(),
             .priority         = 50,
             .__match          = i"outport == ${json_escape(lrp.name)}",
             .actions          = i"outport = ${json_escape(chassis_redirect_name(lrp.name))}; next;",
             .stage_hint       = stage_hint(lrp._uuid),
             .io_port          = None,
             .controller_meter = None)
    };

    /* Packets are allowed by default. */
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_GW_REDIRECT(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"next;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}

/* Local router ingress table ARP_REQUEST: ARP request.
 *
 * In the common case where the Ethernet destination has been resolved,
 * this table outputs the packet (priority 0).  Otherwise, it composes
 * and sends an ARP/IPv6 NA request (priority 100). */
Flow(.logical_datapath = router._uuid,
     .stage            = s_ROUTER_IN_ARP_REQUEST(),
     .priority         = 200,
     .__match          = __match,
     .actions          = actions,
     .io_port          = None,
     .controller_meter = router.copp.get(cOPP_ND_NS_RESOLVE()),
     .stage_hint       = 0) :-
    rsr in RouterStaticRoute(.router = router),
    var dst = FlatMap(rsr.dsts),
    IPv6{var gw_ip6} = dst.nexthop,
    var __match = i"eth.dst == 00:00:00:00:00:00 && "
                  "ip6 && xx${rEG_NEXT_HOP()} == ${dst.nexthop}",
    var sn_addr = gw_ip6.solicited_node(),
    var eth_dst = sn_addr.multicast_to_ethernet(),
    var sn_addr_s = sn_addr.string_mapped(),
    var actions = i"nd_ns { "
                  "eth.dst = ${eth_dst}; "
                  "ip6.dst = ${sn_addr_s}; "
                  "nd.target = ${dst.nexthop}; "
                  "output; "
                  "};".

for (&Router(._uuid = lr_uuid, .copp = copp))
{
    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_ARP_REQUEST(),
         .priority         = 100,
         .__match          = i"eth.dst == 00:00:00:00:00:00 && ip4",
         .actions          = i"arp { "
                             "eth.dst = ff:ff:ff:ff:ff:ff; "
                             "arp.spa = ${rEG_SRC()}; "
                             "arp.tpa = ${rEG_NEXT_HOP()}; "
                             "arp.op = 1; " /* ARP request */
                             "output; "
                             "};",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_ARP_RESOLVE()),
         .stage_hint       = 0);

    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_ARP_REQUEST(),
         .priority         = 100,
         .__match          = i"eth.dst == 00:00:00:00:00:00 && ip6",
         .actions          = i"nd_ns { "
                             "nd.target = xx${rEG_NEXT_HOP()}; "
                             "output; "
                             "};",
         .io_port          = None,
         .controller_meter = copp.get(cOPP_ND_NS_RESOLVE()),
         .stage_hint       = 0);

    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_IN_ARP_REQUEST(),
         .priority         = 0,
         .__match          = i"1",
         .actions          = i"output;",
         .stage_hint       = 0,
         .io_port          = None,
         .controller_meter = None)
}


/* Logical router egress table DELIVERY: Delivery (priority 100).
 *
 * Priority 100 rules deliver packets to enabled logical ports. */
for (&RouterPort(.lrp = lrp,
                 .json_name = json_name,
                 .networks = lrp_networks,
                 .router = &Router{._uuid = lr_uuid, .mcast_cfg = mcast_cfg})
     /* Drop packets to disabled logical ports (since logical flow
      * tables are default-drop). */
     if lrp.is_enabled())
{
    /* If multicast relay is enabled then also adjust source mac for IP
     * multicast traffic.
     */
    if (mcast_cfg.relay) {
        Flow(.logical_datapath = lr_uuid,
             .stage            = s_ROUTER_OUT_DELIVERY(),
             .priority         = 110,
             .__match          = i"(ip4.mcast || ip6.mcast) && "
                                 "outport == ${json_name}",
             .actions          = i"eth.src = ${lrp_networks.ea}; output;",
             .stage_hint       = stage_hint(lrp._uuid),
             .io_port          = None,
             .controller_meter = None)
    };
    /* No egress packets should be processed in the context of
     * a chassisredirect port.  The chassisredirect port should
     * be replaced by the l3dgw port in the local output
     * pipeline stage before egress processing. */

    Flow(.logical_datapath = lr_uuid,
         .stage            = s_ROUTER_OUT_DELIVERY(),
         .priority         = 100,
         .__match          = i"outport == ${json_name}",
         .actions          = i"output;",
         .stage_hint       = stage_hint(lrp._uuid),
         .io_port          = None,
         .controller_meter = None)
}

/*
 * Datapath tunnel key allocation:
 *
 * Allocates a globally unique tunnel id in the range 1...2**24-1 for
 * each Logical_Switch and Logical_Router.
 */

function oVN_MAX_DP_KEY(): integer { (64'd1 << 24) - 1 }
function oVN_MAX_DP_GLOBAL_NUM(): integer { (64'd1 << 16) - 1 }
function oVN_MIN_DP_KEY_LOCAL(): integer { 1 }
function oVN_MAX_DP_KEY_LOCAL(): integer { oVN_MAX_DP_KEY() - oVN_MAX_DP_GLOBAL_NUM() }
function oVN_MIN_DP_KEY_GLOBAL(): integer { oVN_MAX_DP_KEY_LOCAL() + 1 }
function oVN_MAX_DP_KEY_GLOBAL(): integer { oVN_MAX_DP_KEY() }

function oVN_MAX_DP_VXLAN_KEY(): integer { (64'd1 << 12) - 1 }
function oVN_MAX_DP_VXLAN_KEY_LOCAL(): integer { oVN_MAX_DP_KEY() - oVN_MAX_DP_GLOBAL_NUM() }

/* If any chassis uses VXLAN encapsulation, then the entire deployment is in VXLAN mode. */
relation IsVxlanMode0()
IsVxlanMode0() :-
    sb::Chassis(.encaps = encaps),
    var encap_uuid = FlatMap(encaps),
    sb::Encap(._uuid = encap_uuid, .__type = i"vxlan").

relation IsVxlanMode[bool]
IsVxlanMode[true] :-
    IsVxlanMode0().
IsVxlanMode[false] :-
    Unit(),
    not IsVxlanMode0().

/* The maximum datapath tunnel key that may be used. */
relation OvnMaxDpKeyLocal[integer]
/* OVN_MAX_DP_GLOBAL_NUM doesn't apply for vxlan mode. */
OvnMaxDpKeyLocal[oVN_MAX_DP_VXLAN_KEY()] :- IsVxlanMode[true].
OvnMaxDpKeyLocal[oVN_MAX_DP_KEY() - oVN_MAX_DP_GLOBAL_NUM()] :- IsVxlanMode[false].

relation OvnPortKeyBits[bit<32>]
OvnPortKeyBits[12] :- IsVxlanMode[true].
OvnPortKeyBits[16] :- IsVxlanMode[false].

relation OvnDpKeyBits[bit<32>]
OvnDpKeyBits[12] :- IsVxlanMode[true].
OvnDpKeyBits[24] :- IsVxlanMode[false].

function get_dp_tunkey(map: Map<istring,istring>, key: istring, bits: bit<32>): Option<integer> {
    map.get(key)
       .and_then(parse_dec_u64)
       .and_then(|x| if (x > 0 and x < (1<<bits)) {
                         Some{x}
                     } else {
                         None
                     })
}

// Tunnel keys requested by datapaths.
relation RequestedTunKey(datapath: uuid, tunkey: integer)
RequestedTunKey(uuid, tunkey) :-
    OvnDpKeyBits[bits],
    ls in &nb::Logical_Switch(._uuid = uuid),
    Some{var tunkey} = get_dp_tunkey(ls.other_config, i"requested-tnl-key", bits).
RequestedTunKey(uuid, tunkey) :-
    OvnDpKeyBits[bits],
    lr in nb::Logical_Router(._uuid = uuid),
    Some{var tunkey} = get_dp_tunkey(lr.options, i"requested-tnl-key", bits).
Warning[message] :-
    RequestedTunKey(datapath, tunkey),
    var count = datapath.group_by((tunkey)).size(),
    count > 1,
    var message = "${count} logical switches or routers request "
                  "datapath tunnel key ${tunkey}".

// Assign tunnel keys:
// - First priority to requested tunnel keys.
// - Second priority to already assigned tunnel keys.
// In either case, make an arbitrary choice in case of conflicts within a
// priority level.
relation AssignedTunKey(datapath: uuid, tunkey: integer)
AssignedTunKey(datapath, tunkey) :-
    RequestedTunKey(datapath, tunkey),
    var datapath = datapath.group_by(tunkey).first().
AssignedTunKey(datapath, tunkey) :-
    sb::Datapath_Binding(._uuid = datapath, .tunnel_key = tunkey),
    not RequestedTunKey(_, tunkey),
    not RequestedTunKey(datapath, _),
    var datapath = datapath.group_by(tunkey).first().

// all tunnel keys already in use in the Realized table
relation AllocatedTunKeys(keys: Set<integer>)
AllocatedTunKeys(keys) :-
    AssignedTunKey(.tunkey = tunkey),
    var keys = tunkey.group_by(()).to_set().

// Datapath_Binding's not yet in the Realized table
relation NotYetAllocatedTunKeys(datapaths: Vec<uuid>)

NotYetAllocatedTunKeys(datapaths) :-
    OutProxy_Datapath_Binding(._uuid = datapath),
    not AssignedTunKey(datapath, _),
    var datapaths = datapath.group_by(()).to_vec().

// Perform the allocation
relation TunKeyAllocation(datapath: uuid, tunkey: integer)

TunKeyAllocation(datapath, tunkey) :- AssignedTunKey(datapath, tunkey).

// Case 1: AllocatedTunKeys relation is not empty (i.e., contains
// a single record that stores a set of allocated keys)
TunKeyAllocation(datapath, tunkey) :-
    NotYetAllocatedTunKeys(unallocated),
    AllocatedTunKeys(allocated),
    OvnMaxDpKeyLocal[max_dp_key_local],
    var allocation = FlatMap(allocate(allocated, unallocated, 1, max_dp_key_local)),
    (var datapath, var tunkey) = allocation.

// Case 2: AllocatedTunKeys relation is empty
TunKeyAllocation(datapath, tunkey) :-
    NotYetAllocatedTunKeys(unallocated),
    not AllocatedTunKeys(_),
    OvnMaxDpKeyLocal[max_dp_key_local],
    var allocation = FlatMap(allocate(set_empty(), unallocated, 1, max_dp_key_local)),
    (var datapath, var tunkey) = allocation.

/*
 * Port id allocation:
 *
 * Port IDs in a per-datapath space in the range 1...2**(bits-1)-1, where
 * bits is the number of bits available for port keys (default: 16, vxlan: 12)
 */

function get_port_tunkey(map: Map<istring,istring>, key: istring, bits: bit<32>): Option<integer> {
    map.get(key)
       .and_then(parse_dec_u64)
       .and_then(|x| if (x > 0 and x < (1<<bits)) {
                         Some{x}
                     } else {
                         None
                     })
}

// Tunnel keys requested by port bindings.
relation RequestedPortTunKey(datapath: uuid, port: uuid, tunkey: integer)
RequestedPortTunKey(datapath, port, tunkey) :-
    OvnPortKeyBits[bits],
    sp in &SwitchPort(),
    var datapath = sp.sw._uuid,
    var port = sp.lsp._uuid,
    Some{var tunkey} = get_port_tunkey(sp.lsp.options, i"requested-tnl-key", bits).
RequestedPortTunKey(datapath, port, tunkey) :-
    OvnPortKeyBits[bits],
    rp in &RouterPort(),
    var datapath = rp.router._uuid,
    var port = rp.lrp._uuid,
    Some{var tunkey} = get_port_tunkey(rp.lrp.options, i"requested-tnl-key", bits).
Warning[message] :-
    RequestedPortTunKey(datapath, port, tunkey),
    var count = port.group_by((datapath, tunkey)).size(),
    count > 1,
    var message = "${count} logical ports in the same datapath "
                  "request port tunnel key ${tunkey}".

// Assign tunnel keys:
// - First priority to requested tunnel keys.
// - Second priority to already assigned tunnel keys.
// In either case, make an arbitrary choice in case of conflicts within a
// priority level.
relation AssignedPortTunKey(datapath: uuid, port: uuid, tunkey: integer)
AssignedPortTunKey(datapath, port, tunkey) :-
    RequestedPortTunKey(datapath, port, tunkey),
    var port = port.group_by((datapath, tunkey)).first().
AssignedPortTunKey(datapath, port, tunkey) :-
    sb::Port_Binding(._uuid = port_uuid,
                    .datapath = datapath,
                    .tunnel_key = tunkey),
    not RequestedPortTunKey(datapath, _, tunkey),
    not RequestedPortTunKey(datapath, port_uuid, _),
    var port = port_uuid.group_by((datapath, tunkey)).first().

// all tunnel keys already in use in the Realized table
relation AllocatedPortTunKeys(datapath: uuid, keys: Set<integer>)

AllocatedPortTunKeys(datapath, keys) :-
    AssignedPortTunKey(datapath, port, tunkey),
    var keys = tunkey.group_by(datapath).to_set().

// Port_Binding's not yet in the Realized table
relation NotYetAllocatedPortTunKeys(datapath: uuid, all_logical_ids: Vec<uuid>)

NotYetAllocatedPortTunKeys(datapath, all_names) :-
    OutProxy_Port_Binding(._uuid = port_uuid, .datapath = datapath),
    not AssignedPortTunKey(datapath, port_uuid, _),
    var all_names = port_uuid.group_by(datapath).to_vec().

// Perform the allocation.
relation PortTunKeyAllocation(port: uuid, tunkey: integer)

// Transfer existing allocations from the realized table.
PortTunKeyAllocation(port, tunkey) :- AssignedPortTunKey(_, port, tunkey).

// Case 1: AllocatedPortTunKeys(datapath) is not empty (i.e., contains
// a single record that stores a set of allocated keys).
PortTunKeyAllocation(port, tunkey) :-
    AllocatedPortTunKeys(datapath, allocated),
    NotYetAllocatedPortTunKeys(datapath, unallocated),
    var allocation = FlatMap(allocate(allocated, unallocated, 1, 64'hffff)),
    (var port, var tunkey) = allocation.

// Case 2: PortAllocatedTunKeys(datapath) relation is empty
PortTunKeyAllocation(port, tunkey) :-
    NotYetAllocatedPortTunKeys(datapath, unallocated),
    not AllocatedPortTunKeys(datapath, _),
    var allocation = FlatMap(allocate(set_empty(), unallocated, 1, 64'hffff)),
    (var port, var tunkey) = allocation.

/*
 * Multicast group tunnel_key allocation:
 *
 * Tunnel-keys in a per-datapath space in the range 32770...65535
 */

// All tunnel keys already in use in the Realized table.
relation AllocatedMulticastGroupTunKeys(datapath_uuid: uuid, keys: Set<integer>)

AllocatedMulticastGroupTunKeys(datapath_uuid, keys) :-
    sb::Multicast_Group(.datapath = datapath_uuid, .tunnel_key = tunkey),
    //sb::UUIDMap_Datapath_Binding(datapath, Left{datapath_uuid}),
    var keys = tunkey.group_by(datapath_uuid).to_set().

// Multicast_Group's not yet in the Realized table.
relation NotYetAllocatedMulticastGroupTunKeys(datapath_uuid: uuid,
                                              all_logical_ids: Vec<istring>)

NotYetAllocatedMulticastGroupTunKeys(datapath_uuid, all_names) :-
    OutProxy_Multicast_Group(.name = name, .datapath = datapath_uuid),
    not sb::Multicast_Group(.name = name, .datapath = datapath_uuid),
    var all_names = name.group_by(datapath_uuid).to_vec().

// Perform the allocation
relation MulticastGroupTunKeyAllocation(datapath_uuid: uuid, group: istring, tunkey: integer)

// transfer existing allocations from the realized table
MulticastGroupTunKeyAllocation(datapath_uuid, group, tunkey) :-
    //sb::UUIDMap_Datapath_Binding(_, datapath_uuid),
    sb::Multicast_Group(.name = group,
                       .datapath = datapath_uuid,
                       .tunnel_key = tunkey).

// Case 1: AllocatedMulticastGroupTunKeys(datapath) is not empty (i.e.,
// contains a single record that stores a set of allocated keys)
MulticastGroupTunKeyAllocation(datapath_uuid, group, tunkey) :-
    AllocatedMulticastGroupTunKeys(datapath_uuid, allocated),
    NotYetAllocatedMulticastGroupTunKeys(datapath_uuid, unallocated),
    (_, var min_key) = mC_IP_MCAST_MIN(),
    (_, var max_key) = mC_IP_MCAST_MAX(),
    var allocation = FlatMap(allocate(allocated, unallocated,
                                      min_key, max_key)),
    (var group, var tunkey) = allocation.

// Case 2: AllocatedMulticastGroupTunKeys(datapath) relation is empty
MulticastGroupTunKeyAllocation(datapath_uuid, group, tunkey) :-
    NotYetAllocatedMulticastGroupTunKeys(datapath_uuid, unallocated),
    not AllocatedMulticastGroupTunKeys(datapath_uuid, _),
    (_, var min_key) = mC_IP_MCAST_MIN(),
    (_, var max_key) = mC_IP_MCAST_MAX(),
    var allocation = FlatMap(allocate(set_empty(), unallocated,
                                      min_key, max_key)),
    (var group, var tunkey) = allocation.

/*
 * Queue ID allocation
 *
 * Queue IDs on a chassis, for routers that have QoS enabled, in a per-chassis
 * space in the range 1...0xf000.  It looks to me like there'd only be a small
 * number of these per chassis, and probably a small number overall, in case it
 * matters.
 *
 * Queue ID may also need to be deallocated if port loses QoS attributes
 *
 * This logic applies mainly to sb::Port_Binding records bound to a chassis
 * (i.e. with the chassis column nonempty) but "localnet" ports can also
 * have a queue ID.  For those we use the port's own UUID as the chassis UUID.
 */

function port_has_qos_params(opts: Map<istring, istring>): bool = {
    opts.contains_key(i"qos_max_rate") or opts.contains_key(i"qos_burst")
}


// ports in Out_Port_Binding that require queue ID on chassis
relation PortRequiresQID(port: uuid, chassis: uuid)

PortRequiresQID(pb._uuid, chassis) :-
    pb in OutProxy_Port_Binding(),
    pb.__type != i"localnet",
    port_has_qos_params(pb.options),
    sb::Port_Binding(._uuid = pb._uuid, .chassis = chassis_set),
    Some{var chassis} = chassis_set.
PortRequiresQID(pb._uuid, pb._uuid) :-
    pb in OutProxy_Port_Binding(),
    pb.__type == i"localnet",
    port_has_qos_params(pb.options),
    sb::Port_Binding(._uuid = pb._uuid).

relation AggPortRequiresQID(chassis: uuid, ports: Vec<uuid>)

AggPortRequiresQID(chassis, ports) :-
    PortRequiresQID(port, chassis),
    var ports = port.group_by(chassis).to_vec().

relation AllocatedQIDs(chassis: uuid, allocated_ids: Map<uuid, integer>)

AllocatedQIDs(chassis, allocated_ids) :-
    pb in sb::Port_Binding(),
    pb.__type != i"localnet",
    Some{var chassis} = pb.chassis,
    Some{var qid_str} = pb.options.get(i"qdisc_queue_id"),
    Some{var qid} = parse_dec_u64(qid_str),
    var allocated_ids = (pb._uuid, qid).group_by(chassis).to_map().
AllocatedQIDs(chassis, allocated_ids) :-
    pb in sb::Port_Binding(),
    pb.__type == i"localnet",
    var chassis = pb._uuid,
    Some{var qid_str} = pb.options.get(i"qdisc_queue_id"),
    Some{var qid} = parse_dec_u64(qid_str),
    var allocated_ids = (pb._uuid, qid).group_by(chassis).to_map().

// allocate queue IDs to ports
relation QueueIDAllocation(port: uuid, qids: Option<integer>)

// None for ports that do not require a queue
QueueIDAllocation(port, None) :-
    OutProxy_Port_Binding(._uuid = port),
    not PortRequiresQID(port, _).

QueueIDAllocation(port, Some{qid}) :-
    AggPortRequiresQID(chassis, ports),
    AllocatedQIDs(chassis, allocated_ids),
    var allocations = FlatMap(adjust_allocation(allocated_ids, ports, 1, 64'hf000)),
    (var port, var qid) = allocations.

QueueIDAllocation(port, Some{qid}) :-
    AggPortRequiresQID(chassis, ports),
    not AllocatedQIDs(chassis, _),
    var allocations = FlatMap(adjust_allocation(map_empty(), ports, 1, 64'hf000)),
    (var port, var qid) = allocations.

/*
 * This allows ovn-northd to preserve options:ipv6_ra_pd_list, which is set by
 * ovn-controller.
 */
relation PreserveIPv6RAPDList(lrp_uuid: uuid, ipv6_ra_pd_list: Option<istring>)
PreserveIPv6RAPDList(lrp_uuid, ipv6_ra_pd_list) :-
    sb::Port_Binding(._uuid = lrp_uuid, .options = options),
    var ipv6_ra_pd_list = options.get(i"ipv6_ra_pd_list").
PreserveIPv6RAPDList(lrp_uuid, None) :-
    &nb::Logical_Router_Port(._uuid = lrp_uuid),
    not sb::Port_Binding(._uuid = lrp_uuid).

/*
 * Tag allocation for nested containers.
 */

/* Reserved tags for each parent port, including:
 * 1. For ports that need a dynamically allocated tag, existing tag, if any,
 * 2. For ports that have a statically assigned tag (via `tag_request`), the
 *    `tag_request` value.
 * 3. For ports that do not have a tag_request, but have a tag statically assigned
 *    by directly setting the `tag` field, use this value.
 */
relation SwitchPortReservedTag(parent_name: istring, tags: integer)

SwitchPortReservedTag(parent_name, tag) :-
    &SwitchPort(.lsp = lsp, .needs_dynamic_tag = needs_dynamic_tag, .parent_name = Some{parent_name}),
    Some{var tag} = if (needs_dynamic_tag) {
        lsp.tag
    } else {
        match (lsp.tag_request) {
            Some{req} -> Some{req},
            None      -> lsp.tag
        }
    }.

relation SwitchPortReservedTags(parent_name: istring, tags: Set<integer>)

SwitchPortReservedTags(parent_name, tags) :-
    SwitchPortReservedTag(parent_name, tag),
    var tags = tag.group_by(parent_name).to_set().

SwitchPortReservedTags(parent_name, set_empty()) :-
    &nb::Logical_Switch_Port(.name = parent_name),
    not SwitchPortReservedTag(.parent_name = parent_name).

/* Allocate tags for ports that require dynamically allocated tags and do not
 * have any yet.
 */
relation SwitchPortAllocatedTags(lsp_uuid: uuid, tag: Option<integer>)

SwitchPortAllocatedTags(lsp_uuid, tag) :-
    &SwitchPort(.lsp = lsp, .needs_dynamic_tag = true, .parent_name = Some{parent_name}),
    lsp.tag == None,
    var lsps_need_tag = lsp._uuid.group_by(parent_name).to_vec(),
    SwitchPortReservedTags(parent_name, reserved),
    var dyn_tags = allocate_opt(reserved,
                                lsps_need_tag,
                                1, /* Tag 0 is invalid for nested containers. */
                                4095),
    var lsp_tag = FlatMap(dyn_tags),
    (var lsp_uuid, var tag) = lsp_tag.

/* New tag-to-port assignment:
 * Case 1. Statically reserved tag (via `tag_request`), if any.
 * Case 2. Existing tag for ports that require a dynamically allocated tag and already have one.
 * Case 3. Use newly allocated tags (from `SwitchPortAllocatedTags`) for all other ports.
 */
relation SwitchPortNewDynamicTag(port: uuid, tag: Option<integer>)

/* Case 1 */
SwitchPortNewDynamicTag(lsp._uuid, tag) :-
    &SwitchPort(.lsp = lsp, .needs_dynamic_tag = false),
    var tag = match (lsp.tag_request) {
        Some{0} -> None,
        treq    -> treq
    }.

/* Case 2 */
SwitchPortNewDynamicTag(lsp._uuid, Some{tag}) :-
    &SwitchPort(.lsp = lsp, .needs_dynamic_tag = true),
    Some{var tag} = lsp.tag.

/* Case 3 */
SwitchPortNewDynamicTag(lsp._uuid, tag) :-
    &SwitchPort(.lsp = lsp, .needs_dynamic_tag = true),
    lsp.tag == None,
    SwitchPortAllocatedTags(lsp._uuid, tag).

/* IP_Multicast table (only applicable for Switches). */
sb::Out_IP_Multicast(._uuid = cfg.datapath,
                    .datapath = cfg.datapath,
                    .enabled = Some{cfg.enabled},
                    .querier = Some{cfg.querier},
                    .eth_src = cfg.eth_src,
                    .ip4_src = cfg.ip4_src,
                    .ip6_src = cfg.ip6_src,
                    .table_size = Some{cfg.table_size},
                    .idle_timeout = Some{cfg.idle_timeout},
                    .query_interval = Some{cfg.query_interval},
                    .query_max_resp = Some{cfg.query_max_resp}) :-
    McastSwitchCfg[cfg].


relation PortExists(name: istring)
PortExists(name) :- &nb::Logical_Switch_Port(.name = name).
PortExists(name) :- &nb::Logical_Router_Port(.name = name).

sb::Out_Load_Balancer(._uuid = lb._uuid,
                      .name = lb.name,
                      .vips = lb.vips,
                      .protocol = lb.protocol,
                      .datapaths = datapaths,
                      .external_ids = [i"lb_id" -> uuid2str(lb_uuid).intern()],
                      .options = options) :-
    nb in &nb::Logical_Switch(._uuid = ls_uuid, .load_balancer = lb_uuids),
    var lb_uuid = FlatMap(lb_uuids),
    var datapaths = ls_uuid.group_by(lb_uuid).to_set(),
    lb in &nb::Load_Balancer(._uuid = lb_uuid),
    /* Store the fact that northd provides the original (destination IP +
     * transport port) tuple.
     */
    var options = lb.options.insert_imm(i"hairpin_orig_tuple", i"true").

sb::Out_Service_Monitor(._uuid = hash128((svc_monitor.port_name, lbvipbackend.ip, lbvipbackend.port, protocol)),
                       .ip = i"${lbvipbackend.ip}",
                       .protocol = Some{protocol},
                       .port = lbvipbackend.port as integer,
                       .logical_port = svc_monitor.port_name,
                       .src_mac = i"${svc_monitor_mac}",
                       .src_ip = svc_monitor.src_ip,
                       .options = health_check.options,
                       .external_ids = map_empty()) :-
    SvcMonitorMac(svc_monitor_mac),
    LBVIP[lbvip@&LBVIP{.lb = lb}],
    Some{var health_check} = lbvip.health_check,
    var lbvipbackend = FlatMap(lbvip.backends),
    Some{var svc_monitor} = lbvipbackend.svc_monitor,
    PortExists(svc_monitor.port_name),
    var protocol = default_protocol(lb.protocol),
    protocol != i"sctp".

Warning["SCTP load balancers do not currently support "
        "health checks. Not creating health checks for "
        "load balancer ${uuid2str(lb._uuid)}"] :-
    LBVIP[lbvip@&LBVIP{.lb = lb}],
    default_protocol(lb.protocol) == i"sctp",
    Some{var health_check} = lbvip.health_check,
    var lbvipbackend = FlatMap(lbvip.backends),
    Some{var svc_monitor} = lbvipbackend.svc_monitor.

/*
 * BFD table.
 */

/*
 * BFD source port allocation.
 *
 * We need to assign a unique source port to each (logical_port, dst_ip) pair.
 * RFC 5881 section 4 says:
 *
 *   The source port MUST be in the range 49152 through 65535.
 *   The same UDP source port number MUST be used for all BFD
 *   Control packets associated with a particular session.
 *   The source port number SHOULD be unique among all BFD
 *   sessions on the system
 */
function bFD_UDP_SRC_PORT_MIN(): integer { 49152 }
function bFD_UDP_SRC_PORT_MAX(): integer { 65535 }

// Get already assigned BFD source ports.
// If there's a conflict, make an arbitrary choice.
relation AssignedSrcPort(
    logical_port: istring,
    dst_ip: istring,
    src_port: integer)
AssignedSrcPort(logical_port, dst_ip, src_port) :-
    sb::BFD(.logical_port = logical_port, .dst_ip = dst_ip, .src_port = src_port),
    var pair = (logical_port, dst_ip).group_by(src_port).first(),
    (var logical_port, var dst_ip) = pair.

// All source ports already in use.
relation AllocatedSrcPorts0(src_ports: Set<integer>)
AllocatedSrcPorts0(src_ports) :-
    AssignedSrcPort(.src_port = src_port),
    var src_ports = src_port.group_by(()).to_set().

relation AllocatedSrcPorts(src_ports: Set<integer>)
AllocatedSrcPorts(src_ports) :- AllocatedSrcPorts0(src_ports).
AllocatedSrcPorts(set_empty()) :- Unit(), not AllocatedSrcPorts0(_).

// (logical_port, dst_ip) pairs not yet in the Realized table
relation NotYetAllocatedSrcPorts(pairs: Vec<(istring, istring)>)
NotYetAllocatedSrcPorts(pairs) :-
    nb::BFD(.logical_port = logical_port, .dst_ip = dst_ip),
    not AssignedSrcPort(logical_port, dst_ip, _),
    var pairs = (logical_port, dst_ip).group_by(()).to_vec().

// Perform the allocation
relation SrcPortAllocation(
    logical_port: istring,
    dst_ip: istring,
    src_port: integer)
SrcPortAllocation(logical_port, dst_ip, src_port) :- AssignedSrcPort(logical_port, dst_ip, src_port).
SrcPortAllocation(logical_port, dst_ip, src_port) :-
    NotYetAllocatedSrcPorts(unallocated),
    AllocatedSrcPorts(allocated),
    var allocation = FlatMap(allocate(allocated, unallocated,
                                      bFD_UDP_SRC_PORT_MIN(), bFD_UDP_SRC_PORT_MAX())),
    ((var logical_port, var dst_ip), var src_port) = allocation.

relation SouthboundBFDStatus(
    logical_port: istring,
    dst_ip: istring,
    status: Option<istring>
)
SouthboundBFDStatus(bfd.logical_port, bfd.dst_ip, Some{bfd.status}) :- bfd in sb::BFD().
SouthboundBFDStatus(logical_port, dst_ip, None) :-
    nb::BFD(.logical_port = logical_port, .dst_ip = dst_ip),
    not sb::BFD(.logical_port = logical_port, .dst_ip = dst_ip).

function bFD_DEF_MINTX(): integer { 1000 } // 1 second
function bFD_DEF_MINRX(): integer { 1000 } // 1 second
function bFD_DEF_DETECT_MULT(): integer { 5 }
sb::Out_BFD(._uuid = hash,
            .src_port = src_port,
            .disc = max(1, hash as u32) as integer,
            .logical_port = nb.logical_port,
            .dst_ip = nb.dst_ip,
            .min_tx = nb.min_tx.unwrap_or(bFD_DEF_MINTX()),
            .min_rx = nb.min_rx.unwrap_or(bFD_DEF_MINRX()),
            .detect_mult = nb.detect_mult.unwrap_or(bFD_DEF_DETECT_MULT()),
            .status = status,
            .external_ids = map_empty(),
            .options = [i"nb_status" -> nb.status.unwrap_or(i""),
                        i"sb_status" -> sb_status.unwrap_or(i""),
                        i"referenced" -> i"${referenced}"]) :-
    nb in nb::BFD(),
    SrcPortAllocation(nb.logical_port, nb.dst_ip, src_port),
    SouthboundBFDStatus(nb.logical_port, nb.dst_ip, sb_status),
    BFDReferenced(nb._uuid, referenced),
    var status = bfd_new_status(referenced, nb.status, sb_status).1,
    var hash = hash128((nb.logical_port, nb.dst_ip)).

relation BFDReferenced0(bfd_uuid: uuid)
BFDReferenced0(bfd_uuid) :-
    nb::Logical_Router_Static_Route(.bfd = Some{bfd_uuid}, .nexthop = nexthop),
    nb::BFD(._uuid = bfd_uuid, .dst_ip = nexthop).

relation BFDReferenced(bfd_uuid: uuid, referenced: bool)
BFDReferenced(bfd_uuid, true) :- BFDReferenced0(bfd_uuid).
BFDReferenced(bfd_uuid, false) :-
    nb::BFD(._uuid = bfd_uuid),
    not BFDReferenced0(bfd_uuid).

// Given the following:
//    - 'referenced': whether a BFD object is referenced by a route
//    - 'nb_status0': 'status' in the existing nb::BFD record
//    - 'sb_status0': 'status' in the existing sb::BFD record (None, if none exists yet)
// computes and returns (nb_status, sb_status), which are the values to use next in these records
function bfd_new_status(referenced: bool,
                        nb_status0: Option<istring>,
                        sb_status0: Option<istring>): (istring, istring) {
    var nb_status = nb_status0.unwrap_or(i"admin_down");
    match (sb_status0) {
        Some{sb_status} -> if (nb_status != i"admin_down" and sb_status != i"admin_down") {
                               nb_status = sb_status
                           },
        _ -> ()
    };
    var sb_status = nb_status;
    if (referenced) {
        if (nb_status == i"admin_down") {
            nb_status = i"down"
        }
    } else {
        nb_status = i"admin_down"
    };
    warn("nb_status=${nb_status} sb_status=${sb_status} referenced=${referenced}");
    (nb_status, sb_status)
}
nb::Out_BFD(bfd_uuid, Some{status}) :-
    nb in nb::BFD(._uuid = bfd_uuid),
    BFDReferenced(bfd_uuid, referenced),
    SouthboundBFDStatus(nb.logical_port, nb.dst_ip, sb_status),
    var status = bfd_new_status(referenced, nb.status, sb_status).0.

/*
 * Logical router BFD flows
 */

function lrouter_bfd_flows(lr_uuid: uuid,
                           lrp_uuid: uuid,
                           ipX: string,
                           networks: string,
                           controller_meter: Option<istring>)
    : (Flow, Flow)
{
    (Flow{.logical_datapath = lr_uuid,
          .stage            = s_ROUTER_IN_IP_INPUT(),
          .priority         = 110,
          .__match          = i"${ipX}.src == ${networks} && udp.dst == 3784",
          .actions          = i"next; ",
          .stage_hint       = stage_hint(lrp_uuid),
         .io_port          = None,
         .controller_meter = None},
     Flow{.logical_datapath = lr_uuid,
          .stage            = s_ROUTER_IN_IP_INPUT(),
          .priority         = 110,
          .__match          = i"${ipX}.dst == ${networks} && udp.dst == 3784",
          .actions          = i"handle_bfd_msg(); ",
          .io_port          = None,
          .controller_meter = controller_meter,
          .stage_hint       = stage_hint(lrp_uuid)})
}
for (&RouterPort(.router = router, .networks = networks, .lrp = lrp, .has_bfd = true)) {
    var controller_meter = router.copp.get(cOPP_BFD()) in {
        if (not networks.ipv4_addrs.is_empty()) {
            (var a, var b) = lrouter_bfd_flows(router._uuid, lrp._uuid, "ip4",
                                               format_v4_networks(networks, false),
                                               controller_meter) in {
                Flow[a];
                Flow[b]
            }
        };

        if (not networks.ipv6_addrs.is_empty()) {
            (var a, var b) = lrouter_bfd_flows(router._uuid, lrp._uuid, "ip6",
                                               format_v6_networks(networks),
                                               controller_meter) in {
                Flow[a];
                Flow[b]
            }
        }
    }
}

/* Clean up stale FDB entries. */
sb::Out_FDB(_uuid, mac, dp_key, port_key) :-
    sb::FDB(_uuid, mac, dp_key, port_key),
    sb::Out_Datapath_Binding(._uuid = dp_uuid, .tunnel_key = dp_key),
    sb::Out_Port_Binding(.datapath = dp_uuid, .tunnel_key = port_key).
