import OVN_Northbound as nb
import ovsdb
import ovn

/* ACLRef: reference to nb.ACL */
relation &ACLRef[nb.ACL]
&ACLRef[acl] :- nb.ACL[acl].

/* DHCP_Options: reference to nb.DHCP_Options */
relation &DHCP_OptionsRef[nb.DHCP_Options]
&DHCP_OptionsRef[options] :- nb.DHCP_Options[options].

/* QoS: reference to nb.QoS */
relation &QoSRef[nb.QoS]
&QoSRef[qos] :- nb.QoS[qos].

/* LoadBalancerRef: reference to nb.Load_Balancer */
relation &LoadBalancerRef[nb.Load_Balancer]
&LoadBalancerRef[lb] :- nb.Load_Balancer[lb].

/* NATRef: reference to nb.NAT*/
relation &NATRef[nb.NAT]
&NATRef[nat] :- nb.NAT[nat].

/* Switch-to-router logical port connections */
relation SwitchRouterPeer(lsp: uuid, lsp_name: string, lrp: uuid)
SwitchRouterPeer(lsp, lsp_name, lrp) :-
    nb.Logical_Switch_Port(._uuid = lsp, .name = lsp_name, .__type = "router", .options = options),
    Some{var router_port} = map_get(options, "router-port"),
    nb.Logical_Router_Port(.name = router_port, ._uuid = lrp).

function map_get_bool_def(m: Map<string, string>,
                          k: string, def: bool): bool = {
    match (map_get(m, k)) {
        None -> def,
        Some{x} -> {
            if (def) {
                str_to_lower(x) != "false"
            } else {
                str_to_lower(x) == "true"
            }
        }
    }
}

function map_get_int_def(m: Map<string, string>, k: string,
                         def: integer): integer = {
    match (map_get(m, k)) {
        None -> def,
        Some{x} -> {
            match (str_to_int(x, 10)) {
                Some{v} -> v,
                None -> def
            }
        }
    }
}

function map_get_int_def_limit(m: Map<string, string>, k: string, def: integer,
                               min: integer, max: integer): integer = {
    var v = map_get_int_def(m, k, def);
    var v1 = {
        if (v < min) min else v
    };
    if (v1 > max) max else v1
}

function map_get_str_def(m: Map<string, string>, k: string,
                         def: string): string = {
    match (map_get(m, k)) {
        None -> def,
        Some{x} -> x
    }
}
