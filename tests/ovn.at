# OVN_CHECK_PACKETS([PCAP], [EXPECTED])
#
# This compares packets read from PCAP, in pcap format, to those read
# from EXPECTED, which is a text file containing packets as hex
# strings, one per line.  If PCAP contains fewer packets than
# EXPECTED, it waits up to 10 seconds for more packets to appear.
#
# The implementation is an m4 macro that is mostly implemented in
# terms of a shell function.  This reduces the size of the generated
# testsuite file since the shell function is only emitted once even
# when this macro is invoked many times.
m4_divert_text([PREPARE_TESTS],
  [ovn_check_packets__ () {
     echo
     echo "$3: checking packets in $1 against $2:"
     rcv_pcap=$1
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     exp_text=$2
     exp_n=`wc -l < "$exp_text"`
     OVS_WAIT_UNTIL(
       [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $rcv_pcap > $rcv_text
        rcv_n=`wc -l < "$rcv_text"`
        echo "rcv_n=$rcv_n exp_n=$exp_n"
        test $rcv_n -ge $exp_n])
     sort $exp_text > expout
   }
   ovn_check_packets_remove_broadcast__ () {
     echo "$3: checking packets in $1 against $2:"
     rcv_pcap=$1
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     exp_text=$2
     exp_n=`wc -l < "$exp_text"`
     OVS_WAIT_UNTIL(
       [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $rcv_pcap > $rcv_text
        sed -i '/ffffffffffff/d' $rcv_text
        rcv_n=`wc -l < "$rcv_text"`
        echo "rcv_n=$rcv_n exp_n=$exp_n"
        test $rcv_n -ge $exp_n])
     sort $exp_text > expout
   }
])

m4_define([OVN_CHECK_PACKETS],
  [ovn_check_packets__ "$1" "$2" "__file__:__line__"
   AT_CHECK([sort $rcv_text], [0], [expout])])

m4_define([OVN_CHECK_PACKETS_REMOVE_BROADCAST],
  [ovn_check_packets_remove_broadcast__ "$1" "$2" "__file__:__line__"
   AT_CHECK([sort $rcv_text], [0], [expout])])

m4_define([OVN_CHECK_PACKETS_CONTAIN],
  [ovn_check_packets__ "$1" "$2" "__file__:__line__"
   AT_CHECK([sort $rcv_text | comm -2 -3 expout -], [0], [])])

AT_BANNER([OVN components])

AT_SETUP([ovn -- lexer])
dnl For lines without =>, input and expected output are identical.
dnl For lines with =>, input precedes => and expected output follows =>.
AT_DATA([test-cases.txt], [dnl
foo bar baz quuxquuxquux _abcd_ a.b.c.d a123_.456
"abc\u0020def" => "abc def"
" => error("Input ends inside quoted string.")dnl "

$foo $bar $baz $quuxquuxquux $_abcd_ $a.b.c.d $a123_.456
$1 => error("`$' must be followed by a valid identifier.") 1

a/*b*/c => a c
a//b c => a
a/**/b => a b
a/*/b => a error("`/*' without matching `*/'.")
a/*/**/b => a b
a/b => a error("`/' is only valid as part of `//' or `/*'.") b

0 1 12345 18446744073709551615
18446744073709551616 => error("Decimal constants must be less than 2**64.")
9999999999999999999999 => error("Decimal constants must be less than 2**64.")
01 => error("Decimal constants must not have leading zeros.")

0/0
0/1
1/0 => 0/0
1/1
128/384
1/3
1/ => error("Integer constant expected.")

1/0x123 => error("Value and mask have incompatible formats.")

0x1234
0x01234 => 0x1234
0x0 => 0
0x000 => 0
0xfedcba9876543210
0XFEDCBA9876543210 => 0xfedcba9876543210
0xfedcba9876543210fedcba9876543210
0x0000fedcba9876543210fedcba9876543210 => 0xfedcba9876543210fedcba9876543210
0x => error("Hex digits expected following 0x.")
0X => error("Hex digits expected following 0X.")
0x0/0x0 => 0/0
0x0/0x1 => 0/0x1
0x1/0x0 => 0/0
0xffff/0x1ffff
0x. => error("Invalid syntax in hexadecimal constant.")

192.168.128.1 1.2.3.4 255.255.255.255 0.0.0.0
256.1.2.3 => error("Invalid numeric constant.")
192.168.0.0/16
192.168.0.0/255.255.0.0 => 192.168.0.0/16
192.168.0.0/255.255.255.0 => 192.168.0.0/24
192.168.0.0/255.255.0.255
192.168.0.0/255.0.0.0 => 192.0.0.0/8
192.168.0.0/32
192.168.0.0/255.255.255.255 => 192.168.0.0/32
192.168.0.2/32
192.168.0.2/30 => 192.168.0.0/30
192.168.0.2/24 => 192.168.0.0/24
1.2.3.4:5 => 1.2.3.4 : 5

::
::1
ff00::1234 => ff00::1234
2001:db8:85a3::8a2e:370:7334
2001:db8:85a3:0:0:8a2e:370:7334 => 2001:db8:85a3::8a2e:370:7334
2001:0db8:85a3:0000:0000:8a2e:0370:7334 => 2001:db8:85a3::8a2e:370:7334
::ffff:192.0.2.128
::ffff:c000:0280 => ::ffff:192.0.2.128
::1/::1
::1/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff => ::1/128
::1/128
ff00::/8
ff00::/ff00:: => ff00::/8

01:23:45:67:ab:cd
01:23:45:67:AB:CD => 01:23:45:67:ab:cd
fe:dc:ba:98:76:54
FE:DC:ba:98:76:54 => fe:dc:ba:98:76:54
01:00:00:00:00:00/01:00:00:00:00:00
ff:ff:ff:ff:ff:ff/ff:ff:ff:ff:ff:ff
fe:ff:ff:ff:ff:ff/ff:ff:ff:ff:ff:ff
ff:ff:ff:ff:ff:ff/fe:ff:ff:ff:ff:ff => fe:ff:ff:ff:ff:ff/fe:ff:ff:ff:ff:ff
fe:x => error("Invalid numeric constant.")
00:01:02:03:04:x => error("Invalid numeric constant.")

# Test that operators are tokenized as expected, even without white space.
(){}[[]]==!=<<=>>=!&&||..,;=<->--: => ( ) { } [[ ]] == != < <= > >= ! && || .. , ; = <-> -- :
& => error("`&' is only valid as part of `&&'.")
| => error("`|' is only valid as part of `||'.")

^ => error("Invalid character `^' in input.")
])
AT_CAPTURE_FILE([input.txt])
sed 's/ =>.*//' test-cases.txt > input.txt
sed 's/.* => //' test-cases.txt > expout
AT_CHECK([ovstest test-ovn lex < input.txt], [0], [expout])
AT_CLEANUP

dnl The OVN expression parser needs to know what fields overlap with one
dnl another.  This test therefore verifies that all the smaller registers
dnl are defined as terms of subfields of the larger ones.
dnl
dnl When we add or remove registers this test needs to be updated, of course.
AT_SETUP([ovn -- registers])
AT_CHECK([ovstest test-ovn dump-symtab | grep reg | sort], [0],
[[reg0 = xxreg0[96..127]
reg1 = xxreg0[64..95]
reg2 = xxreg0[32..63]
reg3 = xxreg0[0..31]
reg4 = xxreg1[96..127]
reg5 = xxreg1[64..95]
reg6 = xxreg1[32..63]
reg7 = xxreg1[0..31]
reg8 = xreg4[32..63]
reg9 = xreg4[0..31]
xreg0 = xxreg0[64..127]
xreg1 = xxreg0[0..63]
xreg2 = xxreg1[64..127]
xreg3 = xxreg1[0..63]
xreg4 = OXM_OF_PKT_REG4
xxreg0 = NXM_NX_XXREG0
xxreg1 = NXM_NX_XXREG1
]])
AT_CLEANUP

dnl Check that the OVN conntrack field definitions are correct.
AT_SETUP([ovn -- conntrack fields])
AT_CHECK([ovstest test-ovn dump-symtab | grep ^ct | sort], [0],
[[ct.dnat = ct_state[7]
ct.est = ct_state[1]
ct.inv = ct_state[4]
ct.new = ct_state[0]
ct.rel = ct_state[2]
ct.rpl = ct_state[3]
ct.snat = ct_state[6]
ct.trk = ct_state[5]
ct_label = NXM_NX_CT_LABEL
ct_label.blocked = ct_label[0]
ct_label.ecmp_reply_eth = ct_label[32..79]
ct_label.ecmp_reply_port = ct_label[80..95]
ct_label.natted = ct_label[1]
ct_mark = NXM_NX_CT_MARK
ct_state = NXM_NX_CT_STATE
]])
AT_CLEANUP

AT_SETUP([ovn -- composition])
AT_CHECK([ovstest test-ovn composition 2], [0], [ignore])
AT_CLEANUP

AT_SETUP([ovn -- expression parser])
dnl For lines without =>, input and expected output are identical.
dnl For lines with =>, input precedes => and expected output follows =>.
AT_DATA([test-cases.txt], [[
eth.type == 0x800
eth.type==0x800 => eth.type == 0x800
eth.type[0..15] == 0x800 => eth.type == 0x800

vlan.present
vlan.present == 1 => vlan.present
!(vlan.present == 0) => vlan.present
!(vlan.present != 1) => vlan.present
!vlan.present
vlan.present == 0 => !vlan.present
vlan.present != 1 => !vlan.present
!(vlan.present == 1) => !vlan.present
!(vlan.present != 0) => !vlan.present

eth.dst[0]
eth.dst[0] == 1 => eth.dst[0]
eth.dst[0] != 0 => eth.dst[0]
!(eth.dst[0] == 0) => eth.dst[0]
!(eth.dst[0] != 1) => eth.dst[0]

!eth.dst[0]
eth.dst[0] == 0 => !eth.dst[0]
eth.dst[0] != 1 => !eth.dst[0]
!(eth.dst[0] == 1) => !eth.dst[0]
!(eth.dst[0] != 0) => !eth.dst[0]

vlan.tci[12..15] == 0x3
vlan.tci == 0x3000/0xf000 => vlan.tci[12..15] == 0x3
vlan.tci[12..15] != 0x3
vlan.tci != 0x3000/0xf000 => vlan.tci[12..15] != 0x3

!vlan.pcp => vlan.pcp == 0
!(vlan.pcp) => vlan.pcp == 0
vlan.pcp == 0x4
vlan.pcp != 0x4
vlan.pcp > 0x4
vlan.pcp >= 0x4
vlan.pcp < 0x4
vlan.pcp <= 0x4
!(vlan.pcp != 0x4) => vlan.pcp == 0x4
!(vlan.pcp == 0x4) => vlan.pcp != 0x4
!(vlan.pcp <= 0x4) => vlan.pcp > 0x4
!(vlan.pcp < 0x4) => vlan.pcp >= 0x4
!(vlan.pcp >= 0x4) => vlan.pcp < 0x4
!(vlan.pcp > 0x4) => vlan.pcp <= 0x4
0x4 == vlan.pcp => vlan.pcp == 0x4
0x4 != vlan.pcp => vlan.pcp != 0x4
0x4 < vlan.pcp => vlan.pcp > 0x4
0x4 <= vlan.pcp => vlan.pcp >= 0x4
0x4 > vlan.pcp => vlan.pcp < 0x4
0x4 >= vlan.pcp => vlan.pcp <= 0x4
!(0x4 != vlan.pcp) => vlan.pcp == 0x4
!(0x4 == vlan.pcp) => vlan.pcp != 0x4
!(0x4 >= vlan.pcp) => vlan.pcp > 0x4
!(0x4 > vlan.pcp) => vlan.pcp >= 0x4
!(0x4 <= vlan.pcp) => vlan.pcp < 0x4
!(0x4 < vlan.pcp) => vlan.pcp <= 0x4

1 < vlan.pcp < 4 => vlan.pcp > 0x1 && vlan.pcp < 0x4
1 <= vlan.pcp <= 4 => vlan.pcp >= 0x1 && vlan.pcp <= 0x4
1 < vlan.pcp <= 4 => vlan.pcp > 0x1 && vlan.pcp <= 0x4
1 <= vlan.pcp < 4 => vlan.pcp >= 0x1 && vlan.pcp < 0x4
1 <= vlan.pcp <= 4 => vlan.pcp >= 0x1 && vlan.pcp <= 0x4
4 > vlan.pcp > 1 => vlan.pcp < 0x4 && vlan.pcp > 0x1
4 >= vlan.pcp > 1 => vlan.pcp <= 0x4 && vlan.pcp > 0x1
4 > vlan.pcp >= 1 => vlan.pcp < 0x4 && vlan.pcp >= 0x1
4 >= vlan.pcp >= 1 => vlan.pcp <= 0x4 && vlan.pcp >= 0x1
!(1 < vlan.pcp < 4) => vlan.pcp <= 0x1 || vlan.pcp >= 0x4
!(1 <= vlan.pcp <= 4) => vlan.pcp < 0x1 || vlan.pcp > 0x4
!(1 < vlan.pcp <= 4) => vlan.pcp <= 0x1 || vlan.pcp > 0x4
!(1 <= vlan.pcp < 4) => vlan.pcp < 0x1 || vlan.pcp >= 0x4
!(1 <= vlan.pcp <= 4) => vlan.pcp < 0x1 || vlan.pcp > 0x4
!(4 > vlan.pcp > 1) => vlan.pcp >= 0x4 || vlan.pcp <= 0x1
!(4 >= vlan.pcp > 1) => vlan.pcp > 0x4 || vlan.pcp <= 0x1
!(4 > vlan.pcp >= 1) => vlan.pcp >= 0x4 || vlan.pcp < 0x1
!(4 >= vlan.pcp >= 1) => vlan.pcp > 0x4 || vlan.pcp < 0x1

vlan.pcp == {1, 2, 3, 4} => vlan.pcp == 0x1 || vlan.pcp == 0x2 || vlan.pcp == 0x3 || vlan.pcp == 0x4
vlan.pcp == 1 || ((vlan.pcp == 2 || vlan.pcp == 3) || vlan.pcp == 4) => vlan.pcp == 0x1 || vlan.pcp == 0x2 || vlan.pcp == 0x3 || vlan.pcp == 0x4

vlan.pcp != {1, 2, 3, 4} => vlan.pcp != 0x1 && vlan.pcp != 0x2 && vlan.pcp != 0x3 && vlan.pcp != 0x4
vlan.pcp == 1 && ((vlan.pcp == 2 && vlan.pcp == 3) && vlan.pcp == 4) => vlan.pcp == 0x1 && vlan.pcp == 0x2 && vlan.pcp == 0x3 && vlan.pcp == 0x4

vlan.pcp == 1 && !((vlan.pcp == 2 && vlan.pcp == 3) && vlan.pcp == 4) => vlan.pcp == 0x1 && (vlan.pcp != 0x2 || vlan.pcp != 0x3 || vlan.pcp != 0x4)
vlan.pcp == 1 && (!(vlan.pcp == 2 && vlan.pcp == 3) && vlan.pcp == 4) => vlan.pcp == 0x1 && (vlan.pcp != 0x2 || vlan.pcp != 0x3) && vlan.pcp == 0x4
vlan.pcp == 1 && !(!(vlan.pcp == 2 && vlan.pcp == 3) && vlan.pcp == 4) => vlan.pcp == 0x1 && ((vlan.pcp == 0x2 && vlan.pcp == 0x3) || vlan.pcp != 0x4)

ip4.src == {10.0.0.0/8, 192.168.0.0/16, 172.16.20.0/24, 8.8.8.8} => ip4.src[24..31] == 0xa || ip4.src[16..31] == 0xc0a8 || ip4.src[8..31] == 0xac1014 || ip4.src == 0x8080808
ip6.src == ::1 => ip6.src == 0x1

ip4.src == 1.2.3.4 => ip4.src == 0x1020304
ip4.src == ::1.2.3.4/::ffff:ffff => ip4.src == 0x1020304
ip6.src == ::1 => ip6.src == 0x1

1
0
!1 => 0
!0 => 1

inport == "eth0"
!(inport != "eth0") => inport == "eth0"

(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) => 0

ip4.src == "eth0" => Integer field ip4.src is not compatible with string constant.
inport == 1 => String field inport is not compatible with integer constant.
ip4.src = 1.2.3.4 => Syntax error at `=' expecting relational operator.

ip4.src > {1, 2, 3} => Only == and != operators may be used with value sets.
eth.type > 0x800 => Only == and != operators may be used with nominal field eth.type.
vlan.present > 0 => Only == and != operators may be used with Boolean field vlan.present.

inport != "eth0" => Nominal field inport may only be tested for equality (taking enclosing `!' operators into account).
!(inport == "eth0") => Nominal field inport may only be tested for equality (taking enclosing `!' operators into account).
eth.type != 0x800 => Nominal field eth.type may only be tested for equality (taking enclosing `!' operators into account).
!(eth.type == 0x800) => Nominal field eth.type may only be tested for equality (taking enclosing `!' operators into account).
inport = "eth0" => Syntax error at `=' expecting relational operator.

123 == 123 => Syntax error at `123' expecting field name.

$name => Syntax error at `$name' expecting address set name.
@name => Syntax error at `@name' expecting port group name.

123 == xyzzy => Syntax error at `xyzzy' expecting field name.
xyzzy == 1 => Syntax error at `xyzzy' expecting field name.

inport[1] == 1 => Cannot select subfield of string field inport.

eth.type[] == 1 => Syntax error at `@:>@' expecting small integer.
eth.type[::1] == 1 => Syntax error at `::1' expecting small integer.
eth.type[18446744073709551615] == 1 => Syntax error at `18446744073709551615' expecting small integer.

eth.type[5!] => Syntax error at `!' expecting `@:>@'.

eth.type[5..1] => Invalid bit range 5 to 1.

eth.type[12..16] => Cannot select bits 12 to 16 of 16-bit field eth.type.

eth.type[10] == 1 => Cannot select subfield of nominal field eth.type.

eth.type => Explicit `!= 0' is required for inequality test of multibit field against 0.

!(!(vlan.pcp)) => Explicit `!= 0' is required for inequality test of multibit field against 0.

123 => Syntax error at end of input expecting relational operator.

123 x => Syntax error at `x' expecting relational operator.

{1, "eth0"} => Syntax error at `"eth0"' expecting integer.

eth.type == xyzzy => Syntax error at `xyzzy' expecting constant.

(1 x) => Syntax error at `x' expecting `)'.

!0x800 != eth.type => Missing parentheses around operand of !.

eth.type == 0x800 || eth.type == 0x86dd && ip.proto == 17 => && and || must be parenthesized when used together.

eth.dst == {} => Syntax error at `}' expecting constant.

eth.src > 00:00:00:00:11:11/00:00:00:00:ff:ff => Only == and != operators may be used with masked constants.  Consider using subfields instead (e.g. eth.src[0..15] > 0x1111 in place of eth.src > 00:00:00:00:11:11/00:00:00:00:ff:ff).

ip4.src == ::1 => 128-bit constant is not compatible with 32-bit field ip4.src.

1 == eth.type == 2 => Range expressions must have the form `x < field < y' or `x > field > y', with each `<' optionally replaced by `<=' or `>' by `>=').

eth.dst[40] x => Syntax error at `x' expecting end of input.

ip4.src == {1.2.3.4, $set1, $unknownset} => Syntax error at `$unknownset' expecting address set name.
eth.src == {$set3, badmac, 00:00:00:00:00:01} => Syntax error at `badmac' expecting constant.

((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) => Parentheses nested too deeply.

ct_label > $set4 => Only == and != operators may be used to compare a field against an empty value set.
]])
sed 's/ =>.*//' test-cases.txt > input.txt
sed 's/.* => //' test-cases.txt > expout
AT_CHECK([ovstest test-ovn parse-expr < input.txt], [0], [expout])
AT_CLEANUP

AT_SETUP([ovn -- expression annotation])
dnl Input precedes =>, expected output follows =>.
dnl Empty lines and lines starting with # are ignored.
AT_DATA([test-cases.txt], [[
ip4.src == 1.2.3.4 => ip4.src == 0x1020304 && eth.type == 0x800
ip4.src != 1.2.3.4 => ip4.src != 0x1020304 && eth.type == 0x800
ip.proto == 123 => ip.proto == 0x7b && (eth.type == 0x800 || eth.type == 0x86dd)
ip.proto == {123, 234} => (ip.proto == 0x7b || ip.proto == 0xea) && (eth.type == 0x800 || eth.type == 0x86dd)
ip4.src == 1.2.3.4 && ip4.dst == 5.6.7.8 => ip4.src == 0x1020304 && eth.type == 0x800 && ip4.dst == 0x5060708 && eth.type == 0x800

# Nested expressions over a single symbol should be annotated with symbol's
# prerequisites only once, at the top level.
tcp.dst == 1 || (tcp.dst >= 2 && tcp.dst <= 3) => (tcp.dst == 0x1 || (tcp.dst >= 0x2 && tcp.dst <= 0x3)) && ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)

ip => eth.type == 0x800 || eth.type == 0x86dd
ip == 1 => eth.type == 0x800 || eth.type == 0x86dd
ip[0] == 1 => eth.type == 0x800 || eth.type == 0x86dd
ip > 0 => Only == and != operators may be used with nominal field ip.
!ip => Nominal predicate ip may only be tested positively, e.g. `ip' or `ip == 1' but not `!ip' or `ip == 0'.
ip == 0 => Nominal predicate ip may only be tested positively, e.g. `ip' or `ip == 1' but not `!ip' or `ip == 0'.

vlan.present => vlan.tci[12]
!vlan.present => !vlan.tci[12]

!vlan.pcp => vlan.tci[13..15] == 0 && vlan.tci[12]
vlan.pcp == 1 && vlan.vid == 2 => vlan.tci[13..15] == 0x1 && vlan.tci[12] && vlan.tci[0..11] == 0x2 && vlan.tci[12]
!reg0 && !reg1 && !reg2 && !reg3 => xxreg0[96..127] == 0 && xxreg0[64..95] == 0 && xxreg0[32..63] == 0 && xxreg0[0..31] == 0

ip.first_frag => ip.frag[0] && (eth.type == 0x800 || eth.type == 0x86dd) && (!ip.frag[1] || (eth.type != 0x800 && eth.type != 0x86dd))
!ip.first_frag => !ip.frag[0] || (eth.type != 0x800 && eth.type != 0x86dd) || (ip.frag[1] && (eth.type == 0x800 || eth.type == 0x86dd))
ip.later_frag => ip.frag[1] && (eth.type == 0x800 || eth.type == 0x86dd)

bad_prereq != 0 => Error parsing expression `xyzzy' encountered as prerequisite or predicate of initial expression: Syntax error at `xyzzy' expecting field name.
self_recurse != 0 => Error parsing expression `self_recurse != 0' encountered as prerequisite or predicate of initial expression: Recursive expansion of symbol `self_recurse'.
mutual_recurse_1 != 0 => Error parsing expression `mutual_recurse_2 != 0' encountered as prerequisite or predicate of initial expression: Error parsing expression `mutual_recurse_1 != 0' encountered as prerequisite or predicate of initial expression: Recursive expansion of symbol `mutual_recurse_1'.
mutual_recurse_2 != 0 => Error parsing expression `mutual_recurse_1 != 0' encountered as prerequisite or predicate of initial expression: Error parsing expression `mutual_recurse_2 != 0' encountered as prerequisite or predicate of initial expression: Recursive expansion of symbol `mutual_recurse_2'.
]])
sed 's/ =>.*//' test-cases.txt > input.txt
sed 's/.* => //' test-cases.txt > expout
AT_CHECK([ovstest test-ovn annotate-expr < input.txt], [0], [expout])
AT_CLEANUP

AT_SETUP([ovn -- 1-term expression conversion])
AT_CHECK([ovstest test-ovn exhaustive --operation=convert 1], [0],
  [Tested converting all 1-terminal expressions with 2 numeric vars (each 3 bits) in terms of operators == != < <= > >= and 2 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- 2-term expression conversion])
AT_CHECK([ovstest test-ovn exhaustive --operation=convert 2], [0],
  [Tested converting 578 expressions of 2 terminals with 2 numeric vars (each 3 bits) in terms of operators == != < <= > >= and 2 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- 3-term expression conversion])
AT_CHECK([ovstest test-ovn exhaustive --operation=convert --bits=2 3], [0],
  [Tested converting 67410 expressions of 3 terminals with 2 numeric vars (each 2 bits) in terms of operators == != < <= > >= and 2 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- 3-term numeric expression simplification])
AT_CHECK([ovstest test-ovn exhaustive --operation=simplify --nvars=2 --svars=0 3], [0],
  [Tested simplifying 490770 expressions of 3 terminals with 2 numeric vars (each 3 bits) in terms of operators == != < <= > >=.
])
AT_CLEANUP

AT_SETUP([ovn -- 4-term string expression simplification])
AT_CHECK([ovstest test-ovn exhaustive --operation=simplify --nvars=0 --svars=4 4], [0],
  [Tested simplifying 21978 expressions of 4 terminals with 4 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- 3-term mixed expression simplification])
AT_CHECK([ovstest test-ovn exhaustive --operation=simplify --nvars=1 --svars=1 3], [0],
  [Tested simplifying 127890 expressions of 3 terminals with 1 numeric vars (each 3 bits) in terms of operators == != < <= > >= and 1 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- simplification special cases])
simplify() {
    echo "$1" | ovstest test-ovn simplify-expr
}
AT_CHECK([simplify 'eth.dst == 0/0'], [0], [1
])
AT_CHECK([simplify 'eth.dst != 0/0'], [0], [0
])
AT_CHECK([simplify 'tcp.dst >= 0'], [0],
    [ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)
])
AT_CHECK([simplify 'tcp.dst <= 65535'], [0],
    [ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)
])
AT_CHECK([simplify 'tcp.dst > 0'], [0],
    [[(tcp.dst[0] || tcp.dst[1] || tcp.dst[2] || tcp.dst[3] || tcp.dst[4] || tcp.dst[5] || tcp.dst[6] || tcp.dst[7] || tcp.dst[8] || tcp.dst[9] || tcp.dst[10] || tcp.dst[11] || tcp.dst[12] || tcp.dst[13] || tcp.dst[14] || tcp.dst[15]) && ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)
]])
AT_CHECK([simplify 'tcp.dst < 65535'], [0],
    [[(!tcp.dst[0] || !tcp.dst[1] || !tcp.dst[2] || !tcp.dst[3] || !tcp.dst[4] || !tcp.dst[5] || !tcp.dst[6] || !tcp.dst[7] || !tcp.dst[8] || !tcp.dst[9] || !tcp.dst[10] || !tcp.dst[11] || !tcp.dst[12] || !tcp.dst[13] || !tcp.dst[14] || !tcp.dst[15]) && ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)
]])
AT_CLEANUP

AT_SETUP([ovn -- is_chassis_resident simplification])
simplify() {
    echo "$1" | ovstest test-ovn simplify-expr
}
AT_CHECK([simplify 'is_chassis_resident("eth1")'], [0], [1
])
AT_CHECK([simplify 'is_chassis_resident("eth2")'], [0], [0
])
AT_CHECK([simplify '!is_chassis_resident("eth1")'], [0], [0
])
AT_CHECK([simplify '!is_chassis_resident("eth2")'], [0], [1
])
AT_CLEANUP

AT_SETUP([ovn -- 4-term numeric expression normalization])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=3 --svars=0 --bits=1 4], [0],
  [Tested normalizing 1874026 expressions of 4 terminals with 3 numeric vars (each 1 bits) in terms of operators == != < <= > >=.
])
AT_CLEANUP

AT_SETUP([ovn -- 4-term string expression normalization])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=0 --svars=3 --bits=1 4], [0],
  [Tested normalizing 11242 expressions of 4 terminals with 3 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- 4-term mixed expression normalization])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=1 --bits=1 --svars=2 4], [0],
  [Tested normalizing 175978 expressions of 4 terminals with 1 numeric vars (each 1 bits) in terms of operators == != < <= > >= and 2 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- 5-term numeric expression normalization])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=3 --svars=0 --bits=1 --relops='==' 5], [0],
  [Tested normalizing 1317600 expressions of 5 terminals with 3 numeric vars (each 1 bits) in terms of operators ==.
])
AT_CLEANUP

AT_SETUP([ovn -- 5-term string expression normalization])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=0 --svars=3 --bits=1 --relops='==' 5], [0],
  [Tested normalizing 368550 expressions of 5 terminals with 3 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- 5-term mixed expression normalization])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=1 --svars=1 --bits=1 --relops='==' 5], [0],
  [Tested normalizing 216000 expressions of 5 terminals with 1 numeric vars (each 1 bits) in terms of operators == and 1 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- 4-term numeric expressions to flows])
AT_KEYWORDS([expression])
AT_CHECK([ovstest test-ovn exhaustive --operation=flow --nvars=2 --svars=0 --bits=2 --relops='==' 4], [0],
  [Tested converting to flows 175978 expressions of 4 terminals with 2 numeric vars (each 2 bits) in terms of operators ==.
])
AT_CLEANUP

AT_SETUP([ovn -- 4-term string expressions to flows])
AT_KEYWORDS([expression])
AT_CHECK([ovstest test-ovn exhaustive --operation=flow --nvars=0 --svars=4 4], [0],
  [Tested converting to flows 21978 expressions of 4 terminals with 4 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- 4-term mixed expressions to flows])
AT_KEYWORDS([expression])
AT_CHECK([ovstest test-ovn exhaustive --operation=flow --nvars=1 --bits=2 --svars=1 --relops='==' 4], [0],
  [Tested converting to flows 48312 expressions of 4 terminals with 1 numeric vars (each 2 bits) in terms of operators == and 1 string vars.
])
AT_CLEANUP

AT_SETUP([ovn -- 3-term numeric expressions to flows])
AT_KEYWORDS([expression])
AT_CHECK([ovstest test-ovn exhaustive --operation=flow --nvars=3 --svars=0 --bits=3 --relops='==' 3], [0],
  [Tested converting to flows 41328 expressions of 3 terminals with 3 numeric vars (each 3 bits) in terms of operators ==.
])
AT_CLEANUP

AT_SETUP([ovn -- converting expressions to flows -- string fields])
AT_KEYWORDS([expression])
expr_to_flow () {
    echo "$1" | ovstest test-ovn expr-to-flows | sort
}
AT_CHECK([expr_to_flow 'inport == "eth0"'], [0], [reg14=0x5
])
AT_CHECK([expr_to_flow 'inport == "eth1"'], [0], [reg14=0x6
])
AT_CHECK([expr_to_flow 'inport == "eth2"'], [0], [(no flows)
])
AT_CHECK([expr_to_flow 'inport == "eth0" && ip'], [0], [dnl
ip,reg14=0x5
ipv6,reg14=0x5
])
AT_CHECK([expr_to_flow 'inport == "eth1" && ip'], [0], [dnl
ip,reg14=0x6
ipv6,reg14=0x6
])
AT_CHECK([expr_to_flow 'inport == "eth2" && ip'], [0], [(no flows)
])
AT_CHECK([expr_to_flow 'inport == {"eth0", "eth1", "eth2", "LOCAL"}'], [0],
[reg14=0x5
reg14=0x6
reg14=0xfffe
])
AT_CHECK([expr_to_flow 'inport == {"eth0", "eth1", "eth2"} && ip'], [0], [dnl
ip,reg14=0x5
ip,reg14=0x6
ipv6,reg14=0x5
ipv6,reg14=0x6
])
AT_CHECK([expr_to_flow 'inport == "eth0" && inport == "eth1"'], [0], [dnl
(no flows)
])
AT_CLEANUP

AT_SETUP([ovn -- converting expressions to flows -- address sets])
AT_KEYWORDS([expression])
expr_to_flow () {
    echo "$1" | ovstest test-ovn expr-to-flows | sort
}
AT_CHECK([expr_to_flow 'ip4.src == {10.0.0.1, 10.0.0.2, 10.0.0.3}'], [0], [dnl
ip,nw_src=10.0.0.1
ip,nw_src=10.0.0.2
ip,nw_src=10.0.0.3
])
AT_CHECK([expr_to_flow 'ip4.src == $set1'], [0], [dnl
ip,nw_src=10.0.0.1
ip,nw_src=10.0.0.2
ip,nw_src=10.0.0.3
])
AT_CHECK([expr_to_flow 'ip4.src == {1.2.3.4, $set1}'], [0], [dnl
ip,nw_src=1.2.3.4
ip,nw_src=10.0.0.1
ip,nw_src=10.0.0.2
ip,nw_src=10.0.0.3
])
AT_CHECK([expr_to_flow 'ip4.src == {1.2.0.0/20, 5.5.5.0/24, $set1}'], [0], [dnl
ip,nw_src=1.2.0.0/20
ip,nw_src=10.0.0.1
ip,nw_src=10.0.0.2
ip,nw_src=10.0.0.3
ip,nw_src=5.5.5.0/24
])
AT_CHECK([expr_to_flow 'ip6.src == {::1, ::2, ::3}'], [0], [dnl
ipv6,ipv6_src=::1
ipv6,ipv6_src=::2
ipv6,ipv6_src=::3
])
AT_CHECK([expr_to_flow 'ip6.src == {::1, $set2, ::4}'], [0], [dnl
ipv6,ipv6_src=::1
ipv6,ipv6_src=::2
ipv6,ipv6_src=::3
ipv6,ipv6_src=::4
])
AT_CHECK([expr_to_flow 'eth.src == {00:00:00:00:00:01, 00:00:00:00:00:02, 00:00:00:00:00:03}'], [0], [dnl
dl_src=00:00:00:00:00:01
dl_src=00:00:00:00:00:02
dl_src=00:00:00:00:00:03
])
AT_CHECK([expr_to_flow 'eth.src == {$set3}'], [0], [dnl
dl_src=00:00:00:00:00:01
dl_src=00:00:00:00:00:02
dl_src=00:00:00:00:00:03
])
AT_CHECK([expr_to_flow 'eth.src == {00:00:00:00:00:01, $set3, ba:be:be:ef:de:ad, $set3}'], [0], [dnl
dl_src=00:00:00:00:00:01
dl_src=00:00:00:00:00:02
dl_src=00:00:00:00:00:03
dl_src=ba:be:be:ef:de:ad
])
AT_CHECK([expr_to_flow 'ip4.src == {$set4}'], [0], [dnl
(no flows)
])
AT_CHECK([expr_to_flow 'ip4.src == {1.2.3.4, $set4}'], [0], [dnl
ip,nw_src=1.2.3.4
])
AT_CHECK([expr_to_flow 'ip4.src == 1.2.3.4 || ip4.src == {$set4}'], [0], [dnl
ip,nw_src=1.2.3.4
])
AT_CHECK([expr_to_flow 'ip4.src != {$set4}'], [0], [dnl

])
AT_CHECK([expr_to_flow 'ip4.src != {1.0.0.0/8, $set4}'], [0], [dnl
ip,nw_src=0.0.0.0/1.0.0.0
ip,nw_src=128.0.0.0/1
ip,nw_src=16.0.0.0/16.0.0.0
ip,nw_src=2.0.0.0/2.0.0.0
ip,nw_src=32.0.0.0/32.0.0.0
ip,nw_src=4.0.0.0/4.0.0.0
ip,nw_src=64.0.0.0/64.0.0.0
ip,nw_src=8.0.0.0/8.0.0.0
])
AT_CHECK([expr_to_flow 'ip4.src != 1.0.0.0/8 && ip4.src != {$set4}'], [0], [dnl
ip,nw_src=0.0.0.0/1.0.0.0
ip,nw_src=128.0.0.0/1
ip,nw_src=16.0.0.0/16.0.0.0
ip,nw_src=2.0.0.0/2.0.0.0
ip,nw_src=32.0.0.0/32.0.0.0
ip,nw_src=4.0.0.0/4.0.0.0
ip,nw_src=64.0.0.0/64.0.0.0
ip,nw_src=8.0.0.0/8.0.0.0
])
AT_CLEANUP

AT_SETUP([ovn -- converting expressions to flows -- port groups])
AT_KEYWORDS([expression])
expr_to_flow () {
    echo "$1" | ovstest test-ovn expr-to-flows | sort
}
AT_CHECK([expr_to_flow 'outport == @pg1'], [0], [dnl
reg15=0x11
reg15=0x12
reg15=0x13
])
AT_CHECK([expr_to_flow 'outport == {@pg_empty}'], [0], [dnl
(no flows)
])
AT_CHECK([expr_to_flow 'outport == {"lsp1", @pg_empty}'], [0], [dnl
reg15=0x11
])
AT_CLEANUP

AT_SETUP([ovn -- converting expressions to flows -- conjunction])
AT_KEYWORDS([conjunction])
expr_to_flow () {
    echo "$1" | ovstest test-ovn expr-to-flows | sort
}

lflow="ip4.src == {10.0.0.1, 10.0.0.2, 10.0.0.3} && \
ip4.dst == {20.0.0.1, 20.0.0.2, 20.0.0.3}"
AT_CHECK([expr_to_flow "$lflow"], [0], [dnl
conj_id=1,ip
ip,nw_dst=20.0.0.1: conjunction(1, 0/2)
ip,nw_dst=20.0.0.2: conjunction(1, 0/2)
ip,nw_dst=20.0.0.3: conjunction(1, 0/2)
ip,nw_src=10.0.0.1: conjunction(1, 1/2)
ip,nw_src=10.0.0.2: conjunction(1, 1/2)
ip,nw_src=10.0.0.3: conjunction(1, 1/2)
])

lflow="ip && (!ct.est || (ct.est && ct_label.blocked == 1))"
AT_CHECK([expr_to_flow "$lflow"], [0], [dnl
ct_state=+est+trk,ct_label=0x1/0x1,ip
ct_state=+est+trk,ct_label=0x1/0x1,ipv6
ct_state=-est+trk,ip
ct_state=-est+trk,ipv6
])

lflow="ip4.src == {10.0.0.1, 10.0.0.2, 10.0.0.3} && \
ip4.dst == {20.0.0.1, 20.0.0.2}"
AT_CHECK([expr_to_flow "$lflow"], [0], [dnl
conj_id=1,ip
ip,nw_dst=20.0.0.1: conjunction(1, 0/2)
ip,nw_dst=20.0.0.2: conjunction(1, 0/2)
ip,nw_src=10.0.0.1: conjunction(1, 1/2)
ip,nw_src=10.0.0.2: conjunction(1, 1/2)
ip,nw_src=10.0.0.3: conjunction(1, 1/2)
])

lflow="ip4 && ip4.src == {10.0.0.1, 10.0.0.2, 10.0.0.3} && \
ip4.dst == {20.0.0.1, 20.0.0.2, 20.0.0.3} && \
tcp.dst >= 1000 && tcp.dst <= 1010"

AT_CHECK([expr_to_flow "$lflow"], [0], [dnl
conj_id=1,tcp
tcp,nw_dst=20.0.0.1: conjunction(1, 0/3)
tcp,nw_dst=20.0.0.2: conjunction(1, 0/3)
tcp,nw_dst=20.0.0.3: conjunction(1, 0/3)
tcp,nw_src=10.0.0.1: conjunction(1, 1/3)
tcp,nw_src=10.0.0.2: conjunction(1, 1/3)
tcp,nw_src=10.0.0.3: conjunction(1, 1/3)
tcp,tp_dst=0x3ea/0xfffe: conjunction(1, 2/3)
tcp,tp_dst=0x3ec/0xfffc: conjunction(1, 2/3)
tcp,tp_dst=0x3f0/0xfffe: conjunction(1, 2/3)
tcp,tp_dst=1000: conjunction(1, 2/3)
tcp,tp_dst=1001: conjunction(1, 2/3)
tcp,tp_dst=1010: conjunction(1, 2/3)
])

lflow="ip4 && ip4.src == {10.0.0.4, 10.0.0.5, 10.0.0.6} && \
((ip4.dst == {20.0.0.4, 20.0.0.7, 20.0.0.8} && tcp.dst >= 1000 && \
tcp.dst <= 2000 && tcp.src >=1000 && tcp.src <= 2000) \
|| ip4.dst == 20.0.0.5 || ip4.dst == 20.0.0.6)"

AT_CHECK([expr_to_flow "$lflow"], [0], [dnl
conj_id=1,tcp
ip,nw_src=10.0.0.4,nw_dst=20.0.0.5
ip,nw_src=10.0.0.4,nw_dst=20.0.0.6
ip,nw_src=10.0.0.5,nw_dst=20.0.0.5
ip,nw_src=10.0.0.5,nw_dst=20.0.0.6
ip,nw_src=10.0.0.6,nw_dst=20.0.0.5
ip,nw_src=10.0.0.6,nw_dst=20.0.0.6
tcp,nw_dst=20.0.0.4: conjunction(1, 0/4)
tcp,nw_dst=20.0.0.7: conjunction(1, 0/4)
tcp,nw_dst=20.0.0.8: conjunction(1, 0/4)
tcp,nw_src=10.0.0.4: conjunction(1, 1/4)
tcp,nw_src=10.0.0.5: conjunction(1, 1/4)
tcp,nw_src=10.0.0.6: conjunction(1, 1/4)
tcp,tp_dst=0x3ea/0xfffe: conjunction(1, 2/4)
tcp,tp_dst=0x3ec/0xfffc: conjunction(1, 2/4)
tcp,tp_dst=0x3f0/0xfff0: conjunction(1, 2/4)
tcp,tp_dst=0x400/0xfe00: conjunction(1, 2/4)
tcp,tp_dst=0x600/0xff00: conjunction(1, 2/4)
tcp,tp_dst=0x700/0xff80: conjunction(1, 2/4)
tcp,tp_dst=0x780/0xffc0: conjunction(1, 2/4)
tcp,tp_dst=0x7c0/0xfff0: conjunction(1, 2/4)
tcp,tp_dst=1000: conjunction(1, 2/4)
tcp,tp_dst=1001: conjunction(1, 2/4)
tcp,tp_dst=2000: conjunction(1, 2/4)
tcp,tp_src=0x3ea/0xfffe: conjunction(1, 3/4)
tcp,tp_src=0x3ec/0xfffc: conjunction(1, 3/4)
tcp,tp_src=0x3f0/0xfff0: conjunction(1, 3/4)
tcp,tp_src=0x400/0xfe00: conjunction(1, 3/4)
tcp,tp_src=0x600/0xff00: conjunction(1, 3/4)
tcp,tp_src=0x700/0xff80: conjunction(1, 3/4)
tcp,tp_src=0x780/0xffc0: conjunction(1, 3/4)
tcp,tp_src=0x7c0/0xfff0: conjunction(1, 3/4)
tcp,tp_src=1000: conjunction(1, 3/4)
tcp,tp_src=1001: conjunction(1, 3/4)
tcp,tp_src=2000: conjunction(1, 3/4)
])
AT_CLEANUP

AT_SETUP([ovn -- action parsing])
dnl Unindented text is input (a set of OVN logical actions).
dnl Indented text is expected output.
AT_DATA([test-cases.txt],
[[# drop
drop;
    encodes as drop
drop; next;
    Syntax error at `next' expecting end of input.
next; drop;
    Syntax error at `drop' expecting action.

# output
output;
    encodes as resubmit(,64)

# next
next;
    encodes as resubmit(,19)
next(11);
    formats as next;
    encodes as resubmit(,19)
next(0);
    encodes as resubmit(,8)
next(23);
    encodes as resubmit(,31)

next();
    Syntax error at `)' expecting "pipeline" or "table".
next(10;
    Syntax error at `;' expecting `)'.
next(24);
    "next" action cannot advance beyond table 23.

next(table=11);
    formats as next;
    encodes as resubmit(,19)
next(pipeline=ingress);
    formats as next;
    encodes as resubmit(,19)
next(table=11, pipeline=ingress);
    formats as next;
    encodes as resubmit(,19)
next(pipeline=ingress, table=11);
    formats as next;
    encodes as resubmit(,19)

next(pipeline=egress);
    formats as next(pipeline=egress, table=11);
    encodes as resubmit(,51)

next(pipeline=egress, table=5);
    encodes as resubmit(,45)

next(table=10);
    formats as next(10);
    encodes as resubmit(,18)

# Loading a constant value.
tcp.dst=80;
    formats as tcp.dst = 80;
    encodes as set_field:80->tcp_dst
    has prereqs ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)
eth.dst[40] = 1;
    encodes as set_field:01:00:00:00:00:00/01:00:00:00:00:00->eth_dst
vlan.pcp = 2;
    encodes as set_field:0x4000/0xe000->vlan_tci
    has prereqs vlan.tci[12]
vlan.tci[13..15] = 2;
    encodes as set_field:0x4000/0xe000->vlan_tci
inport = "";
    encodes as set_field:0->reg14
ip.ttl=4;
    formats as ip.ttl = 4;
    encodes as set_field:4->nw_ttl
    has prereqs eth.type == 0x800 || eth.type == 0x86dd
outport="eth0"; next; outport="LOCAL"; next;
    formats as outport = "eth0"; next; outport = "LOCAL"; next;
    encodes as set_field:0x5->reg15,resubmit(,19),set_field:0xfffe->reg15,resubmit(,19)

inport[1] = 1;
    Cannot select subfield of string field inport.
ip.proto[1] = 1;
    Cannot select subfield of nominal field ip.proto.
eth.dst[40] == 1;
    Syntax error at `==' expecting `=' or `<->'.
ip = 1;
    Predicate symbol ip used where lvalue required.
ip.proto = 6;
    Field ip.proto is not modifiable.
inport = {"a", "b"};
    Syntax error at `{' expecting constant.
inport = {};
    Syntax error at `{' expecting constant.
bad_prereq = 123;
    Error parsing expression `xyzzy' encountered as prerequisite or predicate of initial expression: Syntax error at `xyzzy' expecting field name.
self_recurse = 123;
    Error parsing expression `self_recurse != 0' encountered as prerequisite or predicate of initial expression: Error parsing expression `self_recurse != 0' encountered as prerequisite or predicate of initial expression: Recursive expansion of symbol `self_recurse'.
vlan.present = 0;
    Predicate symbol vlan.present used where lvalue required.

# Moving one field into another.
reg0=reg1;
    formats as reg0 = reg1;
    encodes as move:NXM_NX_XXREG0[64..95]->NXM_NX_XXREG0[96..127]
vlan.pcp = reg0[0..2];
    encodes as move:NXM_NX_XXREG0[96..98]->NXM_OF_VLAN_TCI[13..15]
    has prereqs vlan.tci[12]
reg0[10] = vlan.pcp[1];
    encodes as move:NXM_OF_VLAN_TCI[14]->NXM_NX_XXREG0[106]
    has prereqs vlan.tci[12]
outport = inport;
    encodes as move:NXM_NX_REG14[]->NXM_NX_REG15[]

reg0[0] = vlan.present;
    Predicate symbol vlan.present used where lvalue required.
reg0 = reg1[0..10];
    Can't assign 11-bit value to 32-bit destination.
inport = reg0;
    Can't assign integer field (reg0) to string field (inport).
inport = big_string;
    String fields inport and big_string are incompatible for assignment.
ip.proto = reg0[0..7];
    Field ip.proto is not modifiable.

# Exchanging fields.
reg0 <-> reg1;
    encodes as push:NXM_NX_XXREG0[64..95],push:NXM_NX_XXREG0[96..127],pop:NXM_NX_XXREG0[64..95],pop:NXM_NX_XXREG0[96..127]
vlan.pcp <-> reg0[0..2];
    encodes as push:NXM_NX_XXREG0[96..98],push:NXM_OF_VLAN_TCI[13..15],pop:NXM_NX_XXREG0[96..98],pop:NXM_OF_VLAN_TCI[13..15]
    has prereqs vlan.tci[12]
reg0[10] <-> vlan.pcp[1];
    encodes as push:NXM_OF_VLAN_TCI[14],push:NXM_NX_XXREG0[106],pop:NXM_OF_VLAN_TCI[14],pop:NXM_NX_XXREG0[106]
    has prereqs vlan.tci[12]
outport <-> inport;
    encodes as push:NXM_NX_REG14[],push:NXM_NX_REG15[],pop:NXM_NX_REG14[],pop:NXM_NX_REG15[]

reg0[0] <-> vlan.present;
    Predicate symbol vlan.present used where lvalue required.
reg0 <-> reg1[0..10];
    Can't exchange 32-bit field with 11-bit field.
inport <-> reg0;
    Can't exchange string field (inport) with integer field (reg0).
inport <-> big_string;
    String fields inport and big_string are incompatible for exchange.
ip.proto <-> reg0[0..7];
    Field ip.proto is not modifiable.
reg0[0..7] <-> ip.proto;
    Field ip.proto is not modifiable.

# TTL decrement.
ip.ttl--;
    encodes as dec_ttl
    has prereqs ip
ip.ttl
    Syntax error at end of input expecting `--'.

# Packet mark.
pkt.mark=1;
    formats as pkt.mark = 1;
    encodes as set_field:0x1->pkt_mark

pkt.mark = 1000;
    encodes as set_field:0x3e8->pkt_mark

pkt.mark;
    Syntax error at `pkt.mark' expecting action.

pkt.mark = foo;
    Syntax error at `foo' expecting field name.

pkt.mark = "foo";
    Integer field pkt.mark is not compatible with string constant.

# load balancing.
ct_lb;
    encodes as ct(table=19,zone=NXM_NX_REG13[0..15],nat)
    has prereqs ip
ct_lb();
    formats as ct_lb;
    encodes as ct(table=19,zone=NXM_NX_REG13[0..15],nat)
    has prereqs ip
ct_lb(192.168.1.2:80, 192.168.1.3:80);
    Syntax error at `192.168.1.2' expecting backends.
ct_lb(backends=192.168.1.2:80,192.168.1.3:80);
    encodes as group:1
    uses group: id(1), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=192.168.1.2, 192.168.1.3, );
    formats as ct_lb(backends=192.168.1.2,192.168.1.3);
    encodes as group:2
    uses group: id(2), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2, fd0f::3, );
    formats as ct_lb(backends=fd0f::2,fd0f::3);
    encodes as group:3
    uses group: id(3), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip

ct_lb(backends=192.168.1.2:);
    Syntax error at `)' expecting port number.
ct_lb(backends=192.168.1.2:123456);
    Syntax error at `123456' expecting port number.
ct_lb(backends=foo);
    Syntax error at `foo' expecting IP address.
ct_lb(backends=[192.168.1.2]);
    Syntax error at `192.168.1.2' expecting IPv6 address.

ct_lb(backends=192.168.1.2:80,192.168.1.3:80; hash_fields=eth_src,eth_dst,ip_src);
    Syntax error at `eth_src' invalid hash_fields.
ct_lb(backends=192.168.1.2:80,192.168.1.3:80; hash_fields="eth_src,eth_dst,ip_src");
    encodes as group:4
    uses group: id(4), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2,fd0f::3; hash_fields="eth_src,eth_dst,ip_src,ip_dst,tp_src,tp_dst");
    encodes as group:5
    uses group: id(5), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,tp_src,tp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2,fd0f::3; hash_fields="eth_src,eth_dst,ip_src,ip_dst,tcp_src,tcp_dst");
    encodes as group:6
    uses group: id(6), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,tcp_src,tcp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2,fd0f::3; hash_fields="eth_src,eth_dst,ip_src,ip_dst,udp_src,udp_dst");
    encodes as group:7
    uses group: id(7), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,udp_src,udp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2,fd0f::3; hash_fields="eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst");
    encodes as group:8
    uses group: id(8), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip

# ct_next
ct_next;
    encodes as ct(table=19,zone=NXM_NX_REG13[0..15])
    has prereqs ip

# ct_commit
ct_commit;
    encodes as ct(commit,zone=NXM_NX_REG13[0..15])
    has prereqs ip
ct_commit { };
    formats as ct_commit;
    encodes as ct(commit,zone=NXM_NX_REG13[0..15])
    has prereqs ip
ct_commit { ct_mark=1; };
    formats as ct_commit { ct_mark = 1; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_mark))
    has prereqs ip
ct_commit { ct_mark=1/1; };
    formats as ct_commit { ct_mark = 1/1; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1/0x1->ct_mark))
    has prereqs ip
ct_commit { ct_label=1; };
    formats as ct_commit { ct_label = 1; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_label))
    has prereqs ip
ct_commit { ct_label=1/1; };
    formats as ct_commit { ct_label = 1/1; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1/0x1->ct_label))
    has prereqs ip
ct_commit { ct_mark=1; ct_label=2; };
    formats as ct_commit { ct_mark = 1; ct_label = 2; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_mark,set_field:0x2->ct_label))
    has prereqs ip

ct_commit { ct_label=0x01020304050607080910111213141516; };
    formats as ct_commit { ct_label = 0x1020304050607080910111213141516; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1020304050607080910111213141516->ct_label))
    has prereqs ip
ct_commit { ct_label=0x1000000000000000000000000000000/0x1000000000000000000000000000000; };
    formats as ct_commit { ct_label = 0x1000000000000000000000000000000/0x1000000000000000000000000000000; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1000000000000000000000000000000/0x1000000000000000000000000000000->ct_label))
    has prereqs ip
ct_commit { ct_label=18446744073709551615; };
    formats as ct_commit { ct_label = 18446744073709551615; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0xffffffffffffffff->ct_label))
    has prereqs ip
ct_commit { ct_label[0..47] = 0x00000f040201; ct_label[48..63] = 0x0002; };
    formats as ct_commit { ct_label[0..47] = 0xf040201; ct_label[48..63] = 0x2; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0xf040201/0xffffffffffff->ct_label,set_field:0x2000000000000/0xffff000000000000->ct_label))
    has prereqs ip
ct_commit { ct_label=18446744073709551616; };
    Decimal constants must be less than 2**64.
ct_commit { ct_label=0x181716151413121110090807060504030201; };
    141-bit constant is not compatible with 128-bit field ct_label.
ct_commit { ip4.dst = 192.168.0.1; };
    Field ip4.dst is not modifiable.

# Legact ct_commit_v1 action.
ct_commit();
    formats as ct_commit;
    encodes as ct(commit,zone=NXM_NX_REG13[0..15])
    has prereqs ip
ct_commit(ct_mark=1);
    formats as ct_commit(ct_mark=0x1);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_mark))
    has prereqs ip
ct_commit(ct_mark=1/1);
    formats as ct_commit(ct_mark=0x1/0x1);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1/0x1->ct_mark))
    has prereqs ip
ct_commit(ct_label=1);
    formats as ct_commit(ct_label=0x1);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_label))
    has prereqs ip
ct_commit(ct_label=1/1);
    formats as ct_commit(ct_label=0x1/0x1);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1/0x1->ct_label))
    has prereqs ip
ct_commit(ct_mark=1, ct_label=2);
    formats as ct_commit(ct_mark=0x1, ct_label=0x2);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_mark,set_field:0x2->ct_label))
    has prereqs ip

ct_commit(ct_label=0x01020304050607080910111213141516);
    formats as ct_commit(ct_label=0x1020304050607080910111213141516);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1020304050607080910111213141516->ct_label))
    has prereqs ip
ct_commit(ct_label=0x181716151413121110090807060504030201);
    formats as ct_commit(ct_label=0x16151413121110090807060504030201);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x16151413121110090807060504030201->ct_label))
    has prereqs ip
ct_commit(ct_label=0x1000000000000000000000000000000/0x1000000000000000000000000000000);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1000000000000000000000000000000/0x1000000000000000000000000000000->ct_label))
    has prereqs ip
ct_commit(ct_label=18446744073709551615);
    formats as ct_commit(ct_label=0xffffffffffffffff);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0xffffffffffffffff->ct_label))
    has prereqs ip
ct_commit(ct_label=18446744073709551616);
    Decimal constants must be less than 2**64.

ct_mark = 12345
    Field ct_mark is not modifiable.
ct_label = 0xcafe
    Field ct_label is not modifiable.
ct_label.blocked = 1/1
    Field ct_label.blocked is not modifiable.

# ct_dnat
ct_dnat;
    encodes as ct(table=19,zone=NXM_NX_REG11[0..15],nat)
    has prereqs ip
ct_dnat(192.168.1.2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=192.168.1.2))
    has prereqs ip
ct_dnat(fd11::2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=fd11::2))
    has prereqs ip
ct_dnat(192.168.1.2, 1-3000);
    formats as ct_dnat(192.168.1.2,1-3000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=192.168.1.2:1-3000))
    has prereqs ip

ct_dnat(192.168.1.2, 192.168.1.3);
    Syntax error at `192.168.1.3' expecting Integer for port range.
ct_dnat(foo);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_dnat(foo, bar);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_dnat();
    Syntax error at `)' expecting IPv4 or IPv6 address.
ct_dnat(192.168.1.2, foo);
    Syntax error at `foo' expecting Integer for port range.
ct_dnat(192.168.1.2, 1000-foo);
    Syntax error at `foo' expecting Integer for port range.
ct_dnat(192.168.1.2, 1000);
    formats as ct_dnat(192.168.1.2,1000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=192.168.1.2:1000))
    has prereqs ip
ct_dnat(192.168.1.2, 1000-100);
    Syntax error at `100' range high should be greater than range low.

# ct_snat
ct_snat;
    encodes as ct(table=19,zone=NXM_NX_REG12[0..15],nat)
    has prereqs ip
ct_snat(192.168.1.2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG12[0..15],nat(src=192.168.1.2))
    has prereqs ip
ct_snat(fd11::2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG12[0..15],nat(src=fd11::2))
    has prereqs ip
ct_snat(192.168.1.2, 1-3000);
    formats as ct_snat(192.168.1.2,1-3000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG12[0..15],nat(src=192.168.1.2:1-3000))
    has prereqs ip

ct_snat(192.168.1.2, 192.168.1.3);
    Syntax error at `192.168.1.3' expecting Integer for port range.
ct_snat(foo);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_snat(foo, bar);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_snat();
    Syntax error at `)' expecting IPv4 or IPv6 address.
ct_snat(192.168.1.2, foo);
    Syntax error at `foo' expecting Integer for port range.
ct_snat(192.168.1.2, 1000-foo);
    Syntax error at `foo' expecting Integer for port range.
ct_snat(192.168.1.2, 1000);
    formats as ct_snat(192.168.1.2,1000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG12[0..15],nat(src=192.168.1.2:1000))
    has prereqs ip
ct_snat(192.168.1.2, 1000-100);
    Syntax error at `100' range high should be greater than range low.
# ct_clear
ct_clear;
    encodes as ct_clear

# clone
clone { ip4.dst = 255.255.255.255; output; }; next;
    encodes as clone(set_field:255.255.255.255->ip_dst,resubmit(,64)),resubmit(,19)
    has prereqs eth.type == 0x800

# arp
arp { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.00.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip4
arp { };
    formats as arp { drop; };
    encodes as controller(userdata=00.00.00.00.00.00.00.00)
    has prereqs ip4

# get_arp
get_arp(outport, ip4.dst);
    encodes as push:NXM_NX_REG0[],push:NXM_OF_IP_DST[],pop:NXM_NX_REG0[],set_field:00:00:00:00:00:00->eth_dst,resubmit(,66),pop:NXM_NX_REG0[]
    has prereqs eth.type == 0x800
get_arp(inport, reg0);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_REG0[],push:NXM_NX_XXREG0[96..127],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],pop:NXM_NX_REG0[],set_field:00:00:00:00:00:00->eth_dst,resubmit(,66),pop:NXM_NX_REG0[],pop:NXM_NX_REG15[]

get_arp;
    Syntax error at `;' expecting `('.
get_arp();
    Syntax error at `)' expecting field name.
get_arp(inport);
    Syntax error at `)' expecting `,'.
get_arp(inport ip4.dst);
    Syntax error at `ip4.dst' expecting `,'.
get_arp(inport, ip4.dst;
    Syntax error at `;' expecting `)'.
get_arp(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 32-bit field is required.
get_arp(inport, outport);
    Cannot use string field outport where numeric field is required.
get_arp(reg0, ip4.dst);
    Cannot use numeric field reg0 where string field is required.

# put_arp
put_arp(inport, arp.spa, arp.sha);
    encodes as push:NXM_NX_REG0[],push:NXM_OF_ETH_SRC[],push:NXM_NX_ARP_SHA[],push:NXM_OF_ARP_SPA[],pop:NXM_NX_REG0[],pop:NXM_OF_ETH_SRC[],controller(userdata=00.00.00.01.00.00.00.00),pop:NXM_OF_ETH_SRC[],pop:NXM_NX_REG0[]
    has prereqs eth.type == 0x806 && eth.type == 0x806

# lookup_arp
reg0[0] = lookup_arp(inport, ip4.dst, eth.src);
    encodes as push:NXM_NX_REG0[],push:NXM_OF_IP_DST[],pop:NXM_NX_REG0[],set_field:0/0x40->reg10,resubmit(,67),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[96],pop:NXM_NX_REG0[]
    has prereqs eth.type == 0x800
reg1[1] = lookup_arp(inport, arp.spa, arp.sha);
    encodes as push:NXM_NX_REG0[],push:NXM_OF_ETH_SRC[],push:NXM_NX_ARP_SHA[],push:NXM_OF_ARP_SPA[],pop:NXM_NX_REG0[],pop:NXM_OF_ETH_SRC[],set_field:0/0x40->reg10,resubmit(,67),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[65],pop:NXM_OF_ETH_SRC[],pop:NXM_NX_REG0[]
    has prereqs eth.type == 0x806 && eth.type == 0x806

lookup_arp;
    Syntax error at `lookup_arp' expecting action.
reg0[0] = lookup_arp;
    Syntax error at `lookup_arp' expecting field name.
reg0[0] = lookup_arp();
    Syntax error at `)' expecting field name.
reg0[0] = lookup_arp(inport);
    Syntax error at `)' expecting `,'.
reg0[0] = lookup_arp(inport ip4.dst);
    Syntax error at `ip4.dst' expecting `,'.
reg0[0] = lookup_arp(inport, ip4.dst;
    Syntax error at `;' expecting `,'.
reg0[0] = lookup_arp(inport, ip4.dst, eth.src;
    Syntax error at `;' expecting `)'.
reg0[0] = lookup_arp(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 32-bit field is required.
reg0[0] = lookup_arp(inport, ip4.src, ip4.dst);
    Cannot use 32-bit field ip4.dst[0..31] where 48-bit field is required.

# lookup_arp_ip
reg0[0] = lookup_arp_ip(inport, ip4.dst);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_REG0[],push:NXM_OF_IP_DST[],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],pop:NXM_NX_REG0[],push:NXM_OF_ETH_DST[],set_field:0/0x40->reg10,resubmit(,66),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[96],pop:NXM_OF_ETH_DST[],pop:NXM_NX_REG0[],pop:NXM_NX_REG15[]
    has prereqs eth.type == 0x800
reg1[1] = lookup_arp_ip(inport, arp.spa);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_REG0[],push:NXM_OF_ARP_SPA[],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],pop:NXM_NX_REG0[],push:NXM_OF_ETH_DST[],set_field:0/0x40->reg10,resubmit(,66),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[65],pop:NXM_OF_ETH_DST[],pop:NXM_NX_REG0[],pop:NXM_NX_REG15[]
    has prereqs eth.type == 0x806

lookup_arp_ip;
    Syntax error at `lookup_arp_ip' expecting action.
reg0[0] = lookup_arp_ip;
    Syntax error at `lookup_arp_ip' expecting field name.
reg0[0] = lookup_arp_ip();
    Syntax error at `)' expecting field name.
reg0[0] = lookup_arp_ip(inport);
    Syntax error at `)' expecting `,'.
reg0[0] = lookup_arp_ip(inport ip4.dst);
    Syntax error at `ip4.dst' expecting `,'.
reg0[0] = lookup_arp_ip(inport, ip4.dst;
    Syntax error at `;' expecting `)'.
reg0[0] = lookup_arp_ip(inport, ip4.dst, eth.src;
    Syntax error at `,' expecting `)'.
reg0[0] = lookup_arp_ip(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 32-bit field is required.

# put_dhcp_opts
reg1[0] = put_dhcp_opts(offerip = 1.2.3.4, router = 10.0.0.1);
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.40.01.02.03.04.03.04.0a.00.00.01,pause)
reg2[5] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.254.0,mtu=1400,domain_name="ovn.org",wpad="https://example.org",bootfile_name="https://127.0.0.1/boot.ipxe",path_prefix="/tftpboot");
    formats as reg2[5] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.254.0, mtu = 1400, domain_name = "ovn.org", wpad = "https://example.org", bootfile_name = "https://127.0.0.1/boot.ipxe", path_prefix = "/tftpboot");
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.25.0a.00.00.04.43.1b.68.74.74.70.73.3a.2f.2f.31.32.37.2e.30.2e.30.2e.31.2f.62.6f.6f.74.2e.69.70.78.65.03.04.0a.00.00.01.01.04.ff.ff.fe.00.1a.02.05.78.0f.07.6f.76.6e.2e.6f.72.67.fc.13.68.74.74.70.73.3a.2f.2f.65.78.61.6d.70.6c.65.2e.6f.72.67.d2.09.2f.74.66.74.70.62.6f.6f.74,pause)
reg0[15] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.255.0,mtu=1400,ip_forward_enable=1,default_ttl=121,dns_server={8.8.8.8,7.7.7.7},classless_static_route={30.0.0.0/24,10.0.0.4,40.0.0.0/16,10.0.0.6,0.0.0.0/0,10.0.0.1},ethernet_encap=1,router_discovery=0,tftp_server_address={10.0.0.4,10.0.0.5},arp_cache_timeout=10,tcp_keepalive_interval=10);
    formats as reg0[15] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.255.0, mtu = 1400, ip_forward_enable = 1, default_ttl = 121, dns_server = {8.8.8.8, 7.7.7.7}, classless_static_route = {30.0.0.0/24, 10.0.0.4, 40.0.0.0/16, 10.0.0.6, 0.0.0.0/0, 10.0.0.1}, ethernet_encap = 1, router_discovery = 0, tftp_server_address = {10.0.0.4, 10.0.0.5}, arp_cache_timeout = 10, tcp_keepalive_interval = 10);
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.6f.0a.00.00.04.03.04.0a.00.00.01.01.04.ff.ff.ff.00.1a.02.05.78.13.01.01.17.01.79.06.08.08.08.08.08.07.07.07.07.79.14.18.1e.00.00.0a.00.00.04.10.28.00.0a.00.00.06.00.0a.00.00.01.24.01.01.1f.01.00.96.08.0a.00.00.04.0a.00.00.05.23.04.00.00.00.0a.26.04.00.00.00.0a,pause)
reg0[15] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.255.0,mtu=1400,ip_forward_enable=1,default_ttl=121,dns_server={8.8.8.8,7.7.7.7},classless_static_route={30.0.0.0/24,10.0.0.4,40.0.0.0/16,10.0.0.6,0.0.0.0/0,10.0.0.1},ethernet_encap=1,router_discovery=0,tftp_server=10.0.0.10,broadcast_address=255.255.255.255);
    formats as reg0[15] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.255.0, mtu = 1400, ip_forward_enable = 1, default_ttl = 121, dns_server = {8.8.8.8, 7.7.7.7}, classless_static_route = {30.0.0.0/24, 10.0.0.4, 40.0.0.0/16, 10.0.0.6, 0.0.0.0/0, 10.0.0.1}, ethernet_encap = 1, router_discovery = 0, tftp_server = 10.0.0.10, broadcast_address = 255.255.255.255);
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.6f.0a.00.00.04.03.04.0a.00.00.01.01.04.ff.ff.ff.00.1a.02.05.78.13.01.01.17.01.79.06.08.08.08.08.08.07.07.07.07.79.14.18.1e.00.00.0a.00.00.04.10.28.00.0a.00.00.06.00.0a.00.00.01.24.01.01.1f.01.00.42.04.0a.00.00.0a.1c.04.ff.ff.ff.ff,pause)
reg0[15] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.255.0,mtu=1400,ip_forward_enable=1,default_ttl=121,dns_server={8.8.8.8,7.7.7.7},classless_static_route={30.0.0.0/24,10.0.0.4,40.0.0.0/16,10.0.0.6,0.0.0.0/0,10.0.0.1},ethernet_encap=1,router_discovery=0,tftp_server="tftp_server_test");
    formats as reg0[15] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.255.0, mtu = 1400, ip_forward_enable = 1, default_ttl = 121, dns_server = {8.8.8.8, 7.7.7.7}, classless_static_route = {30.0.0.0/24, 10.0.0.4, 40.0.0.0/16, 10.0.0.6, 0.0.0.0/0, 10.0.0.1}, ethernet_encap = 1, router_discovery = 0, tftp_server = "tftp_server_test");
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.6f.0a.00.00.04.03.04.0a.00.00.01.01.04.ff.ff.ff.00.1a.02.05.78.13.01.01.17.01.79.06.08.08.08.08.08.07.07.07.07.79.14.18.1e.00.00.0a.00.00.04.10.28.00.0a.00.00.06.00.0a.00.00.01.24.01.01.1f.01.00.42.10.74.66.74.70.5f.73.65.72.76.65.72.5f.74.65.73.74,pause)
reg2[5] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.254.0,mtu=1400,domain_name="ovn.org",wpad="https://example.org",bootfile_name="https://127.0.0.1/boot.ipxe",path_prefix="/tftpboot",domain_search_list="ovn.org,abc.ovn.org",netbios_name_server={10.0.0.7,10.0.0.8},netbios_node_type=2);
    formats as reg2[5] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.254.0, mtu = 1400, domain_name = "ovn.org", wpad = "https://example.org", bootfile_name = "https://127.0.0.1/boot.ipxe", path_prefix = "/tftpboot", domain_search_list = "ovn.org,abc.ovn.org", netbios_name_server = {10.0.0.7, 10.0.0.8}, netbios_node_type = 2);
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.25.0a.00.00.04.43.1b.68.74.74.70.73.3a.2f.2f.31.32.37.2e.30.2e.30.2e.31.2f.62.6f.6f.74.2e.69.70.78.65.03.04.0a.00.00.01.01.04.ff.ff.fe.00.1a.02.05.78.0f.07.6f.76.6e.2e.6f.72.67.fc.13.68.74.74.70.73.3a.2f.2f.65.78.61.6d.70.6c.65.2e.6f.72.67.d2.09.2f.74.66.74.70.62.6f.6f.74.77.0f.03.6f.76.6e.03.6f.72.67.00.03.61.62.63.c0.00.2c.08.0a.00.00.07.0a.00.00.08.2e.01.02,pause)
reg2[5] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.254.0,mtu=1400,domain_name="ovn.org",wpad="https://example.org",bootfile_name="https://127.0.0.1/boot.ipxe",path_prefix="/tftpboot",domain_search_list="ovn.org,abc.ovn.org,def.ovn.org,ovn.test,def.ovn.test,test.org,abc.com");
    formats as reg2[5] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.254.0, mtu = 1400, domain_name = "ovn.org", wpad = "https://example.org", bootfile_name = "https://127.0.0.1/boot.ipxe", path_prefix = "/tftpboot", domain_search_list = "ovn.org,abc.ovn.org,def.ovn.org,ovn.test,def.ovn.test,test.org,abc.com");
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.25.0a.00.00.04.43.1b.68.74.74.70.73.3a.2f.2f.31.32.37.2e.30.2e.30.2e.31.2f.62.6f.6f.74.2e.69.70.78.65.03.04.0a.00.00.01.01.04.ff.ff.fe.00.1a.02.05.78.0f.07.6f.76.6e.2e.6f.72.67.fc.13.68.74.74.70.73.3a.2f.2f.65.78.61.6d.70.6c.65.2e.6f.72.67.d2.09.2f.74.66.74.70.62.6f.6f.74.77.35.03.6f.76.6e.03.6f.72.67.00.03.61.62.63.c0.00.03.64.65.66.c0.00.03.6f.76.6e.04.74.65.73.74.00.03.64.65.66.c0.15.04.74.65.73.74.c0.04.03.61.62.63.03.63.6f.6d.00,pause)

reg1[0..1] = put_dhcp_opts(offerip = 1.2.3.4, router = 10.0.0.1);
    Cannot use 2-bit field reg1[0..1] where 1-bit field is required.
reg1[0] = put_dhcp_opts();
    put_dhcp_opts requires offerip to be specified.
reg1[0] = put_dhcp_opts(x = 1.2.3.4, router = 10.0.0.1);
    Syntax error at `x' expecting DHCPv4 option name.
reg1[0] = put_dhcp_opts(router = 10.0.0.1);
    put_dhcp_opts requires offerip to be specified.
reg1[0] = put_dhcp_opts(offerip=1.2.3.4, "hi");
    Syntax error at `"hi"'.
reg1[0] = put_dhcp_opts(offerip=1.2.3.4, xyzzy);
    Syntax error at `xyzzy' expecting DHCPv4 option name.
reg1[0] = put_dhcp_opts(offerip="xyzzy");
    DHCPv4 option offerip requires numeric value.
reg1[0] = put_dhcp_opts(offerip=1.2.3.4, domain_name=1.2.3.4);
    DHCPv4 option domain_name requires string value.
reg1[0] = put_dhcp_opts(offerip=1.2.3.4, domain_search_list=1.2.3.4);
    DHCPv4 option domain_search_list requires string value.

# nd_ns
nd_ns { nd.target = xxreg0; output; };
    encodes as controller(userdata=00.00.00.09.00.00.00.00.00.1c.00.18.00.80.00.00.00.00.00.00.00.01.de.10.80.00.3e.10.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00)
    has prereqs ip6

nd_ns { };
    formats as nd_ns { drop; };
    encodes as controller(userdata=00.00.00.09.00.00.00.00)
    has prereqs ip6

# nd_na
nd_na { eth.src = 12:34:56:78:9a:bc; nd.tll = 12:34:56:78:9a:bc; outport = inport; inport = ""; /* Allow sending out inport. */ output; };
    formats as nd_na { eth.src = 12:34:56:78:9a:bc; nd.tll = 12:34:56:78:9a:bc; outport = inport; inport = ""; output; };
    encodes as controller(userdata=00.00.00.03.00.00.00.00.00.19.00.10.80.00.08.06.12.34.56.78.9a.bc.00.00.00.19.00.10.80.00.42.06.12.34.56.78.9a.bc.00.00.00.1c.00.18.00.20.00.00.00.00.00.00.00.01.1c.04.00.01.1e.04.00.00.00.00.00.19.00.10.00.01.1c.04.00.00.00.00.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00)
    has prereqs nd_ns
# nd_na_router
nd_na_router { eth.src = 12:34:56:78:9a:bc; nd.tll = 12:34:56:78:9a:bc; outport = inport; inport = ""; /* Allow sending out inport. */ output; };
    formats as nd_na_router { eth.src = 12:34:56:78:9a:bc; nd.tll = 12:34:56:78:9a:bc; outport = inport; inport = ""; output; };
    encodes as controller(userdata=00.00.00.0c.00.00.00.00.00.19.00.10.80.00.08.06.12.34.56.78.9a.bc.00.00.00.19.00.10.80.00.42.06.12.34.56.78.9a.bc.00.00.00.1c.00.18.00.20.00.00.00.00.00.00.00.01.1c.04.00.01.1e.04.00.00.00.00.00.19.00.10.00.01.1c.04.00.00.00.00.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00)
    has prereqs nd_ns

# get_nd
get_nd(outport, ip6.dst);
    encodes as push:NXM_NX_XXREG0[],push:NXM_NX_IPV6_DST[],pop:NXM_NX_XXREG0[],set_field:00:00:00:00:00:00->eth_dst,resubmit(,66),pop:NXM_NX_XXREG0[]
    has prereqs eth.type == 0x86dd
get_nd(inport, xxreg0);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],set_field:00:00:00:00:00:00->eth_dst,resubmit(,66),pop:NXM_NX_REG15[]
get_nd;
    Syntax error at `;' expecting `('.
get_nd();
    Syntax error at `)' expecting field name.
get_nd(inport);
    Syntax error at `)' expecting `,'.
get_nd(inport ip6.dst);
    Syntax error at `ip6.dst' expecting `,'.
get_nd(inport, ip6.dst;
    Syntax error at `;' expecting `)'.
get_nd(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 128-bit field is required.
get_nd(inport, outport);
    Cannot use string field outport where numeric field is required.
get_nd(xxreg0, ip6.dst);
    Cannot use numeric field xxreg0 where string field is required.

# put_nd
put_nd(inport, nd.target, nd.sll);
    encodes as push:NXM_NX_XXREG0[],push:NXM_OF_ETH_SRC[],push:NXM_NX_ND_SLL[],push:NXM_NX_ND_TARGET[],pop:NXM_NX_XXREG0[],pop:NXM_OF_ETH_SRC[],controller(userdata=00.00.00.04.00.00.00.00),pop:NXM_OF_ETH_SRC[],pop:NXM_NX_XXREG0[]
    has prereqs (icmp6.type == 0x87 || icmp6.type == 0x88) && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.code == 0 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && ip.ttl == 0xff && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.type == 0x87 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.code == 0 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && ip.ttl == 0xff && (eth.type == 0x800 || eth.type == 0x86dd)

# put_dhcpv6_opts
reg1[0] = put_dhcpv6_opts(ia_addr = ae70::4, server_id = 00:00:00:00:10:02);
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.05.00.10.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.04.00.02.00.06.00.00.00.00.10.02,pause)
reg1[0] = put_dhcpv6_opts();
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40,pause)
reg1[0] = put_dhcpv6_opts(dns_server={ae70::1,ae70::2});
    formats as reg1[0] = put_dhcpv6_opts(dns_server = {ae70::1, ae70::2});
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.17.00.20.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.01.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.02,pause)
reg1[0] = put_dhcpv6_opts(server_id=12:34:56:78:9a:bc, dns_server={ae70::1,ae89::2});
    formats as reg1[0] = put_dhcpv6_opts(server_id = 12:34:56:78:9a:bc, dns_server = {ae70::1, ae89::2});
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.02.00.06.12.34.56.78.9a.bc.00.17.00.20.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.01.ae.89.00.00.00.00.00.00.00.00.00.00.00.00.00.02,pause)
reg1[0] = put_dhcpv6_opts(domain_search = "ovn.org");
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.18.00.07.6f.76.6e.2e.6f.72.67,pause)
reg1[0] = put_dhcpv6_opts(x = 1.2.3.4);
    Syntax error at `x' expecting DHCPv6 option name.
reg1[0] = put_dhcpv6_opts(ia_addr=ae70::4, "hi");
    Syntax error at `"hi"'.
reg1[0] = put_dhcpv6_opts(ia_addr=ae70::4, xyzzy);
    Syntax error at `xyzzy' expecting DHCPv6 option name.
reg1[0] = put_dhcpv6_opts(ia_addr="ae70::4");
    DHCPv6 option ia_addr requires numeric value.
reg1[0] = put_dhcpv6_opts(ia_addr=ae70::4, domain_search=ae70::1);
    DHCPv6 option domain_search requires string value.

# lookup_nd
reg2[0] = lookup_nd(inport, ip6.dst, eth.src);
    encodes as push:NXM_NX_XXREG0[],push:NXM_NX_IPV6_DST[],pop:NXM_NX_XXREG0[],set_field:0/0x40->reg10,resubmit(,67),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[32],pop:NXM_NX_XXREG0[]
    has prereqs eth.type == 0x86dd
reg3[0] = lookup_nd(inport, nd.target, nd.tll);
    encodes as push:NXM_NX_XXREG0[],push:NXM_OF_ETH_SRC[],push:NXM_NX_ND_TLL[],push:NXM_NX_ND_TARGET[],pop:NXM_NX_XXREG0[],pop:NXM_OF_ETH_SRC[],set_field:0/0x40->reg10,resubmit(,67),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[0],pop:NXM_OF_ETH_SRC[],pop:NXM_NX_XXREG0[]
    has prereqs (icmp6.type == 0x87 || icmp6.type == 0x88) && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.code == 0 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && ip.ttl == 0xff && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.type == 0x88 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.code == 0 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && ip.ttl == 0xff && (eth.type == 0x800 || eth.type == 0x86dd)

lookup_nd;
    Syntax error at `lookup_nd' expecting action.
reg0[0] = lookup_nd;
    Syntax error at `lookup_nd' expecting field name.
reg0[0] = lookup_nd();
    Syntax error at `)' expecting field name.
reg0[0] = lookup_nd(inport);
    Syntax error at `)' expecting `,'.
reg0[0] = lookup_nd(inport ip6.dst);
    Syntax error at `ip6.dst' expecting `,'.
reg0[0] = lookup_nd(inport, ip6.dst;
    Syntax error at `;' expecting `,'.
reg0[0] = lookup_nd(inport, ip6.dst, eth.src;
    Syntax error at `;' expecting `)'.
reg0[0] = lookup_nd(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 128-bit field is required.
reg0[0] = lookup_nd(inport, ip4.src, ip4.dst);
    Cannot use 32-bit field ip4.src[0..31] where 128-bit field is required.
reg0[0] = lookup_nd(inport, ip6.src, ip6.dst);
    Cannot use 128-bit field ip6.dst[0..127] where 48-bit field is required.

# lookup_nd_ip
reg2[0] = lookup_nd_ip(inport, ip6.dst);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_XXREG0[],push:NXM_NX_IPV6_DST[],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],pop:NXM_NX_XXREG0[],push:NXM_OF_ETH_DST[],set_field:0/0x40->reg10,resubmit(,66),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[32],pop:NXM_OF_ETH_DST[],pop:NXM_NX_XXREG0[],pop:NXM_NX_REG15[]
    has prereqs eth.type == 0x86dd
reg3[0] = lookup_nd_ip(inport, nd.target);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_XXREG0[],push:NXM_NX_ND_TARGET[],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],pop:NXM_NX_XXREG0[],push:NXM_OF_ETH_DST[],set_field:0/0x40->reg10,resubmit(,66),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[0],pop:NXM_OF_ETH_DST[],pop:NXM_NX_XXREG0[],pop:NXM_NX_REG15[]
    has prereqs (icmp6.type == 0x87 || icmp6.type == 0x88) && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.code == 0 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && ip.ttl == 0xff && (eth.type == 0x800 || eth.type == 0x86dd)

lookup_nd_ip;
    Syntax error at `lookup_nd_ip' expecting action.
reg0[0] = lookup_nd_ip;
    Syntax error at `lookup_nd_ip' expecting field name.
reg0[0] = lookup_nd_ip();
    Syntax error at `)' expecting field name.
reg0[0] = lookup_nd_ip(inport);
    Syntax error at `)' expecting `,'.
reg0[0] = lookup_nd_ip(inport ip6.dst);
    Syntax error at `ip6.dst' expecting `,'.
reg0[0] = lookup_nd_ip(inport, ip6.dst;
    Syntax error at `;' expecting `)'.
reg0[0] = lookup_nd_ip(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 128-bit field is required.
reg0[0] = lookup_nd_ip(inport, ip4.src);
    Cannot use 32-bit field ip4.src[0..31] where 128-bit field is required.

# set_queue
set_queue(0);
    encodes as set_queue:0
set_queue(61440);
    encodes as set_queue:61440
set_queue(65535);
    Queue ID 65535 for set_queue is not in valid range 0 to 61440.

# dns_lookup
reg1[0] = dns_lookup();
    encodes as controller(userdata=00.00.00.06.00.00.00.00.00.01.de.10.00.00.00.40,pause)
    has prereqs udp
reg1[0] = dns_lookup("foo");
    dns_lookup doesn't take any parameters

# set_meter
set_meter(0);
    Rate 0 for set_meter is not in valid.
set_meter(1);
    encodes as meter:1
set_meter(100, 1000);
    encodes as meter:2
set_meter(100, 1000, );
    Syntax error at `,' expecting `)'.
set_meter(4294967295, 4294967295);
    encodes as meter:3

# log
log(verdict=allow, severity=warning);
    encodes as controller(userdata=00.00.00.07.00.00.00.00.00.04)
log(name="test1", verdict=drop, severity=info);
    encodes as controller(userdata=00.00.00.07.00.00.00.00.01.06.74.65.73.74.31)
log(verdict=drop, severity=info, meter="meter1");
    encodes as controller(userdata=00.00.00.07.00.00.00.00.01.06,meter_id=4)
log(name="test1", verdict=drop, severity=info, meter="meter1");
    encodes as controller(userdata=00.00.00.07.00.00.00.00.01.06.74.65.73.74.31,meter_id=4)
log(verdict=drop);
    formats as log(verdict=drop, severity=info);
    encodes as controller(userdata=00.00.00.07.00.00.00.00.01.06)
log(verdict=bad_verdict, severity=info);
    Syntax error at `bad_verdict' unknown verdict.
log(verdict=drop, severity=bad_severity);
    Syntax error at `bad_severity' unknown severity.
log(severity=notice);
    Syntax error at `;' expecting verdict.

# put_nd_ra_opts
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", mtu = 1500, router_preference = "HIGH", prefix = aef0::/64, slla = ae:01:02:03:04:05);
    encodes as controller(userdata=00.00.00.08.00.00.00.00.00.01.de.10.00.00.00.40.86.00.00.00.ff.08.ff.ff.00.00.00.00.00.00.00.00.05.01.00.00.00.00.05.dc.03.04.40.c0.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.ae.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.ae.01.02.03.04.05,pause)
    has prereqs ip6
reg1[0] = put_nd_ra_opts(addr_mode = "dhcpv6_stateful", router_preference = "MEDIUM", slla = ae:01:02:03:04:10, mtu = 1450);
    encodes as controller(userdata=00.00.00.08.00.00.00.00.00.01.de.10.00.00.00.40.86.00.00.00.ff.80.ff.ff.00.00.00.00.00.00.00.00.01.01.ae.01.02.03.04.10.05.01.00.00.00.00.05.aa,pause)
    has prereqs ip6
reg1[0] = put_nd_ra_opts(addr_mode = "dhcpv6_stateless", router_preference = "LOW", slla = ae:01:02:03:04:06, prefix = aef0::/64);
    encodes as controller(userdata=00.00.00.08.00.00.00.00.00.01.de.10.00.00.00.40.86.00.00.00.ff.58.ff.ff.00.00.00.00.00.00.00.00.01.01.ae.01.02.03.04.06.03.04.40.c0.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.ae.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00,pause)
    has prereqs ip6
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", mtu = 1500, prefix = aef0::/64);
    slla option not present
reg1[0] = put_nd_ra_opts(addr_mode = "dhcpv6_stateful", mtu = 1450, prefix = aef0::/64, prefix = bef0::/64, slla = ae:01:02:03:04:10);
    encodes as controller(userdata=00.00.00.08.00.00.00.00.00.01.de.10.00.00.00.40.86.00.00.00.ff.80.ff.ff.00.00.00.00.00.00.00.00.05.01.00.00.00.00.05.aa.03.04.40.80.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.ae.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.04.40.80.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.be.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.ae.01.02.03.04.10,pause)
    has prereqs ip6
reg1[0] = put_nd_ra_opts(addr_mode = "dhcpv6_stateful", mtu = 1450, prefix = aef0::/64, prefix = bef0::/64, slla = ae:01:02:03:04:10);
    encodes as controller(userdata=00.00.00.08.00.00.00.00.00.01.de.10.00.00.00.40.86.00.00.00.ff.80.ff.ff.00.00.00.00.00.00.00.00.05.01.00.00.00.00.05.aa.03.04.40.80.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.ae.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.04.40.80.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.be.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.ae.01.02.03.04.10,pause)
    has prereqs ip6
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", slla = ae:01:02:03:04:10);
    prefix option needs to be set when address mode is slaac/dhcpv6_stateless.
reg1[0] = put_nd_ra_opts(addr_mode = "dhcpv6_stateless", slla = ae:01:02:03:04:10);
    prefix option needs to be set when address mode is slaac/dhcpv6_stateless.
reg1[0] = put_nd_ra_opts(addr_mode = dhcpv6_stateless, prefix = aef0::/64, slla = ae:01:02:03:04:10);
    Syntax error at `dhcpv6_stateless' expecting constant.
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", mtu = 1500, prefix = aef0::, slla = ae:01:02:03:04:10);
    Invalid value for "prefix" option
reg1[0] = put_nd_ra_opts(addr_mode = "foo", mtu = 1500, slla = ae:01:02:03:04:10);
    Invalid value for "addr_mode" option
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", mtu = "1500", slla = ae:01:02:03:04:10);
    IPv6 ND RA option mtu requires numeric value.
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", mtu = 10.0.0.4, slla = ae:01:02:03:04:10);
    Invalid value for "mtu" option

# icmp4
icmp4 { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.0a.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip4

icmp4 { };
    formats as icmp4 { drop; };
    encodes as controller(userdata=00.00.00.0a.00.00.00.00)
    has prereqs ip4

# icmp4 with icmp4.frag_mtu
icmp4 { eth.dst = ff:ff:ff:ff:ff:ff; icmp4.frag_mtu = 1500; output; }; output;
    encodes as controller(userdata=00.00.00.0a.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.28.00.00.23.20.00.25.00.00.00.00.00.00.00.03.00.0e.00.00.00.0d.00.00.00.00.05.dc.00.00.00.04.00.04.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip4

# icmp4_error
icmp4_error { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.0e.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip4

icmp4_error { };
    formats as icmp4_error { drop; };
    encodes as controller(userdata=00.00.00.0e.00.00.00.00)
    has prereqs ip4

# icmp4_error with icmp4.frag_mtu
icmp4_error { eth.dst = ff:ff:ff:ff:ff:ff; icmp4.frag_mtu = 1500; output; }; output;
    encodes as controller(userdata=00.00.00.0e.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.28.00.00.23.20.00.25.00.00.00.00.00.00.00.03.00.0e.00.00.00.0d.00.00.00.00.05.dc.00.00.00.04.00.04.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip4

icmp4.frag_mtu = 1500;
    encodes as controller(userdata=00.00.00.0d.00.00.00.00.05.dc,pause)

# icmp6
icmp6 { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.0a.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip6

icmp6 { };
    formats as icmp6 { drop; };
    encodes as controller(userdata=00.00.00.0a.00.00.00.00)
    has prereqs ip6

# icmp6_error
icmp6_error { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.14.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip6

icmp6_error { };
    formats as icmp6_error { drop; };
    encodes as controller(userdata=00.00.00.14.00.00.00.00)
    has prereqs ip6

# icmp6_error with icmp6.frag_mtu
icmp6_error { eth.dst = ff:ff:ff:ff:ff:ff; icmp6.frag_mtu = 1500; output; }; output;
    encodes as controller(userdata=00.00.00.14.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.28.00.00.23.20.00.25.00.00.00.00.00.00.00.03.00.10.00.00.00.15.00.00.00.00.00.00.05.dc.00.04.00.04.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip6

icmp6.frag_mtu = 1500;
    encodes as controller(userdata=00.00.00.15.00.00.00.00.00.00.05.dc,pause)

# tcp_reset
tcp_reset { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.0b.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs tcp

tcp_reset { };
    formats as tcp_reset { drop; };
    encodes as controller(userdata=00.00.00.0b.00.00.00.00)
    has prereqs tcp

# sctp_abort
sctp_abort {eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    formats as sctp_abort { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.18.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs sctp

sctp_abort { };
    formats as sctp_abort { drop; };
    encodes as controller(userdata=00.00.00.18.00.00.00.00)
    has prereqs sctp

# reject
reject { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.16.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)

reject { };
    formats as reject { drop; };
    encodes as controller(userdata=00.00.00.16.00.00.00.00)

# trigger_event
trigger_event(event = "empty_lb_backends", vip = "10.0.0.1:80", protocol = "tcp", load_balancer = "12345678-abcd-9876-fedc-11119f8e7d6c");
    encodes as controller(userdata=00.00.00.0f.00.00.00.00.00.00.00.00.00.01.00.0b.31.30.2e.30.2e.30.2e.31.3a.38.30.00.02.00.03.74.63.70.00.03.00.24.31.32.33.34.35.36.37.38.2d.61.62.63.64.2d.39.38.37.36.2d.66.65.64.63.2d.31.31.31.31.39.66.38.65.37.64.36.63)

trigger_event(event = "empty_lb_backends", meter="event-elb" vip = "10.0.0.1:80", protocol = "tcp", load_balancer = "12345678-abcd-9876-fedc-11119f8e7d6c");
    formats as trigger_event(event = "empty_lb_backends", meter = "event-elb", vip = "10.0.0.1:80", protocol = "tcp", load_balancer = "12345678-abcd-9876-fedc-11119f8e7d6c");
    encodes as controller(userdata=00.00.00.0f.00.00.00.00.00.00.00.00.00.01.00.0b.31.30.2e.30.2e.30.2e.31.3a.38.30.00.02.00.03.74.63.70.00.03.00.24.31.32.33.34.35.36.37.38.2d.61.62.63.64.2d.39.38.37.36.2d.66.65.64.63.2d.31.31.31.31.39.66.38.65.37.64.36.63,meter_id=5)

# Testing invalid vip results in extra error messages from socket-util.c
trigger_event(event = "empty_lb_backends", vip = "10.0.0.1:80", protocol = "aarp", load_balancer = "12345678-abcd-9876-fedc-11119f8e7d6c");
    Load balancer protocol 'aarp' is not 'tcp', 'udp', or 'sctp'
trigger_event(event = "empty_lb_backends", vip = "10.0.0.1:80", protocol = "tcp", load_balancer = "bacon");
    Load balancer 'bacon' is not a UUID

# IGMP
igmp;
    encodes as controller(userdata=00.00.00.10.00.00.00.00)

# Contradictionary prerequisites (allowed but not useful):
ip4.src = ip6.src[0..31];
    encodes as move:NXM_NX_IPV6_SRC[0..31]->NXM_OF_IP_SRC[]
    has prereqs eth.type == 0x800 && eth.type == 0x86dd
ip4.src <-> ip6.src[0..31];
    encodes as push:NXM_NX_IPV6_SRC[0..31],push:NXM_OF_IP_SRC[],pop:NXM_NX_IPV6_SRC[0..31],pop:NXM_OF_IP_SRC[]
    has prereqs eth.type == 0x800 && eth.type == 0x86dd

# check_pkt_larger
reg0[0] = check_pkt_larger(1500);
    encodes as check_pkt_larger(1500)->NXM_NX_XXREG0[96]

reg0 = check_pkt_larger(1500);
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

reg0 = check_pkt_larger(foo);
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

reg0[0] = check_pkt_larger(foo);
    Syntax error at `foo' expecting `;'.

# bind_vport
# lsp1's port key is 0x11.
bind_vport("lsp1", inport);
    encodes as controller(userdata=00.00.00.11.00.00.00.00.00.00.00.11)
# lsp2 doesn't exist. So it should be encoded as drop.
bind_vport("lsp2", inport);
    encodes as drop
bind_vport;
    Syntax error at `;' expecting `('.
bind_vport(;
    Syntax error at `;' expecting port name string.
bind_vport("xyzzy";
    Syntax error at `;' expecting `,'.
bind_vport("xyzzy",;
    Syntax error at `;' expecting field name.
bind_vport("xyzzy", inport;
    Syntax error at `;' expecting `)'.

# handle_svc_check
handle_svc_check(inport);
    encodes as controller(userdata=00.00.00.12.00.00.00.00)

handle_svc_check(outport);
    encodes as push:NXM_NX_REG14[],push:NXM_NX_REG15[],pop:NXM_NX_REG14[],controller(userdata=00.00.00.12.00.00.00.00),pop:NXM_NX_REG14[]

handle_svc_check();
    Syntax error at `)' expecting field name.

handle_svc_check(reg0);
    Cannot use numeric field reg0 where string field is required.

# select
reg9[16..31] = select(1=50, 2=100, 3, );
    formats as reg9[16..31] = select(1=50, 2=100, 3=100);
    encodes as group:9
    uses group: id(9), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:50,actions=load:1->xreg4[16..31],resubmit(,19),bucket=bucket_id=1,weight:100,actions=load:2->xreg4[16..31],resubmit(,19),bucket=bucket_id=2,weight:100,actions=load:3->xreg4[16..31],resubmit(,19))

reg0 = select(1, 2);
    formats as reg0 = select(1=100, 2=100);
    encodes as group:10
    uses group: id(10), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=load:1->xxreg0[96..127],resubmit(,19),bucket=bucket_id=1,weight:100,actions=load:2->xxreg0[96..127],resubmit(,19))

reg0 = select(1=, 2);
    Syntax error at `,' expecting weight.
reg0 = select(1=0, 2);
    Syntax error at `,' weight can't be 0.
reg0 = select(1=123456, 2);
    Syntax error at `123456' expecting weight.
reg0 = select(123);
    Syntax error at `;' expecting at least 2 group members.
ip.proto = select(1, 2, 3);
    Field ip.proto is not modifiable.
reg0[0..14] = select(1, 2, 3);
    cannot use 15-bit field reg0[0..14] for "select", which requires at least 16 bits.

fwd_group(liveness=true, childports="eth0", "lsp1");
    formats as fwd_group(liveness="true", childports="eth0", "lsp1");
    encodes as group:11
    uses group: id(11), name(type=select,selection_method=dp_hash,bucket=watch_port:5,load=0x5->NXM_NX_REG15[0..15],resubmit(,64),bucket=watch_port:17,load=0x17->NXM_NX_REG15[0..15],resubmit(,64))

fwd_group(childports="eth0", "lsp1");
    encodes as group:12
    uses group: id(12), name(type=select,selection_method=dp_hash,bucket=load=0x5->NXM_NX_REG15[0..15],resubmit(,64),bucket=load=0x17->NXM_NX_REG15[0..15],resubmit(,64))

fwd_group(childports=eth0);
    Syntax error at `eth0' expecting logical switch port.

fwd_group();
    Syntax error at `)' expecting `;'.

fwd_group(childports="eth0", "lsp1");
    encodes as group:12
    uses group: id(12), name(type=select,selection_method=dp_hash,bucket=load=0x5->NXM_NX_REG15[0..15],resubmit(,64),bucket=load=0x17->NXM_NX_REG15[0..15],resubmit(,64))

fwd_group(liveness=xyzzy, childports="eth0", "lsp1");
    Syntax error at `xyzzy' expecting true or false.

fwd_group(liveness=false childports="eth0", "lsp1");
    Syntax error at `childports' expecting `,'.

# prefix delegation
handle_dhcpv6_reply;
    encodes as controller(userdata=00.00.00.13.00.00.00.00)

# chk_lb_hairpin
reg0[0] = chk_lb_hairpin();
    encodes as set_field:0/0x80->reg10,resubmit(,68),move:NXM_NX_REG10[7]->NXM_NX_XXREG0[96]

reg2[2] = chk_lb_hairpin();
    encodes as set_field:0/0x80->reg10,resubmit(,68),move:NXM_NX_REG10[7]->NXM_NX_XXREG0[34]

reg0 = chk_lb_hairpin();
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

reg0[0] = chk_lb_hairpin(foo);
    chk_lb_hairpin doesn't take any parameters

chk_lb_hairpin;
    Syntax error at `chk_lb_hairpin' expecting action.

# chk_lb_hairpin_reply
reg0[0] = chk_lb_hairpin_reply();
    encodes as set_field:0/0x80->reg10,resubmit(,69),move:NXM_NX_REG10[7]->NXM_NX_XXREG0[96]

reg2[2..3] = chk_lb_hairpin_reply();
    Cannot use 2-bit field reg2[2..3] where 1-bit field is required.

reg0 = chk_lb_hairpin_reply();
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

reg0[0] = chk_lb_hairpin_reply(foo);
    chk_lb_hairpin_reply doesn't take any parameters

chk_lb_hairpin_reply;
    Syntax error at `chk_lb_hairpin_reply' expecting action.

# ct_snat_to_vip
ct_snat_to_vip;
    encodes as resubmit(,70)

ct_snat_to_vip(foo);
    Syntax error at `(' expecting `;'.

# bfd packets
handle_bfd_msg();
    encodes as controller(userdata=00.00.00.17.00.00.00.00)

# put_fdb
put_fdb(inport, arp.sha);
    encodes as push:NXM_OF_ETH_SRC[],push:NXM_NX_ARP_SHA[],pop:NXM_OF_ETH_SRC[],controller(userdata=00.00.00.19.00.00.00.00),pop:NXM_OF_ETH_SRC[]
    has prereqs eth.type == 0x806

put_fdb(inport, eth.src);
    encodes as controller(userdata=00.00.00.19.00.00.00.00)

put_fdb(inport, ip4.src);
    Cannot use 32-bit field ip4.src[0..31] where 48-bit field is required.

# get_fdb
outport = get_fdb(eth.dst);
    encodes as set_field:0->reg15,resubmit(,71)

outport = get_fdb(eth.src);
    encodes as push:NXM_OF_ETH_DST[],push:NXM_OF_ETH_SRC[],pop:NXM_OF_ETH_DST[],set_field:0->reg15,resubmit(,71),pop:NXM_OF_ETH_DST[]

inport = get_fdb(arp.sha);
    encodes as push:NXM_OF_ETH_DST[],push:NXM_NX_ARP_SHA[],pop:NXM_OF_ETH_DST[],set_field:0->reg15,resubmit(,71),pop:NXM_OF_ETH_DST[],move:NXM_NX_REG15[]->NXM_NX_REG14[]
    has prereqs eth.type == 0x806

reg0 = get_fdb(arp.tha);
    encodes as push:NXM_OF_ETH_DST[],push:NXM_NX_ARP_THA[],pop:NXM_OF_ETH_DST[],set_field:0->reg15,resubmit(,71),pop:NXM_OF_ETH_DST[],move:NXM_NX_REG15[]->NXM_NX_XXREG0[96..127]
    has prereqs eth.type == 0x806

reg0[1..3] = get_fdb(eth.src);
    Cannot use 3-bit field reg0[1..3] where 32-bit field is required.

reg15 = get_fdb(eth.dst);
    Syntax error at `reg15' expecting field name.

outport = get_fdb(ip4.dst);
    Cannot use 32-bit field ip4.dst[0..31] where 48-bit field is required.

# lookup_fdb
reg0[0] = lookup_fdb(inport, eth.src);
    encodes as set_field:0/0x100->reg10,resubmit(,72),move:NXM_NX_REG10[8]->NXM_NX_XXREG0[96]

reg1[4] = lookup_fdb(outport, eth.dst);
    encodes as push:NXM_NX_REG14[],push:NXM_OF_ETH_SRC[],push:NXM_OF_ETH_DST[],push:NXM_NX_REG15[],pop:NXM_NX_REG14[],pop:NXM_OF_ETH_SRC[],set_field:0/0x100->reg10,resubmit(,72),pop:NXM_OF_ETH_SRC[],pop:NXM_NX_REG14[],move:NXM_NX_REG10[8]->NXM_NX_XXREG0[68]

reg0[0] = lookup_fdb(outport, arp.sha);
    encodes as push:NXM_NX_REG14[],push:NXM_OF_ETH_SRC[],push:NXM_NX_ARP_SHA[],push:NXM_NX_REG15[],pop:NXM_NX_REG14[],pop:NXM_OF_ETH_SRC[],set_field:0/0x100->reg10,resubmit(,72),pop:NXM_OF_ETH_SRC[],pop:NXM_NX_REG14[],move:NXM_NX_REG10[8]->NXM_NX_XXREG0[96]
    has prereqs eth.type == 0x806

reg0 = lookup_fdb(outport, arp.sha);
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

outport = lookup_fdb(outport, arp.sha);
    Cannot use string field outport where numeric field is required.

reg1[1] = lookup_fdb(outport, ip4.src);
    Cannot use 32-bit field ip4.src[0..31] where 48-bit field is required.

reg1[1] = lookup_fdb(ip4.src, eth.src);
    Cannot use numeric field ip4.src where string field is required.

# Miscellaneous negative tests.
;
    Syntax error at `;'.
xyzzy;
    Syntax error at `xyzzy' expecting action.
next; 123;
    Syntax error at `123'.
next; xyzzy;
    Syntax error at `xyzzy' expecting action.
next
    Syntax error at end of input expecting `;'.
]])
sed '/^[[ 	]]/d' test-cases.txt > input.txt
cp test-cases.txt expout
AT_CHECK([ovstest test-ovn parse-actions < input.txt], [0], [expout])
AT_CLEANUP

AT_BANNER([OVN end-to-end tests])

# 3 hypervisors, one logical switch, 3 logical ports per hypervisor
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 3 HVs, 1 LS, 3 lports/HV])
AT_KEYWORDS([ovnarp])
ovn_start

# Create hypervisors hv[123].
# Add vif1[123] to hv1, vif2[123] to hv2, vif3[123] to hv3.
# Add all of the vifs to a single logical switch lsw0.
# Turn on port security on all the vifs except vif[123]1.
# Make vif13, vif2[23], vif3[123] destinations for unknown MACs.
# Add some ACLs for Ethertypes 1234, 1235, 1236.
check ovn-nbctl ls-add lsw0
net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2 3; do
        check ovs-vsctl add-port br-int vif$i$j -- set Interface vif$i$j external-ids:iface-id=lp$i$j options:tx_pcap=hv$i/vif$i$j-tx.pcap options:rxq_pcap=hv$i/vif$i$j-rx.pcap ofport-request=$i$j
        check ovn-nbctl lsp-add lsw0 lp$i$j
        if test $j = 1; then
            check ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j 192.168.0.$i$j" unknown
        else
            if test $j = 3; then
                ip_addrs="192.168.0.$i$j fe80::ea2a:eaff:fe28:$i$j/64 192.169.0.$i$j"
            else
                ip_addrs="192.168.0.$i$j"
            fi
            check ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j $ip_addrs"
            check ovn-nbctl lsp-set-port-security lp$i$j f0:00:00:00:00:$i$j
        fi
    done
done
check ovn-nbctl acl-add lsw0 from-lport 1000 'eth.type == 0x1234' drop
check ovn-nbctl acl-add lsw0 from-lport 1000 'eth.type == 0x1235 && inport == "lp11"' drop
check ovn-nbctl acl-add lsw0 to-lport 1000 'eth.type == 0x1236 && outport == "lp33"' drop
ovn-nbctl create Address_Set name=set1 addresses=\"f0:00:00:00:00:11\",\"f0:00:00:00:00:21\",\"f0:00:00:00:00:31\"
check ovn-nbctl acl-add lsw0 to-lport 1000 'eth.type == 0x1237 && eth.src == $set1 && outport == "lp33"' drop

check ovn-nbctl pg-add pg1 lp22 lp33
check ovn-nbctl acl-add lsw0 to-lport 1000 'eth.type == 0x1238 && outport == @pg1' drop
check ovn-nbctl --wait=hv sync
wait_for_ports_up

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Make sure there is no attempt to adding duplicated flows by ovn-controller
AT_FAIL_IF([test -n "`grep duplicate hv1/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv2/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv3/ovn-controller.log`"])

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}

# test_packet INPORT DST SRC ETHTYPE OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 11 for vif11.
for i in 1 2 3; do
    for j in 1 2 3; do
        : > $i$j.expected
    done
done
test_packet() {
    local inport=$1 packet=$2$3$4; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local inport=$1 sha=$2 spa=$3 tpa=$4 reply_ha=$5
    local request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $request

    if test X$reply_ha = X; then
        # Expect to receive the broadcast ARP on the other logical switch ports
        # if no reply is expected.
        local i j
        for i in 1 2 3; do
            for j in 1 2 3; do
                if test $i$j != $inport; then
                    echo $request >> $i$j.expected
                fi
            done
        done
    else
        # Expect to receive the reply, if any.
        local reply=${sha}${reply_ha}08060001080006040002${reply_ha}${tpa}${sha}${spa}
        echo $reply >> $inport.expected
    fi
}

# Send packets between all pairs of source and destination ports:
#
# 1. Unicast packets are delivered to exactly one logical switch port
#    (except that packets destined to their input ports are dropped).
#
# 2. Broadcast and multicast are delivered to all logical switch ports
#    except the input port.
#
# 3. When port security is turned on, the switch drops packets from the wrong
#    MAC address.
#
# 4. The switch drops all packets with a VLAN tag.
#
# 5. The switch drops all packets with a multicast source address.  (This only
#    affects behavior when port security is turned off, since otherwise port
#    security would drop the packet anyway.)
#
# 6. The switch delivers packets with an unknown destination to logical
#    switch ports with "unknown" among their MAC addresses (and port
#    security disabled).
#
# 7. The switch drops unicast packets that violate an ACL.
#
# 8. The switch drops multicast and broadcast packets that violate an ACL.
#
# 9. OVN generates responses to ARP requests for known IPs, except for
#    requests from a port for the port's own IP.
#
# 10. No response to ARP requests for unknown IPs.

for is in 1 2 3; do
    for js in 1 2 3; do
        s=$is$js
        bcast=
        unknown=
        bacl2=
        bacl3=
        for id in 1 2 3; do
            for jd in 1 2 3; do
                d=$id$jd

                if test $d != $s; then unicast=$d; else unicast=; fi
                test_packet $s f000000000$d f000000000$s $s$d $unicast     #1

                if test $d != $s && test $js = 1; then
                    impersonate=$d
                else
                    impersonate=
                fi
                test_packet $s f000000000$d f00000000055 55$d $impersonate #3

                if test $d != $s && test $s != 11; then acl2=$d; else acl2=; fi
                if test $d != $s && test $d != 33; then acl3=$d; else acl3=; fi
                if test $d = $s || (test $js = 1 && test $d = 33); then
                    # Source of 11, 21, or 31 and dest of 33 should be dropped
                    # due to the 4th ACL that uses address_set(set1).
                    acl4=
                else
                    acl4=$d
                fi
                if test $d = $s || test $d = 22 || test $d = 33; then
                    # dest of 22 and 33 should be dropped
                    # due to the 5th ACL that uses port_group(pg1).
                    acl5=
                else
                    acl5=$d
                fi
                test_packet $s f000000000$d f000000000$s 1234        #7, acl1
                test_packet $s f000000000$d f000000000$s 1235 $acl2  #7, acl2
                test_packet $s f000000000$d f000000000$s 1236 $acl3  #7, acl3
                test_packet $s f000000000$d f000000000$s 1237 $acl4  #7, acl4
                test_packet $s f000000000$d f000000000$s 1238 $acl5  #7, acl5

                test_packet $s f000000000$d f00000000055 810000091234      #4
                test_packet $s f000000000$d 0100000000$s $s$d              #5

                if test $d != $s && test $jd = 1; then
                    unknown="$unknown $d"
                fi
                bcast="$bcast $unicast"
                bacl2="$bacl2 $acl2"
                bacl3="$bacl3 $acl3"

                sip=`ip_to_hex 192 168 0 $is$js`
                tip=`ip_to_hex 192 168 0 $id$jd`
                tip_unknown=`ip_to_hex 11 11 11 11`
                reply_ha=;
                if test $d != $s; then
                    if test $jd != 1; then
                        reply_ha=f000000000$d
                    fi
                fi

                test_arp $s f000000000$s $sip $tip $reply_ha               #9
                test_arp $s f000000000$s $sip $tip_unknown                 #10

                if test $jd = 3; then
                    # lsp[123]3 has an additional ip 192.169.0.[123]3.
                    tip=`ip_to_hex 192 169 0 $id$jd`
                    test_arp $s f000000000$s $sip $tip $reply_ha           #9
                fi
            done
        done

        # Broadcast and multicast.
        test_packet $s ffffffffffff f000000000$s ${s}ff $bcast             #2
        test_packet $s 010000000000 f000000000$s ${s}ff $bcast             #2
        if test $js = 1; then
            bcast_impersonate=$bcast
        else
            bcast_impersonate=
        fi
        test_packet $s 010000000000 f00000000044 44ff $bcast_impersonate   #3

        test_packet $s f0000000ffff f000000000$s ${s}66 $unknown           #6

        test_packet $s ffffffffffff f000000000$s 1234                #8, acl1
        test_packet $s ffffffffffff f000000000$s 1235 $bacl2         #8, acl2
        test_packet $s ffffffffffff f000000000$s 1236 $bacl3         #8, acl3
        test_packet $s 010000000000 f000000000$s 1234                #8, acl1
        test_packet $s 010000000000 f000000000$s 1235 $bacl2         #8, acl2
        test_packet $s 010000000000 f000000000$s 1236 $bacl3         #8, acl3
    done
done

# set address for lp13 with invalid characters.
# lp13 should be configured with only 192.168.0.13.
check ovn-nbctl --wait=hv lsp-set-addresses lp13 "f0:00:00:00:00:13 192.168.0.13 invalid 192.169.0.13"

sip=`ip_to_hex 192 168 0 11`
tip=`ip_to_hex 192 168 0 13`
test_arp 11 f00000000011  $sip $tip f00000000013

tip=`ip_to_hex 192 169 0 13`
#arp request for 192.169.0.13 should be flooded
test_arp 11 f00000000011  $sip $tip

# dump information and flows with counters
ovn-sbctl dump-flows -- list multicast_group > sbflows
AT_CAPTURE_FILE([sbflows])

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    for j in 1 2 3; do
        OVN_CHECK_PACKETS([hv$i/vif$i$j-tx.pcap], [$i$j.expected])
    done
done

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

# 2 hypervisors, one logical switch, 2 logical ports per hypervisor
# logical ports bound to chassis encap-ip.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 1 LS, 2 lports/HV])
AT_KEYWORDS([ovnarp])
ovn_start

# Create hypervisors hv[12].
# Add vif1[12] to hv1, vif2[12] to hv2
ovn-nbctl ls-add lsw0
net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2; do
        ovs-vsctl add-port br-int vif$i$j -- set Interface vif$i$j external-ids:iface-id=lp$i$j options:tx_pcap=hv$i/vif$i$j-tx.pcap options:rxq_pcap=hv$i/vif$i$j-rx.pcap ofport-request=$i$j
        ovn-nbctl lsp-add lsw0 lp$i$j
        ip_addrs="192.168.0.$i$j"
        ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j $ip_addrs"
        ovn-nbctl --wait=hv lsp-set-port-security lp$i$j f0:00:00:00:00:$i$j
    done
done

get_lsp_uuid () {
    ovn-nbctl lsp-list lsw0 | grep $1 | awk '{ print $1 }'
}

# XXX-Check how to pass lp$i1 in AT_CHECK_UNQUOTED, for now just do it
# explictly

# For Chassis hv1
check_row_count Port_Binding 1 logical_port=lp11 'encap=[[]]'
check_row_count Port_Binding 1 logical_port=lp12 'encap=[[]]'

# For Chassis hv2
check_row_count Port_Binding 1 logical_port=lp21 'encap=[[]]'
check_row_count Port_Binding 1 logical_port=lp22 'encap=[[]]'

# Bind the ports to the encap-ip
for i in 1 2; do
    for j in 1 2; do
        as hv$i
        ovs-vsctl set Interface vif$i$j external-ids:encap-ip=192.168.0.$i
    done
done

# Wait for bindings to take effect.
wait_row_count Port_Binding 1 logical_port=lp11 'encap!=[[]]'
wait_row_count Port_Binding 1 logical_port=lp12 'encap!=[[]]'
wait_row_count Port_Binding 1 logical_port=lp21 'encap!=[[]]'
wait_row_count Port_Binding 1 logical_port=lp22 'encap!=[[]]'

# dump port bindings; since we have vxlan and geneve tunnels, we expect the
# ports to be bound to geneve tunnels.

# For Chassis 1
encap_rec=$(fetch_column Encap _uuid chassis_name=hv1 type=geneve ip=192.168.0.1)
check_row_count Port_Binding 1 logical_port=lp11 encap=$encap_rec
check_row_count Port_Binding 1 logical_port=lp12 encap=$encap_rec

# For Chassis 2
encap_rec=$(fetch_column Encap _uuid chassis_name=hv2 type=geneve ip=192.168.0.2)
check_row_count Port_Binding 1 logical_port=lp21 encap=$encap_rec
check_row_count Port_Binding 1 logical_port=lp22 encap=$encap_rec

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Make sure there is no attempt to adding duplicated flows by ovn-controller
AT_FAIL_IF([test -n "`grep duplicate hv1/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv2/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv3/ovn-controller.log`"])

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}

# test_packet INPORT DST SRC ETHTYPE OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 11 for vif11.
for i in 1 2; do
    for j in 1 2; do
        : > $i$j.expected
    done
done
test_packet() {
    local inport=$1 packet=$2$3$4; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Send packets between all pairs of source and destination ports:
#
# 1. Unicast packets are delivered to exactly one logical switch port
#    (except that packets destined to their input ports are dropped).

for is in 1 2; do
    for js in 1 2; do
        s=$is$js
        bcast=
        unknown=
        bacl2=
        bacl3=
        for id in 1 2 3; do
            for jd in 1 2 3; do
                d=$id$jd

                if test $d != $s; then unicast=$d; else unicast=; fi
                test_packet $s f000000000$d f000000000$s $s$d $unicast     #1
            done
        done

    done
done

# dump information and flows with counters
ovn-sbctl dump-flows -- list multicast_group

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv3 dump ------"
as hv3 ovs-vsctl show
as hv3 ovs-ofctl -O OpenFlow13 dump-flows br-int

# Now check the packets actually received against the ones expected.
for i in 1 2; do
    for j in 1 2; do
        OVN_CHECK_PACKETS([hv$i/vif$i$j-tx.pcap], [$i$j.expected])
    done
done

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- trace 1 LS, 3 LSPs])
ovn_start

# Create a logical switch and some logical ports.
# Turn on port security on all lports except ls1.
# Make ls1 a destination for unknown MACs.
# Add some ACLs for Ethertypes 1234, 1235, 1236.
ovn-nbctl ls-add lsw0
ovn-sbctl chassis-add hv0 geneve 127.0.0.1
for i in 1 2 3; do
    ovn-nbctl lsp-add lsw0 lp$i
done
ovn-nbctl --wait=sb sync
for i in 1 2 3; do
    ovn-sbctl lsp-bind lp$i hv0
    if test $i = 1; then
        ovn-nbctl lsp-set-addresses lp$i "f0:00:00:00:00:0$i 192.168.0.$i" unknown
    else
        if test $i = 3; then
           ip_addrs="192.168.0.$i fe80::ea2a:eaff:fe28:$i/64 192.169.0.$i"
        else
           ip_addrs="192.168.0.$i"
        fi
        ovn-nbctl lsp-set-addresses lp$i "f0:00:00:00:00:0$i $ip_addrs"
        ovn-nbctl lsp-set-port-security lp$i f0:00:00:00:00:0$i
    fi
done
ovn-nbctl acl-add lsw0 from-lport 1000 'eth.type == 0x1234' drop
ovn-nbctl acl-add lsw0 from-lport 1000 'eth.type == 0x1235 && inport == "lp1"' drop
ovn-nbctl acl-add lsw0 to-lport 1000 'eth.type == 0x1236 && outport == "lp3"' drop
ovn-nbctl create Address_Set name=set1 addresses=\"f0:00:00:00:00:01\",\"f0:00:00:00:00:02\"
ovn-nbctl acl-add lsw0 to-lport 1000 'eth.type == 0x1237 && eth.src == $set1 && outport == "lp3"' drop

ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])
on_exit 'kill `cat ovn-trace.pid`'
ovn-trace --detach --pidfile --no-chdir

# test_packet INPORT DST SRC [-vlan] [-eth TYPE] OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 11 for vif11.
test_packet() {
    local inport=$1 eth_dst=$2 eth_src=$3; shift; shift; shift
    uflow="inport==\"lp$inport\" && eth.dst==$eth_dst && eth.src==$eth_src"
    while :; do
        case $1 in # (
            -vlan) uflow="$uflow && vlan.vid == 1234"; shift ;; # (
            -eth) uflow="$uflow && eth.type == 0x$2"; shift; shift ;; # (
            *) break ;;
        esac
    done
    for outport; do
        echo "output(\"lp$outport\");"
    done > expout

    AT_CAPTURE_FILE([trace])
    AT_CHECK([ovs-appctl -t ovn-trace trace --all lsw0 "$uflow" | tee trace | sed '1,/Minimal trace/d'], [0], [expout])
}

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local inport=$1 sha=$2 spa=$3 tpa=$4 reply_ha=$5

    local request="inport == \"lp$inport\"
                   && eth.dst == ff:ff:ff:ff:ff:ff && eth.src == $sha
                   && arp.op == 1 && arp.sha == $sha && arp.spa == $spa
                   && arp.tha == ff:ff:ff:ff:ff:ff && arp.tpa == $tpa"

    if test -z "$reply_ha"; then
        reply=
        local i
        for i in 1 2 3; do
            if test $i != $inport; then
                reply="${reply}output(\"lp$i\");
"
            fi
        done
    else
        reply="\
eth.dst = $sha;
eth.src = $reply_ha;
arp.op = 2;
arp.tha = $sha;
arp.sha = $reply_ha;
arp.tpa = $spa;
arp.spa = $tpa;
output(\"lp$inport\");
"
    fi

    AT_CAPTURE_FILE([trace])
    AT_CHECK_UNQUOTED([ovs-appctl -t ovn-trace trace --all lsw0 "$request" | tee trace | sed '1,/Minimal trace/d'], [0], [$reply])
}

# Send packets between all pairs of source and destination ports:
#
# 1. Unicast packets are delivered to exactly one logical switch port
#    (except that packets destined to their input ports are dropped).
#
# 2. Broadcast and multicast are delivered to all logical switch ports
#    except the input port.
#
# 3. When port security is turned on, the switch drops packets from the wrong
#    MAC address.
#
# 4. The switch drops all packets with a VLAN tag.
#
# 5. The switch drops all packets with a multicast source address.  (This only
#    affects behavior when port security is turned off, since otherwise port
#    security would drop the packet anyway.)
#
# 6. The switch delivers packets with an unknown destination to logical
#    switch ports with "unknown" among their MAC addresses (and port
#    security disabled).
#
# 7. The switch drops unicast packets that violate an ACL.
#
# 8. The switch drops multicast and broadcast packets that violate an ACL.
#
# 9. OVN generates responses to ARP requests for known IPs, except for
#    requests from a port for the port's own IP.
#
# 10. No response to ARP requests for unknown IPs.

for s in 1 2 3; do
    bcast=
    unknown=
    bacl2=
    bacl3=
    for d in 1 2 3; do
        echo
        echo "lp$s -> lp$d"
        if test $d != $s; then unicast=$d; else unicast=; fi
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:0$s $unicast      #1

        if test $d != $s && test $s = 1; then
            impersonate=$d
        else
            impersonate=
        fi
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:55 $impersonate   #3

        if test $d != $s && test $s != 1; then acl2=$d; else acl2=; fi
        if test $d != $s && test $d != 3; then acl3=$d; else acl3=; fi
        if test $d = $s || ( (test $s = 1 || test $s = 2) && test $d = 3); then
            # Source of 1 or 2 and dest of 3 should be dropped
            # due to the 4th ACL that uses address_set(set1).
            acl4=
        else
            acl4=$d
        fi

        #7, acl1 to acl4:
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:0$s -eth 1234
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:0$s -eth 1235 $acl2
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:0$s -eth 1236 $acl3
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:0$s -eth 1237 $acl4

        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:55 -vlan          #4
        test_packet $s f0:00:00:00:00:0$d 01:00:00:00:00:0$s               #5

        if test $d != $s && test $d = 1; then
            unknown="$unknown $d"
        fi
        bcast="$bcast $unicast"
        bacl2="$bacl2 $acl2"
        bacl3="$bacl3 $acl3"

        sip=192.168.0.$s
        tip=192.168.0.$d
        tip_unknown=11.11.11.11
        reply_ha=;
        if test $d != $s; then
            if test $d != 1; then
                reply_ha=f0:00:00:00:00:0$d;
            fi
        fi

        test_arp $s f0:00:00:00:00:0$s $sip $tip $reply_ha                 #9
        test_arp $s f0:00:00:00:00:0$s $sip $tip_unknown                   #10

        if test $d = 3; then
            # lp3 has an additional ip 192.169.0.[123]3.
            tip=192.169.0.$d
            test_arp $s f0:00:00:00:00:0$s $sip $tip $reply_ha             #9
        fi
    done

    # Broadcast and multicast.
    test_packet $s ff:ff:ff:ff:ff:ff f0:00:00:00:00:0$s $bcast             #2
    test_packet $s 01:00:00:00:00:00 f0:00:00:00:00:0$s $bcast             #2
    if test $s = 1; then
       bcast_impersonate=$bcast
    else
       bcast_impersonate=
    fi
    test_packet $s 01:00:00:00:00:00 f0:00:00:00:00:44 $bcast_impersonate  #3

    test_packet $s f0:00:00:00:ff:ff f0:00:00:00:00:0$s $unknown           #6

    #8, acl1 to acl3:
    test_packet $s ff:ff:ff:ff:ff:ff f0:00:00:00:00:0$s -eth 1234
    test_packet $s ff:ff:ff:ff:ff:ff f0:00:00:00:00:0$s -eth 1235 $bacl2
    test_packet $s ff:ff:ff:ff:ff:ff f0:00:00:00:00:0$s -eth 1236 $bacl3

    #8, acl1 to acl3:
    test_packet $s 01:00:00:00:00:00 f0:00:00:00:00:0$s -eth 1234
    test_packet $s 01:00:00:00:00:00 f0:00:00:00:00:0$s -eth 1235 $bacl2
    test_packet $s 01:00:00:00:00:00 f0:00:00:00:00:0$s -eth 1236 $bacl3
done

# send packets for unknown datapath
AT_CAPTURE_FILE([trace])
AT_CHECK_UNQUOTED([ovs-appctl -t ovn-trace trace --all lsw100 "inport == p100 && ip4.dst == 10.96.57.175"], [0], [dnl
unknown datapath "lsw100"
])

AT_CLEANUP
])

# 2 hypervisors, 4 logical ports per HV
# 2 locally attached networks (one flat, one vlan tagged over same device)
# 2 ports per HV on each network
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 4 lports/HV, localnet ports])
ovn_start

# In this test cases we create 3 switches, all connected to same
# physical network (through br-phys on each HV). Each switch has
# VIF ports across 2 HVs. Each HV has 5 VIF ports. The first digit
# of VIF port name indicates the hypervisor it is bound to, e.g.
# lp23 means VIF 3 on hv2.
#
# Each switch's VLAN tag and their logical switch ports are:
#   - ls1:
#       - untagged
#       - ports: lp11, lp12, lp21, lp22
#
#   - ls2:
#       - tagged with VLAN 101
#       - ports: lp13, lp14, lp23, lp24
#   - ls3:
#       - untagged
#       - ports: lp15, lp25
#
# Note: a localnet port is created for each switch to connect to
# physical network.

for i in 1 2 3; do
    ls_name=ls$i
    ovn-nbctl ls-add $ls_name
    ln_port_name=ln$i
    if test $i -eq 2; then
        ovn-nbctl lsp-add $ls_name $ln_port_name "" 101
    else
        ovn-nbctl lsp-add $ls_name $ln_port_name
    fi
    ovn-nbctl lsp-set-addresses $ln_port_name unknown
    ovn-nbctl lsp-set-type $ln_port_name localnet
    ovn-nbctl lsp-set-options $ln_port_name network_name=phys
done

# lsp_to_ls LSP
#
# Prints the name of the logical switch that contains LSP.
lsp_to_ls () {
    case $1 in dnl (
        lp?[[12]]) echo ls1 ;; dnl (
        lp?[[34]]) echo ls2 ;; dnl (
        lp?5) echo ls3 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2 3 4 5; do
        ovs-vsctl add-port br-int vif$i$j -- \
            set Interface vif$i$j external-ids:iface-id=lp$i$j \
                                  options:tx_pcap=hv$i/vif$i$j-tx.pcap \
                                  options:rxq_pcap=hv$i/vif$i$j-rx.pcap \
                                  ofport-request=$i$j

        lsp_name=lp$i$j
        ls_name=$(lsp_to_ls $lsp_name)

        ovn-nbctl lsp-add $ls_name $lsp_name
        ovn-nbctl lsp-set-addresses $lsp_name f0:00:00:00:00:$i$j
        ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:$i$j

        OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])
    done
done
wait_for_ports_up
ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

OVN_POPULATE_ARP

# XXX This is now the 3rd copy of these functions in this file ...

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}
#
# test_packet INPORT DST SRC ETHTYPE EOUT LOUT
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  INPORT is specified as
# logical switch port numbers, e.g. 11 for vif11.
#
# EOUT is the end-to-end output port, that is, where the packet will end up
# after possibly bouncing through one or more localnet ports.  LOUT is the
# logical output port, which might be a localnet port, as seen by ovn-trace
# (which doesn't know what localnet ports are connected to and therefore can't
# figure out the end-to-end answer).
for i in 1 2; do
    for j in 1 2 3 4 5; do
        : > $i$j.expected
    done
done
test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6
    echo "$@"

    # First try tracing the packet.
    uflow="inport==\"lp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    if test $lout != drop; then
        echo "output(\"$lout\");"
    fi > expout
    AT_CAPTURE_FILE([trace])
    AT_CHECK([ovn-trace --all $(lsp_to_ls lp$inport) "$uflow" | tee trace | sed '1,/Minimal trace/d'], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    hv=`vif_to_hv $inport`
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    if test $eout != drop; then
        echo $packet >> ${eout#lp}.expected
    fi
}

# lp11 and lp21 are on the same network (phys, untagged)
# and on different hypervisors
test_packet 11 f0:00:00:00:00:21 f0:00:00:00:00:11 1121 lp21 lp21
test_packet 21 f0:00:00:00:00:11 f0:00:00:00:00:21 2111 lp11 lp11

# lp11 and lp12 are on the same network (phys, untagged)
# and on the same hypervisor
test_packet 11 f0:00:00:00:00:12 f0:00:00:00:00:11 1112 lp12 lp12
test_packet 12 f0:00:00:00:00:11 f0:00:00:00:00:12 1211 lp11 lp11

# lp13 and lp23 are on the same network (phys, VLAN 101)
# and on different hypervisors
test_packet 13 f0:00:00:00:00:23 f0:00:00:00:00:13 1323 lp23 lp23
test_packet 23 f0:00:00:00:00:13 f0:00:00:00:00:23 2313 lp13 lp13

# lp13 and lp14 are on the same network (phys, VLAN 101)
# and on the same hypervisor
test_packet 13 f0:00:00:00:00:14 f0:00:00:00:00:13 1314 lp14 lp14
test_packet 14 f0:00:00:00:00:13 f0:00:00:00:00:14 1413 lp13 lp13

# lp11 and lp15 are on the same network (phys, untagged),
# same hypervisor, and on different switches
test_packet 11 f0:00:00:00:00:15 f0:00:00:00:00:11 1115 lp15 ln1
test_packet 15 f0:00:00:00:00:11 f0:00:00:00:00:15 1511 lp11 ln3

# lp11 and lp25 are on the same network (phys, untagged),
# different hypervisors, and on different switches
test_packet 11 f0:00:00:00:00:25 f0:00:00:00:00:11 1125 lp25 ln1
test_packet 25 f0:00:00:00:00:11 f0:00:00:00:00:25 2511 lp11 ln3

# Ports that should not be able to communicate
test_packet 11 f0:00:00:00:00:13 f0:00:00:00:00:11 1113 drop ln1
test_packet 11 f0:00:00:00:00:23 f0:00:00:00:00:11 1123 drop ln1
test_packet 21 f0:00:00:00:00:13 f0:00:00:00:00:21 2113 drop ln1
test_packet 21 f0:00:00:00:00:23 f0:00:00:00:00:21 2123 drop ln1
test_packet 13 f0:00:00:00:00:11 f0:00:00:00:00:13 1311 drop ln2
test_packet 13 f0:00:00:00:00:21 f0:00:00:00:00:13 1321 drop ln2
test_packet 23 f0:00:00:00:00:11 f0:00:00:00:00:23 2311 drop ln2
test_packet 23 f0:00:00:00:00:21 f0:00:00:00:00:23 2321 drop ln2

# Dump a bunch of info helpful for debugging if there's a failure.

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int

# Now check the packets actually received against the ones expected.
for i in 1 2; do
    for j in 1 2 3 4 5; do
        OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv$i/vif$i$j-tx.pcap], [$i$j.expected])
    done
done

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 2 LS, routing works for multiple collocated segments attached to different switches])
ovn_start

for tag in `seq 10 30`; do
    net_add n-$tag
done

for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys11
    ovs-vsctl add-br br-phys21
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-11:br-phys11,phys-21:br-phys21
    ovn_attach n-11 br-phys11 192.168.0.${i}1
    ovn_attach n-21 br-phys21 192.168.0.${i}2
done

for i in 1 2; do
    lsname=ls-${i}0
    ovn-nbctl ls-add $lsname
    for tag in `seq ${i}1 ${i}9`; do
        ln_port_name=ln-$tag
        ovn-nbctl lsp-add $lsname $ln_port_name "" $tag
        ovn-nbctl lsp-set-addresses $ln_port_name unknown
        ovn-nbctl lsp-set-type $ln_port_name localnet
        ovn-nbctl lsp-set-options $ln_port_name network_name=phys-$tag
    done
done

for hv in 1 2; do
    as hv-$hv
    for ls in 1 2; do
        lsp_name=lp-$hv-$ls
        ovs-vsctl add-port br-int vif-$hv-$ls -- \
            set Interface vif-$hv-$ls external-ids:iface-id=$lsp_name \
                                  options:tx_pcap=hv-$hv/vif-$hv-$ls-tx.pcap \
                                  options:rxq_pcap=hv-$hv/vif-$hv-$ls-rx.pcap \
                                  ofport-request=$hv$ls

        ovn-nbctl lsp-add ls-${ls}0 $lsp_name
        ovn-nbctl lsp-set-addresses $lsp_name f0:00:00:00:00:${hv}${ls}
        ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:${hv}${ls}

        OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])
    done
done


wait_for_ports_up
ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

ovn-nbctl show > nbctl-show
AT_CAPTURE_FILE([nbctl-show])
ovn-sbctl show > sbctl-show
AT_CAPTURE_FILE([sbctl-show])

for i in 1 2; do
    hv=hv-$i
    echo "------ $hv dump ------"
    as $hv ovs-vsctl show
    as $hv ovs-ofctl -O OpenFlow13 dump-flows br-int
done

# vif ports
for i in 1-1 1-2 2-1 2-2; do
    : > vif-$i.expected
done

# localnet ports
for hv in 1 2; do
    : > out-$hv.expected
done

test_packet() {
    local hv=$1 inport=$2 outport=$3 dst=$4 src=$5 eth=$6 lout=$7

    : > expout
    if test $lout = unknown; then
        # Expect the packet cloned to all localnet ports
        for tag in `seq ${hv}1 ${hv}9`; do
            echo "output(\"ln-$tag\");" >> expout
        done
    else
        echo "output(\"$lout\");" >> expout
    fi

    # First try tracing the packet.
    uflow="inport==\"lp-$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    AT_CAPTURE_FILE([trace])
    AT_CHECK([ovn-trace --all ls-${hv}0 "$uflow" | tee trace | sed '1,/Minimal trace/d'], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    as hv-$hv ovs-appctl netdev-dummy/receive vif-$inport $packet

    if test $lout != unknown; then
        # Expect the packet received by the peer VIF port
        echo $packet >> vif-$outport.expected
    fi

    # regardless, the packet is sent through the bridge
    local packet=$(echo $dst$src | sed 's/://g')810000$(printf "%.2x\n" ${hv}1)${eth}
    echo $packet >> out-$hv.expected
}

test_packet 1 1-1 2-1 f0:00:00:00:00:21 f0:00:00:00:00:11 1001 lp-2-1
test_packet 2 2-2 1-2 f0:00:00:00:00:12 f0:00:00:00:00:22 1001 lp-1-2

# unknown mac goes through localnet port
test_packet 1 1-1 2-1 f0:00:00:00:00:e0 f0:00:00:00:00:11 1001 unknown
test_packet 2 2-2 1-2 f0:00:00:00:00:e0 f0:00:00:00:00:22 1001 unknown

# Now check the packets actually received against the ones expected.
for hv in 1 2; do
    for ls in 1 2; do
        port=$hv-$ls
        # check that packets targeted to actual vifs arrived on the other end
        OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv-$hv/vif-$port-tx.pcap], [vif-$port.expected])
    done
    # check that all packets, whether to known or unknown mac addresses, were sent to fabric
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv-$hv/br-phys${hv}1_n-${hv}1-tx.pcap], [out-$hv.expected])
done

OVN_CLEANUP([hv-1],[hv-2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 2 LS, broadcast traffic with multiple localnet ports per switch])
ovn_start

for tag in `seq 10 30`; do
    net_add n-$tag
done

for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys11
    ovs-vsctl add-br br-phys21
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-11:br-phys11,phys-21:br-phys21
    ovn_attach n-11 br-phys11 192.168.0.${i}1
    ovn_attach n-21 br-phys21 192.168.0.${i}2
done

for i in 1 2; do
    lsname=ls-${i}0
    ovn-nbctl ls-add $lsname
    for tag in `seq ${i}1 ${i}9`; do
        ln_port_name=ln-$tag
        ovn-nbctl lsp-add $lsname $ln_port_name "" $tag
        ovn-nbctl lsp-set-addresses $ln_port_name unknown
        ovn-nbctl lsp-set-type $ln_port_name localnet
        ovn-nbctl lsp-set-options $ln_port_name network_name=phys-$tag
    done
done

for hv in 1 2; do
    as hv-$hv
    for ls in 1 2; do
        for peer in 8 9; do
            lsp_name=lp-$hv-$ls-$peer
            ovs-vsctl add-port br-int vif-$hv-$ls-$peer -- \
                set Interface vif-$hv-$ls-$peer external-ids:iface-id=$lsp_name \
                                      options:tx_pcap=hv-$hv/vif-$hv-$ls-$peer-tx.pcap \
                                      options:rxq_pcap=hv-$hv/vif-$hv-$ls-$peer-rx.pcap \
                                      ofport-request=$hv$ls$peer

            ovn-nbctl lsp-add ls-${ls}0 $lsp_name
            ovn-nbctl lsp-set-addresses $lsp_name f0:00:00:00:0${peer}:${hv}${ls}
            ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:0${peer}:${hv}${ls}

            OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])

            : > vif-$hv-$ls-$peer.expected
        done
    done
done


wait_for_ports_up
ovn-nbctl --wait=sb sync
ovn-nbctl show
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

for i in 1 2; do
    hv=hv-$i
    echo "------ $hv dump ------"
    as $hv ovs-vsctl show
    as $hv ovs-ofctl -O OpenFlow13 dump-flows br-int
done

# localnet ports
for hv in 1 2; do
    : > out-$hv.expected
done

test_packet() {
    local hv=$1 inport=$2 dst=$3 src=$4 eth=$5
    shift; shift; shift; shift; shift

    : > expout
    for lout in "$@"; do
        if test $lout = unknown; then
            # Expect the packet cloned to all localnet ports
            for tag in `seq ${hv}1 ${hv}9`; do
                echo "output(\"ln-$tag\");" >> expout
            done
        else
            echo "output(\"$lout\");" >> expout
        fi
    done

    # First try tracing the packet.
    uflow="inport==\"lp-$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    AT_CAPTURE_FILE([trace])
    AT_CHECK([ovn-trace --all ls-${hv}0 "$uflow" | tee trace | sed '1,/Minimal trace/d' | sort], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    as hv-$hv ovs-appctl netdev-dummy/receive vif-$inport $packet

    for lout in "$@"; do
        if test $lout != unknown; then
            # Expect the packet received by the peer VIF port
            echo $packet >> vif-${lout#lp-}.expected
        fi
    done

    # regardless, the packet is sent through the bridge
    local packet=$(echo $dst$src | sed 's/://g')810000$(printf "%.2x\n" ${hv}1)${eth}
    echo $packet >> out-$hv.expected
}

test_packet 1 1-1-8 f0:00:00:00:08:21 f0:00:00:00:08:11 1001 lp-2-1-8
test_packet 2 2-2-8 f0:00:00:00:08:12 f0:00:00:00:08:22 1001 lp-1-2-8

# unknown mac goes through localnet port
test_packet 1 1-1-8 f0:00:00:00:08:e0 f0:00:00:00:08:11 1001 unknown
test_packet 2 2-2-8 f0:00:00:00:08:e0 f0:00:00:00:08:22 1001 unknown

# broadcast traffic goes to all peers, foreign and local
test_packet 1 1-1-8 ff:ff:ff:ff:ff:ff f0:00:00:00:08:11 1001 $(for n in `seq 11 19`; do echo ln-$n; done) lp-1-1-9 lp-2-1-8 lp-2-1-9

# Now check the packets actually received against the ones expected.
for hv in 1 2; do
    for ls in 1 2; do
        for peer in 8 9; do
            port=$hv-$ls-$peer
            # check that packets targeted to actual vifs arrived on the other end
            OVN_CHECK_PACKETS_CONTAIN([hv-$hv/vif-$port-tx.pcap], [vif-$port.expected])
        done
    done
    # check that all packets, whether to known or unknown mac addresses, were sent to fabric
    OVN_CHECK_PACKETS_CONTAIN([hv-$hv/br-phys${hv}1_n-${hv}1-tx.pcap], [out-$hv.expected])
done

OVN_CLEANUP([hv-1],[hv-2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 2 LS, switching between multiple localnet ports with same tags])
ovn_start

# In this test case we create two switches with multiple localnet ports. Only a
# single localnet of the same tag is connected to fabric for each switch. Two
# hypervisors have VIFs that belong to these switches. The test validates that
# routing between these switches and hypervisors still works regardless of the
# number of (unplugged) localnet ports.

# two switches, each connected to lots of networks
for i in 1 2; do
    ovn-nbctl ls-add ls-$i
    for tag in `seq 10 20`; do
        ln_port_name=ln-$i-$tag
        ovn-nbctl lsp-add ls-$i $ln_port_name "" $tag
        ovn-nbctl lsp-set-addresses $ln_port_name unknown
        ovn-nbctl lsp-set-type $ln_port_name localnet
        ovn-nbctl lsp-set-options $ln_port_name network_name=phys-$tag
    done
done

# multiple networks
for tag in `seq 10 20`; do
    net_add n-$tag
done

# two hypervisors, each connected to the same network
for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-20:br-phys
    ovn_attach n-10 br-phys 192.168.0.$i
done

# two vif ports, one per switch
for i in 1 2; do
    as hv-$i
    ovs-vsctl add-port br-int vif-$i -- \
        set Interface vif-$i external-ids:iface-id=lp-$i \
                              options:tx_pcap=hv-$i/vif-$i-tx.pcap \
                              options:rxq_pcap=hv-$i/vif-$i-rx.pcap \
                              ofport-request=$i

    lsp_name=lp-$i
    ovn-nbctl lsp-add ls-$i $lsp_name
    ovn-nbctl lsp-set-addresses $lsp_name f0:00:00:00:00:0$i
    ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:0$i

    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])
done

wait_for_ports_up
ovn-nbctl --wait=sb sync
ovn-nbctl show
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# vif ports
for i in 1 2; do
    : > vif-$i.expected
done

# localnet ports
for i in 1 2; do
    for tag in `seq 10 20`; do
        : > $i-$tag.expected
    done
done

test_packet() {
    local inport=$1 outport=$2 dst=$3 src=$4 eth=$5 eout=$6 lout=$7

    # Expect the packet cloned to all localnet ports
    : > expout
    for tag in `seq 10 20`; do
        echo "output(\"ln-$inport-$tag\");" >> expout
    done

    # First try tracing the packet.
    uflow="inport==\"lp-$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    AT_CAPTURE_FILE([trace])
    AT_CHECK([ovn-trace --all ls-$inport "$uflow" | tee trace | sed '1,/Minimal trace/d'], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    as hv-$1 ovs-appctl netdev-dummy/receive vif-$inport $packet

    # Expect the packet received by the peer VIF port
    echo $packet >> vif-$outport.expected

    # Expect the packet to transfer through the common fabric network
    local packet=$(echo $dst$src | sed 's/://g')810000$(printf "%.2x" 20)${eth}
    echo $packet >> $1-10.expected
}

test_packet 1 2 f0:00:00:00:00:02 f0:00:00:00:00:01 1001 ln-1-10 ln-1-10
test_packet 1 2 f0:00:00:00:00:02 f0:00:00:00:00:01 1002 ln-1-10 ln-1-10

test_packet 2 1 f0:00:00:00:00:01 f0:00:00:00:00:02 1003 ln-2-10 ln-2-10
test_packet 2 1 f0:00:00:00:00:01 f0:00:00:00:00:02 1004 ln-2-10 ln-2-10

# Dump a bunch of info helpful for debugging if there's a failure.

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

for i in 1 2; do
    hv=hv-$i
    echo "------ $hv dump ------"
    as $hv ovs-vsctl show
    as $hv ovs-ofctl -O OpenFlow13 dump-flows br-int
done

# Now check the packets actually received against the ones expected.
for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv-$i/vif-$i-tx.pcap], [vif-$i.expected])
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv-$i/br-phys_n-10-tx.pcap], [$i-10.expected])
done

OVN_CLEANUP([hv-1],[hv-2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- VLAN transparency, passthru=true])
ovn_start

check ovn-nbctl ls-add ls
check ovn-nbctl --wait=sb add Logical-Switch ls other_config vlan-passthru=true
for i in 1 2; do
    check ovn-nbctl lsp-add ls lsp$i
    check ovn-nbctl lsp-set-addresses lsp$i f0:00:00:00:00:0$i
done

net_add physnet
ovs-vsctl add-br br-phys
ovs-vsctl set open . external-ids:ovn-bridge-mappings=physnet:br-phys
ovn_attach physnet br-phys 192.168.0.1

for i in 1 2; do
    ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i \
                                  options:tx_pcap=vif$i-tx.pcap \
                                  options:rxq_pcap=vif$i-rx.pcap \
                                  ofport-request=$i
    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp$i` = xup])
done

test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6

    # First try tracing the packet.
    uflow="inport==\"lsp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth && vlan.present==1"
    echo "output(\"$lout\");" > expout
    AT_CAPTURE_FILE([trace])
    AT_CHECK([ovn-trace --all ls "$uflow" | tee trace | sed '1,/Minimal trace/d'], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}fefefefe
    vif=vif$inport
    ovs-appctl netdev-dummy/receive $vif $packet
    echo $packet >> ${eout#lsp}.expected
}

test_packet 1 f0:00:00:00:00:02 f0:00:00:00:00:01 8100 lsp2 lsp2
test_packet 2 f0:00:00:00:00:01 f0:00:00:00:00:02 8100 lsp1 lsp1
for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([vif$i-tx.pcap], [$i.expected])
done

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- VLAN transparency, passthru=false])
ovn_start

check ovn-nbctl ls-add ls
check ovn-nbctl --wait=sb add Logical-Switch ls other_config vlan-passthru=false
for i in 1 2; do
    check ovn-nbctl lsp-add ls lsp$i
    check ovn-nbctl lsp-set-addresses lsp$i f0:00:00:00:00:0$i
done

net_add physnet
ovs-vsctl add-br br-phys
ovs-vsctl set open . external-ids:ovn-bridge-mappings=physnet:br-phys
ovn_attach physnet br-phys 192.168.0.1

for i in 1 2; do
    ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i \
                                  options:tx_pcap=vif$i-tx.pcap \
                                  options:rxq_pcap=vif$i-rx.pcap \
                                  ofport-request=$i
    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp$i` = xup])

    : > $i.expected
done

test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6

    # First try tracing the packet.
    uflow="inport==\"lsp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth && vlan.present==1"
    AT_CHECK([ovn-trace --all ls "$uflow" | grep drop], [0], [ignore])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}fefefefe
    ovs-appctl netdev-dummy/receive vif$inport $packet
}

test_packet 1 f0:00:00:00:00:02 f0:00:00:00:00:01 8100 lsp2 lsp2
test_packet 2 f0:00:00:00:00:01 f0:00:00:00:00:02 8100 lsp1 lsp1
for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([vif$i-tx.pcap], [$i.expected])
done

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 1 LS, no switching between multiple localnet ports with different tags])
ovn_start

# In this test case we create a single switch connected to two physical
# networks via two localnet ports. Then we create two hypervisors, with 2
# ports on each. The test validates no interconnectivity between VIF ports
# located on chassis plugged to different physical networks.

# create the single switch with two locanet ports
ovn-nbctl ls-add ls1
for tag in 10 20; do
    ln_port_name=ln-$tag
    ovn-nbctl lsp-add ls1 $ln_port_name "" $tag
    ovn-nbctl lsp-set-addresses $ln_port_name unknown
    ovn-nbctl lsp-set-type $ln_port_name localnet
    ovn-nbctl lsp-set-options $ln_port_name network_name=phys-$tag
done

# create fabric networks
for tag in 10 20; do
    net_add n-$tag
done

# create four chassis, each connected to one network, each with a single VIF port
for tag in 10 20; do
    for i in 1 2; do
        sim_add hv-$tag-$i
        as hv-$tag-$i
        ovs-vsctl add-br br-phys
        ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-$tag:br-phys
        ovn_attach n-$tag br-phys 192.168.$i.$tag

        ovs-vsctl add-port br-int vif-$tag-$i -- \
            set Interface vif-$tag-$i external-ids:iface-id=lp-$tag-$i \
                                  options:tx_pcap=hv-$tag-$i/vif-$tag-$i-tx.pcap \
                                  options:rxq_pcap=hv-$tag-$i/vif-$tag-$i-rx.pcap \
                                  ofport-request=$tag$i

        lsp_name=lp-$tag-$i
        ovn-nbctl lsp-add ls1 $lsp_name
        ovn-nbctl lsp-set-addresses $lsp_name f0:00:00:00:0$i:$tag
        ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:0$i:$tag

        OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])
    done
done
wait_for_ports_up
ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows

for tag in 10 20; do
    for i in 1 2; do
        : > $tag-$i.expected
    done
done

vif_to_hv() {
    echo hv-$1
}

test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6

    # First try tracing the packet.
    uflow="inport==\"lp-$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    echo "output(\"$lout\");" > expout
    AT_CAPTURE_FILE([trace])
    AT_CHECK([ovn-trace --all ls1 "$uflow" | tee trace | sed '1,/Minimal trace/d'], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    hv=`vif_to_hv $inport`
    vif=vif-$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    if test $eth = 1002 -o $eth = 2002; then
        echo $packet >> ${eout#lp-}.expected
    fi
}

# different fabric networks -> should fail
test_packet 10-1 f0:00:00:00:01:20 f0:00:00:00:01:10 1001 lp-20-1 lp-20-1
test_packet 20-1 f0:00:00:00:01:10 f0:00:00:00:01:20 2001 lp-10-1 lp-10-1

# same fabric networks -> should pass
test_packet 10-1 f0:00:00:00:02:10 f0:00:00:00:01:10 1002 lp-10-2 lp-10-2
test_packet 20-1 f0:00:00:00:02:20 f0:00:00:00:01:20 2002 lp-20-2 lp-20-2
test_packet 10-2 f0:00:00:00:01:10 f0:00:00:00:02:10 1002 lp-10-1 lp-10-1
test_packet 20-2 f0:00:00:00:01:20 f0:00:00:00:02:20 2002 lp-20-1 lp-20-1

# Dump a bunch of info helpful for debugging if there's a failure.
echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

for tag in 10 20; do
    for i in 1 2; do
        hv=hv-$tag-$i
        echo "------ $hv dump ------"
        as $hv ovs-vsctl show
        as $hv ovs-ofctl -O OpenFlow13 dump-flows br-int
    done
done

# Now check the packets actually received against the ones expected.
for tag in 10 20; do
    for i in 1 2; do
        echo "hv = $tag-$i"
        OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv-$tag-$i/vif-$tag-$i-tx.pcap], [$tag-$i.expected])
    done
done

OVN_CLEANUP([hv-10-1],[hv-10-2],[hv-20-1],[hv-20-2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- vtep: 3 HVs, 1 VIFs/HV, 1 GW, 1 LS])
AT_KEYWORDS([vtep])
ovn_start

# Configure the Northbound database
ovn-nbctl ls-add lsw0

ovn-nbctl lsp-add lsw0 lp1
ovn-nbctl lsp-set-addresses lp1 f0:00:00:00:00:01

ovn-nbctl lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp2 f0:00:00:00:00:02

ovn-nbctl lsp-add lsw0 lp-vtep
ovn-nbctl lsp-set-type lp-vtep vtep
ovn-nbctl lsp-set-options lp-vtep vtep-physical-switch=br-vtep vtep-logical-switch=lsw0
ovn-nbctl lsp-set-addresses lp-vtep unknown

# lpr, lr and lrp1 are used for the ARP request handling test only.
ovn-nbctl lsp-add lsw0 lpr
ovn-nbctl lr-add lr
ovn-nbctl lrp-add lr lrp1 f0:00:00:00:00:f1 192.168.1.1/24
ovn-nbctl set Logical_Switch_Port lpr type=router \
                             options:router-port=lrp1 \
    addresses='"f0:00:00:00:00:f1 192.168.1.1"'


net_add n1               # Network to connect hv1, hv2, and vtep
net_add n2               # Network to connect vtep and hv3

# Create hypervisor hv1 connected to n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1 options:tx_pcap=hv1/vif1-tx.pcap options:rxq_pcap=hv1/vif1-rx.pcap ofport-request=1

# Create hypervisor hv2 connected to n1
sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl add-port br-int vif2 -- set Interface vif2 external-ids:iface-id=lp2 options:tx_pcap=hv2/vif2-tx.pcap options:rxq_pcap=hv2/vif2-rx.pcap ofport-request=1


# Start the vtep emulator with a leg in both networks
sim_add vtep
as vtep

ovsdb-tool create "$ovs_base"/vtep/vtep.db "$ovs_srcdir"/vtep/vtep.ovsschema
ovs-appctl -t ovsdb-server ovsdb-server/add-db "$ovs_base"/vtep/vtep.db

ovs-vsctl add-br br-phys
net_attach n1 br-phys

mac=`ovs-vsctl get Interface br-phys mac_in_use | sed s/\"//g`
arp_table="$arp_table $sandbox,br-phys,192.168.0.3,$mac"
ovs-appctl netdev-dummy/ip4addr br-phys 192.168.0.3/24 >/dev/null
ovs-appctl ovs/route/add 192.168.0.3/24 br-phys >/dev/null

ovs-vsctl add-br br-vtep
net_attach n2 br-vtep

vtep-ctl add-ps br-vtep
vtep-ctl set Physical_Switch br-vtep tunnel_ips=192.168.0.3
vtep-ctl add-ls lsw0

start_daemon ovs-vtep br-vtep
start_daemon ovn-controller-vtep --vtep-db=unix:"$ovs_base"/vtep/db.sock --ovnsb-db=unix:"$ovs_base"/ovn-sb/ovn-sb.sock

OVS_WAIT_UNTIL([vtep-ctl bind-ls br-vtep br-vtep_n2 0 lsw0])

OVS_WAIT_UNTIL([test -n "`as vtep vtep-ctl get-replication-mode lsw0 |
               grep -- source`"])
# It takes more time for the update to be processed by ovs-vtep.
sleep 1

# Add hv3 on the other side of the vtep
sim_add hv3
as hv3
ovs-vsctl add-br br-phys
net_attach n2 br-phys

ovs-vsctl add-port br-phys vif3 -- set Interface vif3 options:tx_pcap=hv3/vif3-tx.pcap options:rxq_pcap=hv3/vif3-rx.pcap ofport-request=1

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# test_packet INPORT DST SRC ETHTYPE OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 1 for vif1.
for i in 1 2 3; do
    : > $i.expected
done
test_packet() {
    local inport=$1 packet=$2$3$4; shift; shift; shift; shift
    #hv=hv`echo $inport | sed 's/^\(.\).*/\1/'`
    hv=hv$inport
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Send packets between all pairs of source and destination ports:
#
# 1. Unicast packets are delivered to exactly one logical switch port
#    (except that packets destined to their input ports are dropped).
#
# 2. Broadcast and multicast are delivered to all logical switch ports
#    except the input port.
#
# 3. The switch delivers packets with an unknown destination to logical
#    switch ports with "unknown" among their MAC addresses (and port
#    security disabled).
for s in 1 2 3; do
    bcast=
    unknown=
    for d in 1 2 3; do
        if test $d != $s; then unicast=$d; else unicast=; fi
        test_packet $s f0000000000$d f0000000000$s 00$s$d $unicast       #1

        # The vtep (vif3) is the only one configured for "unknown"
        if test $d != $s && test $d = 3; then
            unknown="$unknown $d"
        fi
        bcast="$bcast $unicast"
    done

    # Broadcast and multicast.
    test_packet $s ffffffffffff f0000000000$s 0${s}ff $bcast             #2
    test_packet $s 010000000000 f0000000000$s 0${s}ff $bcast             #2

    test_packet $s f0000000ffff f0000000000$s 0${s}66 $unknown           #3
done

# ARP request should not be responded to by logical switch router
# type arp responder on HV1 and HV2 and should reach directly to
# vif1 and vif2
sha=f00000000003
spa=`ip_to_hex 192 168 1 2`
tpa=`ip_to_hex 192 168 1 1`
request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
as hv3 ovs-appctl netdev-dummy/receive vif3 $request
echo $request >> 1.expected
echo $request >> 2.expected

# dump information with counters
echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"
ovn-sbctl dump-flows

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-ofctl -O OpenFlow13 show br-int
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-ofctl -O OpenFlow13 show br-int
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv3 dump ------"
as hv3 ovs-vsctl show
# note: hv3 has no logical port bind, thus it should not have br-int
AT_CHECK([as hv3 ovs-ofctl -O OpenFlow13 show br-int], [1], [],
[ovs-ofctl: br-int is not a bridge or a socket
])

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    OVN_CHECK_PACKETS([hv$i/vif$i-tx.pcap], [$i.expected])
done

# Gracefully terminate daemons
OVN_CLEANUP([hv1],[hv2],[vtep])
OVN_CLEANUP_VSWITCH([hv3])

AT_CLEANUP
])

# Similar test to "hardware GW"
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 3 HVs, 1 VIFs/HV, 1 software GW, 1 LS])
ovn_start

# Configure the Northbound database
ovn-nbctl ls-add lsw0

ovn-nbctl lsp-add lsw0 lp1
ovn-nbctl lsp-set-addresses lp1 f0:00:00:00:00:01

ovn-nbctl lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp2 f0:00:00:00:00:02

ovn-nbctl lsp-add lsw0 lp-gw
ovn-nbctl lsp-set-type lp-gw l2gateway
ovn-nbctl lsp-set-options lp-gw network_name=physnet1 l2gateway-chassis=hv_gw
ovn-nbctl lsp-set-addresses lp-gw unknown

net_add n1               # Network to connect hv1, hv2, and gw
net_add n2               # Network to connect gw and hv3

# Create hypervisor hv1 connected to n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1 options:tx_pcap=hv1/vif1-tx.pcap options:rxq_pcap=hv1/vif1-rx.pcap ofport-request=1

# Create hypervisor hv2 connected to n1
sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl add-port br-int vif2 -- set Interface vif2 external-ids:iface-id=lp2 options:tx_pcap=hv2/vif2-tx.pcap options:rxq_pcap=hv2/vif2-rx.pcap ofport-request=1

# Create hypervisor hv_gw connected to n1 and n2
# connect br-phys bridge to n1; connect hv-gw bridge to n2
sim_add hv_gw
as hv_gw
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl add-br br-phys2
net_attach n2 br-phys2
ovs-vsctl set open . external_ids:ovn-bridge-mappings="physnet1:br-phys2"

# Add hv3 on the other side of the GW
sim_add hv3
as hv3
ovs-vsctl add-br br-phys
net_attach n2 br-phys
ovs-vsctl add-port br-phys vif3 -- set Interface vif3 options:tx_pcap=hv3/vif3-tx.pcap options:rxq_pcap=hv3/vif3-rx.pcap ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# test_packet INPORT DST SRC ETHTYPE OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as lport numbers, e.g. 1 for vif1.
for i in 1 2 3; do
    : > $i.expected
done
test_packet() {
    local inport=$1 packet=$2$3$4; shift; shift; shift; shift
    #hv=hv`echo $inport | sed 's/^\(.\).*/\1/'`
    hv=hv$inport
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Send packets between all pairs of source and destination ports:
#
# 1. Unicast packets are delivered to exactly one lport (except that packets
#    destined to their input ports are dropped).
#
# 2. Broadcast and multicast are delivered to all lports except the input port.
#
# 3. The lswitch delivers packets with an unknown destination to lports with
#    "unknown" among their MAC addresses (and port security disabled).
for s in 1 2 3 ; do
    bcast=
    unknown=
    for d in 1 2 3 ; do
        if test $d != $s; then unicast=$d; else unicast=; fi
        test_packet $s f0000000000$d f0000000000$s 00$s$d $unicast       #1

        # The vtep (vif3) is the only one configured for "unknown"
        if test $d != $s && test $d = 3; then
            unknown="$unknown $d"
        fi
        bcast="$bcast $unicast"
    done

    test_packet $s ffffffffffff f0000000000$s 0${s}ff $bcast             #2
    test_packet $s 010000000000 f0000000000$s 0${s}ff $bcast             #3
    test_packet $s f0000000ffff f0000000000$s 0${s}66 $unknown           #4
done

echo "------ ovn-nbctl show ------"
ovn-nbctl show
echo "------ ovn-sbctl show ------"
ovn-sbctl show

echo "------ hv1 ------"
as hv1 ovs-vsctl show
echo "------ hv1 br-int ------"
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int
echo "------ hv1 br-phys ------"
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-phys

echo "------ hv2 ------"
as hv2 ovs-vsctl show
echo "------ hv2 br-int ------"
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int
echo "------ hv2 br-phys ------"
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-phys

echo "------ hv_gw ------"
as hv_gw ovs-vsctl show
echo "------ hv_gw br-phys ------"
as hv_gw ovs-ofctl -O OpenFlow13 dump-flows br-phys
echo "------ hv_gw br-phys2 ------"
as hv_gw ovs-ofctl -O OpenFlow13 dump-flows br-phys2

echo "------ hv3 ------"
as hv3 ovs-vsctl show
echo "------ hv3 br-phys ------"
as hv3 ovs-ofctl -O OpenFlow13 dump-flows br-phys

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    OVN_CHECK_PACKETS([hv$i/vif$i-tx.pcap], [$i.expected])
done
AT_CLEANUP
])

# 3 hypervisors, 3 logical switches with 3 logical ports each, 1 logical router
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 3 HVs, 3 LS, 3 lports/LS, 1 LR])
ovn_start

# Logical network:
#
# Three logical switches ls1, ls2, ls3.
# One logical router lr0 connected to ls[123],
# with nine subnets, three per logical switch:
#
#    lrp11 on ls1 for subnet 192.168.11.0/24
#    lrp12 on ls1 for subnet 192.168.12.0/24
#    lrp13 on ls1 for subnet 192.168.13.0/24
#    ...
#    lrp33 on ls3 for subnet 192.168.33.0/24
#
# 27 VIFs, 9 per LS, 3 per subnet: lp[123][123][123], where the first two
# digits are the subnet and the last digit distinguishes the VIF.
for i in 1 2 3; do
    ovn-nbctl ls-add ls$i
    for j in 1 2 3; do
        for k in 1 2 3; do
            # Add "unknown" to MAC addresses for lp?11, so packets for
            # MAC-IP bindings discovered via ARP later have somewhere to go.
            if test $j$k = 11; then unknown=unknown; else unknown=; fi

            ovn-nbctl \
                -- lsp-add ls$i lp$i$j$k \
                -- lsp-set-addresses lp$i$j$k \
                   "f0:00:00:00:0$i:$j$k 192.168.$i$j.$k" $unknown
        done
    done
done

ovn-nbctl lr-add lr0
for i in 1 2 3; do
    for j in 1 2 3; do
        ovn-nbctl lrp-add lr0 lrp$i$j 00:00:00:00:ff:$i$j 192.168.$i$j.254/24
        ovn-nbctl \
            -- lsp-add ls$i lrp$i$j-attachment \
            -- set Logical_Switch_Port lrp$i$j-attachment type=router \
                             options:router-port=lrp$i$j \
                             addresses='"00:00:00:00:ff:'$i$j'"'
    done
done

ovn-nbctl set Logical_Switch_Port lrp33-attachment \
    addresses='"00:00:00:00:ff:33 192.168.33.254"'

# Physical network:
#
# Three hypervisors hv[123].
# lp?1[123] spread across hv[123]: lp?11 on hv1, lp?12 on hv2, lp?13 on hv3.
# lp?2[123] spread across hv[23]: lp?21 and lp?22 on hv2, lp?23 on hv3.
# lp?3[123] all on hv3.


# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    case $1 in dnl (
        ?11) echo 1 ;; dnl (
        ?12 | ?21 | ?22) echo 2 ;; dnl (
        ?13 | ?23 | ?3?) echo 3 ;;
    esac
}

# Given the name of a logical port, prints the name of its logical router
# port, e.g. "vif_to_lrp 123" yields 12.
vif_to_lrp() {
    echo ${1%?}
}

# Given the name of a logical port, prints the name of its logical
# switch, e.g. "vif_to_ls 123" yields 1.
vif_to_ls() {
    echo ${1%??}
}

net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            hv=`vif_to_hv $i$j$k`
                as hv$hv ovs-vsctl \
                -- add-port br-int vif$i$j$k \
                -- set Interface vif$i$j$k \
                    external-ids:iface-id=lp$i$j$k \
                    options:tx_pcap=hv$hv/vif$i$j$k-tx.pcap \
                    options:rxq_pcap=hv$hv/vif$i$j$k-rx.pcap \
                    ofport-request=$i$j$k
        done
    done
done

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 123 for vif123.
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            : > $i$j$k.expected
        done
    done
done
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    #as $hv ovs-appctl ofproto/trace br-int in_port=$inport $packet
    in_ls=`vif_to_ls $inport`
    in_lrp=`vif_to_lrp $inport`
    for outport; do
        out_ls=`vif_to_ls $outport`
        if test $in_ls = $out_ls; then
            # Ports on the same logical switch receive exactly the same packet.
            echo $packet
        else
            # Routing decrements TTL and updates source and dest MAC
            # (and checksum).
            out_lrp=`vif_to_lrp $outport`
            echo f00000000${outport}00000000ff${out_lrp}08004500001c00000000"3f1101"00${src_ip}${dst_ip}0035111100080000
        fi >> $outport.expected
    done
}

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    echo "$@"
    local inport=$1 sha=$2 spa=$3 tpa=$4 reply_ha=$5
    local request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $request
    as $hv ovs-appctl ofproto/trace br-int in_port=$inport $request > trace

    # Expect to receive the broadcast ARP on the other logical switch ports if
    # IP address is not configured to the switch patch port.
    local i=`vif_to_ls $inport`
    local j k
    for j in 1 2 3; do
        for k in 1 2 3; do
            # 192.168.33.254 is configured to the switch patch port for lrp33,
            # so no ARP flooding expected for it.
            if test $i$j$k != $inport && test $tpa != `ip_to_hex 192 168 33 254`; then
                echo $request >> $i$j$k.expected
            fi
        done
    done

    # Expect to receive the reply, if any.
    if test X$reply_ha != X; then
        lrp=`vif_to_lrp $inport`
        local reply=${sha}00000000ff${lrp}08060001080006040002${reply_ha}${tpa}${sha}${spa}
        echo $reply >> $inport.expected
    fi
}

as hv1 ovs-vsctl --columns=name,ofport list interface > interfaces
(as hv1 ovn-sbctl list port_binding
 as hv1 ovn-sbctl list datapath_binding) > bindings
as hv1 ovn-sbctl dump-flows > sbflows
as hv1 ovs-ofctl dump-flows br-int > offlows
AT_CAPTURE_FILE([interfaces])
AT_CAPTURE_FILE([bindings])
AT_CAPTURE_FILE([sbflows])
AT_CAPTURE_FILE([offlows])

# Send IP packets between all pairs of source and destination ports:
#
# 1. Unicast IP packets are delivered to exactly one logical switch port
#    (except that packets destined to their input ports are dropped).
#
# 2. Broadcast IP packets are delivered to all logical switch ports
#    except the input port.
for is in 1 2 3; do
  for js in 1 2 3; do
    for ks in 1 2 3; do
      bcast=
      s=$is$js$ks
      smac=f00000000$s
      sip=`ip_to_hex 192 168 $is$js $ks`
      for id in 1 2 3; do
          for jd in 1 2 3; do
              for kd in 1 2 3; do
                d=$id$jd$kd
                dip=`ip_to_hex 192 168 $id$jd $kd`
                if test $is = $id; then dmac=f00000000$d; else dmac=00000000ff$is$js; fi
                if test $d != $s; then unicast=$d; else unicast=; fi

                test_ip $s $smac $dmac $sip $dip $unicast & #1

                if test $id = $is && test $d != $s; then bcast="$bcast $d"; fi
              done
          done
        done
      test_ip $s $smac ffffffffffff $sip ffffffff $bcast & #2
      done
  done
  wait
done

: > mac_bindings.expected

# 3. Send an IP packet from every logical port to every other subnet,
#    to an IP address that does not have a static IP-MAC binding.
#    This should generate a broadcast ARP request for the destination
#    IP address in the destination subnet.
#    Moreover generate an ARP reply for each of the IP addresses ARPed
for is in 1 2 3; do
  for js in 1 2 3; do
    for ks in 1 2 3; do
      s=$is$js$ks
      smac=f00000000$s
      sip=`ip_to_hex 192 168 $is$js $ks`
      for id in 1 2 3; do
        for jd in 1 2 3; do
          if test $is$js = $id$jd; then
            continue
          fi

          # Send the packet.
          dmac=00000000ff$is$js
          # Calculate a 4th octet for the destination that is
          # unique per $s, avoids the .1 .2 .3 and .254 IP addresses
          # that have static MAC bindings, and fits in the range
          # 0-255.
          o4=`expr $is '*' 9 + $js '*' 3 + $ks + 10`
          dip=`ip_to_hex 192 168 $id$jd $o4`
          test_ip $s $smac $dmac $sip $dip

          # Every LP on the destination subnet's lswitch should
          # receive the ARP request.
          lrmac=00000000ff$id$jd
          lrip=`ip_to_hex 192 168 $id$jd 254`
          arp=ffffffffffff${lrmac}08060001080006040001${lrmac}${lrip}000000000000${dip}
          for jd2 in 1 2 3; do
            for kd in 1 2 3; do
              echo $arp >> $id$jd2$kd.expected
            done
          done

          hmac=8000000000$o4
          rmac=00000000ff$id$jd
          echo ${hmac}${rmac}08004500001c00000000"3f1101"00${sip}${dip}0035111100080000 >> ${id}11.expected

          host_mac=8000000000$o4
          lrmac=00000000ff$id$jd

          arp_reply=${lrmac}${host_mac}08060001080006040002${host_mac}${dip}${lrmac}${lrip}

          hv=hv`vif_to_hv ${id}${jd}1`
          as $hv ovs-appctl netdev-dummy/receive vif${id}${jd}1 $arp_reply

          host_ip_pretty=192.168.$id$jd.$o4
          host_mac_pretty=80:00:00:00:00:$o4
          echo lrp$id$jd,$host_ip_pretty,$host_mac_pretty >> mac_bindings.expected
        done
      done
    done
  done
done

# Test router replies to ARP requests from all source ports:
#
# 4. Router replies to query for its MAC address from port's own IP address.
#
# 5. Router replies to query for its MAC address from any random IP address
#    in its subnet.
#
# 6. No reply to query for IP address other than router IP.
#
# 7. No reply to query from another subnet.
for i in 1 2 3; do
  for j in 1 2 3; do
    for k in 1 2 3; do
      smac=f00000000$i$j$k               # Source MAC
      sip=`ip_to_hex 192 168 $i$j $k`    # Source IP
      rip=`ip_to_hex 192 168 $i$j 254`   # Router IP
      rmac=00000000ff$i$j                # Router MAC
      otherip=`ip_to_hex 192 168 $i$j 55` # Some other IP in subnet
      externalip=`ip_to_hex 1 2 3 4`      # Some other IP not in subnet

      test_arp $i$j$k $smac $sip        $rip        $rmac      #4
      test_arp $i$j$k $smac $otherip    $rip        $rmac      #5
      test_arp $i$j$k $smac $sip        $otherip               #6

      # When rip is 192.168.33.254, ARP request from externalip won't be
      # filtered, because 192.168.33.254 is configured to switch peer port
      # for lrp33.
      lrp33_rsp=
      if test $i = 3 && test $j = 3; then
        lrp33_rsp=$rmac
      fi
      test_arp $i$j$k $smac $externalip $rip        $lrp33_rsp #7

      # MAC binding should be learned from ARP request.
      host_mac_pretty=f0:00:00:00:0$i:$j$k

      host_ip_pretty=192.168.$i$j.$k
      echo lrp$i$j,$host_ip_pretty,$host_mac_pretty >> mac_bindings.expected

      # mac_binding is learned and overwritten so only the last one remains.
      if test $k = 3; then
          # lrp33 will not learn from ARP request, because 192.168.33.254 is
          # configured to switch peer port for lrp33.
          if test $i != 3 || test $j != 3; then
              host_ip_pretty=192.168.$i$j.55
              echo lrp$i$j,$host_ip_pretty,$host_mac_pretty >> mac_bindings.expected
          fi
      fi

    done
  done
done


# Allow some time for packet forwarding.
# XXX This can be improved.
sleep 1

# 8. Send an IP packet from every logical port to every other subnet.  These
#    are the same packets already sent as #3, but now the destinations' IP-MAC
#    bindings have been discovered via ARP, so instead of provoking an ARP
#    request, these packets now get routed to their destinations (which don't
#    have static MAC bindings, so they go to the port we've designated as
#    accepting "unknown" MACs.)
for is in 1 2 3; do
  for js in 1 2 3; do
    for ks in 1 2 3; do
      s=$is$js$ks
      smac=f00000000$s
      sip=`ip_to_hex 192 168 $is$js $ks`
      for id in 1 2 3; do
        for jd in 1 2 3; do
          if test $is$js = $id$jd; then
            continue
          fi

          # Send the packet.
          dmac=00000000ff$is$js
          # Calculate a 4th octet for the destination that is
          # unique per $s, avoids the .1 .2 .3 and .254 IP addresses
          # that have static MAC bindings, and fits in the range
          # 0-255.
          o4=`expr $is '*' 9 + $js '*' 3 + $ks + 10`
          dip=`ip_to_hex 192 168 $id$jd $o4`
          test_ip $s $smac $dmac $sip $dip

          # Expect the packet egress.
          host_mac=8000000000$o4
          outport=${id}11
          out_lrp=$id$jd
          echo ${host_mac}00000000ff${out_lrp}08004500001c00000000"3f1101"00${sip}${dip}0035111100080000 >> $outport.expected
        done
      done
    done
  done
done

ovn-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
check_packets() {
    > expected
    > received
    for i in 1 2 3; do
        for j in 1 2 3; do
            for k in 1 2 3; do
                pcap=hv`vif_to_hv $i$j$k`/vif$i$j$k-tx.pcap
                echo "--- $pcap" | tee -a expected >> received
                sort $i$j$k.expected >> expected
                $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | sort >> received
                echo | tee -a expected >> received
            done
        done
    done

    echo '--- MAC bindings' | tee -a expected >> received
    ovn-sbctl -f csv -d bare --no-heading \
        -- --columns=logical_port,ip,mac list mac_binding | sort >> received
    sort < mac_bindings.expected >> expected

    $at_diff expected received >/dev/null
}
OVS_WAIT_UNTIL([check_packets], [$at_diff -F'^---' expected received])

# Gracefully terminate daemons
OVN_CLEANUP([hv1], [hv2], [hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- IP relocation using GARP request])
ovn_start

# Logical network:
#
# Two logical switches ls1, ls2.
# One logical router lr0 connected to ls[12],
# with 2 subnets, 1 per logical switch:
#
#    lrp1 on ls1 for subnet 192.168.1.1/24
#    lrp2 on ls2 for subnet 192.168.2.1/24
#
# 4 VIFs, 2 per LS lp[12][12], first digit being LS.
# VIFs' fixed IP addresses are 192.168.[12].1[12].
#
# There is a secondary IP 192.168.1.100 that is unknown in NB and learned
# through ARP only, and it can move between lp11 and lp12.
#
ovn-nbctl lr-add lr0
for i in 1 2 ; do
    ovn-nbctl ls-add ls$i
    ovn-nbctl lrp-add lr0 lrp$i 00:00:00:00:ff:0$i 192.168.$i.1/24
    ovn-nbctl \
        -- lsp-add ls$i lrp$i-attachment \
        -- set Logical_Switch_Port lrp$i-attachment type=router \
                         options:router-port=lrp$i \
                         addresses=router
    for j in 1 2; do
        ovn-nbctl \
            -- lsp-add ls$i lp$i$j \
            -- lsp-set-addresses lp$i$j \
               "f0:00:00:00:00:$i$j 192.168.$i.1$j"
    done
done

# Physical network:
# 2 hypervisors hv[12], lp?1 on hv1, lp?2 on hv2.

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located, e.g. "vif_to_hv 12" yields 2.
vif_to_hv() {
    echo ${1#?}
}

# Given the name of a logical port, prints the name of its logical router
# port, e.g. "vif_to_lrp 12" yields 1.
vif_to_lrp() {
    echo ${1%?}
}

# Given the name of a logical port, prints the name of its logical
# switch, e.g. "vif_to_ls 12" yields 1.
vif_to_ls() {
    echo ${1%?}
}

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done
for i in 1 2; do
    for j in 1 2; do
        hv=`vif_to_hv $i$j`
            as hv$hv ovs-vsctl \
                -- add-port br-int vif$i$j \
                -- set Interface vif$i$j \
                    external-ids:iface-id=lp$i$j \
                    options:tx_pcap=hv$hv/vif$i$j-tx.pcap \
                    options:rxq_pcap=hv$hv/vif$i$j-rx.pcap \
                    ofport-request=$i$j
    done
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 12 for vif12.
for i in 1 2; do
    for j in 1 2; do
        : > $i$j.expected
    done
done
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    in_ls=`vif_to_ls $inport`
    in_lrp=`vif_to_lrp $inport`
    for outport; do
        out_ls=`vif_to_ls $outport`
        if test $in_ls = $out_ls; then
            # Ports on the same logical switch receive exactly the same packet.
            echo $packet
        else
            # Routing decrements TTL and updates source and dest MAC
            # (and checksum).
            out_lrp=`vif_to_lrp $outport`
            echo f000000000${outport}00000000ff0${out_lrp}08004500001c00000000"3f1101"00${src_ip}${dst_ip}0035111100080000
        fi >> $outport.expected
    done
}

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local inport=$1 sha=$2 spa=$3 tpa=$4 reply_ha=$5
    local request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $request

    # Expect to receive the broadcast ARP on the other logical switch ports if
    # IP address is not configured to the switch patch port.
    local i=`vif_to_ls $inport`
    local j
    for j in 1 2; do
        if test $i$j != $inport; then
            echo $request >> $i$j$k.expected
        fi
    done

    # Expect to receive the reply, if any.
    if test X$reply_ha != X; then
        lrp=`vif_to_lrp $inport`
        local reply=${sha}00000000ff0${lrp}08060001080006040002${reply_ha}${tpa}${sha}${spa}
        echo $reply >> $inport.expected
    fi
}

# lp11 send GARP request to announce ownership of 192.168.1.100.

sha=f00000000011
spa=`ip_to_hex 192 168 1 100`
tpa=$spa

# When always_learn_from_arp_request=false, the new mac-binding will not be learned
# through GARP request.
ovn-nbctl --wait=hv set logical_router lr0 options:always_learn_from_arp_request=false

test_arp 11 $sha $spa $tpa
sleep 1
check_row_count MAC_Binding 0 ip="192.168.1.100"

# When always_learn_from_arp_request=true, the new mac-binding will be learned.
ovn-nbctl --wait=hv set logical_router lr0 options:always_learn_from_arp_request=true

test_arp 11 $sha $spa $tpa
OVS_WAIT_UNTIL([test `ovn-sbctl find mac_binding ip="192.168.1.100" | wc -l` -gt 0])
ovn-nbctl --wait=hv sync

# Send an IP packet from lp21 to 192.168.1.100, which should go to lp11.

smac=f00000000021
dmac=00000000ff02
sip=`ip_to_hex 192 168 2 11`
dip=`ip_to_hex 192 168 1 100`
test_ip 21 $smac $dmac $sip $dip 11

# lp12 send GARP request to announce ownership of 192.168.1.100.

# Even when always_learn_from_arp_request=false, the existing mac-binding should be
# updated through GARP request.
ovn-nbctl --wait=hv set logical_router lr0 options:always_learn_from_arp_request=false

sha=f00000000012
test_arp 12 $sha $spa $tpa
wait_row_count MAC_Binding 1 ip="192.168.1.100" mac='"f0:00:00:00:00:12"'
ovn-nbctl --wait=hv sync
# give to the hv the time to send queued ip packets
sleep 1

# Send an IP packet from lp21 to 192.168.1.100, which should go to lp12.

test_ip 21 $smac $dmac $sip $dip 12

# Now check the packets actually received against the ones expected.
for i in 1 2; do
    for j in 1 2; do
        OVN_CHECK_PACKETS([hv`vif_to_hv $i$j`/vif$i$j-tx.pcap],
                          [$i$j.expected])
    done
done

# Gracefully terminate daemons
OVN_CLEANUP([hv1], [hv2])

AT_CLEANUP
])

# 3 hypervisors, one logical switch, 3 logical ports per hypervisor
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- portsecurity : 3 HVs, 1 LS, 3 lports/HV])
ovn_start

# Create hypervisors hv[123].
# Add vif1[123] to hv1, vif2[123] to hv2, vif3[123] to hv3.
# Add all of the vifs to a single logical switch lsw0.
# Turn off port security on vifs vif[123]1
# Turn on l2 port security on vifs vif[123]2
# Turn of l2 and l3 port security on vifs vif[123]3
# Make vif13, vif2[23], vif3[123] destinations for unknown MACs.
ovn-nbctl ls-add lsw0
net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2 3; do
        ovs-vsctl add-port br-int vif$i$j -- set Interface vif$i$j external-ids:iface-id=lp$i$j options:tx_pcap=hv$i/vif$i$j-tx.pcap options:rxq_pcap=hv$i/vif$i$j-rx.pcap ofport-request=$i$j
        ovn-nbctl lsp-add lsw0 lp$i$j
        if test $j = 1; then
            ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j 192.168.0.$i$j" unknown
        elif test $j = 2; then
            ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j 192.168.0.$i$j 4343::00$i$j"
            ovn-nbctl lsp-set-port-security lp$i$j f0:00:00:00:00:$i$j
        else
            extra_addr="f0:00:00:00:0$i:$i$j fe80::ea2a:eaff:fe28:$i$j 4242::00$i$j"
            ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j 192.168.0.$i$j" "$extra_addr"
            ovn-nbctl lsp-set-port-security lp$i$j "f0:00:00:00:00:$i$j 192.168.0.$i$j" "$extra_addr"
        fi
        OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp$i$j` = xup])
    done
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}

for i in 1 2 3; do
    for j in 1 2 3; do
        : > $i$j.expected
    done
done

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes an ip packet to be received on INPORT.
# The packet's content has Ethernet destination DST and source SRC
# (each exactly 12 hex digits) and Ethernet type ETHTYPE (4 hex digits).
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 11 for vif11.
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    #as $hv ovs-appctl ofproto/trace br-int in_port=$inport $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# test_arp INPORT SHA SPA TPA DROP [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local inport=$1 smac=$2 sha=$3 spa=$4 tpa=$5 drop=$6 reply_ha=$7
    local request=ffffffffffff${smac}08060001080006040001${sha}${spa}ffffffffffff${tpa}
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $request
    #as $hv ovs-appctl ofproto/trace br-int in_port=$inport $request
    if test $drop != 1; then
        if test X$reply_ha = X; then
            # Expect to receive the broadcast ARP on the other logical switch ports
            # if no reply is expected.
            local i j
            for i in 1 2 3; do
                for j in 1 2 3; do
                    if test $i$j != $inport; then
                        echo $request >> $i$j.expected
                    fi
                done
            done
        else
            # Expect to receive the reply, if any.
            local reply=${smac}${reply_ha}08060001080006040002${reply_ha}${tpa}${sha}${spa}
            echo $reply >> $inport.expected
        fi
    fi
}

# test_ipv6 INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
# This function is similar to test_ip() except that it sends
# ipv6 packet
test_ipv6() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}86dd6000000000083aff${src_ip}${dst_ip}0000000000000000
    shift; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    #as $hv ovs-appctl ofproto/trace br-int in_port=$inport $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# test_icmpv6 INPORT  SRC_MAC DST_MAC SRC_IP DST_IP ICMP_TYPE OUTPORT...
# This function is similar to test_ipv6() except it specifies the ICMPv6 type
# of the test packet
test_icmpv6() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 icmp_type=$6
    local packet=${dst_mac}${src_mac}86dd6000000000083aff${src_ip}${dst_ip}${icmp_type}00000000000000
    shift; shift; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    #as $hv ovs-appctl ofproto/trace br-int in_port=$inport $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# no port security
sip=`ip_to_hex 192 168 0 12`
tip=`ip_to_hex 192 168 0 13`
# the arp packet should be allowed even if lp[123]1 is
# not configured with mac f00000000023 and ip 192.168.0.12
for i in 1 2 3; do
    test_arp ${i}1 f00000000023 f00000000023 $sip $tip 0 f00000000013
    for j in 1 2 3; do
        if test $i != $j; then
            test_ip ${i}1 f000000000${i}1 f000000000${j}1 $sip $tip ${j}1
        fi
    done
done

# l2 port security
sip=`ip_to_hex 192 168 0 12`
tip=`ip_to_hex 192 168 0 13`

# arp packet should be allowed since lp22 is configured with
# mac f00000000022
test_arp 22 f00000000022 f00000000022 $sip $tip 0 f00000000013

# arp packet should not be allowed since lp32 is not configured with
# mac f00000000021
test_arp 32 f00000000021 f00000000021 $sip $tip 1

# arp packet with sha set to f00000000021 should not be allowed
# for lp12
test_arp 12 f00000000012 f00000000021 $sip $tip 1

# ip packets should be allowed and received since lp[123]2 do not
# have l3 port security
sip=`ip_to_hex 192 168 0 55`
tip=`ip_to_hex 192 168 0 66`
for i in 1 2 3; do
    for j in 1 2 3; do
        if test $i != $j; then
            test_ip ${i}2 f000000000${i}2 f000000000${j}2 $sip $tip ${j}2
        fi
    done
done

# ipv6 packets should be received by lp[123]2
# lp[123]1 can send ipv6 traffic as there is no port security
sip=fe800000000000000000000000000000
tip=ff020000000000000000000000000000

for i in 1 2 3; do
    test_ipv6 ${i}1 f000000000${i}1 f000000000${i}2 $sip $tip ${i}2
done


# l2 and l3 port security
sip=`ip_to_hex 192 168 0 13`
tip=`ip_to_hex 192 168 0 22`
# arp packet should be allowed since lp13 is configured with
# f00000000013 and 192.168.0.13
test_arp 13 f00000000013 f00000000013 $sip $tip 0 f00000000022

# the arp packet should be dropped because lp23 is not configured
# with mac f00000000022
sip=`ip_to_hex 192 168 0 13`
tip=`ip_to_hex 192 168 0 22`
test_arp 23 f00000000022 f00000000022 $sip $tip 1

# the arp packet should be dropped because lp33 is not configured
# with ip 192.168.0.55
spa=`ip_to_hex 192 168 0 55`
tpa=`ip_to_hex 192 168 0 22`
test_arp 33 f00000000031 f00000000031 $spa $tpa 1

# ip packets should not be received by lp[123]3 since
# l3 port security is enabled
sip=`ip_to_hex 192 168 0 55`
tip=`ip_to_hex 192 168 0 66`
for i in 1 2 3; do
    for j in 1 2 3; do
        test_ip ${i}2 f000000000${i}2 f000000000${j}3 $sip $tip
    done
done

# ipv6 packets should be dropped for lp[123]3 since
# it is configured with only ipv4 address
sip=fe800000000000000000000000000000
tip=ff020000000000000000000000000000

for i in 1 2 3; do
    test_ipv6 ${i}3 f000000000${i}3 f00000000022 $sip $tip
done

# ipv6 packets should not be received by lp[123]3 with mac f000000000$[123]3
# lp[123]1 can send ipv6 traffic as there is no port security
for i in 1 2 3; do
    test_ipv6 ${i}1 f000000000${i}1 f000000000${i}3 $sip $tip
done

# lp13 has extra port security with mac f0000000113 and ipv6 addr
# fe80::ea2a:eaff:fe28:0012 and 4242::0013

# ipv4 packet should be dropped for lp13 with mac f0000000113
sip=`ip_to_hex 192 168 0 13`
tip=`ip_to_hex 192 168 0 23`
test_ip 13 f00000000113 f00000000023 $sip $tip

# ipv6 packet should be received by lp[123]3 with mac f00000000${i}${i}3
# and ip6.dst as fe80::ea2a:eaff:fe28:0${i}${i}3.
# lp11 can send ipv6 traffic as there is no port security
sip=ee800000000000000000000000000000
for i in 1 2 3; do
    tip=fe80000000000000ea2aeafffe2800${i}3
    test_ipv6 11 f00000000011 f00000000${i}${i}3 $sip $tip ${i}3
    tip=424200000000000000000000000000${i}3
    test_ipv6 11 f00000000011 f00000000${i}${i}3 $sip $tip ${i}3
done


# ipv6 packet should not be received by lp33 with mac f0000000333
# and ip6.dst as fe80::ea2a:eaff:fe28:0023 or 4242::0023 as it is
# configured with fe80::ea2a:eaff:fe28:0033 and 4242::0033
# lp11 can send ipv6 traffic as there is no port security

sip=ee800000000000000000000000000000
tip=fe80000000000000ea2aeafffe280023
test_ipv6 11 f00000000011 f00000000333 $sip $tip
tip=42420000000000000000000000000023
test_ipv6 11 f00000000011 f00000000333 $sip $tip

# ipv6 packet should be allowed for lp[123]3 with mac f0000000${i}${i}3
# and ip6.src fe80::ea2a:eaff:fe28:0${i}${i}3, 4242::00${i}3 and ip6.src ::.
# and should be dropped for any other ip6.src
# lp21 can receive ipv6 traffic as there is no port security

tip=ee800000000000000000000000000000
for i in 1 2 3; do
    sip=fe80000000000000ea2aeafffe2800${i}3
    test_ipv6 ${i}3 f00000000${i}${i}3 f00000000021 $sip $tip 21
    sip=424200000000000000000000000000${i}3
    test_ipv6 ${i}3 f00000000${i}${i}3 f00000000021 $sip $tip 21

    # Test ICMPv6 MLD reports (v1 and v2) and NS for DAD
    sip=00000000000000000000000000000000
    test_icmpv6 ${i}3 f00000000${i}${i}3 f00000000021 $sip ff020000000000000000000000160000 83 21
    test_icmpv6 ${i}3 f00000000${i}${i}3 f00000000021 $sip ff020000000000000000000000160000 8f 21
    test_icmpv6 ${i}3 f00000000${i}${i}3 f00000000021 $sip ff0200000000000000ea2aeafffe2800 87 21
    # Traffic to non-multicast traffic should be dropped
    test_icmpv6 ${i}3 f00000000${i}${i}3 f00000000021 $sip $tip 83
    # Traffic of other ICMPv6 types should be dropped
    test_icmpv6 ${i}3 f00000000${i}${i}3 f00000000021 $sip ff020000000000000000000000160000 80

    # should be dropped
    sip=ae80000000000000ea2aeafffe2800aa
    test_ipv6 ${i}3 f00000000${i}${i}3 f00000000021 $sip $tip
done

# configure lsp13 to send and received IPv4 packets with an address range
ovn-nbctl --wait=hv lsp-set-port-security lp13 "f0:00:00:00:00:13 192.168.0.13 20.0.0.4/24 10.0.0.0/24 4242::/64"

sip=`ip_to_hex 10 0 0 13`
tip=`ip_to_hex 192 168 0 22`
# arp packet with inner ip 10.0.0.13 should be allowed for lsp13
test_arp 13 f00000000013 f00000000013 $sip $tip 0 f00000000022

sip=`ip_to_hex 10 0 0 14`
tip=`ip_to_hex 192 168 0 23`
# IPv4 packet from lsp13 with src ip 10.0.0.14 destined to lsp23
# with dst ip 192.168.0.23 should be allowed
test_ip 13 f00000000013 f00000000023 $sip $tip 23

sip=42420000000000000000000000000014
tip=42420000000000000000000000000023
# IPv6 packet from lsp13 with src ip 4242::14 destined to lsp23
# with dst ip 4242::23 should be received by lsp23
test_ipv6 13 f00000000013 f00000000223 $sip $tip 23

sip=`ip_to_hex 192 168 0 33`
tip=`ip_to_hex 10 0 0 15`
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 10.0.0.15 should be received by lsp13
test_ip 33 f00000000033 f00000000013 $sip $tip 13

sip=42420000000000000000000000000033
tip=42420000000000000000000000000013
# IPv6 packet from lsp33 with src ip 4242::33 destined to lsp13
# with dst ip 4242::13 should be received by lsp13
test_ipv6 33 f00000000333 f00000000013 $sip $tip 13

sip=`ip_to_hex 192 168 0 33`
tip=`ip_to_hex 20 0 0 4`
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 20.0.0.4 should be received by lsp13
test_ip 33 f00000000033 f00000000013 $sip $tip 13

sip=`ip_to_hex 192 168 0 33`
tip=`ip_to_hex 20 0 0 5`
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 20.0.0.5 should not be received by lsp13
test_ip 33 f00000000033 f00000000013 $sip $tip

sip=42420000000000000000000000000033
tip=42420000000000000000000000000005
# IPv6 packet from lsp33 with src ip 4242::33 destined to lsp13
# with dst ip 4242::5 should not be received by lsp13
test_ipv6 33 f00000000333 f00000000013 $sip $tip 13

sip=`ip_to_hex 192 168 0 33`
tip=`ip_to_hex 20 0 0 255`
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 20.0.0.255 should be received by lsp13
test_ip 33 f00000000033 f00000000013 $sip $tip 13

sip=`ip_to_hex 192 168 0 33`
tip=`ip_to_hex 192 168 0 255`
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 192.168.0.255 should not be received by lsp13
test_ip 33 f00000000033 f00000000013 $sip $tip

sip=`ip_to_hex 192 168 0 33`
tip=`ip_to_hex 224 0 0 4`
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 224.0.0.4  should be received by lsp13
test_ip 33 f00000000033 f00000000013 $sip $tip 13

#dump information including flow counters
ovn-nbctl show
ovn-sbctl dump-flows -- list multicast_group > sbflows
AT_CAPTURE_FILE([sbflows])

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-ofctl -O OpenFlow13 show br-int
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-ofctl -O OpenFlow13 show br-int
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv3 dump ------"
as hv3 ovs-vsctl show
as hv3 ovs-ofctl -O OpenFlow13 show br-int
as hv3 ovs-ofctl -O OpenFlow13 dump-flows br-int

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    for j in 1 2 3; do
        OVN_CHECK_PACKETS([hv$i/vif$i$j-tx.pcap], [$i$j.expected])
    done
done

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 2 LS, 1 lport/LS, 2 peer LRs])
ovn_start

# Logical network:
# Two LRs - R1 and R2 that are connected to each other as peers in 20.0.0.0/24
# network. R1 has a switchs ls1 (191.168.1.0/24) connected to it.
# R2 has ls2 (172.16.1.0/24) connected to it.

ls1_lp1_mac="f0:00:00:01:02:03"
rp_ls1_mac="00:00:00:01:02:03"
rp_ls2_mac="00:00:00:01:02:04"
ls2_lp1_mac="f0:00:00:01:02:04"

ls1_lp1_ip="192.168.1.2"
ls2_lp1_ip="172.16.1.2"

ovn-nbctl lr-add R1
ovn-nbctl lr-add R2

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 $rp_ls1_mac 192.168.1.1/24

ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 type=router \
  options:router-port=ls1 addresses=\"$rp_ls1_mac\"

# Connect ls2 to R2
ovn-nbctl lrp-add R2 ls2 $rp_ls2_mac 172.16.1.1/24

ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 type=router \
  options:router-port=ls2 addresses=\"$rp_ls2_mac\"

# Connect R1 to R2
ovn-nbctl lrp-add R1 R1_R2 00:00:00:02:03:04 20.0.0.1/24 peer=R2_R1
ovn-nbctl lrp-add R2 R2_R1 00:00:00:02:03:05 20.0.0.2/24 peer=R1_R2

ovn-nbctl lr-route-add R1 "0.0.0.0/0" 20.0.0.2
ovn-nbctl lr-route-add R2 "0.0.0.0/0" 20.0.0.1

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "$ls1_lp1_mac $ls1_lp1_ip"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "$ls2_lp1_mac $ls2_lp1_ip"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Packet to send.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_lp1_mac && eth.dst==$rp_ls1_mac &&
        ip4 && ip.ttl==64 && ip4.src==$ls1_lp1_ip && ip4.dst==$ls2_lp1_ip &&
        udp && udp.src==53 && udp.dst==4369"
AT_CHECK([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])


echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl show br-int
as hv1 ovs-ofctl dump-flows br-int
echo "------ hv2 dump ----------"
as hv2 ovs-ofctl show br-int
as hv2 ovs-ofctl dump-flows br-int

# Packet to Expect
# The TTL should be decremented by 2.
packet="eth.src==$rp_ls2_mac && eth.dst==$ls2_lp1_mac &&
        ip4 && ip.ttl==62 && ip4.src==$ls1_lp1_ip && ip4.dst==$ls2_lp1_ip &&
        udp && udp.src==53 && udp.dst==4369"
echo $packet | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

AT_CHECK([ovn-sbctl dump-flows | grep lr_in_arp_resolve | \
grep "reg0 == 172.16.1.2" | wc -l], [0], [1
])

# Disable the ls2-lp1 port.
ovn-nbctl --wait=hv set logical_switch_port ls2-lp1 enabled=false

AT_CHECK([ovn-sbctl dump-flows | grep lr_in_arp_resolve | \
grep "reg0 == 172.16.1.2" | wc -l], [0], [0
])

# Generate the packet destined for ls2-lp1 and it should not be delivered.
# Packet to send.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_lp1_mac && eth.dst==$rp_ls1_mac &&
        ip4 && ip.ttl==64 && ip4.src==$ls1_lp1_ip && ip4.dst==$ls2_lp1_ip &&
        udp && udp.src==53 && udp.dst==4369"

as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"
# The 2nd packet sent shound not be received.
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 1 HV, 1 LS, 2 lport/LS, 1 LR])
AT_KEYWORDS([router-admin-state])
ovn_start

# Logical network:
# One LR - R1 has switch ls1 with two subnets attached to it (191.168.1.0/24
# and 172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:03 192.168.1.1/24 172.16.1.1/24
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 type=router \
          options:router-port=ls1 addresses=\"00:00:00:01:02:03\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
          -- lsp-set-addresses ls1-lp1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port ls1-lp2 in ls1
ovn-nbctl lsp-add ls1 ls1-lp2 \
          -- lsp-set-addresses ls1-lp2 "f0:00:00:01:02:04 172.16.1.2"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1


wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Send ip packets between the two ports.

# Packet to send.
src_mac="f00000010203"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vif1 $packet


echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list logical_flow
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int


#Disable router R1
ovn-nbctl --wait=hv set Logical_Router R1 enabled=false

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list logical_flow
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int

as hv1 ovs-appctl netdev-dummy/receive vif1 $packet

# Packet to Expect
expect_src_mac="000000010203"
expect_dst_mac="f00000010204"
echo "${expect_dst_mac}${expect_src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000" > expected

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 1 HV, 2 LSs, 1 lport/LS, 1 LR])
AT_KEYWORDS([router-admin-state])
ovn_start

# Logical network:
# One LR - R1 has switch ls1 (191.168.1.0/24) connected to it,
# and has switch ls2 (172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 type=router \
          options:router-port=ls1 addresses=\"00:00:00:01:02:03\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 00:00:00:01:02:04 172.16.1.1/24
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 type=router \
          options:router-port=ls2 addresses=\"00:00:00:01:02:04\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "f0:00:00:01:02:04 172.16.1.2"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1

wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovs-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Send ip packets between the two ports.

# Packet to send.
src_mac="f00000010203"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vif1 $packet

#Disable router R1
ovn-nbctl --wait=hv set Logical_Router R1 enabled=false

ovs-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

as hv1 ovs-appctl netdev-dummy/receive vif1 $packet

# Packet to Expect
expect_src_mac="000000010204"
expect_dst_mac="f00000010204"
echo "${expect_dst_mac}${expect_src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000" > expected

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 3 LS, 1 lport/LS, 2 peer LRs, static routes])
ovn_start

# Logical network:
# Two LRs - R1 and R2 that are connected to each other as peers in 20.0.0.0/24
# network. R1 has switchess foo (192.168.1.0/24)
# connected to it.
# R2 has alice (172.16.1.0/24) and bob (172.16.2.0/24) connected to it.

ovn-nbctl lr-add R1
ovn-nbctl lr-add R2

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:00:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
          options:router-port=foo addresses=\"00:00:00:01:02:03\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:00:01:02:04 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
          type=router options:router-port=alice addresses=\"00:00:00:01:02:04\"

# Connect bob to R2
ovn-nbctl lrp-add R2 bob 00:00:00:01:02:05 172.16.2.1/24
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob type=router \
          options:router-port=bob addresses=\"00:00:00:01:02:05\"

# Connect R1 to R2
ovn-nbctl lrp-add R1 R1_R2 00:00:00:02:03:04 20.0.0.1/24 peer=R2_R1
ovn-nbctl lrp-add R2 R2_R1 00:00:00:02:03:05 20.0.0.2/24 peer=R1_R2

#install static routes
ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
ovn-nbctl lr-route-add R2 172.16.2.0/24 20.0.0.2 R1_R2
ovn-nbctl lr-route-add R2 192.168.1.0/24 20.0.0.1

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port alice1 in alice
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Create logical port bob1 in bob
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:05 172.16.2.2"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=alice1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=bob1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Send ip packets between foo1 and alice1
src_mac="f00000010203"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Send ip packets between foo1 and bob1
src_mac="f00000010203"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 2 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Packet to Expect at bob1
src_mac="000000010205"
dst_mac="f00000010205"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 2 2`
echo "${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000" > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Packet to Expect at alice1
src_mac="000000010204"
dst_mac="f00000010204"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 2`
echo "${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000" > expected

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- send gratuitous arp on localnet])
ovn_start
ovn-nbctl ls-add lsw0
net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0

ovn_attach n1 br-phys 192.168.0.1

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
AT_CHECK([ovs-vsctl add-port br-eth0 snoopvif -- set Interface snoopvif options:tx_pcap=hv/snoopvif-tx.pcap options:rxq_pcap=hv/snoopvif-rx.pcap])

# Create a vif.
AT_CHECK([ovn-nbctl lsp-add lsw0 localvif1])
AT_CHECK([ovn-nbctl lsp-set-addresses localvif1 "f0:00:00:00:00:01 192.168.1.2"])
AT_CHECK([ovn-nbctl lsp-set-port-security localvif1 "f0:00:00:00:00:01"])

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add lsw0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])

AT_CHECK([ovs-vsctl add-port br-int localvif1 -- set Interface localvif1 external_ids:iface-id=localvif1])

# Wait for packet to be received.
echo "fffffffffffff0000000000108060001080006040001f00000000001c0a80102000000000000c0a80102" > expected
OVN_CHECK_PACKETS([hv/snoopvif-tx.pcap], [expected])

# Check GARP packet when restart openflow connection.
as hv
OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])

OVS_WAIT_UNTIL([grep -c "waiting 4 seconds before reconnect" hv/ovn-controller.log])

as hv
start_daemon ovs-vswitchd --enable-dummy=system -vvconn -vofproto_dpif -vunixctl

# Wait for packet to be received.
echo "fffffffffffff0000000000108060001080006040001f00000000001c0a80102000000000000c0a80102" > expected
OVN_CHECK_PACKETS([hv/snoopvif-tx.pcap], [expected])

# Delete the localnet ports.
AT_CHECK([ovs-vsctl del-port localvif1])
AT_CHECK([ovn-nbctl lsp-del ln_port])

OVN_CLEANUP([hv])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 3 LRs connected via LS, static routes])
ovn_start

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24)
# connected to it. R2 has alice (172.16.1.0/24) and R3 has bob (10.32.1.0/24)
# connected to it.

ovn-nbctl lr-add R1
ovn-nbctl lr-add R2
ovn-nbctl lr-add R3

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
    options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 10.32.1.1/24
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24
ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

#install static routes
ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
ovn-nbctl lr-route-add R1 10.32.1.0/24 20.0.0.3

ovn-nbctl lr-route-add R2 192.168.1.0/24 20.0.0.1
ovn-nbctl lr-route-add R2 10.32.1.0/24 20.0.0.3

ovn-nbctl lr-route-add R3 192.168.1.0/24 20.0.0.1
ovn-nbctl lr-route-add R3 172.16.1.0/24 20.0.0.2

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port alice1 in alice
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Create logical port bob1 in bob
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:05 10.32.1.2"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=alice1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=bob1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Send ip packets between foo1 and alice1
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
as hv1 ovs-appctl ofproto/trace br-int in_port=1 $packet

# Send ip packets between foo1 and bob1
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 10 32 1 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"
ovn-sbctl dump-flows
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl show br-int
as hv1 ovs-ofctl dump-flows br-int
echo "------ hv2 dump ----------"
as hv2 ovs-ofctl show br-int
as hv2 ovs-ofctl dump-flows br-int
echo "----------------------------"

# Packet to Expect at bob1
src_mac="000003010203"
dst_mac="f00000010205"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 10 32 1 2`
echo "${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000" > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Packet to Expect at alice1
src_mac="000002010203"
dst_mac="f00000010204"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 2`
echo "${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000" > expected

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- dhcpv4 : 1 HV, 2 LS, 2 LSPs/LS])
ovn_start

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

check ovn-nbctl lsp-set-port-security ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

check ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02 10.0.0.6 20.0.0.4"

check ovn-nbctl lsp-set-port-security ls1-lp2 "f0:00:00:00:00:02 10.0.0.6 20.0.0.4"

check ovn-nbctl ls-add ls2
check ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "f0:00:00:00:00:03 30.0.0.6 40.0.0.4"
check ovn-nbctl lsp-set-port-security ls2-lp1 "f0:00:00:00:00:03 30.0.0.6 40.0.0.4"
check ovn-nbctl lsp-add ls2 ls2-lp2 \
-- lsp-set-addresses ls2-lp2 "f0:00:00:00:00:04 30.0.0.7"
check ovn-nbctl lsp-set-port-security ls2-lp2 "f0:00:00:00:00:04 30.0.0.7"

d1="$(ovn-nbctl create DHCP_Options cidr=10.0.0.0/24 \
options="\"server_id\"=\"10.0.0.1\" \"server_mac\"=\"ff:10:00:00:00:01\" \
\"lease_time\"=\"3600\" \"router\"=\"10.0.0.1\"")"

check ovn-nbctl lsp-set-dhcpv4-options ls1-lp1 ${d1}
check ovn-nbctl lsp-set-dhcpv4-options ls1-lp2 ${d1}

d2="$(ovn-nbctl create DHCP_Options cidr=30.0.0.0/24 \
options="\"server_id\"=\"30.0.0.1\" \"server_mac\"=\"ff:10:00:00:00:02\" \
\"lease_time\"=\"3600\"")"

check ovn-nbctl lsp-set-dhcpv4-options ls2-lp2 ${d2}

net_add n1
sim_add hv1

as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

check ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

check ovs-vsctl -- add-port br-int hv1-vif4 -- \
    set interface hv1-vif4 external-ids:iface-id=ls2-lp2 \
    options:tx_pcap=hv1/vif4-tx.pcap \
    options:rxq_pcap=hv1/vif4-rx.pcap \
    ofport-request=4

as hv1 ovs-appctl vlog/set dbg

OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

as hv1 ovs-vsctl show

# This shell function sends a DHCP request packet
#
# The first argument is just the number of calls to this function so
# far (1, 2, ...).  This is redundant, but it makes it easier to find
# the failures by searching for the number.
#
# test_dhcp PACKET_NUM INPORT SRC_MAC DHCP_TYPE BROADCAST CIADDR OFFER_IP REQUEST_IP ETH_BOOT USE_IP ...
packet_num=0
test_dhcp() {
    local expect_resume=:
    local trace=false
    while :; do
        case $1 in 
            (--no-resume) expect_resume=false; shift ;;
            # --trace isn't used but it can be useful for debugging:
            (--trace) trace=:; shift ;;
            (*) break ;;
        esac
    done

    packet_num=$(expr $packet_num + 1)
    AT_FAIL_IF([test $packet_num != $1])
    shift

    local inport=$1 src_mac=$2 dhcp_type=$3 broadcast=$4 ciaddr=$5 offer_ip=$6 request_ip=$7 eth_boot=$8 use_ip=$9
    shift; shift; shift; shift; shift; shift; shift; shift; shift;

    if test $use_ip != 0; then
        src_ip=$1
        dst_ip=$2
        shift; shift;
    else
        src_ip=`ip_to_hex 0 0 0 0`
        dst_ip=`ip_to_hex 255 255 255 255`
    fi

    AS_BOX([dhcp test packet $packet_num])

    as hv1
    if test -f hv1/ovs-ofctl.pid; then
        OVS_APP_EXIT_AND_WAIT([ovs-ofctl])
        AT_FAIL_IF([test -f ovs-ofctl.pid])
    fi
    AT_CAPTURE_FILE([ofctl_monitor$packet_num.log])
    ovs-ofctl monitor br-int resume --detach --no-chdir \
        --pidfile=ovs-ofctl.pid 2> ofctl_monitor$packet_num.log

    echo "inport=$inport src_mac=$src_mac dhcp_type=$dhcp_type broadcast=$broadcast ciaddr=$ciaddr offer_ip=$offer_ip request_ip=$request_ip use_ip=$use_ip src_ip=$src_ip dst_ip=$dst_ip"

    if test $request_ip != 0; then
        if test $eth_boot != 0; then
            ip_len=0124
            udp_len=010f
        else
            ip_len=0120
            udp_len=010b
        fi
    else
        if test $eth_boot != 0; then
            ip_len=011e
            udp_len=010a
        else
            ip_len=011a
            udp_len=0106
        fi
    fi

    if test $broadcast != 0; then
        flags=8000
        reply_dst_ip=`ip_to_hex 255 255 255 255`
    else
        flags=0000
        reply_dst_ip=${offer_ip}
    fi

    if test "$dhcp_type" = "04"; then
        ciaddr=$offer_ip
    fi

    local request=ffffffffffff${src_mac}08004510${ip_len}0000000080110000${src_ip}${dst_ip}
    # udp header and dhcp header
    request=${request}00440043${udp_len}0000
    request=${request}010106006359aa760000${flags}${ciaddr}000000000000000000000000${src_mac}
    # client hardware padding
    request=${request}00000000000000000000
    # server hostname
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    # boot file name
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    # dhcp magic cookie
    request=${request}63825363
    # dhcp message type
    request=${request}3501${dhcp_type}
    # dhcp unknown option
    request=${request}d70701020304050607
    # dhcp pad option
    request=${request}00
    if test $request_ip != 0; then
        # dhcp requested ip
        request=${request}3204${request_ip}
    fi
    if test $eth_boot != 0; then
        request=${request}af020000
    fi
    # dhcp end option
    request=${request}ff
    tcpdump_hex "-- sending DHCP request on hv1-vif$inport" $request

    for port in $inport "$@"; do
        : >> $port.expected
    done
    if test $offer_ip != 0; then
        local srv_mac=$1 srv_ip=$2 dhcp_reply_type=$3 expected_dhcp_opts=$4
        local offered_ip=$offer_ip
        if [[ "$dhcp_type" == "08" ]]; then
            # DHCP ACK for DHCP INFORM should not have any offer ip.
            offered_ip=00000000
        fi

        # total IP length will be the IP length of the request packet
        # (which is 272 in our case) + 8 (padding bytes) + (expected_dhcp_opts / 2)
        ip_len=`expr 280 + ${#expected_dhcp_opts} / 2`
        udp_len=`expr $ip_len - 20`
        ip_len=$(printf "%x" $ip_len)
        udp_len=$(printf "%x" $udp_len)
        # $ip_len var will be in 3 digits i.e 134. So adding a '0' before $ip_len
        local reply=${src_mac}${srv_mac}0800
        local ip_header=45100${ip_len}0000000080110000${srv_ip}${reply_dst_ip}
        reply=${reply}$(ip4_csum_inplace $ip_header)
        # udp header and dhcp header.
        # $udp_len var will be in 3 digits. So adding a '0' before $udp_len
        reply=${reply}004300440${udp_len}0000020106006359aa760000${flags}${ciaddr}
        # your ip address; 0 for NAK
        if test $dhcp_reply_type = 06; then
            reply=${reply}00000000
        else
            reply=${reply}${offered_ip}
        fi
        # next server ip address, relay agent ip address, client mac address
        reply=${reply}0000000000000000${src_mac}
        # client hardware padding
        reply=${reply}00000000000000000000
        # server hostname
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        # boot file name
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        # dhcp magic cookie
        reply=${reply}63825363
        reply=${reply}3501${dhcp_reply_type}${expected_dhcp_opts}00000000ff00000000
        echo $reply >> $inport.expected
        tcpdump_hex "-- expecting DHCP reply on $inport" $request
    else
        for outport; do
            echo $request >> $outport.expected
        done
    fi
    if $trace; then
        as hv1 ovs-appctl ofproto/trace br-int in_port=hv1-vif$inport $request > trace$packet_num
        AT_CAPTURE_FILE([trace$packet_num])
    else
        check as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $request
    fi

    # NXT_RESUMEs should be 1.
    if $expect_resume; then
        OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor$packet_num.log | grep -c NXT_RESUME`])
    fi
}

compare_dhcp_packets() {
    received=$($PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif$1-tx.pcap)
    expected=$(cat $1.expected)

    if test "$received" != "$expected"; then
        AT_CHECK_UNQUOTED([echo "$received"; tcpdump_hex "$received"], [0],
            [$(echo "$expected"; tcpdump_hex "$expected")])
    fi
}

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    check ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    check ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

AT_CAPTURE_FILE([sbflows])
ovn-sbctl dump-flows > sbflows

# ----------------------------------------------------------------------

# Send DHCPDISCOVER.
offer_ip=`ip_to_hex 10 0 0 4`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 1 1 f00000000001 01 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 02 $expected_dhcp_opts
compare_dhcp_packets 1

# ----------------------------------------------------------------------

# ovs-ofctl also resumes the packets and this causes other ports to receive
# the DHCP request packet. So reset the pcap files so that its easier to test.
reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST in the SELECTING/INIT-REBOOT state with the offered IP
# address in the Requested IP Address option.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=$offer_ip
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 2 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST in the SELECTING/INIT-REBOOT state with a mismatched IP in
# the Requested IP Address option, expect a DHCPNAK.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=`ip_to_hex 10 0 0 7`
expected_dhcp_opts=""
test_dhcp 3 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 06 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------
reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send Invalid DHCPv4 packet on ls1-lp2. It should be received by ovn-controller
# but should be resumed without the reply.
# ls1-lp1 (vif1-tx.pcap) should receive the DHCPv4 request packet twice,
# one from ovn-controller and the other from "ovs-ofctl resume."
ciaddr=`ip_to_hex 0 0 0 0`
offer_ip=0
request_ip=0
test_dhcp 4 2 f00000000002 09 0 $ciaddr $offer_ip $request_ip 0 0 1 1

# NXT_RESUMEs should be 4.
# vif1-tx.pcap should have received the DHCPv4 (invalid) request packet
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# NXT_RESUMEs should be 4.
# Send DHCPREQUEST in the RENEWING/REBINDING state with ip4.src set to 10.0.0.6
# and ip4.dst set to 10.0.0.1.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=$offer_ip
request_ip=0
src_ip=$offer_ip
dst_ip=$server_ip
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 5 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST in the RENEWING/REBINDING state with ip4.src set to 10.0.0.6
# and ip4.dst set to 255.255.255.255.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=$offer_ip
request_ip=0
src_ip=$offer_ip
dst_ip=`ip_to_hex 255 255 255 255`
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 6 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST in the RENEWING/REBINDING state with a mismatched IP in the
# ciaddr, expect a DHCPNAK.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 10 0 0 7`
request_ip=0
src_ip=$offer_ip
dst_ip=`ip_to_hex 255 255 255 255`
expected_dhcp_opts=""
test_dhcp 7 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 06 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST in the RENEWING/REBINDING state without a specifyied ciaddr,
# expect a DHCPNAK.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
src_ip=$offer_ip
dst_ip=`ip_to_hex 255 255 255 255`
expected_dhcp_opts=""
test_dhcp 8 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 06 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST with ip4.src set to 10.0.0.6 and ip4.dst set to 10.0.0.4.
# The packet should not be received by ovn-controller.
ciaddr=`ip_to_hex 0 0 0 0`
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 4`
test_dhcp --no-resume 9 2 f00000000002 03 0 $ciaddr 0 0 0 1 $src_ip $dst_ip 1

# vif1-tx.pcap should have received the DHCPv4 request packet
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPDISCOVER with BROADCAST flag on.
offer_ip=`ip_to_hex 10 0 0 4`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 10 1 f00000000001 01 1 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 02 $expected_dhcp_opts
compare_dhcp_packets 1

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPRELEASE.
offer_ip=0
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 10 0 0 6`
request_ip=0
expected_dhcp_opts=0
test_dhcp 11 2 f00000000002 07 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001

# There is no reply for this. Check for the INFO log in ovn-controller.log
AT_CHECK([test 1 = $(cat hv1/ovn-controller.log | \
grep "DHCPRELEASE f0:00:00:00:00:02 10.0.0.6" -c)])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [])

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPINFORM
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=$offer_ip
request_ip=0
src_ip=$offer_ip
dst_ip=$server_ip
# In the expected_dhcp_opts we should not see 330400000e10 which is
# dhcp lease time option and 0104ffffff00 which is subnet mask option.
expected_dhcp_opts=03040a00000136040a000001
test_dhcp 12 2 f00000000002 08 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# Now add the dhcp option T1 to the dhcp options.
check ovn-nbctl --wait=hv set dhcp_options ${d1} options:T1=4000
AT_CAPTURE_FILE([sbflows2])
ovn-sbctl dump-flows > sbflows2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST to make sure that T1 is in the reply dhcp options.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=$offer_ip
request_ip=0
src_ip=$offer_ip
dst_ip=$server_ip
# In the expected_dhcp_opts we should not see 330400000e10 which is
# dhcp lease time option.
expected_dhcp_opts=3a0400000fa0330400000e100104ffffff0003040a00000136040a000001
test_dhcp 13 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Now send DHCPINFORM again.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=00000000
request_ip=0
src_ip=$offer_ip
dst_ip=$server_ip
# In the expected_dhcp_opts we should not see 330400000e10 which is
# dhcp lease time option and 0104ffffff00 which is subnet mask option.
expected_dhcp_opts=03040a00000136040a000001
test_dhcp 14 2 f00000000002 08 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Set tftp server option (IPv4 address) for ls1
echo "------ Set tftp server (IPv4 address) --------"
ovn-nbctl --wait=hv dhcp-options-set-options $d1 server_id=10.0.0.1 \
server_mac=ff:10:00:00:00:01 lease_time=3600 router=10.0.0.1 \
tftp_server=10.10.10.10
AT_CAPTURE_FILE([sbflows3])
ovn-sbctl dump-flows > sbflows3
echo "----------------------------------------------"

# Send DHCPREQUEST in the SELECTING/INIT-REBOOT state with the offered IP
# address in the Requested IP Address option.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=$offer_ip
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a00000142040a0a0a0a
test_dhcp 15 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Set tftp server option (Hostname) for ls1
echo "------ Set tftp server (hostname) --------"
ovn-nbctl --wait=hv dhcp-options-set-options $d1 server_id=10.0.0.1 \
server_mac=ff:10:00:00:00:01 lease_time=3600 router=10.0.0.1 \
tftp_server=\"test_tftp_server\"
AT_CAPTURE_FILE([sbflows4])
ovn-sbctl dump-flows > sbflows4
echo "------------------------------------------"

# Send DHCPREQUEST in the SELECTING/INIT-REBOOT state with the offered IP
# address in the Requested IP Address option.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=$offer_ip
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a0000014210746573745f746674705f736572766572
test_dhcp 16 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Set domain search list option for ls1
echo "------ Set domain search list --------"
ovn-nbctl --wait=hv dhcp-options-set-options $d1 server_id=10.0.0.1 \
server_mac=ff:10:00:00:00:01 lease_time=3600 router=10.0.0.1 \
domain_search_list=\"test1.com,test2.com\"
AT_CAPTURE_FILE([sbflows5])
ovn-sbctl dump-flows > sbflows5
echo "------------------------------------------"

# Send DHCPREQUEST in the SELECTING/INIT-REBOOT state with the offered IP
# address in the Requested IP Address option.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=$offer_ip
expected_dhcp_opts=771305746573743103636f6d00057465737432c006330400000e100104ffffff0003040a00000136040a000001
test_dhcp 17 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

# test DHCPDECLINE
offer_ip=`ip_to_hex 10 0 0 4`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
expected_dhcp_opts=""
test_dhcp 18 1 f00000000001 04 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 02 $expected_dhcp_opts
AT_CHECK([fgrep -iq 'DHCPDECLINE from f0:00:00:00:00:01, 10.0.0.4 duplicated' hv1/ovn-controller.log], [0], [])

# Send Etherboot.

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

ovn-nbctl --all destroy dhcp-option

ovn-nbctl dhcp-options-create 10.0.0.0/24
d3=$(ovn-nbctl --bare --columns=_uuid find dhcp_options cidr="10.0.0.0/24")
ovn-nbctl dhcp-options-set-options $d3 \
   server_id=10.0.0.1 server_mac=ff:10:00:00:00:01 \
   lease_time=3600 router=10.0.0.1 bootfile_name_alt=\"bootfile_name_alt\" \
   bootfile_name=\"bootfile\"

ovn-nbctl lsp-set-dhcpv4-options ls1-lp1 $d3

offer_ip=`ip_to_hex 10 0 0 4`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
boofile=4308626f6f7466696c65
expected_dhcp_opts=${boofile}330400000e100104ffffff0003040a00000136040a000001
test_dhcp 19 1 f00000000001 01 0 $ciaddr $offer_ip $request_ip 1 0 ff1000000001 $server_ip 02 $expected_dhcp_opts
compare_dhcp_packets 1

# Test that ovn-controller pinctrl thread handles dhcp requests when it
# connects to a wrong version of ovn-northd at startup.

# Stop ovn-northd so that we can modify the northd_version.
as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as northd-backup
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

northd_version=$(ovn-sbctl get SB_Global . options:northd_internal_version | sed s/\"//g)
echo "northd version = $northd_version"

check ovn-sbctl set SB_Global . options:northd_internal_version=foo

echo
echo "__file__:__line__: Stop ovn-controller."
as hv1
OVS_APP_EXIT_AND_WAIT([ovn-controller])

echo
echo "__file__:__line__: Pin ovn-controller to ovn-northd version."

as hv1
check ovs-vsctl set open . external_ids:ovn-match-northd-version=true

# Start ovn-controller
as hv1
start_daemon ovn-controller

OVS_WAIT_UNTIL(
    [test 1 = $(grep -c "controller version - $northd_version mismatch with northd version - foo" hv1/ovn-controller.log)
])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# ----------------------------------------------------------------------

offer_ip=`ip_to_hex 10 0 0 4`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
boofile=4308626f6f7466696c65
expected_dhcp_opts=${boofile}330400000e100104ffffff0003040a00000136040a000001
test_dhcp 20 1 f00000000001 01 0 $ciaddr $offer_ip $request_ip 1 0 ff1000000001 $server_ip 02 $expected_dhcp_opts
compare_dhcp_packets 1

as hv1
OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- dhcpv6 : 1 HV, 2 LS, 5 LSPs])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4 ae70::4"

ovn-nbctl lsp-set-port-security ls1-lp1 "f0:00:00:00:00:01 10.0.0.4 ae70::4"

ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02 ae70::5"

ovn-nbctl lsp-set-port-security ls1-lp2 "f0:00:00:00:00:02 ae70::5"

ovn-nbctl lsp-add ls1 ls1-lp3 \
-- lsp-set-addresses ls1-lp3 "f0:00:00:00:00:22 ae70::22"

ovn-nbctl lsp-set-port-security ls1-lp3 "f0:00:00:00:00:22 ae70::22"

d1="$(ovn-nbctl create DHCP_Options cidr="ae70\:\:/64" \
options="\"server_id\"=\"00:00:00:10:00:01\"")"

ovn-nbctl lsp-set-dhcpv6-options ls1-lp1 ${d1}
ovn-nbctl lsp-set-dhcpv6-options ls1-lp2 ${d1}

d2="$(ovn-nbctl create DHCP_Options cidr="ae70\:\:/64" \
options="\"dhcpv6_stateless\"=\"true\" \"server_id\"=\"00:00:00:10:00:01\"")"

ovn-nbctl lsp-set-dhcpv6-options ls1-lp3 ${d2}

ovn-nbctl ls-add ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "f0:00:00:00:00:03 be70::3"
ovn-nbctl lsp-set-port-security ls2-lp1 "f0:00:00:00:00:03 be70::3"
ovn-nbctl lsp-add ls2 ls2-lp2 \
-- lsp-set-addresses ls2-lp2 "f0:00:00:00:00:04 be70::4"
ovn-nbctl lsp-set-port-security ls2-lp2 "f0:00:00:00:00:04 be70::4"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

ovs-vsctl -- add-port br-int hv1-vif4 -- \
    set interface hv1-vif4 external-ids:iface-id=ls2-lp2 \
    options:tx_pcap=hv1/vif4-tx.pcap \
    options:rxq_pcap=hv1/vif4-rx.pcap \
    ofport-request=4

ovs-vsctl -- add-port br-int hv1-vif5 -- \
    set interface hv1-vif5 external-ids:iface-id=ls1-lp3 \
    options:tx_pcap=hv1/vif5-tx.pcap \
    options:rxq_pcap=hv1/vif5-rx.pcap \
    ofport-request=5

OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

# This shell function sends a DHCPv6 request packet
# test_dhcpv6 INPORT SRC_MAC SRC_LLA DHCPv6_MSG_TYPE OFFER_IP OUTPORT...
# The OUTPORTs (zero or more) list the VIFs on which the original DHCPv6
# packet should be received twice (one from ovn-controller and the other
# from the "ovs-ofctl monitor br-int resume"
test_dhcpv6() {
    local inport=$1 src_mac=$2 src_lla=$3 msg_code=$4 offer_ip=$5
    if test $msg_code != 0b; then
        req_len=2a
    else
        req_len=1a
    fi
    local request=ffffffffffff${src_mac}86dd0000000000${req_len}1101${src_lla}
    # dst ip ff02::1:2
    request=${request}ff020000000000000000000000010002
    # udp header and dhcpv6 header
    request=${request}0222022300${req_len}ffff${msg_code}010203
    # Client identifier
    request=${request}0001000a00030001${src_mac}
    # Add IA-NA (Identity Association for Non Temporary Address) if msg_code
    # is not 11 (information request packet)
    if test $msg_code != 0b; then
        request=${request}0003000c0102030400000e1000001518
    fi
    shift; shift; shift; shift; shift;
    if test $offer_ip != 0; then
        local server_mac=000000100001
        local server_lla=fe80000000000000020000fffe100001
        local reply_code=07
        if test $msg_code = 01; then
            reply_code=02
        fi
        local msg_len=54
        if test $offer_ip = 1; then
            msg_len=28
        fi
        local reply=${src_mac}${server_mac}86dd0000000000${msg_len}1101${server_lla}${src_lla}
        # udp header and dhcpv6 header
        reply=${reply}0223022200${msg_len}ffff${reply_code}010203
        # Client identifier
        reply=${reply}0001000a00030001${src_mac}
        # IA-NA
        if test $offer_ip != 1; then
            reply=${reply}0003002801020304ffffffffffffffff00050018${offer_ip}ffffffffffffffff
        fi
        # Server identifier
        reply=${reply}0002000a00030001${server_mac}
        echo $reply | trim_zeros >> $inport.expected
    else
        for outport; do
            echo $request | trim_zeros >> $outport.expected
        done
    fi

    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $request
}

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

AT_CAPTURE_FILE([ofctl_monitor0.log])
as hv1 ovs-ofctl monitor br-int resume --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0.log

echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list logical_flow
echo "---------------------"

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int

src_mac=f00000000001
src_lla=fe80000000000000f20000fffe000001
offer_ip=ae700000000000000000000000000004
test_dhcpv6 1 $src_mac $src_lla 01 $offer_ip

# NXT_RESUMEs should be 1.
OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap | trim_zeros > 1.packets
# cat 1.expected | trim_zeros > expout
cat 1.expected | cut -c -120 > expout
AT_CHECK([cat 1.packets | cut -c -120], [0], [expout])
# Skipping the UDP checksum
cat 1.expected | cut -c 125- > expout
AT_CHECK([cat 1.packets | cut -c 125-], [0], [expout])

rm  1.expected

# Send invalid packet on ls1-lp2. ovn-controller should resume the packet
# without any modifications and the packet should be received by ls1-lp1.
# ls1-lp1 will receive the packet twice, one from the ovn-controller after the
# resume and the other from ovs-ofctl monitor resume.

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2

src_mac=f00000000002
src_lla=fe80000000000000f20000fffe000002
offer_ip=ae700000000000000000000000000005
# Set invalid msg_type

test_dhcpv6 2 $src_mac $src_lla 10 0 1 1

# NXT_RESUMEs should be 2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

# vif2-tx.pcap should not have received the DHCPv6 reply packet
rm 2.packets
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap | trim_zeros > 2.packets
AT_CHECK([cat 2.packets], [0], [])

# vif1-tx.pcap should have received the DHCPv6 (invalid) request packet
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap | trim_zeros > 1.packets
cat 1.expected > expout
AT_CHECK([cat 1.packets], [0], [expout])

# Send DHCPv6 packet on ls2-lp1. native DHCPv6 is disabled on this port.
# There should be no DHCPv6 reply from ovn-controller and the request packet
# should be received by ls2-lp2.

src_mac=f00000000003
src_lla=fe80000000000000f20000fffe000003
test_dhcpv6 3 $src_mac $src_lla 01 0 4

# NXT_RESUMEs should be 2 only.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

# vif3-tx.pcap should not have received the DHCPv6 reply packet
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif3-tx.pcap | trim_zeros > 3.packets
AT_CHECK([cat 3.packets], [0], [])

# vif4-tx.pcap should have received the DHCPv6 request packet
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif4-tx.pcap | trim_zeros > 4.packets
cat 4.expected > expout
AT_CHECK([cat 4.packets], [0], [expout])

# Send DHCPv6 packet on ls1-lp3. native DHCPv6 works as stateless mode for this port.
# The DHCPv6 reply shouldn't contain offer_ip.
src_mac=f00000000022
src_lla=fe80000000000000f20000fffe000022
reset_pcap_file hv1-vif5 hv1/vif5
test_dhcpv6 5 $src_mac $src_lla 01 1 5

# NXT_RESUMEs should be 3.
OVS_WAIT_UNTIL([test 3 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif5-tx.pcap | trim_zeros > 5.packets
# Skipping the UDP checksum
cat 5.expected | cut -c 1-120,125- > expout
AT_CHECK([cat 5.packets | cut -c 1-120,125- ], [0], [expout])

# Send DHCPv6 information request (code 11) on ls1-lp3. The DHCPv6 reply
# shouldn't contain offer_ip
src_mac=f00000000022
src_lla=fe80000000000000f20000fffe000022
reset_pcap_file hv1-vif5 hv1/vif5
rm -f 5.expected
test_dhcpv6 5 $src_mac $src_lla 0b 1 5

# NXT_RESUMEs should be 4.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif5-tx.pcap |
trim_zeros > 5.packets
# Skipping the UDP checksum
cat 5.expected | cut -c 1-120,125- > expout
AT_CHECK([cat 5.packets | cut -c 1-120,125- ], [0], [expout])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 2 LRs connected via LS, gateway router])
ovn_start

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24)
# connected to it. R2 has alice (172.16.1.0/24) connected to it.
# R2 is a gateway router.



# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1


sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=alice1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis="hv2"

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'


#install static routes
ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
ip_prefix=172.16.1.0/24 nexthop=20.0.0.2 -- add Logical_Router \
R1 static_routes @lrt

ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
ip_prefix=192.168.1.0/24 nexthop=20.0.0.1 -- add Logical_Router \
R2 static_routes @lrt

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port alice1 in alice
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Send ip packets between foo1 and alice1
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"
ovn-sbctl dump-flows
echo "---------------------"
ovn-sbctl list chassis
ovn-sbctl list encap
echo "---------------------"

# Packet to Expect at alice1
src_mac="000002010203"
dst_mac="f00000010204"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 2`
expected=${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000


as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
as hv1 ovs-appctl ofproto/trace br-int in_port=1 $packet

echo "------ hv1 dump after packet 1 ----------"
as hv1 ovs-ofctl show br-int
as hv1 ovs-ofctl dump-flows br-int
echo "------ hv2 dump after packet 1 ----------"
as hv2 ovs-ofctl show br-int
as hv2 ovs-ofctl dump-flows br-int
echo "----------------------------"

echo $expected > expected
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Delete the router and re-create it. Things should work as before.
ovn-nbctl  lr-del R2
ovn-nbctl create Logical_Router name=R2 options:chassis="hv2"
# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24

ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
ip_prefix=192.168.1.0/24 nexthop=20.0.0.1 -- add Logical_Router \
R2 static_routes @lrt

# Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Send the packet again.
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

echo "------ hv1 dump after packet 2 ----------"
as hv1 ovs-ofctl show br-int
as hv1 ovs-ofctl dump-flows br-int
echo "------ hv2 dump after packet 2 ----------"
as hv2 ovs-ofctl show br-int
as hv2 ovs-ofctl dump-flows br-int
echo "----------------------------"

echo $expected >> expected
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- icmp_reply: 1 HVs, 2 LSs, 1 lport/LS, 1 LR])
AT_KEYWORDS([router-icmp-reply])
ovn_start

# Logical network:
# One LR - R1 has switch ls1 (191.168.1.0/24) connected to it,
# and has switch ls2 (172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:f1 192.168.1.1/24
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 \
    type=router options:router-port=ls1 addresses=\"00:00:00:01:02:f1\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 00:00:00:01:02:f2 172.16.1.1/24
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 \
    type=router options:router-port=ls2 addresses=\"00:00:00:01:02:f2\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "00:00:00:01:02:03 192.168.1.2"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "00:00:00:01:02:04 172.16.1.2"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync
ovn-nbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

for i in 1 2; do
    : > vif$i.expected
done
# test_ipv4_icmp_request INPORT ETH_SRC ETH_DST IPV4_SRC IPV4_DST IP_CHKSUM ICMP_CHKSUM [EXP_IP_CHKSUM EXP_ICMP_CHKSUM]
#
# Causes a packet to be received on INPORT.  The packet is an ICMPv4
# request with ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHSUM and
# ICMP_CHKSUM as specified.  If EXP_IP_CHKSUM and EXP_ICMP_CHKSUM are
# provided, then it should be the ip and icmp checksums of the packet
# responded; otherwise, no reply is expected.
# In the absence of an ip checksum calculation helpers, this relies
# on the caller to provide the checksums for the ip and icmp headers.
# XXX This should be more systematic.
#
# INPORT is an lport number, e.g. 11 for vif11.
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_DST are each 8 hex digits.
# IP_CHSUM and ICMP_CHKSUM are each 4 hex digits.
# EXP_IP_CHSUM and EXP_ICMP_CHKSUM are each 4 hex digits.
test_ipv4_icmp_request() {
    local inport=$1 eth_src=$2 eth_dst=$3 ipv4_src=$4 ipv4_dst=$5 ip_chksum=$6 icmp_chksum=$7
    local exp_ip_chksum=$8 exp_icmp_chksum=$9
    shift; shift; shift; shift; shift; shift; shift
    shift; shift

    # Use ttl to exercise section 4.2.2.9 of RFC1812
    local ip_ttl=01
    local icmp_id=5fbf
    local icmp_seq=0001
    local icmp_data=$(seq 1 56 | xargs printf "%02x")
    local icmp_type_code_request=0800
    local icmp_payload=${icmp_type_code_request}${icmp_chksum}${icmp_id}${icmp_seq}${icmp_data}
    local packet=${eth_dst}${eth_src}08004500005400004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}${icmp_payload}

    as hv1 ovs-appctl netdev-dummy/receive vif$inport $packet
    if test X$exp_icmp_chksum != X; then
        # Expect to receive the reply, if any. In same port where packet was sent.
        # Note: src and dst fields are expected to be reversed.
        local icmp_type_code_response=0000
        local reply_icmp_ttl=fe
        local reply_icmp_payload=${icmp_type_code_response}${exp_icmp_chksum}${icmp_id}${icmp_seq}${icmp_data}
        local reply=${eth_src}${eth_dst}08004500005400004000${reply_icmp_ttl}01${exp_ip_chksum}${ipv4_dst}${ipv4_src}${reply_icmp_payload}
        echo $reply >> vif$inport.expected
    fi
}

# Send ping packet to router's ip addresses, from each of the 2 logical ports.
rtr_l1_ip=$(ip_to_hex 192 168 1 1)
rtr_l2_ip=$(ip_to_hex 172 16 1 1)
l1_ip=$(ip_to_hex 192 168 1 2)
l2_ip=$(ip_to_hex 172 16 1 2)

# Ping router ip address that is on same subnet as the logical port
test_ipv4_icmp_request 1 000000010203 0000000102f1 $l1_ip $rtr_l1_ip 0000 8510 02ff 8d10
test_ipv4_icmp_request 2 000000010204 0000000102f2 $l2_ip $rtr_l2_ip 0000 8510 02ff 8d10

# Ping router ip address that is on the other side of the logical ports
test_ipv4_icmp_request 1 000000010203 0000000102f1 $l1_ip $rtr_l2_ip 0000 8510 02ff 8d10
test_ipv4_icmp_request 2 000000010204 0000000102f2 $l2_ip $rtr_l1_ip 0000 8510 02ff 8d10


echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list logical_flow
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int

# Now check the packets actually received against the ones expected.
for inport in 1 2; do
    OVN_CHECK_PACKETS([hv1/vif${inport}-tx.pcap], [vif$inport.expected])
done

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- policy-based routing: 1 HVs, 2 LSs, 1 lport/LS, 1 LR])
AT_KEYWORDS([policy-based-routing])
ovn_start

# Logical network:
# One LR - R1 has switch ls1 (191.168.1.0/24) connected to it,
# and has switch ls2 (172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl ls-add ls3

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:f1 192.168.1.1/24
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 \
    type=router options:router-port=ls1 addresses=\"00:00:00:01:02:f1\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 00:00:00:01:02:f2 172.16.1.1/24
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 \
    type=router options:router-port=ls2 addresses=\"00:00:00:01:02:f2\"

# Connect ls3 to R1
ovn-nbctl lrp-add R1 ls3 00:00:00:01:02:f3 20.20.1.1/24
ovn-nbctl lsp-add ls3 rp-ls3 -- set Logical_Switch_Port rp-ls3 \
    type=router options:router-port=ls3 addresses=\"00:00:00:01:02:f3\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "00:00:00:01:02:03 192.168.1.2"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "00:00:00:01:02:04 172.16.1.2"

# Create logical port ls3-lp1 in ls3
ovn-nbctl lsp-add ls3 ls3-lp1 \
-- lsp-set-addresses ls3-lp1 "00:00:00:01:02:05 20.20.1.2"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add pbr-hv
as pbr-hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=pbr-hv/vif1-tx.pcap \
    options:rxq_pcap=pbr-hv/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=pbr-hv/vif2-tx.pcap \
    options:rxq_pcap=pbr-hv/vif2-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif3 -- \
    set interface vif3 external-ids:iface-id=ls3-lp1 \
    options:tx_pcap=pbr-hv/vif3-tx.pcap \
    options:rxq_pcap=pbr-hv/vif3-rx.pcap \
    ofport-request=1

ls1_ro_mac=00:00:00:01:02:f1
ls1_ro_ip=192.168.1.1

ls2_ro_mac=00:00:00:01:02:f2
ls2_ro_ip=172.16.1.1

ls3_ro_mac=00:00:00:01:02:f3

ls1_p1_mac=00:00:00:01:02:03
ls1_p1_ip=192.168.1.2

ls2_p1_mac=00:00:00:01:02:04
ls2_p1_ip=172.16.1.2

ls3_p1_mac=00:00:00:01:02:05

# Create a drop policy
check ovn-nbctl --wait=hv lr-policy-add R1 10 "ip4.src==192.168.1.0/24 && ip4.dst==172.16.1.0/24" drop

# Check logical flow
ovn-sbctl dump-flows > sbflows
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_policy | grep "192.168.1.0" | wc -l], [0], [dnl
1
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip4 && ip.ttl==64 && ip4.src==$ls1_p1_ip && ip4.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"

as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Check if packet hit the drop policy
AT_CHECK([ovs-ofctl dump-flows br-int | \
    grep "nw_src=192.168.1.0/24,nw_dst=172.16.1.0/24 actions=drop" | \
    grep "priority=10" | \
    grep "n_packets=1" | wc -l], [0], [dnl
1
])

# Expected to drop the packet.
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" pbr-hv/vif2-tx.pcap > vif2.packets
rcvd_packet=`cat vif2.packets`
AT_FAIL_IF([test "$rcvd_packet" != ""])

# Override drop policy with allow
check ovn-nbctl --wait=hv lr-policy-add R1 20 "ip4.src==192.168.1.0/24 && ip4.dst==172.16.1.0/24" allow

# Check logical flow
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_policy | grep "192.168.1.0" | wc -l], [0], [dnl
2
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip4 && ip.ttl==64 && ip4.src==$ls1_p1_ip && ip4.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Check if packet hit the allow policy
sleep 1
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_policy | \
    grep "192.168.1.0" | \
    grep "priority=20" | wc -l], [0], [dnl
1
])

# Expected packet has TTL decreased by 1
expected="eth.src==$ls2_ro_mac && eth.dst==$ls2_p1_mac &&
       ip4 && ip.ttl==63 && ip4.src==$ls1_p1_ip && ip4.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([pbr-hv/vif2-tx.pcap], [expected])

# Override allow policy with reroute
check ovn-nbctl --wait=hv lr-policy-add R1 30 "ip4.src==192.168.1.0/24 && ip4.dst==172.16.1.0/24" reroute 20.20.1.2

# Check logical flow
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_policy | \
    grep "192.168.1.0" | \
    grep "priority=30" | wc -l], [0], [dnl
1
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip4 && ip.ttl==64 && ip4.src==$ls1_p1_ip && ip4.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"
sleep 1

echo "southbound flows"
ovn-sbctl --ovs dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])
echo "ovs flows"
ovs-ofctl dump-flows br-int > brflows
AT_CAPTURE_FILE([brflows])
# Check if packet hit the allow policy
AT_CHECK([grep "nw_src=192.168.1.0/24,nw_dst=172.16.1.0/24" brflows | \
    grep "priority=30" | \
    grep "n_packets=1" | wc -l], [0], [dnl
1
])
echo "packet hit reroute policy"

# Expected packet has TTL decreased by 1
expected="eth.src==$ls3_ro_mac && eth.dst==$ls3_p1_mac &&
       ip4 && ip.ttl==63 && ip4.src==$ls1_p1_ip && ip4.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > 3.expected

OVN_CHECK_PACKETS([pbr-hv/vif3-tx.pcap], [3.expected])

OVN_CLEANUP([pbr-hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- policy-based routing IPv6: 1 HVs, 3 LSs, 1 lport/LS, 1 LR])
AT_KEYWORDS([policy-based-routing])
ovn_start

# Logical network:
# One LR - R1 has switch ls1 (191.168.1.0/24) connected to it,
# and has switch ls2 (172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl ls-add ls3

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:f1 2001::1/64
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 \
    type=router options:router-port=ls1 addresses=\"00:00:00:01:02:f1\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 00:00:00:01:02:f2 2002::1/64
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 \
    type=router options:router-port=ls2 addresses=\"00:00:00:01:02:f2\"

# Connect ls3 to R1
ovn-nbctl lrp-add R1 ls3 00:00:00:01:02:f3 2003::1/64
ovn-nbctl lsp-add ls3 rp-ls3 -- set Logical_Switch_Port rp-ls3 \
    type=router options:router-port=ls3 addresses=\"00:00:00:01:02:f3\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "00:00:00:01:02:03 2001::2"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "00:00:00:01:02:04 2002::2"

# Create logical port ls3-lp1 in ls3
ovn-nbctl lsp-add ls3 ls3-lp1 \
-- lsp-set-addresses ls3-lp1 "00:00:00:01:02:05 2003::2"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add pbr-hv
as pbr-hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=pbr-hv/vif1-tx.pcap \
    options:rxq_pcap=pbr-hv/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=pbr-hv/vif2-tx.pcap \
    options:rxq_pcap=pbr-hv/vif2-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif3 -- \
    set interface vif3 external-ids:iface-id=ls3-lp1 \
    options:tx_pcap=pbr-hv/vif3-tx.pcap \
    options:rxq_pcap=pbr-hv/vif3-rx.pcap \
    ofport-request=1

ls1_ro_mac=00:00:00:01:02:f1
ls1_ro_ip=2001::1

ls2_ro_mac=00:00:00:01:02:f2
ls2_ro_ip=2002::1

ls3_ro_mac=00:00:00:01:02:f3

ls1_p1_mac=00:00:00:01:02:03
ls1_p1_ip=2001::2

ls2_p1_mac=00:00:00:01:02:04
ls2_p1_ip=2002::2

ls3_p1_mac=00:00:00:01:02:05

# Create a drop policy
check ovn-nbctl --wait=sb lr-policy-add R1 10 "ip6.src==2001::/64 && ip6.dst==2002::/64" drop

# Check logical flow
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])
AT_CHECK([grep lr_in_policy sbflows | grep "2001" | wc -l], [0], [dnl
1
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip6 && ip.ttl==64 && ip6.src==$ls1_p1_ip && ip6.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"

as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Check if packet hit the drop policy
AT_CHECK([ovs-ofctl dump-flows br-int | \
    grep "ipv6_src=2001::/64,ipv6_dst=2002::/64 actions=drop" | \
    grep "priority=10" | \
    grep "n_packets=1" | wc -l], [0], [dnl
1
])

# Expected to drop the packet.
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" pbr-hv/vif2-tx.pcap > vif2.packets
AT_FAIL_IF([test -s vif2.packets])

# Override drop policy with allow
check ovn-nbctl --wait=sb lr-policy-add R1 20 "ip6.src==2001::/64 && ip6.dst==2002::/64" allow

# Check logical flow
ovn-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])
AT_CHECK([grep lr_in_policy sbflows2 | grep "2001" | wc -l], [0], [dnl
2
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip6 && ip.ttl==64 && ip6.src==$ls1_p1_ip && ip6.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Check if packet hit the allow policy
ovn-sbctl dump-flows > sbflows3
AT_CAPTURE_FILE([sbflows3])
AT_CHECK([grep lr_in_policy sbflows3 | \
    grep "2001" | \
    grep "priority=20" | wc -l], [0], [dnl
1
])

# Expected packet has TTL decreased by 1
expected="eth.src==$ls2_ro_mac && eth.dst==$ls2_p1_mac &&
       ip6 && ip.ttl==63 && ip6.src==$ls1_p1_ip && ip6.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([pbr-hv/vif2-tx.pcap], [expected])

# Override allow policy with reroute
check ovn-nbctl --wait=sb lr-policy-add R1 30 "ip6.src==2001::/64 && ip6.dst==2002::/64" reroute 2003::2

# Check logical flow
ovn-sbctl dump-flows > sbflows4
AT_CAPTURE_FILE([sbflows4])
AT_CHECK([grep lr_in_policy sbflows4 | \
    grep "2001" | \
    grep "priority=30" | wc -l], [0], [dnl
1
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip6 && ip.ttl==64 && ip6.src==$ls1_p1_ip && ip6.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"
sleep 1

ovn-sbctl dump-flows > sbflows5
ovs-ofctl dump-flows br-int > offlows5
AT_CAPTURE_FILE([sbflows5])
AT_CAPTURE_FILE([offlows5])
# Check if packet hit the allow policy
AT_CHECK([grep "ipv6_src=2001::/64,ipv6_dst=2002::/64" offlows5 | \
    grep "priority=30" | \
    grep "n_packets=1" | wc -l], [0], [dnl
1
])

# Expected packet has TTL decreased by 1
expected="eth.src==$ls3_ro_mac && eth.dst==$ls3_p1_mac &&
       ip6 && ip.ttl==63 && ip6.src==$ls1_p1_ip && ip6.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > 3.expected

OVN_CHECK_PACKETS([pbr-hv/vif3-tx.pcap], [3.expected])

OVN_CLEANUP([pbr-hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# 1 hypervisor, 1 port
# make sure that the port state is properly set to up and back down
# when created and deleted.
AT_SETUP([ovn -- port state up and down])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 lp1
ovn-nbctl lsp-set-addresses lp1 unknown

net_add n1
sim_add hv1
as hv1 ovs-vsctl add-br br-phys
as hv1 ovn_attach n1 br-phys 192.168.0.1

as hv1 ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp1` = xup])

as hv1 ovs-vsctl del-port br-int vif1
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp1` = xdown])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# 1 hypervisor, 1 port
# make sure that the OF rules created to support a datapath are added/cleared
# when logical switch is created and removed.
AT_SETUP([ovn -- datapath rules added/removed])
AT_KEYWORDS([cleanup])
ovn_start

net_add n1
sim_add hv1
as hv1 ovs-vsctl add-br br-phys
as hv1 ovn_attach n1 br-phys 192.168.0.1

# This shell function checks if OF rules in br-int have clauses
# related to OVN datapaths. The caller determines if it should find
# a match in the output, or not.
#
# EXPECT_DATAPATH param determines whether flows that refer to
#                 datapath to should be present or not. 0 means
#                 they should not be.
# STAGE_INFO param is a simple string to help identify the stage
#            in the test when this function was invoked.
test_datapath_in_of_rules() {
    local expect_datapath=$1 stage_info=$2
    echo "------ ovn-nbctl show ${stage_info} ------"
    ovn-nbctl show
    echo "------ ovn-sbctl show ${stage_info} ------"
    ovn-sbctl show
    echo "------ OF rules ${stage_info} ------"
    AT_CHECK([ovs-ofctl dump-flows br-int], [0], [stdout])
    # if there is a datapath mentioned in the output, check for the
    # magic keyword that represents one, based on the exit status of
    # a quiet grep
    if test $expect_datapath != 0; then
       AT_CHECK([grep -q -i 'metadata=' stdout], [0], [ignore-nolog])
    else
       AT_CHECK([grep -q -i 'metadata=' stdout], [1], [ignore-nolog])
    fi
}

test_datapath_in_of_rules 0 "before ls+port create"

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 lp1
ovn-nbctl lsp-set-addresses lp1 unknown

as hv1 ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp1` = xup])

test_datapath_in_of_rules 1 "after port is bound"

as hv1 ovs-vsctl del-port br-int vif1
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp1` = xdown])

ovn-nbctl lsp-set-addresses lp1
ovn-nbctl lsp-del lp1
ovn-nbctl ls-del ls1

# wait for earlier changes to take effect
wait_for_ports_up
check ovn-nbctl --wait=sb sync

# ensure OF rules are no longer present. There used to be a bug here.
test_datapath_in_of_rules 0 "after lport+ls removal"

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- nd_na ])
ovn_start

#TODO: since patch port for IPv6 logical router port is not ready not,
#  so we are not going to test vifs on different lswitches cases. Try
#  to update for that once relevant stuff implemented.

# In this test cases we create 1 lswitch, it has 2 VIF ports attached
# with. NS packet we test, from one VIF for another VIF, will be replied
# by local ovn-controller, but not by target VIF.

# Create hypervisors and logical switch lsw0.
ovn-nbctl ls-add lsw0
net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

# Add vif1 to hv1 and lsw0, turn on l2 port security on vif1.
ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1 options:tx_pcap=hv1/vif1-tx.pcap options:rxq_pcap=hv1/vif1-rx.pcap ofport-request=1
ovn-nbctl lsp-add lsw0 lp1
ovn-nbctl lsp-set-addresses lp1 "fa:16:3e:94:05:98 192.168.0.3 fd81:ce49:a948:0:f816:3eff:fe94:598"
ovn-nbctl lsp-set-port-security lp1 "fa:16:3e:94:05:98 192.168.0.3 fd81:ce49:a948:0:f816:3eff:fe94:598"

# Add vif2 to hv1 and lsw0, turn on l2 port security on vif2.
ovs-vsctl add-port br-int vif2 -- set Interface vif2 external-ids:iface-id=lp2 options:tx_pcap=hv1/vif2-tx.pcap options:rxq_pcap=hv1/vif2-rx.pcap ofport-request=2
ovn-nbctl lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp2 "fa:16:3e:a1:f9:ae 192.168.0.4 fd81:ce49:a948:0:f816:3eff:fea1:f9ae"
ovn-nbctl lsp-set-port-security lp2 "fa:16:3e:a1:f9:ae 192.168.0.4 fd81:ce49:a948:0:f816:3eff:fea1:f9ae"

# Add ACL rule for ICMPv6 on lsw0
ovn-nbctl acl-add lsw0 from-lport 1002 'ip6 && icmp6'  allow-related
ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp1" && ip6 && icmp6'  allow-related
ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp2" && ip6 && icmp6'  allow-related

# Allow some time for ovn-northd and ovn-controller to catch up.
# XXX The "sleep" here seems to be essential for ovn-northd-ddlog,
# which may indicate that it needs improvement.
wait_for_ports_up
check ovn-nbctl --wait=hv sync
sleep 1

ovn-nbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

for i in 1 2; do
    : > $i.expected
done

# Complete Neighbor Solicitation packet and Neighbor Advertisement packet
# vif1 -> NS -> vif2.  vif1 <- NA <- ovn-controller.
# vif2 will not receive NS packet, since ovn-controller will reply for it.
ns_packet=3333ffa1f9aefa163e94059886dd6000000000203afffd81ce49a9480000f8163efffe940598fd81ce49a9480000f8163efffea1f9ae8700e01160000000fd81ce49a9480000f8163efffea1f9ae0101fa163e940598
na_packet=fa163e940598fa163ea1f9ae86dd6000000000203afffd81ce49a9480000f8163efffea1f9aefd81ce49a9480000f8163efffe9405988800e9ed60000000fd81ce49a9480000f8163efffea1f9ae0201fa163ea1f9ae

as hv1 ovs-appctl netdev-dummy/receive vif1 $ns_packet
echo $na_packet >> 1.expected

for i in 1 2; do
    OVN_CHECK_PACKETS([hv1/vif$i-tx.pcap], [$i.expected])
done

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- address sets modification/removal smoke test])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

row=`ovn-nbctl create Address_Set name=set1 addresses=\"1.1.1.1\"`
ovn-nbctl set Address_Set $row name=set1 addresses=\"1.1.1.1,1.1.1.2\"
ovn-nbctl --wait=hv destroy Address_Set $row

# A bug previously existed in the address set support code
# that caused ovn-controller to crash after an address set
# was updated and then removed.  This test case ensures
# that ovn-controller is at least still running after
# creating, updating, and deleting an address set.
AT_CHECK([ovs-appctl -t ovn-controller version], [0], [ignore])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ipam])
ovn_start

check_dynamic_addresses() {
    local arg
    case $2 in
        ('') arg='[[]]' ;;
        (*) arg="\"$2\"" ;;
    esac
    check_row_count nb:Logical_Switch_Port 1 name="$1" dynamic_addresses="$arg"
}

# Add a port to a switch that does not have a subnet set, then set the
# subnet which should result in an address being allocated for the port.
ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="0a:00:00:00:00:00"
ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 p0 -- lsp-set-addresses p0 dynamic
ovn-nbctl --wait=sb add Logical-Switch sw0 other_config subnet=192.168.1.0/24
check_dynamic_addresses p0 "0a:00:00:a8:01:03 192.168.1.2"

# Add 9 more ports to sw0, addresses should all be unique.
for n in `seq 1 9`; do
    ovn-nbctl --wait=sb lsp-add sw0 "p$n" -- lsp-set-addresses "p$n" dynamic
done
for i in `seq 1 9`; do
    mac=0a:00:00:a8:01:$(printf "%02x" $(expr $i + 3))
    ip=192.168.1.$(expr $i + 2)
    check_dynamic_addresses p$i "$mac $ip"
done

# Trying similar tests with a second switch. MAC addresses should be unique
# across both switches but IP's only need to be unique within the same switch.
ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 p10 -- lsp-set-addresses p10 dynamic
ovn-nbctl --wait=sb add Logical-Switch sw1 other_config subnet=192.168.1.0/24
check_row_count nb:Logical_Switch_Port 1 name=p10 dynamic_addresses='"0a:00:00:a8:01:0d 192.168.1.2"'

for n in `seq 11 19`; do
    ovn-nbctl --wait=sb lsp-add sw1 "p$n" -- lsp-set-addresses "p$n" dynamic
done
for i in `seq 11 19`; do
    mac=0a:00:00:a8:01:$(printf "%02x" $(expr $i + 3))
    ip=192.168.1.$(expr $i - 8)
    check_dynamic_addresses p$i "$mac $ip"
done

# Change a port's address to test for multiple ip's for a single address entry
# and addresses set by the user.
ovn-nbctl lsp-set-addresses p0 "0a:00:00:a8:01:17 192.168.1.2 192.168.1.12 192.168.1.14"
ovn-nbctl --wait=sb lsp-add sw0 p20 -- lsp-set-addresses p20 dynamic
check_dynamic_addresses p20 "0a:00:00:a8:01:18 192.168.1.13"

# Test for logical router port address management.
ovn-nbctl create Logical_Router name=R1
ovn-nbctl -- --id=@lrp create Logical_Router_port name=sw0 \
network="192.168.1.1/24" mac=\"0a:00:00:a8:01:19\" \
-- add Logical_Router R1 ports @lrp -- lsp-add sw0 rp-sw0 \
-- set Logical_Switch_Port rp-sw0 type=router options:router-port=sw0
ovn-nbctl --wait=sb lsp-add sw0 p21 -- lsp-set-addresses p21 dynamic
check_dynamic_addresses p21 "0a:00:00:a8:01:1a 192.168.1.15"

# Test for address reuse after logical port is deleted.
ovn-nbctl lsp-del p0
ovn-nbctl --wait=sb lsp-add sw0 p23 -- lsp-set-addresses p23 dynamic
check_dynamic_addresses p23 "0a:00:00:a8:01:03 192.168.1.2"

# Test for multiple addresses to one logical port.
ovn-nbctl lsp-add sw0 p25 -- lsp-set-addresses p25 \
"0a:00:00:a8:01:1b 192.168.1.12" "0a:00:00:a8:01:1c 192.168.1.14"
ovn-nbctl --wait=sb lsp-add sw0 p26 -- lsp-set-addresses p26 dynamic
check_dynamic_addresses p26 "0a:00:00:a8:01:17 192.168.1.16"

# Test for exhausting subnet address space.
ovn-nbctl ls-add sw2 -- add Logical-Switch sw2 other_config subnet=172.16.1.0/30
ovn-nbctl --wait=sb lsp-add sw2 p27 -- lsp-set-addresses p27 dynamic
check_dynamic_addresses p27 "0a:00:00:10:01:03 172.16.1.2"

ovn-nbctl --wait=sb lsp-add sw2 p28 -- lsp-set-addresses p28 dynamic
check_dynamic_addresses p28 "0a:00:00:00:00:01"

# Test that address management does not add duplicate MAC for lsp/lrp peers.
ovn-nbctl create Logical_Router name=R2
ovn-nbctl ls-add sw3
ovn-nbctl lsp-add sw3 p29 -- lsp-set-addresses p29 \
"0a:00:00:a8:01:18"
ovn-nbctl -- --id=@lrp create Logical_Router_port name=sw3 \
network="192.168.2.1/24" mac=\"0a:00:00:a8:01:18\" \
-- add Logical_Router R2 ports @lrp -- lsp-add sw3 rp-sw3 \
-- set Logical_Switch_Port rp-sw3 type=router options:router-port=sw3
ovn-nbctl --wait=sb lsp-add sw0 p30 -- lsp-set-addresses p30 dynamic
check_dynamic_addresses p30 "0a:00:00:a8:01:1d 192.168.1.17"

# Test static MAC address with dynamically allocated IP
ovn-nbctl --wait=sb lsp-add sw0 p31 -- lsp-set-addresses p31 \
"fe:dc:ba:98:76:54 dynamic"
check_dynamic_addresses p31 "fe:dc:ba:98:76:54 192.168.1.18"

# Update the static MAC address with dynamically allocated IP and check
# if the MAC address is updated in 'Logical_Switch_Port.dynamic_adddresses'
ovn-nbctl --wait=sb lsp-set-addresses p31 "fe:dc:ba:98:76:55 dynamic"
check_dynamic_addresses p31 "fe:dc:ba:98:76:55 192.168.1.18"

ovn-nbctl --wait=sb lsp-set-addresses p31 "dynamic"
check_dynamic_addresses p31 "0a:00:00:a8:01:1e 192.168.1.18"

ovn-nbctl --wait=sb lsp-set-addresses p31 "fe:dc:ba:98:76:56 dynamic"
check_dynamic_addresses p31 "fe:dc:ba:98:76:56 192.168.1.18"

# Test the exclude_ips from the IPAM list
ovn-nbctl --wait=sb set logical_switch sw0 \
other_config:exclude_ips="192.168.1.19 192.168.1.21 192.168.1.23..192.168.1.50"

ovn-nbctl --wait=sb lsp-add sw0 p32 -- lsp-set-addresses p32 "dynamic"
# 192.168.1.20 should be assigned as 192.168.1.19 is excluded.
check_dynamic_addresses p32 "0a:00:00:a8:01:1e 192.168.1.20"

ovn-nbctl --wait=sb lsp-add sw0 p33 -- lsp-set-addresses p33 \
"dynamic"
# 192.168.1.22 should be assigned as 192.168.1.21 is excluded.
check_dynamic_addresses p33 "0a:00:00:a8:01:1f 192.168.1.22"

ovn-nbctl --wait=sb lsp-add sw0 p34 -- lsp-set-addresses p34 \
"dynamic"
# 192.168.1.51 should be assigned as 192.168.1.23-192.168.1.50 is excluded.
check_dynamic_addresses p34 "0a:00:00:a8:01:34 192.168.1.51"

# Now clear the exclude_ips list. 192.168.1.19 should be assigned.
ovn-nbctl --wait=sb set Logical-switch sw0 other_config:exclude_ips="invalid"
ovn-nbctl --wait=sb lsp-add sw0 p35 -- lsp-set-addresses p35 "dynamic"
check_dynamic_addresses p35 "0a:00:00:a8:01:20 192.168.1.19"

# Set invalid data in exclude_ips list. It should be ignored.
ovn-nbctl --wait=sb set Logical-switch sw0 other_config:exclude_ips="182.168.1.30"
ovn-nbctl --wait=sb lsp-add sw0 p36 -- lsp-set-addresses p36 \
"dynamic"
# 192.168.1.21 should be assigned as that's the next free one.
check_dynamic_addresses p36 "0a:00:00:a8:01:21 192.168.1.21"

# Clear the dynamic addresses assignment request.
ovn-nbctl --wait=sb clear logical_switch_port p36 addresses
check_dynamic_addresses p36

# Set IPv6 prefix
ovn-nbctl --wait=sb set Logical-switch sw0 other_config:ipv6_prefix="aef0::"
ovn-nbctl --wait=sb lsp-add sw0 p37 -- lsp-set-addresses p37 "dynamic"

# With prefix aef0 and mac 0a:00:00:00:00:26, the dynamic IPv6 should be
# - aef0::800:ff:fe00:26 (EUI64)
check_dynamic_addresses p37 "0a:00:00:a8:01:21 192.168.1.21 aef0::800:ff:fea8:121"

ovn-nbctl --wait=sb ls-add sw4
ovn-nbctl --wait=sb set Logical-switch sw4 other_config:ipv6_prefix="bef0::" \
-- set Logical-switch sw4 other_config:subnet=192.168.2.0/30
ovn-nbctl --wait=sb lsp-add sw4 p38 -- lsp-set-addresses p38 "dynamic"

check_dynamic_addresses p38 "0a:00:00:a8:02:03 192.168.2.2 bef0::800:ff:fea8:203"

ovn-nbctl --wait=sb lsp-add sw4 p39 -- lsp-set-addresses p39 \
"f0:00:00:00:10:12 dynamic"

check_dynamic_addresses p39 "f0:00:00:00:10:12 bef0::f200:ff:fe00:1012"

# Test the case where IPv4 addresses are exhausted and IPv6 prefix is set
# p40 should not have an IPv4 address since the pool is exhausted
ovn-nbctl --wait=sb lsp-add sw4 p40 -- lsp-set-addresses p40 \
"dynamic"
check_dynamic_addresses p40 "0a:00:00:00:00:02 bef0::800:ff:fe00:2"

# Test dynamic changes on switch ports.
#
ovn-nbctl --wait=sb ls-add sw5
ovn-nbctl --wait=sb lsp-add sw5 p41 -- lsp-set-addresses p41 \
"dynamic"
# p41 will start with nothing
check_dynamic_addresses p41 ''

# Set a subnet. Now p41 should have an ipv4 address, too
ovn-nbctl --wait=sb add Logical-Switch sw5 other_config subnet=192.168.1.0/24
check_dynamic_addresses p41 "0a:00:00:a8:01:22 192.168.1.2"

# Clear the other_config. The IPv4 address should be gone
ovn-nbctl --wait=sb clear Logical-Switch sw5 other_config
check_dynamic_addresses p41 ''

# Set an IPv6 prefix. Now p41 should have an IPv6 address.
ovn-nbctl --wait=sb set Logical-Switch sw5 other_config:ipv6_prefix="aef0::"
check_dynamic_addresses p41 "0a:00:00:00:00:03 aef0::800:ff:fe00:3"

# Change the MAC address to a static one. The IPv6 address should update.
ovn-nbctl --wait=sb lsp-set-addresses p41 "f0:00:00:00:10:2b dynamic"
check_dynamic_addresses p41 "f0:00:00:00:10:2b aef0::f200:ff:fe00:102b"

# Change the IPv6 prefix. The IPv6 address should update.
ovn-nbctl --wait=sb set Logical-Switch sw5 other_config:ipv6_prefix="bef0::"
check_dynamic_addresses p41 "f0:00:00:00:10:2b bef0::f200:ff:fe00:102b"

# Clear the other_config. The IPv6 address should be gone
ovn-nbctl --wait=sb clear Logical-Switch sw5 other_config
check_dynamic_addresses p41 ''

# Set the subnet again. Now p41 should get the IPv4 address again.
ovn-nbctl --wait=sb add Logical-Switch sw5 other_config subnet=192.168.1.0/24
check_dynamic_addresses p41 "f0:00:00:00:10:2b 192.168.1.2"

# Add an excluded IP address that conflicts with p41. p41 should update.
ovn-nbctl --wait=sb add Logical-Switch sw5 other_config \
exclude_ips="192.168.1.2"
check_dynamic_addresses p41 "f0:00:00:00:10:2b 192.168.1.3"

# Add static ip address
ovn-nbctl --wait=sb lsp-set-addresses p41 "dynamic 192.168.1.100"
ovn-nbctl list Logical-Switch-Port p41
ovn-nbctl --wait=sb lsp-add sw5 p42 -- lsp-set-addresses p42 \
"dynamic 192.168.1.101"
check_dynamic_addresses p41 "0a:00:00:a8:01:65 192.168.1.100"
check_dynamic_addresses p42 "0a:00:00:a8:01:66 192.168.1.101"

# define a mac address prefix
ovn-nbctl ls-add sw6
ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="00:11:22:33:44:55"
ovn-nbctl --wait=sb set Logical-Switch sw6 other_config:subnet=192.168.100.0/24
for n in $(seq 1 3); do
    ovn-nbctl --wait=sb lsp-add sw6 "p5$n" -- lsp-set-addresses "p5$n" dynamic
done
check_dynamic_addresses p51 "00:11:22:a8:64:03 192.168.100.2"
check_dynamic_addresses p52 "00:11:22:a8:64:04 192.168.100.3"
check_dynamic_addresses p53 "00:11:22:a8:64:05 192.168.100.4"

# verify configuration order does not break IPAM/MACAM
ovn-nbctl ls-add sw7
for n in $(seq 1 3); do
    ovn-nbctl --wait=sb lsp-add sw7 "p7$n" -- lsp-set-addresses "p7$n" dynamic
done
ovn-nbctl --wait=sb set Logical-Switch sw7 other_config:ipv6_prefix="bef0::"
p71_addr=$(ovn-nbctl get Logical-Switch-Port p71 dynamic_addresses)
p72_addr=$(ovn-nbctl get Logical-Switch-Port p72 dynamic_addresses)
p73_addr=$(ovn-nbctl get Logical-Switch-Port p73 dynamic_addresses)
AT_CHECK([test "$p71_addr" != "$p72_addr"], [0], [])
AT_CHECK([test "$p71_addr" != "$p73_addr"], [0], [])
AT_CHECK([test "$p72_addr" != "$p73_addr"], [0], [])

# request to assign mac only
#
ovn-nbctl ls-add sw8
ovn-nbctl --wait=sb set Logical-Switch sw8 other_config:mac_only=true
for n in $(seq 1 3); do
    ovn-nbctl --wait=sb lsp-add sw8 "p8$n" -- lsp-set-addresses "p8$n" dynamic
done
check_dynamic_addresses p81 "00:11:22:00:00:06"
check_dynamic_addresses p82 "00:11:22:00:00:07"
check_dynamic_addresses p83 "00:11:22:00:00:08"

# clear mac_prefix and check it is allocated in a random manner
ovn-nbctl --wait=hv remove NB_Global . options mac_prefix
ovn-nbctl ls-add sw9
ovn-nbctl --wait=sb set Logical-Switch sw9 other_config:mac_only=true
ovn-nbctl --wait=sb lsp-add sw9 p91 -- lsp-set-addresses p91 dynamic

mac_prefix=$(ovn-nbctl --wait=sb get NB_Global . options:mac_prefix | tr -d \")
port_addr=$(ovn-nbctl get Logical-Switch-Port p91 dynamic_addresses | tr -d \")
AT_CHECK([test "$port_addr" = "${mac_prefix}:00:00:09"], [0], [])

ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="00:11:22"
ovn-nbctl ls-add sw10
ovn-nbctl --wait=sb set Logical-Switch sw10 other_config:ipv6_prefix="ae01::"
ovn-nbctl --wait=sb lsp-add sw10 p101 -- lsp-set-addresses p101 "dynamic ae01::1"
check_dynamic_addresses p101 "00:11:22:00:00:0a ae01::1"

ovn-nbctl --wait=sb set Logical-Switch sw10 other_config:subnet=192.168.110.0/24
ovn-nbctl --wait=sb lsp-add sw10 p102 -- lsp-set-addresses p102 "dynamic 192.168.110.10 ae01::2"
check_dynamic_addresses p102 "00:11:22:a8:6e:0b 192.168.110.10 ae01::2"

# Configure subnet using address from middle of the subnet and ensure
# address is allocated from the beginning.

ovn-nbctl ls-add sw11
ovn-nbctl --wait=sb set Logical-Switch sw11 other_config:subnet=172.16.1.254/29
ovn-nbctl --wait=sb lsp-add sw11 p103 -- lsp-set-addresses p103 "22:33:44:55:66:77 dynamic"

check_dynamic_addresses p103 "22:33:44:55:66:77 172.16.1.250"

ovn-nbctl ls-add sw12
for i in $(seq 0 1); do
    for j in $(seq 1 99); do
        idx=$((i*100+j))
        ovn-nbctl lsp-add sw12 sw12-p${idx} -- \
        lsp-set-addresses sw12-p${idx} "00:00:00:00:$i:$j dynamic"
    done
done
ovn-nbctl --wait=sb set Logical-Switch sw12 other_config:subnet=192.10.2.0/24
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.127], [0], [ignore])
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.128], [0], [ignore])
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.180], [0], [ignore])

ovn-nbctl --wait=sb set Logical-Switch sw12 other_config:subnet=192.10.2.0/25
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.127], [1])
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.128], [1])
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.180], [1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ipam connectivity])
ovn_start

ovn-nbctl lr-add R1

# Test for a ping using dynamically allocated addresses.
ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="0a:00:00:00:00:00"
ovn-nbctl ls-add foo -- add Logical_Switch foo other_config subnet=192.168.1.0/24
ovn-nbctl ls-add alice -- add Logical_Switch alice other_config subnet=192.168.2.0/24

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:00:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
          options:router-port=foo \
          -- lsp-set-addresses rp-foo router

# Connect alice to R1
ovn-nbctl lrp-add R1 alice 00:00:00:01:02:04 192.168.2.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice type=router \
          options:router-port=alice addresses=\"00:00:00:01:02:04\"

# Create logical port foo1 in foo
ovn-nbctl --wait=sb lsp-add foo foo1 \
-- lsp-set-addresses foo1 "dynamic"
check ovn-nbctl wait-until Logical-Switch-Port foo1 dynamic_addresses='"0a:00:00:a8:01:03 192.168.1.2"'

# Create logical port alice1 in alice
ovn-nbctl --wait=sb lsp-add alice alice1 \
-- lsp-set-addresses alice1 "dynamic"
check ovn-nbctl wait-until Logical-Switch-Port alice1 dynamic_addresses='"0a:00:00:a8:02:03 192.168.2.2"'

# Create logical port foo2 in foo
ovn-nbctl --wait=sb lsp-add foo foo2 \
-- lsp-set-addresses foo2 "dynamic"
check ovn-nbctl wait-until Logical-Switch-Port foo2 dynamic_addresses='"0a:00:00:a8:01:04 192.168.1.3"'

# Create a hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=foo2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=alice1 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Send ip packets between foo1 and foo2
src_mac="0a0000a80103"
dst_mac="0a0000a80104"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 1 3`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Send ip packets between foo1 and alice1
src_mac="0a0000a80103"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int

# Packet to Expect at foo2
src_mac="0a0000a80103"
dst_mac="0a0000a80104"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 1 3`
expected=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > received1.packets
echo $expected > expout
AT_CHECK([cat received1.packets], [0], [expout])

# Packet to Expect at alice1
src_mac="000000010204"
dst_mac="0a0000a80203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
expected=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif3-tx.pcap > received2.packets
echo $expected > expout
AT_CHECK([cat received2.packets], [0], [expout])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ovs-vswitchd restart])
AT_KEYWORDS([vswitchd])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

ovn-nbctl lsp-set-port-security ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

OVN_POPULATE_ARP
sleep 2

as hv1 ovs-vsctl show

echo "---------------------"
ovn-sbctl dump-flows
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int
total_flows=`as hv1 ovs-ofctl dump-flows br-int | wc -l`

echo "Total flows before vswitchd restart = " $total_flows

# Code taken from ovs-save utility
save_flows () {
    echo "ovs-ofctl add-flows br-int - << EOF" > restore_flows.sh
    as hv1 ovs-ofctl dump-flows "br-int" | sed -e '/NXST_FLOW/d' \
            -e 's/\(idle\|hard\)_age=[^,]*,//g' >> restore_flows.sh
    echo "EOF" >> restore_flows.sh
}

restart_vswitchd () {
    restore_flows=$1

    if test $restore_flows = true; then
        save_flows
    fi

    as hv1
    OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])

    if test $restore_flows = true; then
        as hv1
        ovs-vsctl --no-wait set open_vswitch . other_config:flow-restore-wait="true"
    fi

    as hv1
    start_daemon ovs-vswitchd --enable-dummy=system -vvconn -vofproto_dpif -vunixctl
    ovs-ofctl dump-flows br-int

    if test $restore_flows = true; then
        sh ./restore_flows.sh
        echo "Flows after restore"
        as hv1
        ovs-ofctl dump-flows br-int
        ovs-vsctl --no-wait --if-exists remove open_vswitch . other_config \
            flow-restore-wait="true"
    fi
}

# Save the flows, restart vswitchd and restore the flows
restart_vswitchd true
OVS_WAIT_UNTIL([
    total_flows_after_restart=`as hv1 ovs-ofctl dump-flows br-int | wc -l`
    echo "Total flows after vswitchd restart = " $total_flows_after_restart
    test "${total_flows}" = "${total_flows_after_restart}"
])

# Restart vswitchd without restoring
restart_vswitchd false
OVS_WAIT_UNTIL([
    total_flows_after_restart=`as hv1 ovs-ofctl dump-flows br-int | wc -l`
    echo "Total flows after vswitchd restart = " $total_flows_after_restart
    test "${total_flows}" = "${total_flows_after_restart}"
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- send arp for nexthop])
ovn_start

# Topology: Two LSs - ls1 and ls2 are connected via router r0

# Create logical switches
ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Create  router
ovn-nbctl create Logical_Router name=lr0

# Add router ls1p1 port to gateway router
ovn-nbctl lrp-add lr0 lrp-ls1lp1 f0:00:00:00:00:01 192.168.0.1/24
ovn-nbctl lsp-add ls1 ls1lp1 -- set Logical_Switch_Port ls1lp1  \
    type=router options:router-port=lrp-ls1lp1 \
    addresses='"f0:00:00:00:00:01 192.168.0.1"'

# Add router ls2p2 port to gateway router
ovn-nbctl lrp-add lr0 lrp-ls2lp1 f0:00:00:00:00:02 192.168.1.1/24
ovn-nbctl lsp-add ls2 ls2lp1 -- set Logical_Switch_Port ls2lp1 \
    type=router options:router-port=lrp-ls2lp1 \
    addresses='"f0:00:00:00:00:02 192.168.1.1"'

# Set default gateway (nexthop) to 192.168.1.254
ovn-nbctl lr-route-add lr0 "0.0.0.0/0" 192.168.1.254 lrp-ls2lp1

# Create logical port ls1lp2 in ls1
ovn-nbctl lsp-add ls1 ls1lp2 \
-- lsp-set-addresses ls1lp2 "f0:00:00:00:00:03 192.168.0.2"

# Create logical port ls2lp2 in ls2
ovn-nbctl lsp-add ls2 ls2lp2 \
-- lsp-set-addresses ls2lp2 "f0:00:00:00:00:04 192.168.1.10"

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-ls1lp2 -- \
    set interface hv1-ls1lp2 external-ids:iface-id=ls1lp2 \
    options:tx_pcap=hv1/ls1lp2-tx.pcap \
    options:rxq_pcap=hv1/ls1lp2-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-ls2lp2 -- \
    set interface hv1-ls2lp2 external-ids:iface-id=ls2lp2 \
    options:tx_pcap=hv1/ls2lp2-tx.pcap \
    options:rxq_pcap=hv1/ls2lp2-rx.pcap \
    ofport-request=2

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

src_mac="f00000000003"
dst_mac="f00000000001"
src_ip=`ip_to_hex 192 168 0 2`
dst_ip=`ip_to_hex 8 8 8 8`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

# Send IP packet destined to 8.8.8.8 from lsp1lp2
as hv1 ovs-appctl netdev-dummy/receive hv1-ls1lp2 $packet

trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

# ARP packet should be received with Target IP Address set to 192.168.1.254 and
# not 8.8.8.8

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ls2lp2-tx.pcap | trim_zeros > packets
expected="fffffffffffff0000000000208060001080006040001f00000000002c0a80101000000000000c0a801fe"
echo $expected > expout
AT_CHECK([cat packets], [0], [expout])
cat packets

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- send gratuitous arp for nat ips in localnet])
ovn_start
# Create logical switch
ovn-nbctl ls-add ls0
# Create gateway router
ovn-nbctl create Logical_Router name=lr0 options:chassis=hv1
# Add router port to gateway router
ovn-nbctl lrp-add lr0 lrp0 f0:00:00:00:00:01 192.168.0.1/24
ovn-nbctl lsp-add ls0 lrp0-rp -- set Logical_Switch_Port lrp0-rp \
    type=router options:router-port=lrp0 addresses='"f0:00:00:00:00:01"'
# Add nat-address option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="f0:00:00:00:00:01 192.168.0.2"

net_add n1
sim_add hv1
as hv1
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0

ovn_attach n1 br-phys 192.168.0.1

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
AT_CHECK([ovs-vsctl add-port br-eth0 snoopvif -- set Interface snoopvif options:tx_pcap=hv1/snoopvif-tx.pcap options:rxq_pcap=hv1/snoopvif-rx.pcap])

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl --wait=hv lsp-set-options ln_port network_name=physnet1])

# Wait until the patch ports are created in hv1 to connect br-int to br-eth0
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-vsctl show | \
grep "Port patch-br-int-to-ln_port" | wc -l`])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Wait for packet to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 140])
trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros > packets
AT_CHECK([sort packets], [0], [dnl
fffffffffffff0000000000108060001080006040001f00000000001c0a80001000000000000c0a80001
fffffffffffff0000000000108060001080006040001f00000000001c0a80002000000000000c0a80002
])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- send gratuitous arp with nat-addresses router in localnet])
ovn_start
# Create logical switch
ovn-nbctl ls-add ls0
# Create gateway router
ovn-nbctl create Logical_Router name=lr0 options:chassis=hv1
# Add router port to gateway router
ovn-nbctl lrp-add lr0 lrp0 f0:00:00:00:00:01 192.168.0.1/24
ovn-nbctl lsp-add ls0 lrp0-rp -- set Logical_Switch_Port lrp0-rp \
    type=router options:router-port=lrp0 addresses='"f0:00:00:00:00:01"'
# Add nat-address option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"
# Add NAT rules
AT_CHECK([ovn-nbctl lr-nat-add lr0 snat 192.168.0.1 10.0.0.0/24])
AT_CHECK([ovn-nbctl lr-nat-add lr0 dnat 192.168.0.2 10.0.0.1])
# Add load balancers
AT_CHECK([ovn-nbctl lb-add lb0 192.168.0.3:80 10.0.0.2:80,10.0.0.3:80])
AT_CHECK([ovn-nbctl lr-lb-add lr0 lb0])
AT_CHECK([ovn-nbctl lb-add lb1 192.168.0.3:8080 10.0.0.2:8080,10.0.0.3:8080])
AT_CHECK([ovn-nbctl lr-lb-add lr0 lb1])

net_add n1
sim_add hv1
as hv1
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0

ovn_attach n1 br-phys 192.168.0.1

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
AT_CHECK([ovs-vsctl add-port br-eth0 snoopvif -- set Interface snoopvif options:tx_pcap=hv1/snoopvif-tx.pcap options:rxq_pcap=hv1/snoopvif-rx.pcap])

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])

# Wait until the patch ports are created to connect br-int to br-eth0
OVS_WAIT_UNTIL([test 1 = `ovs-vsctl show | \
grep "Port patch-br-int-to-ln_port" | wc -l`])

ovn-sbctl list port_binding lrp0-rp
echo "*****"
ovn-nbctl list logical_switch_port lrp0-rp
ovn-nbctl list logical_router_port lrp0
ovn-nbctl show
# Wait for packet to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 50])
trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros > packets
expected="fffffffffffff0000000000108060001080006040001f00000000001c0a80001000000000000c0a80001"
echo $expected > expout
expected="fffffffffffff0000000000108060001080006040001f00000000001c0a80002000000000000c0a80002"
echo $expected >> expout
expected="fffffffffffff0000000000108060001080006040001f00000000001c0a80003000000000000c0a80003"
echo $expected >> expout
AT_CHECK([sort packets], [0], [expout])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- delete mac bindings])
ovn_start
net_add n1
sim_add hv1
as hv1
ovs-vsctl -- add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
# Create logical switch ls0
ovn-nbctl ls-add ls0
# Create ports lp0, lp1 in ls0
ovn-nbctl lsp-add ls0 lp0
ovn-nbctl lsp-add ls0 lp1
ovn-nbctl lsp-set-addresses lp0 "f0:00:00:00:00:01 192.168.0.1"
ovn-nbctl lsp-set-addresses lp1 "f0:00:00:00:00:02 192.168.0.2"
dp_uuid=$(fetch_column Datapath_Binding _uuid)
ovn-sbctl create MAC_Binding ip=10.0.0.1 datapath=$dp_uuid logical_port=lp0 mac="mac1"
ovn-sbctl create MAC_Binding ip=10.0.0.1 datapath=$dp_uuid logical_port=lp1 mac="mac2"
ovn-sbctl find MAC_Binding
# Delete port lp0 and check that its MAC_Binding is deleted.
ovn-nbctl lsp-del lp0
ovn-sbctl find MAC_Binding
wait_row_count MAC_Binding 0 logical_port=lp0
# Delete logical switch ls0 and check that its MAC_Binding is deleted.
ovn-nbctl ls-del ls0
ovn-sbctl find MAC_Binding
wait_row_count MAC_Binding 0

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- conntrack zone allocation])
ovn_start

# Logical network:
# 2 logical switches "foo" (192.168.1.0/24) and "bar" (172.16.1.0/24)
# connected to a router R1.
# foo has foo1 to act as a client.
# bar has bar1, bar2, bar3 to act as servers.

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
for i in foo1 bar1 bar2 bar3; do
    ovs-vsctl -- add-port br-int $i -- \
        set interface $i external-ids:iface-id=$i \
        options:tx_pcap=hv1/$i-tx.pcap \
        options:rxq_pcap=hv1/$i-rx.pcap
done

ovn-nbctl create Logical_Router name=R1
ovn-nbctl ls-add foo
ovn-nbctl ls-add bar

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 172.16.1.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port bar1, bar2 and bar3 in bar
for i in `seq 1 3`; do
    ip=`expr $i + 1`
    ovn-nbctl lsp-add bar bar$i \
    -- lsp-set-addresses bar$i "f0:00:0a:01:02:$i 172.16.1.$ip"
done

OVS_WAIT_UNTIL([test `ovs-ofctl dump-flows br-int table=0 | grep REG13 | wc -l` -eq 4])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- tag allocation])
ovn_start

AT_CHECK([ovn-nbctl ls-add ls0])
AT_CHECK([ovn-nbctl lsp-add ls0 parent1])
AT_CHECK([ovn-nbctl lsp-add ls0 parent2])
AT_CHECK([ovn-nbctl ls-add ls1])

AS_BOX([requested tag for parent1])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c0 parent1 3])
c0_tag=$(ovn-nbctl lsp-get-tag c0)
echo c0_tag=$c0_tag
check test "$c0_tag" = 3
dnl The same 'tag' gets created in southbound database.
check_row_count Port_Binding 1 logical_port=c0 tag=$c0_tag

AS_BOX([tag allocation 1 for parent1])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c1 parent1 0])
c1_tag=$(ovn-nbctl lsp-get-tag c1)
echo c1_tag=$c1_tag
check test "$c1_tag" != "$c0_tag"
check_row_count Port_Binding 1 logical_port=c1 tag=$c1_tag

AS_BOX([tag allocation 2 for parent1])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c2 parent1 0])
c2_tag=$(ovn-nbctl lsp-get-tag c2)
echo c2_tag=$c2_tag
check test "$c2_tag" != "$c0_tag"
check test "$c2_tag" != "$c1_tag"
check_row_count Port_Binding 1 logical_port=c2 tag=$c2_tag

AS_BOX([tag allocation 3 for parent1])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c3 parent1 0])
c3_tag=$(ovn-nbctl lsp-get-tag c3)
echo c3_tag=$c3_tag
check test "$c3_tag" != "$c0_tag"
check test "$c3_tag" != "$c1_tag"
check test "$c3_tag" != "$c2_tag"
check_row_count Port_Binding 1 logical_port=c3 tag=$c3_tag

AS_BOX([tag allocation 1 for parent2])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c4 parent2 0])
c4_tag=$(ovn-nbctl lsp-get-tag c4)
echo c4_tag=$c4_tag
check_row_count Port_Binding 1 logical_port=c4 tag=$c4_tag

AS_BOX([tag allocation 2 for parent2])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c5 parent2 0])
c5_tag=$(ovn-nbctl lsp-get-tag c5)
echo c5_tag=$c5_tag
check test "$c5_tag" != "$c4_tag"
check_row_count Port_Binding 1 logical_port=c5 tag=$c5_tag

AS_BOX([delete and add tag allocation for parent1])
AT_CHECK([ovn-nbctl --wait=sb lsp-del c1])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c6 parent1 0])
c6_tag=$(ovn-nbctl lsp-get-tag c6)
echo c6_tag=$c6_tag
check_row_count Port_Binding 1 logical_port=c6 tag=$c6_tag
check test "$c6_tag" != "$c0_tag"
check test "$c6_tag" != "$c2_tag"
check test "$c6_tag" != "$c3_tag"

AS_BOX([restart northd and make sure tag allocation is stable]) 
as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])
start_daemon NORTHD_TYPE \
    --ovnnb-db=unix:"$ovs_base"/ovn-nb/ovn-nb.sock \
    --ovnsb-db=unix:"$ovs_base"/ovn-sb/ovn-sb.sock

dnl Create a switch to make sure that ovn-northd has run through the main loop.
AT_CHECK([ovn-nbctl --wait=sb ls-add ls-dummy])

AT_CHECK_UNQUOTED([
    for lsp in c0 c2 c3 c4 c5 c6; do
        ovn-nbctl lsp-get-tag $lsp
    done], [0],
[$c0_tag
$c2_tag
$c3_tag
$c4_tag
$c5_tag
$c6_tag
])

dnl Create a switch port with a tag that has already been allocated.
dnl It should go through fine with a duplicate tag.
AS_BOX([request duplicate tag])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c7 parent2 $c5_tag])
AT_CHECK([ovn-nbctl lsp-get-tag c7], [0], [2
])
check_row_count Port_Binding 1 logical_port=c7 tag=$c5_tag
check_row_count Port_Binding 1 logical_port=c5 tag=$c5_tag
check_row_count Port_Binding 2 parent_port=parent2 tag=$c5_tag

AS_BOX([tag_request without parent_name])
AT_CHECK([ovn-nbctl ls-add ls2])
dnl When there is no parent_name provided (for say, 'localnet'), 'tag_request'
dnl gets copied to 'tag'
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls2 local0 "" 25])
AT_CHECK([ovn-nbctl lsp-get-tag local0], [0], [25
])
dnl The same 'tag' gets created in southbound database.
AT_CHECK([ovn-sbctl --data=bare --no-heading --columns=tag find port_binding \
logical_port="local0"], [0], [25
])
dnl If 'tag_request' is 0 for localnet, nothing gets written to 'tag'
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls2 local1 "" 0])
AT_CHECK([ovn-nbctl lsp-get-tag local1])
dnl change the tag_request.
AT_CHECK([ovn-nbctl --wait=sb  set logical_switch_port local1 tag_request=50])
AT_CHECK([ovn-nbctl lsp-get-tag local1], [0], [50
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- lsp deletion and broadcast-flow deletion on localnet])
ovn_start
ovn-nbctl ls-add lsw0
net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    ovs-vsctl add-br br-eth0
    AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
done

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add lsw0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])


# Create 3 vifs.
AT_CHECK([ovn-nbctl lsp-add lsw0 localvif1])
AT_CHECK([ovn-nbctl lsp-set-addresses localvif1 "f0:00:00:00:00:01 192.168.1.1"])
AT_CHECK([ovn-nbctl lsp-set-port-security localvif1 "f0:00:00:00:00:01"])
AT_CHECK([ovn-nbctl lsp-add lsw0 localvif2])
AT_CHECK([ovn-nbctl lsp-set-addresses localvif2 "f0:00:00:00:00:02 192.168.1.2"])
AT_CHECK([ovn-nbctl lsp-set-port-security localvif2 "f0:00:00:00:00:02"])
AT_CHECK([ovn-nbctl lsp-add lsw0 localvif3])
AT_CHECK([ovn-nbctl lsp-set-addresses localvif3 "f0:00:00:00:00:03 192.168.1.3"])
AT_CHECK([ovn-nbctl lsp-set-port-security localvif3 "f0:00:00:00:00:03"])

# Bind the localvif1 to hv1.
as hv1
AT_CHECK([ovs-vsctl add-port br-int localvif1 -- set Interface localvif1 external_ids:iface-id=localvif1])

# On hv1, check that there are no flows outputting bcast to tunnel
OVS_WAIT_UNTIL([test `ovs-ofctl dump-flows br-int table=37 | ofctl_strip | grep output | wc -l` -eq 0])

# On hv2, check that no flow outputs bcast to tunnel to hv1.
as hv2
OVS_WAIT_UNTIL([test `ovs-ofctl dump-flows br-int table=37 | ofctl_strip | grep output | wc -l` -eq 0])

# Now bind vif2 on hv2.
AT_CHECK([ovs-vsctl add-port br-int localvif2 -- set Interface localvif2 external_ids:iface-id=localvif2])

# At this point, the broadcast flow on vif2 should be deleted.
# because, there is now a localnet vif bound (table=37 programming logic)
OVS_WAIT_UNTIL([test `ovs-ofctl dump-flows br-int table=37 | ofctl_strip | grep output | wc -l` -eq 0])

# Verify that the local net patch port exists on hv2.
OVS_WAIT_UNTIL([test `ovs-vsctl show | grep "Port patch-br-int-to-ln_port" | wc -l` -eq 1])

# Now bind vif3 on hv2.
AT_CHECK([ovs-vsctl add-port br-int localvif3 -- set Interface localvif3 external_ids:iface-id=localvif3])

# Verify that the local net patch port still exists on hv2
OVS_WAIT_UNTIL([test `ovs-vsctl show | grep "Port patch-br-int-to-ln_port" | wc -l` -eq 1])

# Delete localvif2
AT_CHECK([ovn-nbctl lsp-del localvif2])

# Verify that the local net patch port still exists on hv2,
# because, localvif3 is still bound.
OVS_WAIT_UNTIL([test `ovs-vsctl show | grep "Port patch-br-int-to-ln_port" | wc -l` -eq 1])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ACL logging])
AT_KEYWORDS([ovn])
ovn_start

net_add n1

sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
for i in lp1 lp2; do
    ovs-vsctl -- add-port br-int $i -- \
        set interface $i external-ids:iface-id=$i \
        options:tx_pcap=hv/$i-tx.pcap \
        options:rxq_pcap=hv/$i-rx.pcap
done

lp1_mac="f0:00:00:00:00:01"
lp1_ip="192.168.1.2"

lp2_mac="f0:00:00:00:00:02"
lp2_ip="192.168.1.3"

ovn-nbctl ls-add lsw0
ovn-nbctl --wait=sb lsp-add lsw0 lp1
ovn-nbctl --wait=sb lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp1 $lp1_mac
ovn-nbctl lsp-set-addresses lp2 $lp2_mac
ovn-nbctl --wait=sb sync
wait_for_ports_up

ovn-nbctl acl-add lsw0 to-lport 1000 'tcp.dst==80' drop
ovn-nbctl --log --severity=alert --name=drop-flow acl-add lsw0 to-lport 1000 'tcp.dst==81' drop

ovn-nbctl acl-add lsw0 to-lport 1000 'tcp.dst==82' allow
ovn-nbctl --log --severity=info --name=allow-flow acl-add lsw0 to-lport 1000 'tcp.dst==83' allow

ovn-nbctl acl-add lsw0 to-lport 1000 'tcp.dst==84' allow-related
ovn-nbctl --log acl-add lsw0 to-lport 1000 'tcp.dst==85' allow-related

ovn-nbctl acl-add lsw0 to-lport 1000 'tcp.dst==86' reject
ovn-nbctl --wait=hv --log --severity=alert --name=reject-flow acl-add lsw0 to-lport 1000 'tcp.dst==87' reject

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Send packet that should be dropped without logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4360 && tcp.dst==80"
as hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Send packet that should be dropped with logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4361 && tcp.dst==81"
as hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Send packet that should be allowed without logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4362 && tcp.dst==82"
as hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Send packet that should be allowed with logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4363 && tcp.dst==83"
as hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Send packet that should allow related flows without logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4364 && tcp.dst==84"
as hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Send packet that should allow related flows with logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4365 && tcp.dst==85"
as hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Send packet that should be rejected without logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4366 && tcp.dst==86"
as hv ovs-appctl -t ovn-controller inject-pkt "$packet"

# Send packet that should be rejected with logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4367 && tcp.dst==87"
as hv ovs-appctl -t ovn-controller inject-pkt "$packet"

OVS_WAIT_UNTIL([ test 4 = $(grep -c 'acl_log' hv/ovn-controller.log) ])

AT_CHECK([grep 'acl_log' hv/ovn-controller.log | sed 's/.*name=/name=/'], [0], [dnl
name="drop-flow", verdict=drop, severity=alert: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4361,tp_dst=81,tcp_flags=syn
name="allow-flow", verdict=allow, severity=info: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4363,tp_dst=83,tcp_flags=syn
name="<unnamed>", verdict=allow, severity=info: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4365,tp_dst=85,tcp_flags=syn
name="reject-flow", verdict=reject, severity=alert: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4367,tp_dst=87,tcp_flags=syn
])

OVN_CLEANUP([hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ACL rate-limited logging])
AT_KEYWORDS([ovn])
ovn_start

net_add n1

sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
for i in lp1 lp2; do
    ovs-vsctl -- add-port br-int $i -- \
        set interface $i external-ids:iface-id=$i \
        options:tx_pcap=hv/$i-tx.pcap \
        options:rxq_pcap=hv/$i-rx.pcap
done

lp1_mac="f0:00:00:00:00:01"
lp1_ip="192.168.1.2"

lp2_mac="f0:00:00:00:00:02"
lp2_ip="192.168.1.3"

ovn-nbctl ls-add lsw0
ovn-nbctl --wait=sb lsp-add lsw0 lp1
ovn-nbctl --wait=sb lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp1 $lp1_mac
ovn-nbctl lsp-set-addresses lp2 $lp2_mac
ovn-nbctl --wait=sb sync
wait_for_ports_up


# Add an ACL that rate-limits logs at 10 per second.
ovn-nbctl meter-add http-rl1 drop 10 pktps
ovn-nbctl --log --severity=alert --meter=http-rl1 --name=http-acl1 acl-add lsw0 to-lport 1000 'tcp.dst==80' drop
check ovn-nbctl --wait=hv sync

# Add an ACL that rate-limits logs at 5 per second.
ovn-nbctl meter-add http-rl2 drop 5 pktps
ovn-nbctl --log --severity=alert --meter=http-rl2 --name=http-acl2 acl-add lsw0 to-lport 1000 'tcp.dst==81' allow
check ovn-nbctl --wait=hv sync

# Add an ACL that doesn't rate-limit logs.
ovn-nbctl --log --severity=alert --name=http-acl3 acl-add lsw0 to-lport 1000 'tcp.dst==82' drop
ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# For each ACL, send 100 packets.
for i in `seq 1 100`; do
    ovs-appctl netdev-dummy/receive lp1 'in_port(1),eth(src=f0:00:00:00:00:01,dst=f0:00:00:00:00:02),eth_type(0x0800),ipv4(src=192.168.1.2,dst=192.168.1.3,proto=6,tos=0,ttl=64,frag=no),tcp(src=7777,dst=80)'

    ovs-appctl netdev-dummy/receive lp1 'in_port(1),eth(src=f0:00:00:00:00:01,dst=f0:00:00:00:00:02),eth_type(0x0800),ipv4(src=192.168.1.2,dst=192.168.1.3,proto=6,tos=0,ttl=64,frag=no),tcp(src=7777,dst=81)'

    ovs-appctl netdev-dummy/receive lp1 'in_port(1),eth(src=f0:00:00:00:00:01,dst=f0:00:00:00:00:02),eth_type(0x0800),ipv4(src=192.168.1.2,dst=192.168.1.3,proto=6,tos=0,ttl=64,frag=no),tcp(src=7777,dst=82)'
done

# The rate at which packets are sent is highly system-dependent, so we
# can't count on precise drop counts.  To work around that, we just
# check that exactly 100 "http-acl3" actions were logged and that there
# were more "http-acl1" actions than "http-acl2" ones.
OVS_WAIT_UNTIL([ test 100 = $(grep -c 'http-acl3' hv/ovn-controller.log) ])

# On particularly slow or overloaded systems, the transmission rate may
# be lower than the configured meter rate.  To prevent false test
# failures, we check the duration count of the meter, and if it's
# greater than nine seconds, just skip the test.
d_secs=$(as hv ovs-ofctl -O OpenFlow13 meter-stats br-int | grep "meter:1" | sed 's/.* duration:\([[0-9]]\{1,\}\)\.[[0-9]]\+s .*/\1/')

echo "Meter duration: $d_secs"
AT_SKIP_IF([test $d_secs -gt 9])

# Print some information that may help debugging.
AT_CHECK([as hv ovs-appctl -t ovn-controller meter-table-list], [0], [dnl
http-rl1: 1
http-rl2: 2
])
as hv ovs-ofctl -O OpenFlow13 meter-stats br-int

n_acl1=$(grep -c 'http-acl1' hv/ovn-controller.log)
n_acl2=$(grep -c 'http-acl2' hv/ovn-controller.log)
n_acl3=$(grep -c 'http-acl3' hv/ovn-controller.log)

AT_CHECK([ test $n_acl3 -gt $n_acl1 ], [0], [])
AT_CHECK([ test $n_acl1 -gt $n_acl2 ], [0], [])

OVN_CLEANUP([hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- same meter used by multiple logical flows])
AT_KEYWORDS([ovn])
ovn_start

net_add n1

sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
for i in lp1 lp2; do
    ovs-vsctl -- add-port br-int $i -- \
        set interface $i external-ids:iface-id=$i \
        options:tx_pcap=hv/$i-tx.pcap \
        options:rxq_pcap=hv/$i-rx.pcap
done

lp1_mac="f0:00:00:00:00:01"
lp1_ip="192.168.1.2"

lp2_mac="f0:00:00:00:00:02"
lp2_ip="192.168.1.3"

ovn-nbctl ls-add lsw0
ovn-nbctl --wait=sb lsp-add lsw0 lp1
ovn-nbctl --wait=sb lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp1 $lp1_mac
ovn-nbctl lsp-set-addresses lp2 $lp2_mac
ovn-nbctl --wait=sb sync
wait_for_ports_up

ovn-appctl -t ovn-controller vlog/set file:dbg

# Add acl1 and acl2 using same meter.
ovn-nbctl meter-add http-rl1 drop 10 pktps
ovn-nbctl --log --meter=http-rl1 acl-add lsw0 to-lport 1000 'tcp.dst==80' drop \
       -- --log --meter=http-rl1 acl-add lsw0 to-lport 1000 'tcp.dst==81' allow

ovn-nbctl --wait=hv sync

AT_CHECK([ovs-ofctl -O OpenFlow13 dump-meters br-int | grep meter], [0], [ignore], [ignore])

# Delete acl1, meter should be kept in OVS
ovn-nbctl acl-del lsw0 to-lport 1000 'tcp.dst==80'
ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl -O OpenFlow13 dump-meters br-int | grep meter], [0], [ignore], [ignore])

# Delete acl2, meter should be deleted in OVS
ovn-nbctl acl-del lsw0 to-lport 1000 'tcp.dst==81'
ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl -O OpenFlow13 dump-meters br-int | grep meter], [1])

OVN_CLEANUP([hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- DSCP marking and meter check])
AT_KEYWORDS([ovn])
ovn_start

check ovn-nbctl ls-add lsw0
check ovn-nbctl --wait=sb lsp-add lsw0 lp1
check ovn-nbctl --wait=sb lsp-add lsw0 lp2
check ovn-nbctl --wait=sb lsp-add lsw0 lp3
check ovn-nbctl lsp-set-addresses lp1 f0:00:00:00:00:01
check ovn-nbctl lsp-set-addresses lp2 f0:00:00:00:00:02
check ovn-nbctl lsp-set-addresses lp3 f0:00:00:00:00:03
check ovn-nbctl lsp-set-port-security lp1 f0:00:00:00:00:01
check ovn-nbctl lsp-set-port-security lp2 f0:00:00:00:00:02
check ovn-nbctl --wait=sb sync
net_add n1
sim_add hv
as hv
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1 options:tx_pcap=vif1-tx.pcap options:rxq_pcap=vif1-rx.pcap ofport-request=1
check ovs-vsctl add-port br-int vif2 -- set Interface vif2 external-ids:iface-id=lp2 options:tx_pcap=vif2-tx.pcap options:rxq_pcap=vif2-rx.pcap ofport-request=2
wait_for_ports_up lp1 lp2

AT_CAPTURE_FILE([trace])
ovn_trace () {
    ovn-trace --all "$@" | tee trace | sed '1,/Minimal trace/d'
}

# Extracts nw_tos from the final flow from ofproto/trace output and prints
# it on stdout.  Prints "none" if no nw_tos was included.
get_final_nw_tos() {
    if flow=$(grep '^Final flow:' stdout); then :; else
       # The output didn't have a final flow.
       return 99
    fi

    tos=$(echo "$flow" | sed -n 's/.*nw_tos=\([[0-9]]\{1,\}\).*/\1/p')
    case $tos in
        '') echo none ;;
        *) echo $tos ;;
    esac
}

# check_tos TOS
#
# Checks that a packet from 1.1.1.1 to 1.1.1.2 gets its DSCP set to TOS.
check_tos() {
    # First check with ovn-trace for logical flows.
    echo "checking for tos $1"
    (if test $1 != 0; then echo "ip.dscp = $1;"; fi;
     echo 'output("lp2");') > expout
    AT_CHECK_UNQUOTED([ovn_trace lsw0 'inport == "lp1" && eth.src == f0:00:00:00:00:01 && eth.dst == f0:00:00:00:00:02 && ip4.src == 1.1.1.1 && ip4.dst == 1.1.1.2'], [0], [expout])

    # Then re-check with ofproto/trace for a physical packet.
    AT_CHECK([ovs-appctl ofproto/trace br-int 'in_port=1,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,dl_type=0x800,nw_src=1.1.1.1,nw_dst=1.1.1.2'], [0], [stdout-nolog])
    AT_CHECK_UNQUOTED([get_final_nw_tos], [0], [`expr $1 \* 4`
])
}

# check at L2
AT_CHECK([ovn_trace lsw0 'inport == "lp1" && eth.src == f0:00:00:00:00:01 && eth.dst == f0:00:00:00:00:02'], [0], [output("lp2");
])
AT_CHECK([ovs-appctl ofproto/trace br-int 'in_port=1,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02'], [0], [stdout-nolog])
AT_CHECK([get_final_nw_tos], [0], [none
])

# check at L3 without dscp marking
check_tos 0

# Mark DSCP with a valid value
qos_id=$(ovn-nbctl --wait=hv -- --id=@lp1-qos create QoS priority=100 action=dscp=48 match="inport\=\=\"lp1\"\ &&\ is_chassis_resident(\"lp1\")" direction="from-lport" -- set Logical_Switch lsw0 qos_rules=@lp1-qos)
as hv check_row_count nb:QoS 1
check_tos 48

# check at hv without qos meter
AT_CHECK([as hv ovs-ofctl dump-flows br-int -O OpenFlow13 | grep meter | wc -l], [0], [0
])

# Update the meter rate
check ovn-nbctl --wait=hv set QoS $qos_id bandwidth=rate=100

# check at hv with a qos meter table
AT_CHECK([as hv ovs-ofctl dump-meters br-int -O OpenFlow13 | grep rate=100 | wc -l], [0], [1
])
AT_CHECK([as hv ovs-ofctl dump-flows br-int -O OpenFlow13 | grep meter | wc -l], [0], [1
])

# Update the DSCP marking
check ovn-nbctl --wait=hv set QoS $qos_id action=dscp=63
check_tos 63

# Update the meter rate
check ovn-nbctl --wait=hv set QoS $qos_id bandwidth=rate=4294967295,burst=4294967295

# check at hv with a qos meter table
AT_CHECK([as hv ovs-ofctl dump-meters br-int -O OpenFlow13 | grep burst_size=4294967295 | wc -l], [0], [1
])
AT_CHECK([as hv ovs-ofctl dump-flows br-int -O OpenFlow13 | grep meter | wc -l], [0], [1
])

check ovn-nbctl --wait=hv set QoS $qos_id match="outport\=\=\"lp2\"" direction="to-lport"
check_tos 63

# Disable DSCP marking
check ovn-nbctl --wait=hv qos-del lsw0
as hv check_row_count nb:QoS 0
check_tos 0

# check at hv without qos meter
AT_CHECK([as hv ovs-ofctl dump-flows br-int -O OpenFlow13 | grep meter | wc -l], [0], [0
])

# check meter with chassis not resident
check ovn-nbctl --wait=hv qos-add lsw0 to-lport 1001 'inport=="lp3" && is_chassis_resident("lp3")' rate=11123 burst=111230
as hv check_row_count nb:QoS 1

# check no meter table
AT_CHECK([as hv ovs-ofctl dump-flows br-int -O OpenFlow13 | grep meter | wc -l], [0], [0
])
AT_CHECK([as hv ovs-ofctl dump-meters br-int -O OpenFlow13 | grep rate=11123 | wc -l], [0], [0
])

# Check multiple qos meters
check ovn-nbctl qos-del lsw0
check ovn-nbctl qos-add lsw0 to-lport 1001 'inport=="lp1" && is_chassis_resident("lp1")' rate=100000 burst=100000
check ovn-nbctl qos-add lsw0 to-lport 1001 'inport=="lp2" && is_chassis_resident("lp2")' rate=100000 burst=100000
check ovn-nbctl qos-add lsw0 to-lport 1002 'inport=="lp1" && is_chassis_resident("lp1")' rate=100001 burst=100001
check ovn-nbctl --wait=hv qos-add lsw0 to-lport 1002 'inport=="lp2" && is_chassis_resident("lp2")' rate=100001 burst=100001

AT_CHECK([as hv ovs-ofctl dump-meters br-int -O OpenFlow13 | grep meter | wc -l], [0], [4
])

OVN_CLEANUP([hv])
AT_CLEANUP
])

AT_SETUP([ovn -- read-only sb db:ptcp access])

: > .$1.db.~lock~
ovsdb-tool create ovn-sb.db "$abs_top_srcdir"/ovn-sb.ovsschema

# Add read-only remote to sb ovsdb-server
AT_CHECK(
  [ovsdb-tool transact ovn-sb.db \
     ['["OVN_Southbound",
       {"op": "insert",
        "table": "SB_Global",
        "row": {
          "connections": ["set", [["named-uuid", "xyz"]]]}},
       {"op": "insert",
        "table": "Connection",
        "uuid-name": "xyz",
        "row": {"target": "ptcp:0:127.0.0.1",
               "read_only": true}}]']], [0], [ignore], [ignore])

start_daemon ovsdb-server --remote=punix:ovn-sb.sock --remote=db:OVN_Southbound,SB_Global,connections ovn-sb.db

PARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])

# read-only accesses should succeed
AT_CHECK([ovn-sbctl --db=tcp:127.0.0.1:$TCP_PORT list SB_Global], [0], [stdout], [ignore])
AT_CHECK([ovn-sbctl --db=tcp:127.0.0.1:$TCP_PORT list Connection], [0], [stdout], [ignore])

# write access should fail
AT_CHECK([ovn-sbctl --db=tcp:127.0.0.1:$TCP_PORT chassis-add ch vxlan 1.2.4.8], [1], [ignore],
[ovn-sbctl: transaction error: {"details":"insert operation not allowed when database server is in read only mode","error":"not allowed"}
])

OVS_APP_EXIT_AND_WAIT([ovsdb-server])
AT_CLEANUP

AT_SETUP([ovn -- read-only sb db:pssl access])
AT_SKIP_IF([test "$HAVE_OPENSSL" = no])
PKIDIR="$(cd $abs_top_builddir/tests && pwd)"
AT_SKIP_IF([expr "$PKIDIR" : ".*[ 	'\"
\\]"])

: > .$1.db.~lock~
ovsdb-tool create ovn-sb.db "$abs_top_srcdir"/ovn-sb.ovsschema

# Add read-only remote to sb ovsdb-server
AT_CHECK(
  [ovsdb-tool transact ovn-sb.db \
     ['["OVN_Southbound",
       {"op": "insert",
        "table": "SB_Global",
        "row": {
          "connections": ["set", [["named-uuid", "xyz"]]]}},
       {"op": "insert",
        "table": "Connection",
        "uuid-name": "xyz",
        "row": {"target": "pssl:0:127.0.0.1",
               "read_only": true}}]']], [0], [ignore], [ignore])

start_daemon ovsdb-server --remote=punix:ovn-sb.sock \
                          --remote=db:OVN_Southbound,SB_Global,connections \
                          --private-key="$PKIDIR/testpki-privkey2.pem" \
                          --certificate="$PKIDIR/testpki-cert2.pem" \
                          --ca-cert="$PKIDIR/testpki-cacert.pem" \
                          ovn-sb.db

PARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])

# read-only accesses should succeed
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-privkey.pem \
                    --certificate=$PKIDIR/testpki-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
                    list SB_Global], [0], [stdout], [ignore])
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-privkey.pem \
                    --certificate=$PKIDIR/testpki-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
                    list Connection], [0], [stdout], [ignore])

# write access should fail
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-privkey.pem \
                    --certificate=$PKIDIR/testpki-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
                    chassis-add ch vxlan 1.2.4.8], [1], [ignore],
[ovn-sbctl: transaction error: {"details":"insert operation not allowed when database server is in read only mode","error":"not allowed"}
])

OVS_APP_EXIT_AND_WAIT([ovsdb-server])
AT_CLEANUP

AT_SETUP([ovn -- nb connection/ssl commands])
AT_SKIP_IF([test "$HAVE_OPENSSL" = no])
PKIDIR="$(cd $abs_top_builddir/tests && pwd)"
AT_SKIP_IF([expr "$PKIDIR" : ".*[ 	'\"
\\]"])

: > .$1.db.~lock~
ovsdb-tool create ovn-nb.db "$abs_top_srcdir"/ovn-nb.ovsschema

# Start nb db server using db connection/ssl entries (unpopulated initially)
start_daemon ovsdb-server --remote=punix:ovnnb_db.sock \
                          --remote=db:OVN_Northbound,NB_Global,connections \
                          --private-key=db:OVN_Northbound,SSL,private_key \
                          --certificate=db:OVN_Northbound,SSL,certificate \
                          --ca-cert=db:OVN_Northbound,SSL,ca_cert \
                          ovn-nb.db

# Populate SSL configuration entries in nb db
AT_CHECK(
    [ovn-nbctl set-ssl $PKIDIR/testpki-privkey.pem \
                       $PKIDIR/testpki-cert.pem \
                       $PKIDIR/testpki-cacert.pem], [0], [stdout], [ignore])

# Populate a passive SSL connection in nb db
AT_CHECK([ovn-nbctl set-connection pssl:0:127.0.0.1], [0], [stdout], [ignore])

PARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])

# Verify SSL connetivity to nb db server
AT_CHECK([ovn-nbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-privkey.pem \
                    --certificate=$PKIDIR/testpki-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          list NB_Global],
         [0], [stdout], [ignore])
AT_CHECK([ovn-nbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-privkey.pem \
                    --certificate=$PKIDIR/testpki-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          list Connection],
         [0], [stdout], [ignore])
AT_CHECK([ovn-nbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-privkey.pem \
                    --certificate=$PKIDIR/testpki-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          get-connection],
         [0], [stdout], [ignore])

OVS_APP_EXIT_AND_WAIT([ovsdb-server])
AT_CLEANUP

AT_SETUP([ovn -- sb connection/ssl commands])
AT_SKIP_IF([test "$HAVE_OPENSSL" = no])
PKIDIR="$(cd $abs_top_builddir/tests && pwd)"
AT_SKIP_IF([expr "$PKIDIR" : ".*[ 	'\"
\\]"])

: > .$1.db.~lock~
ovsdb-tool create ovn-sb.db "$abs_top_srcdir"/ovn-sb.ovsschema

# Start sb db server using db connection/ssl entries (unpopulated initially)
start_daemon ovsdb-server --remote=punix:ovnsb_db.sock \
                          --remote=db:OVN_Southbound,SB_Global,connections \
                          --private-key=db:OVN_Southbound,SSL,private_key \
                          --certificate=db:OVN_Southbound,SSL,certificate \
                          --ca-cert=db:OVN_Southbound,SSL,ca_cert \
                          ovn-sb.db

# Populate SSL configuration entries in sb db
AT_CHECK(
    [ovn-sbctl set-ssl $PKIDIR/testpki-privkey.pem \
                       $PKIDIR/testpki-cert.pem \
                       $PKIDIR/testpki-cacert.pem], [0], [stdout], [ignore])

# Populate a passive SSL connection in sb db
AT_CHECK([ovn-sbctl set-connection pssl:0:127.0.0.1], [0], [stdout], [ignore])

PARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])

# Verify SSL connetivity to sb db server
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-privkey.pem \
                    --certificate=$PKIDIR/testpki-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          list SB_Global],
         [0], [stdout], [ignore])
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-privkey.pem \
                    --certificate=$PKIDIR/testpki-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          list Connection],
         [0], [stdout], [ignore])
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-privkey.pem \
                    --certificate=$PKIDIR/testpki-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          get-connection],
         [0], [stdout], [ignore])

OVS_APP_EXIT_AND_WAIT([ovsdb-server])
AT_CLEANUP

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- nested containers])
ovn_start

# Physical network:
# 2 HVs. HV1 has 2 VMs - "VM1" and "bar3". HV2 has 1 VM - "VM2"

# Logical network:
# 3 Logical switches - "mgmt" (172.16.1.0/24), "foo" (192.168.1.0/24)
# and "bar" (192.168.2.0/24). They are all connected to router R1.

ovn-nbctl lr-add R1
ovn-nbctl ls-add mgmt
ovn-nbctl ls-add foo
ovn-nbctl ls-add bar

# Connect mgmt to R1
ovn-nbctl lrp-add R1 mgmt 00:00:00:01:02:02 172.16.1.1/24
ovn-nbctl lsp-add mgmt rp-mgmt -- set Logical_Switch_Port rp-mgmt type=router \
          options:router-port=mgmt addresses=\"00:00:00:01:02:02\"

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:00:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
          options:router-port=foo addresses=\"00:00:00:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:00:01:02:04 192.168.2.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar type=router \
          options:router-port=bar addresses=\"00:00:00:01:02:04\"

# "mgmt" has VM1 and VM2 connected
ovn-nbctl lsp-add mgmt vm1 \
-- lsp-set-addresses vm1 "f0:00:00:01:02:03 172.16.1.2"

ovn-nbctl lsp-add mgmt vm2 \
-- lsp-set-addresses vm2 "f0:00:00:01:02:04 172.16.1.3"

# "foo1" and "foo2" are containers belonging to switch "foo"
# "foo1" has "VM1" as parent_port and "foo2" has "VM2" as parent_port.
ovn-nbctl lsp-add foo foo1 vm1 1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:05 192.168.1.2"

ovn-nbctl lsp-add foo foo2 vm2 2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 192.168.1.3"

# "bar1" and "bar2" are containers belonging to switch "bar"
# "bar1" has "VM1" as parent_port and "bar2" has "VM2" as parent_port.
ovn-nbctl lsp-add bar bar1 vm1 2 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:07 192.168.2.2"

ovn-nbctl lsp-add bar bar2 vm2 1 \
-- lsp-set-addresses bar2 "f0:00:00:01:02:08 192.168.2.3"

# bar3 is a standalone VM belonging to switch "bar"
ovn-nbctl lsp-add bar bar3 \
-- lsp-set-addresses bar3 "f0:00:00:01:02:09 192.168.2.4"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vm1 -- \
    set interface vm1 external-ids:iface-id=vm1 \
    options:tx_pcap=hv1/vm1-tx.pcap \
    options:rxq_pcap=hv1/vm1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int bar3 -- \
    set interface bar3 external-ids:iface-id=bar3 \
    options:tx_pcap=hv1/bar3-tx.pcap \
    options:rxq_pcap=hv1/bar3-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int vm2 -- \
    set interface vm2 external-ids:iface-id=vm2 \
    options:tx_pcap=hv2/vm2-tx.pcap \
    options:rxq_pcap=hv2/vm2-rx.pcap \
    ofport-request=1

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Test that ovn-controllers create ct-zone entry for container ports.
foo1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-foo1)
AT_CHECK([test ! -z $foo1_zoneid])

bar1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-bar1)
AT_CHECK([test ! -z $bar1_zoneid])

bar3_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-bar3)
AT_CHECK([test ! -z $bar3_zoneid])

foo2_zoneid=$(as hv2 ovs-vsctl get bridge br-int external_ids:ct-zone-foo2)
AT_CHECK([test ! -z $foo2_zoneid])

bar2_zoneid=$(as hv2 ovs-vsctl get bridge br-int external_ids:ct-zone-bar2)
AT_CHECK([test ! -z $bar2_zoneid])

ovn-nbctl lsp-del bar2
ovn-nbctl --wait=hv sync

bar2_zoneid=$(as hv2 ovs-vsctl get bridge br-int external_ids:ct-zone-bar2)
AT_CHECK([test  -z $bar2_zoneid])

# Add back bar2
ovn-nbctl lsp-add bar bar2 vm2 1 \
-- lsp-set-addresses bar2 "f0:00:00:01:02:08 192.168.2.3"
wait_for_ports_up
ovn-nbctl --wait=hv sync

bar2_zoneid=$(as hv2 ovs-vsctl get bridge br-int external_ids:ct-zone-bar2)
AT_CHECK([test ! -z $bar2_zoneid])

# Send ip packets between foo1 and foo2 (same switch, different HVs and
# different VLAN tags).
src_mac="f00000010205"
dst_mac="f00000010206"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 1 3`
packet=${dst_mac}${src_mac}8100000108004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at foo2
packet=${dst_mac}${src_mac}8100000208004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
echo  $packet > expected
OVN_CHECK_PACKETS([hv2/vm2-tx.pcap], [expected])

# Send ip packets between foo1 and bar2 (different switch, different HV)
src_mac="f00000010205"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 3`
packet=${dst_mac}${src_mac}8100000108004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at bar2
src_mac="000000010204"
dst_mac="f00000010208"
packet=${dst_mac}${src_mac}8100000108004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
echo  $packet >> expected
OVN_CHECK_PACKETS([hv2/vm2-tx.pcap], [expected])

# Send ip packets between foo1 and bar1
# (different switch, loopback to same vm but different tag)
src_mac="f00000010205"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
packet=${dst_mac}${src_mac}8100000108004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at bar1
src_mac="000000010204"
dst_mac="f00000010207"
packet=${dst_mac}${src_mac}8100000208004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
echo  $packet > expected1
OVN_CHECK_PACKETS([hv1/vm1-tx.pcap], [expected1])

# Send ip packets between bar1 and bar3
# (same switch. But one is container and another is a standalone VM)
src_mac="f00000010207"
dst_mac="f00000010209"
src_ip=`ip_to_hex 192 168 2 2`
dst_ip=`ip_to_hex 192 168 2 3`
packet=${dst_mac}${src_mac}8100000208004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at bar3
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
echo  $packet > expected
OVN_CHECK_PACKETS([hv1/bar3-tx.pcap], [expected])

# Send ip packets between foo1 and vm1.
(different switch, container to the VM hosting it.)
src_mac="f00000010205"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 2`
packet=${dst_mac}${src_mac}8100000108004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at vm1
src_mac="000000010202"
dst_mac="f00000010203"
packet=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
echo  $packet >> expected1
OVN_CHECK_PACKETS([hv1/vm1-tx.pcap], [expected1])

# Send packets from vm1 to bar1.
(different switch, A hosting VM to a container inside it)
src_mac="f00000010203"
dst_mac="000000010202"
src_ip=`ip_to_hex 172 16 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at vm1
src_mac="000000010204"
dst_mac="f00000010207"
packet=${dst_mac}${src_mac}8100000208004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
echo  $packet >> expected1
OVN_CHECK_PACKETS([hv1/vm1-tx.pcap], [expected1])

# Send broadcast packet from foo1. foo1 should not receive the same packet.
src_mac="f00000010205"
dst_mac="ffffffffffff"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 255 255 255 255`
packet=${dst_mac}${src_mac}8100000108004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at VM1
OVN_CHECK_PACKETS([hv1/vm1-tx.pcap], [expected1])

# Test binding of parent and container ports.
ovn-nbctl lsp-set-options vm1 requested-chassis=foo

OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up bar1)])

ovn-nbctl clear logical_switch_port vm1 options
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up bar1)])

as hv1 ovs-vsctl set interface vm1 external_ids:iface-id=foo
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up bar1)])

as hv1 ovs-vsctl set interface vm1 external_ids:iface-id=vm1
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up bar1)])

ovn-nbctl lsp-del vm1
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up bar1)])

ovn-nbctl lsp-add mgmt vm1
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up bar1)])

# Move VM1 to a new logical switch.
ovn-nbctl ls-add mgmt2
ovn-nbctl lsp-del vm1 -- lsp-add mgmt2 vm1
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up bar1)])

as hv1 ovs-vsctl del-port vm1
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up bar1)])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 3 HVs, 3 LRs connected via LS, source IP based routes])
ovn_start

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and bar
# (192.168.2.0/24) connected to it.
#
# R2 and R3 are gateway routers.
# R2 has alice (172.16.1.0/24) and R3 has bob (172.16.1.0/24)
# connected to it. Note how both alice and bob have the same subnet behind it.
# We are trying to simulate external network via those 2 switches. In real
# world the switch ports of these switches will have addresses set as "unknown"
# to make them learning switches. Or those switches will be "localnet" ones.

# Create three hypervisors and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=bar1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=alice1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=bob1 \
    options:tx_pcap=hv3/vif1-tx.pcap \
    options:rxq_pcap=hv3/vif1-rx.pcap \
    ofport-request=1


ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis="hv2"
ovn-nbctl create Logical_Router name=R3 options:chassis="hv3"

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
    options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar type=router \
    options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24
ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.1.0/24 20.0.0.2
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.2.0/24 20.0.0.3

# Install static routes with destination ip address as the policy for routing.
ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1

ovn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port bar1 in bar
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 192.168.2.2"

# Create logical port alice1 in alice
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 172.16.1.3"

# Create logical port bob1 in bob
ovn-nbctl --wait=hv lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.1.4"

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

# Send ip packets between foo1 and bar1
# (East-west traffic should flow normally)
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Send ip packets between foo1 and alice1
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 3`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
as hv1 ovs-appctl ofproto/trace br-int in_port=1 $packet

# Send ip packets between bar1 and bob1
src_mac="f00000010204"
dst_mac="000001010204"
src_ip=`ip_to_hex 192 168 2 2`
dst_ip=`ip_to_hex 172 16 1 4`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif2 $packet
#as hv1 ovs-appctl ofproto/trace br-int in_port=2 $packet

# Packet to expect at bar1
src_mac="000001010204"
dst_mac="f00000010204"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
expected=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
echo $expected > expected
OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

# Packet to Expect at alice1
src_mac="000002010203"
dst_mac="f00000010205"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 3`
expected=${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000
echo $expected > expected
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Packet to Expect at bob1
src_mac="000003010203"
dst_mac="f00000010206"
src_ip=`ip_to_hex 192 168 2 2`
dst_ip=`ip_to_hex 172 16 1 4`
expected=${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000
echo $expected > expected
OVN_CHECK_PACKETS([hv3/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- dns lookup : 1 HV, 2 LS, 2 LSPs/LS])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4 aef0::4"

ovn-nbctl lsp-set-port-security ls1-lp1 "f0:00:00:00:00:01 10.0.0.4 aef0::4"

ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02 10.0.0.6 20.0.0.4"

ovn-nbctl lsp-set-port-security ls1-lp2 "f0:00:00:00:00:02 10.0.0.6 20.0.0.4"

DNS1=`ovn-nbctl create DNS records={}`
DNS2=`ovn-nbctl create DNS records={}`

ovn-nbctl set DNS $DNS1 records:vm1.ovn.org="10.0.0.4 aef0::4"
ovn-nbctl set DNS $DNS1 records:vm2.ovn.org="10.0.0.6 20.0.0.4"
ovn-nbctl set DNS $DNS2 records:vm3.ovn.org="40.0.0.4"

ovn-nbctl set Logical_switch ls1 dns_records="$DNS1"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync
as hv1 ovs-vsctl show

echo "*************************"
ovn-sbctl list DNS
echo "*************************"

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

# set_dns_params host_name
# Sets the dns_req_data and dns_resp_data
set_dns_params() {
    local hname=$1
    local ttl=00000e10
    an_count=0001
    type=0001
    case $hname in
    vm1)
        # vm1.ovn.org
        query_name=03766d31036f766e036f726700
        # IPv4 address - 10.0.0.4
        expected_dns_answer=${query_name}00010001${ttl}00040a000004
        ;;
    VM1)
        # VM1.OVN.ORG
        query_name=03564d31034f564e034f524700
        # IPv4 address - 10.0.0.4
        expected_dns_answer=${query_name}00010001${ttl}00040a000004
        ;;
    vm2)
        # vm2.ovn.org
        query_name=03766d32036f766e036f726700
        # IPv4 address - 10.0.0.6
        expected_dns_answer=${query_name}00010001${ttl}00040a000006
        # IPv4 address - 20.0.0.4
        expected_dns_answer=${expected_dns_answer}${query_name}00010001${ttl}000414000004
        an_count=0002
        ;;
    vm3)
        # vm3.ovn.org
        query_name=03766d33036f766e036f726700
        # IPv4 address - 40.0.0.4
        expected_dns_answer=${query_name}00010001${ttl}000428000004
        ;;
    vm1_ipv6_only)
        # vm1.ovn.org
        query_name=03766d31036f766e036f726700
        # IPv6 address - aef0::4
        type=001c
        expected_dns_answer=${query_name}${type}0001${ttl}0010aef00000000000000000000000000004
        ;;
    vm1_ipv4_v6)
        # vm1.ovn.org
        query_name=03766d31036f766e036f726700
        type=00ff
        an_count=0002
        # IPv4 address - 10.0.0.4
        # IPv6 address - aef0::4
        expected_dns_answer=${query_name}00010001${ttl}00040a000004
        expected_dns_answer=${expected_dns_answer}${query_name}001c0001${ttl}0010
        expected_dns_answer=${expected_dns_answer}aef00000000000000000000000000004
        ;;
    vm1_invalid_type)
        # vm1.ovn.org
        query_name=03766d31036f766e036f726700
        # IPv6 address - aef0::4
        type=0002
        ;;
    vm1_incomplete)
        # set type to none
        type=''
    esac
    # TTL - 3600
    local dns_req_header=010201200001000000000000
    local dns_resp_header=010281200001${an_count}00000000
    dns_req_data=${dns_req_header}${query_name}${type}0001
    dns_resp_data=${dns_resp_header}${query_name}${type}0001${expected_dns_answer}
}

# This shell function sends a DNS request packet
# test_dns INPORT SRC_MAC DST_MAC SRC_IP DST_IP DNS_QUERY EXPEC
test_dns() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 dns_reply=$6
    local dns_query_data=$7
    shift; shift; shift; shift; shift; shift; shift;
    # Packet size => IPv4 header (20) + UDP header (8) +
    #                DNS data (header + query)
    ip_len=`expr 28 + ${#dns_query_data} / 2`
    udp_len=`expr $ip_len - 20`
    ip_len=$(printf "%x" $ip_len)
    udp_len=$(printf "%x" $udp_len)
    local request=${dst_mac}${src_mac}0800450000${ip_len}0000000080110000
    request=${request}${src_ip}${dst_ip}9234003500${udp_len}0000
    # dns data
    request=${request}${dns_query_data}

    if test $dns_reply != 0; then
        local dns_reply=$1
        ip_len=`expr 28 + ${#dns_reply} / 2`
        udp_len=`expr $ip_len - 20`
        ip_len=$(printf "%x" $ip_len)
        udp_len=$(printf "%x" $udp_len)
        local reply=${src_mac}${dst_mac}0800450000${ip_len}0000000080110000
        reply=${reply}${dst_ip}${src_ip}0035923400${udp_len}0000${dns_reply}
        echo $reply >> $inport.expected
    else
        for outport; do
            echo $request >> $outport.expected
        done
    fi
    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $request
}

test_dns6() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 dns_reply=$6
    local dns_query_data=$7
    shift; shift; shift; shift; shift; shift; shift;
    # Packet size => UDP header (8) +
    #                DNS data (header + query)
    ip_len=`expr 8 + ${#dns_query_data} / 2`
    udp_len=$ip_len
    ip_len=$(printf "%x" $ip_len)
    udp_len=$(printf "%x" $udp_len)
    local request=${dst_mac}${src_mac}86dd6000000000${ip_len}11ff${src_ip}${dst_ip}
    request=${request}9234003500${udp_len}0000
    #dns data
    request=${request}${dns_query_data}

    if test $dns_reply != 0; then
        local dns_reply=$1
        ip_len=`expr 8 + ${#dns_reply} / 2`
        udp_len=$ip_len
        ip_len=$(printf "%x" $ip_len)
        udp_len=$(printf "%x" $udp_len)
        local reply=${src_mac}${dst_mac}86dd6000000000${ip_len}11ff${dst_ip}${src_ip}
        reply=${reply}0035923400${udp_len}0000${dns_reply}
        echo $reply >> $inport.expected
    else
        for outport; do
            echo $request >> $outport.expected
        done
    fi
    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $request
}

AT_CAPTURE_FILE([ofctl_monitor0.log])
as hv1 ovs-ofctl monitor br-int resume --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0.log

set_dns_params vm2
src_ip=`ip_to_hex 10 0 0 4`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 1 f00000000001 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 1.
OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap > 1.packets
cat 1.expected | cut -c -48 > expout
AT_CHECK([cat 1.packets | cut -c -48], [0], [expout])
# Skipping the IPv4 checksum.
cat 1.expected | cut -c 53- > expout
AT_CHECK([cat 1.packets | cut -c 53-], [0], [expout])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

set_dns_params vm1
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
cat 2.expected | cut -c -48 > expout
AT_CHECK([cat 2.packets | cut -c -48], [0], [expout])
# Skipping the IPv4 checksum.
cat 2.expected | cut -c 53- > expout
AT_CHECK([cat 2.packets | cut -c 53-], [0], [expout])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Try vm1 again but an all-caps query name

set_dns_params VM1
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 3.
OVS_WAIT_UNTIL([test 3 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
cat 2.expected | cut -c -48 > expout
AT_CHECK([cat 2.packets | cut -c -48], [0], [expout])
# Skipping the IPv4 checksum.
cat 2.expected | cut -c 53- > expout
AT_CHECK([cat 2.packets | cut -c 53-], [0], [expout])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Clear the query name options for ls1-lp2
ovn-nbctl --wait=hv remove DNS $DNS1 records vm2.ovn.org

set_dns_params vm2
src_ip=`ip_to_hex 10 0 0 4`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=0
test_dns 1 f00000000001 f00000000002 $src_ip $dst_ip $dns_reply $dns_req_data

# NXT_RESUMEs should be 4.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap > 1.packets
AT_CHECK([cat 1.packets], [0], [])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Clear the query name for ls1-lp1
# Since ls1 has no query names configued,
# ovn-northd should not add the DNS flows.
ovn-nbctl --wait=hv remove DNS $DNS1 records vm1.ovn.org

set_dns_params vm1
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=0
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data

# NXT_RESUMEs should be 4 only.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Test IPv6 (AAAA records) using IPv4 packet.
# Add back the DNS options for ls1-lp1.
ovn-nbctl --wait=hv set DNS $DNS1 records:vm1.ovn.org="10.0.0.4 aef0::4"

set_dns_params vm1_ipv6_only
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 5.
OVS_WAIT_UNTIL([test 5 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
cat 2.expected | cut -c -48 > expout
AT_CHECK([cat 2.packets | cut -c -48], [0], [expout])
# Skipping the IPv4 checksum.
cat 2.expected | cut -c 53- > expout
AT_CHECK([cat 2.packets | cut -c 53-], [0], [expout])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Test both IPv4 (A) and IPv6 (AAAA records) using IPv4 packet.
set_dns_params vm1_ipv4_v6
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 6.
OVS_WAIT_UNTIL([test 6 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
cat 2.expected | cut -c -48 > expout
AT_CHECK([cat 2.packets | cut -c -48], [0], [expout])
# Skipping the IPv4 checksum.
cat 2.expected | cut -c 53- > expout
AT_CHECK([cat 2.packets | cut -c 53-], [0], [expout])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Invalid type.
set_dns_params vm1_invalid_type
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=0
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data

# NXT_RESUMEs should be 7.
OVS_WAIT_UNTIL([test 7 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Incomplete DNS packet.
set_dns_params vm1_incomplete
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=0
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data

# NXT_RESUMEs should be 8.
OVS_WAIT_UNTIL([test 8 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Add one more DNS record to the ls1.
ovn-nbctl --wait=hv set Logical_switch ls1 dns_records="$DNS1 $DNS2"

set_dns_params vm3
src_ip=`ip_to_hex 10 0 0 4`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 1 f00000000001 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 9.
OVS_WAIT_UNTIL([test 9 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap > 1.packets
cat 1.expected | cut -c -48 > expout
AT_CHECK([cat 1.packets | cut -c -48], [0], [expout])
# Skipping the IPv4 checksum.
cat 1.expected | cut -c 53- > expout
AT_CHECK([cat 1.packets | cut -c 53-], [0], [expout])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Try DNS query over IPv6
set_dns_params vm1
src_ip=aef00000000000000000000000000004
dst_ip=aef00000000000000000000000000001
dns_reply=1
test_dns6 1 f00000000001 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 10
OVS_WAIT_UNTIL([test 10 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap > 1.packets
# Skipping the UDP checksum.
cat 1.expected | cut -c 1-120,125- > expout
AT_CHECK([cat 1.packets | cut -c 1-120,125-], [0], [expout])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 4 HV, 1 LS, 1 LR, packet test with HA distributed router gateway port])
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add gw1
as gw1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

sim_add gw2
as gw2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.4

sim_add ext1
as ext1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
check ovs-vsctl -- add-port br-int ext1-vif1 -- \
    set interface ext1-vif1 external-ids:iface-id=outside1 \
    options:tx_pcap=ext1/vif1-tx.pcap \
    options:rxq_pcap=ext1/vif1-rx.pcap \
    ofport-request=1

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

AT_CHECK([ovn-nbctl create Logical_Router name=R1 | uuidfilt], [0], [<0>
])

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add outside

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect alice to R1 as distributed router gateway port on gw1
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24

AT_CHECK([ovn-nbctl \
          --id=@gc0 create Gateway_Chassis name=alice_gw1 \
                                           chassis_name=gw1 \
                                           priority=20 -- \
          --id=@gc1 create Gateway_Chassis name=alice_gw2 \
                                           chassis_name=gw2 \
                                           priority=10 -- \
          set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]' \
          | uuidfilt], [0], [<0>
<1>
])

check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Create logical port foo1 in foo
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port outside1 in outside
check ovn-nbctl lsp-add outside outside1 \
-- lsp-set-addresses outside1 "f0:00:00:01:02:04 172.16.1.3"

# Create localnet port in alice
check ovn-nbctl lsp-add alice ln-alice
check ovn-nbctl lsp-set-addresses ln-alice unknown
check ovn-nbctl lsp-set-type ln-alice localnet
check ovn-nbctl lsp-set-options ln-alice network_name=phys

# Create localnet port in outside
check ovn-nbctl lsp-add outside ln-outside
check ovn-nbctl lsp-set-addresses ln-outside unknown
check ovn-nbctl lsp-set-type ln-outside localnet
check ovn-nbctl lsp-set-options ln-outside network_name=phys

# Create bridge-mappings on gw1, gw2 and ext1, hv1 doesn't need
# mapping to the external network, is the one generating packets
check as gw1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
check as gw2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
check as ext1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

wait_for_ports_up
AT_CHECK([ovn-nbctl --wait=sb sync], [0], [ignore])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    check ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    check ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

test_ip_packet()
{
    local active_gw=$1
    local backup_gw=$2
    local backup_vswitchd_dead=$3

    # Send ip packet between foo1 and outside1
    src_mac="f00000010203" # foo1 mac
    dst_mac="000001010203" # rp-foo mac (internal router leg)
    src_ip=`ip_to_hex 192 168 1 2`
    dst_ip=`ip_to_hex 172 16 1 3`
    packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

    # ARP request packet to expect at outside1
    #arp_request=ffffffffffff${src_mac}08060001080006040001${src_mac}${src_ip}000000000000${dst_ip}

    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

    # Send ARP reply from outside1 back to the router
    # XXX: note, we could avoid this if we plug this port into a netns
    # and setup the IP address into the port, so the kernel would simply reply
    src_mac="000002010203"
    reply_mac="f00000010204"
    dst_ip=`ip_to_hex 172 16 1 3`
    src_ip=`ip_to_hex 172 16 1 1`
    arp_reply=${src_mac}${reply_mac}08060001080006040002${reply_mac}${dst_ip}${src_mac}${src_ip}

    check as ext1 ovs-appctl netdev-dummy/receive ext1-vif1 $arp_reply

    AT_CAPTURE_FILE([offlows])
    OVS_WAIT_UNTIL([
        as $active_gw ovs-ofctl dump-flows br-int > offlows
        test `grep table=66 offlows | grep actions=mod_dl_dst:f0:00:00:01:02:04 | wc -l` -eq 1
    ])

    # Packet to Expect at ext1 chassis, outside1 port
    src_mac="000002010203"
    dst_mac="f00000010204"
    src_ip=`ip_to_hex 192 168 1 2`
    dst_ip=`ip_to_hex 172 16 1 3`
    expected=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
    echo $expected > ext1-vif1.expected
    exp_gw_ip_garp=ffffffffffff00000201020308060001080006040001000002010203ac100101000000000000ac100101
    echo $exp_gw_ip_garp >> ext1-vif1.expected
    as $active_gw reset_pcap_file br-phys_n1 $active_gw/br-phys_n1

    if test $backup_vswitchd_dead != 1; then
        # Reset the file only if vswitchd in backup gw is alive
        as $backup_gw reset_pcap_file br-phys_n1 $backup_gw/br-phys_n1
    fi
    as ext1 reset_pcap_file ext1-vif1 ext1/vif1

    # Resend packet from foo1 to outside1
    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

    AT_CAPTURE_FILE([exp])
    AT_CAPTURE_FILE([rcv])
    check_packets() {
        > exp
        > rcv

        pcap=ext1/vif1-tx.pcap
        type=ext1-vif1.expected
        echo "--- $pcap" | tee -a exp >> rcv
        sort -u "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | sort -u >> rcv
        echo | tee -a exp >> rcv

        pcap=$active_gw/br-phys_n1-tx.pcap
        echo "--- $pcap" | tee -a exp >> rcv
        sort -u "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap > packets
        (grep "$expected" packets; grep "$exp_gw_ip_garp" packets) | sort -u >> rcv
        echo | tee -a exp >> rcv

        $at_diff exp rcv >/dev/null
    }

    OVS_WAIT_UNTIL([check_packets], [$at_diff -F'^---' exp rcv])

    if test $backup_vswitchd_dead != 1; then
        # Check for backup gw only if vswitchd is alive
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $backup_gw/br-phys_n1-tx.pcap  > packets
        AT_CHECK([grep $expected packets | sort], [0], [])
    fi
}

test_ip_packet gw1 gw2 0

AT_CHECK(
  [ovn-nbctl --wait=hv \
    --id=@gc0 create Gateway_Chassis name=alice_gw1 \
                                     chassis_name=gw1 \
                                     priority=10 -- \
    --id=@gc1 create Gateway_Chassis name=alice_gw2 \
                                     chassis_name=gw2 \
                                     priority=20 -- \
    set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]' | uuidfilt], 0,
  [<0>
<1>
])

test_ip_packet gw2 gw1 0

# Get the claim count of both gw1 and gw2.
gw1_claim_ct=`grep "cr-alice: Claiming" gw1/ovn-controller.log | wc -l`
gw2_claim_ct=`grep "cr-alice: Claiming" gw2/ovn-controller.log | wc -l`

# Stop ovs-vswitchd in gw2. gw1 should claim the gateway port.
as gw2
OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])

# gw1 should claim the cr-alice and the claim count of gw1 should be
# incremented by 1.
gw1_claim_ct=$((gw1_claim_ct+1))

OVS_WAIT_UNTIL([test $gw1_claim_ct = `cat gw1/ovn-controller.log \
| grep -c "cr-alice: Claiming"`])

AT_CHECK([test $gw2_claim_ct = `cat gw2/ovn-controller.log | \
grep -c "cr-alice: Claiming"`])

test_ip_packet gw1 gw2 1

as gw2
OVS_APP_EXIT_AND_WAIT([ovn-controller])
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

OVN_CLEANUP([hv1],[gw1],[ext1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 4 HV, 3 LS, 2 LR, packet test with HA distributed router gateway port])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add gw1
as gw1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

sim_add gw2
as gw2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.4

sim_add ext1
as ext1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl -- add-port br-int ext1-vif1 -- \
    set interface ext1-vif1 external-ids:iface-id=outside1 \
    options:tx_pcap=ext1/vif1-tx.pcap \
    options:rxq_pcap=ext1/vif1-rx.pcap \
    ofport-request=1

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

ovn-nbctl create Logical_Router name=R0
ovn-nbctl create Logical_Router name=R1

ovn-nbctl ls-add foo
ovn-nbctl ls-add join
ovn-nbctl ls-add alice
ovn-nbctl ls-add outside

#Connect foo to R0
ovn-nbctl lrp-add R0 R0-foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo foo-R0 -- set Logical_Switch_Port foo-R0 \
    type=router options:router-port=R0-foo \
    -- lsp-set-addresses foo-R0 router

#Connect R0 to join
ovn-nbctl lrp-add R0 R0-join 00:00:0d:01:02:03 100.60.1.1/24
ovn-nbctl lsp-add join join-R0 -- set Logical_Switch_Port join-R0 \
    type=router options:router-port=R0-join \
    -- lsp-set-addresses join-R0 router

#Connect join to R1
ovn-nbctl lrp-add R1 R1-join 00:00:0e:01:02:03 100.60.1.2/24
ovn-nbctl lsp-add join join-R1 -- set Logical_Switch_Port join-R1 \
    type=router options:router-port=R1-join \
    -- lsp-set-addresses join-R1 router

#add route rules
ovn-nbctl lr-route-add R0 0.0.0.0/0 100.60.1.2
ovn-nbctl lr-route-add R1 192.168.0.0/16 100.60.1.1

# Connect alice to R1 as distributed router gateway port on gw1
ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24

ovn-nbctl \
    --id=@gc0 create Gateway_Chassis name=alice_gw1 \
                                     chassis_name=gw1 \
                                     priority=20 -- \
    --id=@gc1 create Gateway_Chassis name=alice_gw2 \
                                     chassis_name=gw2 \
                                     priority=10 -- \
    set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]'

ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port outside1 in outside
ovn-nbctl lsp-add outside outside1 \
-- lsp-set-addresses outside1 "f0:00:00:01:02:04 172.16.1.3"

# Create localnet port in alice
ovn-nbctl lsp-add alice ln-alice
ovn-nbctl lsp-set-addresses ln-alice unknown
ovn-nbctl lsp-set-type ln-alice localnet
ovn-nbctl lsp-set-options ln-alice network_name=phys

# Create localnet port in outside
ovn-nbctl lsp-add outside ln-outside
ovn-nbctl lsp-set-addresses ln-outside unknown
ovn-nbctl lsp-set-type ln-outside localnet
ovn-nbctl lsp-set-options ln-outside network_name=phys

# Create bridge-mappings on gw1, gw2 and ext1, hv1 doesn't need
# mapping to the external network, is the one generating packets
as gw1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
as gw2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
as ext1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

wait_for_ports_up
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# hv1 should be in 'ref_chassis' of the ha_chasssi_group as logical
# switch 'foo' can reach the router 'R1' (which has gw router port)
# via foo1 -> foo -> R0 -> join -> R1
hv1_ch_uuid=$(fetch_column Chassis _uuid name=hv1)
wait_column "$hv1_ch_uuid" HA_Chassis_Group ref_chassis

# Allow some time for ovn-northd and ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

test_ip_packet()
{
    local active_gw=$1
    local backup_gw=$2

    # Send ip packet between foo1 and outside1
    src_mac="f00000010203" # foo1 mac
    dst_mac="000001010203" # foo-R0 mac (internal router leg)
    src_ip=`ip_to_hex 192 168 1 2`
    dst_ip=`ip_to_hex 172 16 1 3`
    packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

    # ARP request packet to expect at outside1
    #arp_request=ffffffffffff${src_mac}08060001080006040001${src_mac}${src_ip}000000000000${dst_ip}

    as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

    # Send ARP reply from outside1 back to the router
    # XXX: note, we could avoid this if we plug this port into a netns
    # and setup the IP address into the port, so the kernel would simply reply
    src_mac="000002010203"
    reply_mac="f00000010204"
    dst_ip=`ip_to_hex 172 16 1 3`
    src_ip=`ip_to_hex 172 16 1 1`
    arp_reply=${src_mac}${reply_mac}08060001080006040002${reply_mac}${dst_ip}${src_mac}${src_ip}

    as ext1 ovs-appctl netdev-dummy/receive ext1-vif1 $arp_reply

    OVS_WAIT_UNTIL([
        test `as $active_gw ovs-ofctl dump-flows br-int | grep table=66 | \
grep actions=mod_dl_dst:f0:00:00:01:02:04 | wc -l` -eq 1
    ])

    # Packet to Expect at ext1 chassis, outside1 port
    src_mac="000002010203"
    dst_mac="f00000010204"
    src_ip=`ip_to_hex 192 168 1 2`
    dst_ip=`ip_to_hex 172 16 1 3`
    expected=${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000
    echo $expected > ext1-vif1.expected
    exp_gw_ip_garp=ffffffffffff00000201020308060001080006040001000002010203ac100101000000000000ac100101
    echo $exp_gw_ip_garp >> ext1-vif1.expected

    as $active_gw reset_pcap_file br-phys_n1 $active_gw/br-phys_n1
    as $backup_gw reset_pcap_file br-phys_n1 $backup_gw/br-phys_n1
    as ext1 reset_pcap_file ext1-vif1 ext1/vif1

    # Resend packet from foo1 to outside1
    as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

    OVN_CHECK_PACKETS([ext1/vif1-tx.pcap], [ext1-vif1.expected])
    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $active_gw/br-phys_n1-tx.pcap  > packets
    cat packets | grep $expected > exp
    cat packets | grep $exp_gw_ip_garp | head -1 >> exp
    AT_CHECK([cat exp], [0], [expout])

    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $backup_gw/br-phys_n1-tx.pcap  > packets
    AT_CHECK([grep $expected packets | sort], [0], [])
}

test_ip_packet gw1 gw2

ovn-nbctl --wait=hv \
    --id=@gc0 create Gateway_Chassis name=alice_gw1 \
                                     chassis_name=gw1 \
                                     priority=10 -- \
    --id=@gc1 create Gateway_Chassis name=alice_gw2 \
                                     chassis_name=gw2 \
                                     priority=20 -- \
    set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]'

test_ip_packet gw2 gw1

OVN_CLEANUP([hv1],[gw1],[gw2],[ext1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 1 LR with distributed router gateway port])
ovn_start

# Logical network:
# One LR R1 that has switches foo (192.168.1.0/24) and
# alice (172.16.1.0/24) connected to it.  The logical port
# between R1 and alice has a gateway chassis specified,
# i.e. it is the distributed router gateway port.
# Switch alice also has a localnet port defined.
# An additional switch outside has a localnet port and the
# same subnet as alice (172.16.1.0/24).

# Physical network:
# Three hypervisors hv[123].
# hv1 hosts vif foo1.
# hv2 is the gateway chassis that hosts the distributed
# router gateway port.
# hv3 hosts vif outside1.
# In order to show that connectivity works only through hv2,
# an initial round of tests is run without any bridge-mapping
# defined for the localnet on hv2.  These tests are expected
# to fail.
# Subsequent tests are run after defining the bridge-mapping
# for the localnet on hv2. These tests are expected to succeed.

# Create three hypervisors and create OVS ports corresponding
# to logical ports.
net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

sim_add hv3
as hv3
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
check ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=outside1 \
    options:tx_pcap=hv3/vif1-tx.pcap \
    options:rxq_pcap=hv3/vif1-rx.pcap \
    ofport-request=1

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

check ovn-nbctl lr-add R1 -- set Logical_Router R1 options:requested-tnl-key=1

check ovn-nbctl ls-add foo -- set Logical_Switch foo other_config:requested-tnl-key=2
check ovn-nbctl ls-add alice -- set Logical_Switch alice other_config:requested-tnl-key=3
check ovn-nbctl ls-add outside -- set Logical_Switch outside other_config:requested-tnl-key=4

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 \
    -- set Logical_Router_Port foo options:requested-tnl-key=1
check ovn-nbctl lsp-add foo rp-foo \
    -- set Logical_Switch_Port rp-foo type=router options:router-port=foo options:requested-tnl-key=1 \
    -- lsp-set-addresses rp-foo router

# Connect alice to R1 as distributed router gateway port on hv2
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \
    -- set Logical_Router_Port alice options:requested-tnl-key=2 \
    -- lrp-set-gateway-chassis alice hv2
check ovn-nbctl lsp-add alice rp-alice \
    -- set Logical_Switch_Port rp-alice type=router options:router-port=alice options:requested-tnl-key=1 \
    -- lsp-set-addresses rp-alice router

# Create logical port foo1 in foo
check ovn-nbctl lsp-add foo foo1 \
    -- set Logical_Switch_Port foo1 options:requested-tnl-key=2 \
    -- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port outside1 in outside
check ovn-nbctl lsp-add outside outside1 \
    -- set Logical_Switch_Port outside1 options:requested-tnl-key=1 \
    -- lsp-set-addresses outside1 "f0:00:00:01:02:04 172.16.1.3"

# Create localnet port in alice
check ovn-nbctl --wait=sb lsp-add alice ln-alice \
    -- set Logical_Switch_Port ln-alice options:requested-tnl-key=2
check ovn-nbctl lsp-set-addresses ln-alice unknown
check ovn-nbctl lsp-set-type ln-alice localnet
check ovn-nbctl lsp-set-options ln-alice network_name=phys

# Create localnet port in outside
check ovn-nbctl --wait=sb lsp-add outside ln-outside \
    -- set Logical_Switch_Port ln-outside options:requested-tnl-key=2
check ovn-nbctl lsp-set-addresses ln-outside unknown
check ovn-nbctl lsp-set-type ln-outside localnet
check ovn-nbctl lsp-set-options ln-outside network_name=phys

# Create bridge-mappings on hv1 and hv3, leaving hv2 for later
check as hv1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
check as hv3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys


dnl Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
ovn-nbctl --wait=hv sync

(echo "---------NB dump-----"
 ovn-nbctl show
 echo "---------------------"
 ovn-nbctl list logical_router
 echo "---------------------"
 ovn-nbctl list logical_router_port) > nbdump
AT_CAPTURE_FILE([nbdump])

(echo "---------SB dump-----"
 ovn-sbctl list datapath_binding
 echo "---------------------"
 ovn-sbctl list port_binding
 echo "---------------------"
 ovn-sbctl list chassis
 ovn-sbctl list encap
 echo "------ Gateway_Chassis dump (SBDB) -------"
 ovn-sbctl list Gateway_Chassis
 echo "------ Port_Binding chassisredirect -------"
 ovn-sbctl find Port_Binding type=chassisredirect) > sbdump
AT_CAPTURE_FILE([sbdump])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

(echo "------ hv1 dump ----------"
 as hv1 ovs-ofctl show br-int
 as hv1 ovs-ofctl dump-flows br-int
 echo "------ hv2 dump ----------"
 as hv2 ovs-ofctl show br-int
 as hv2 ovs-ofctl dump-flows br-int
 echo "------ hv3 dump ----------"
 as hv3 ovs-ofctl show br-int
 as hv3 ovs-ofctl dump-flows br-int) > hvdump
AT_CAPTURE_FILE([hvdump])

as hv1 ovs-ofctl dump-flows br-int > hv1flows
as hv2 ovs-ofctl dump-flows br-int > hv2flows
AT_CAPTURE_FILE([hv1flows])
AT_CAPTURE_FILE([hv2flows])

AT_CHECK(
  [# Check that redirect mapping is programmed only on hv2
   grep table=38 hv1flows | grep =0x3,metadata=0x1 | wc -l
   grep table=38 hv2flows | grep =0x3,metadata=0x1 | grep load:0x2- | wc -l

   # Check that hv1 sends chassisredirect port traffic to hv2
   grep table=37 hv1flows | grep =0x3,metadata=0x1 | grep output | wc -l
   grep table=37 hv2flows | grep =0x3,metadata=0x1 | wc -l

   # Check that arp reply on distributed gateway port is only programmed on hv2
   grep arp hv1flows | grep load:0x2- | grep =0x2,metadata=0x1 | wc -l
   grep arp hv2flows | grep load:0x2- | grep =0x2,metadata=0x1 | wc -l], [0],
  [0
1
1
0
0
1
])

: > hv2-vif1.expected
: > hv3-vif1.expected

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local hv=$1 inport=$2 sha=$3 spa=$4 tpa=$5 reply_ha=$6
    local request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request

    if test X$reply_ha != X; then
        # Expect to receive the reply, if any.
        local reply=${sha}${reply_ha}08060001080006040002${reply_ha}${tpa}${sha}${spa}
        echo $reply >> hv${hv}-vif$inport.expected
    fi
}

rtr_ip=$(ip_to_hex 172 16 1 1)
foo_ip=$(ip_to_hex 192 168 1 2)
outside_ip=$(ip_to_hex 172 16 1 3)

echo $rtr_ip
echo $foo_ip
echo $outside_ip

# ARP for router IP address from outside1, no response expected
test_arp 3 1 f00000010204 $outside_ip $rtr_ip

# Now check the packets actually received against the ones expected.
OVN_CHECK_PACKETS([hv3/vif1-tx.pcap], [hv3-vif1.expected])

# Send ip packet between foo1 and outside1
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 3`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

# Now check the packets actually received against the ones expected.
OVN_CHECK_PACKETS([hv3/vif1-tx.pcap], [hv3-vif1.expected])

# Now add bridge-mappings on hv2, which should make everything work
as hv2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

# Wait until the patch ports are created in hv2 to connect br-int to br-phys
OVS_WAIT_UNTIL([test 1 = `as hv2 ovs-vsctl show | \
grep "Port patch-br-int-to-ln-alice" | wc -l`])

dnl Allow some time for ovn-controller to catch up.
wait_for_ports_up
ovn-nbctl --wait=hv sync

# ARP for router IP address from outside1
test_arp 3 1 f00000010204 $outside_ip $rtr_ip 000002010203

# hv3-vif1.expected should also have the gw router port garp packet.
exp_gw_ip_garp=ffffffffffff00000201020308060001080006040001000002010203ac100101000000000000ac100101
echo $exp_gw_ip_garp >> hv3-vif1.expected

# Now check the packets actually received against the ones expected.
OVN_CHECK_PACKETS([hv3/vif1-tx.pcap], [hv3-vif1.expected])

# Send ip packet between foo1 and outside1
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 3`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

# Packet to Expect at outside1
src_mac="000002010203"
dst_mac="f00000010204"
expected=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000

as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl show br-int
as hv1 ovs-ofctl dump-flows br-int
echo "------ hv2 dump ----------"
as hv2 ovs-ofctl show br-int
as hv2 ovs-ofctl dump-flows br-int
echo "------ hv3 dump ----------"
as hv3 ovs-ofctl show br-int
as hv3 ovs-ofctl dump-flows br-int
echo "----------------------------"

echo $expected >> hv3-vif1.expected
OVN_CHECK_PACKETS([hv3/vif1-tx.pcap], [hv3-vif1.expected])

#Check ovn-trace over "chassisredirect" port
AT_CAPTURE_FILE([trace])
ovn_trace () {
    ovn-trace --all "$@" | tee trace | sed '1,/Minimal trace/d'
}

echo 'ip.ttl--;' > expout
echo 'eth.src = 00:00:02:01:02:03;' >> expout
echo 'eth.dst = f0:00:00:01:02:04;' >> expout
echo 'output("ln-alice");' >> expout
AT_CHECK_UNQUOTED([ovn_trace foo 'inport == "foo1" && eth.src == f0:00:00:01:02:03 && eth.dst == 00:00:01:01:02:03 && ip4.src == 192.168.1.2 && ip4.dst == 172.16.1.3 && ip.ttl == 0xff'], [0], [expout])

# Create logical port alice1 in alice on hv1
as hv1 ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=alice1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1

ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 172.16.1.4"

# Create logical port foo2 in foo on hv2
as hv2 ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=foo2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 192.168.1.3"

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

: > hv1-vif2.expected

# Send ip packet between alice1 and foo2
src_mac="f00000010205"
dst_mac="000002010203"
src_ip=`ip_to_hex 172 16 1 4`
dst_ip=`ip_to_hex 192 168 1 3`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

as hv1 ovs-appctl netdev-dummy/receive hv1-vif2 $packet

# Packet to Expect at foo2
src_mac="000001010203"
dst_mac="f00000010206"
src_ip=`ip_to_hex 172 16 1 4`
dst_ip=`ip_to_hex 192 168 1 3`
expected=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000

echo $expected >> hv2-vif1.expected
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [hv2-vif1.expected])

check_row_count Port_Binding 1 logical_port=cr-alice

check ovn-nbctl --wait=sb lrp-del-gateway-chassis alice hv2

check_row_count Port_Binding 0 logical_port=cr-alice

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- send gratuitous arp for NAT rules on distributed router])
ovn_start
# Create logical switches
ovn-nbctl ls-add ls0
ovn-nbctl ls-add ls1
# Create distributed router
ovn-nbctl create Logical_Router name=lr0
# Add distributed gateway port to distributed router
ovn-nbctl lrp-add lr0 lrp0 f0:00:00:00:00:01 192.168.0.1/24 \
    -- lrp-set-gateway-chassis lrp0 hv2
ovn-nbctl lsp-add ls0 lrp0-rp -- set Logical_Switch_Port lrp0-rp \
    type=router options:router-port=lrp0 addresses="router"
# Add router port to ls1
ovn-nbctl lrp-add lr0 lrp1 f0:00:00:00:00:02 10.0.0.1/24
ovn-nbctl lsp-add ls1 lrp1-rp -- set Logical_Switch_Port lrp1-rp \
    type=router options:router-port=lrp1 addresses="router"
# Add logical ports for NAT rules
ovn-nbctl lsp-add ls1 foo1 \
-- lsp-set-addresses foo1 "00:00:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-add ls1 foo2 \
-- lsp-set-addresses foo2 "00:00:00:00:00:04 10.0.0.4"
# Add nat-addresses option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"
# Add NAT rules
AT_CHECK([ovn-nbctl lr-nat-add lr0 snat 192.168.0.1 10.0.0.0/24])
AT_CHECK([ovn-nbctl lr-nat-add lr0 dnat 192.168.0.2 10.0.0.2])
AT_CHECK([ovn-nbctl lr-nat-add lr0 dnat_and_snat 192.168.0.3 10.0.0.3 foo1 f0:00:00:00:00:03])
AT_CHECK([ovn-nbctl lr-nat-add lr0 dnat_and_snat 192.168.0.4 10.0.0.4 foo2 f0:00:00:00:00:04])

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])
AT_CHECK([ovs-vsctl add-port br-phys snoopvif -- set Interface snoopvif options:tx_pcap=hv1/snoopvif-tx.pcap options:rxq_pcap=hv1/snoopvif-rx.pcap])

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
# Initially test with no bridge-mapping on hv2, expect to receive no packets

sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
# Initially test with no bridge-mapping on hv3

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl --wait=hv lsp-set-options ln_port network_name=physnet1])

# Expect no packets when hv2 bridge-mapping is not present
: > packets
OVN_CHECK_PACKETS([hv1/snoopvif-tx.pcap], [packets])

# Add bridge-mapping on hv2
AT_CHECK([as hv2 ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])

# Wait until the patch ports are created in hv2 to connect br-int to br-phys
OVS_WAIT_UNTIL([test 1 = `as hv2 ovs-vsctl show | \
grep "Port patch-br-int-to-ln_port" | wc -l`])

# Wait for packets to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 100])
trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros > packets
expected="fffffffffffff0000000000108060001080006040001f00000000001c0a80001000000000000c0a80001"
echo $expected > expout
expected="fffffffffffff0000000000108060001080006040001f00000000001c0a80002000000000000c0a80002"
echo $expected >> expout
AT_CHECK([sort packets], [0], [expout])
sort packets | cat

# Temporarily remove nat-addresses option to avoid race conditions
# due to GARP backoff
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses=""

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

as hv1 reset_pcap_file snoopvif hv1/snoopvif

# Add OVS ports for foo1 and foo2 on hv3
ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=foo1 \
    ofport-request=1
ovs-vsctl -- add-port br-int hv3-vif2 -- \
    set interface hv3-vif2 external-ids:iface-id=foo2 \
    ofport-request=2

# Add bridge-mapping on hv3
AT_CHECK([as hv3 ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])

# Wait until the patch ports are created in hv3 to connect br-int to br-phys
OVS_WAIT_UNTIL([test 1 = `as hv3 ovs-vsctl show | \
grep "Port patch-br-int-to-ln_port" | wc -l`])

# Re-add nat-addresses option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"

# Wait for packets to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 250])
trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros > packets
garp_1="fffffffffffff0000000000308060001080006040001f00000000003c0a80003000000000000c0a80003"
echo $garp_1 > expout
garp_2="fffffffffffff0000000000408060001080006040001f00000000004c0a80004000000000000c0a80004"
echo $garp_2 >> expout

cat packets | grep $garp_1 | head -1 > exp
cat packets | grep $garp_2 | head -1 >> exp
AT_CHECK([cat exp], [0], [expout])

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

# VLAN traffic for external network redirected through distributed router
# gateway port should use vlans(i.e input network vlan tag) across hypervisors
# instead of tunneling.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- vlan traffic for external network with distributed router gateway port])
ovn_start

# Logical network:
# # One LR R1 that has switches foo (192.168.1.0/24) and
# # alice (172.16.1.0/24) connected to it.  The logical port
# # between R1 and alice has a gateway chassis specified,
# # i.e. it is the distributed router gateway port(172.16.1.6).
# # Switch alice also has a localnet port defined.
# # An additional switch outside has the same subnet as alice
# # (172.16.1.0/24), a localnet port and nexthop port(172.16.1.1)
# # which will receive the packet destined for external network
# # (i.e 8.8.8.8 as destination ip).

# Physical network:
# # Four hypervisors hv[1234].
# # hv1 hosts vif foo1.
# # hv2 is the gateway chassis that hosts the distributed router gateway port.
# # Later to test GARPs for the router port - foo, hv2 and hv4 are added to the ha_chassis_group
# # hv3 hosts nexthop port vif outside1.
# # All other tests connect hypervisors to network n1 through br-phys for tunneling.
# # But in this test, hv1 won't connect to n1(and no br-phys in hv1), and
# # in order to show vlans(instead of tunneling) used between hv1 and hv2,
# # a new network n2 created and hv1 and hv2 connected to this network through br-ex.
# # hv2 and hv3 are still connected to n1 network through br-phys.
net_add n1

# We are not calling ovn_attach for hv1, to avoid adding br-phys.
# Tunneling won't work in hv1 as ovn-encap-ip is not added to any bridge in hv1
sim_add hv1
as hv1
ovs-vsctl \
    -- set Open_vSwitch . external-ids:system-id=hv1 \
    -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
    -- set Open_vSwitch . external-ids:ovn-encap-type=geneve,vxlan \
    -- set Open_vSwitch . external-ids:ovn-encap-ip=192.168.0.1 \
    -- add-br br-int \
    -- set bridge br-int fail-mode=secure other-config:disable-in-band=true \
    -- set Open_vSwitch . external-ids:ovn-bridge-mappings=public:br-ex

start_daemon ovn-controller
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings="public:br-ex,phys:br-phys"

sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=outside1 \
    options:tx_pcap=hv3/vif1-tx.pcap \
    options:rxq_pcap=hv3/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings="phys:br-phys"

sim_add hv4
as hv4
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.4
ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings="public:br-ex,phys:br-phys"

# Create network n2 for vlan connectivity between hv1 and hv2
net_add n2

as hv1
ovs-vsctl add-br br-ex
net_attach n2 br-ex

as hv2
ovs-vsctl add-br br-ex
net_attach n2 br-ex

as hv4
ovs-vsctl add-br br-ex
net_attach n2 br-ex

OVN_POPULATE_ARP

ovn-nbctl create Logical_Router name=R1

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice
ovn-nbctl ls-add outside

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect alice to R1 as distributed router gateway port (172.16.1.6) on hv2
ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.6/24 \
    -- lrp-set-gateway-chassis alice hv2
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router \

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port outside1 in outside, which is a nexthop address
# for 172.16.1.0/24
ovn-nbctl lsp-add outside outside1 \
-- lsp-set-addresses outside1 "f0:00:00:01:02:04 172.16.1.1"

# Set default gateway (nexthop) to 172.16.1.1
ovn-nbctl lr-route-add R1 "0.0.0.0/0" 172.16.1.1 alice
AT_CHECK([ovn-nbctl lr-nat-add R1 snat 172.16.1.6 192.168.1.1/24])
ovn-nbctl set Logical_Switch_Port rp-alice options:nat-addresses=router

ovn-nbctl lsp-add foo ln-foo
ovn-nbctl lsp-set-addresses ln-foo unknown
ovn-nbctl lsp-set-options ln-foo network_name=public
ovn-nbctl lsp-set-type ln-foo localnet
AT_CHECK([ovn-nbctl set Logical_Switch_Port ln-foo tag=2])

# Create localnet port in alice
ovn-nbctl lsp-add alice ln-alice
ovn-nbctl lsp-set-addresses ln-alice unknown
ovn-nbctl lsp-set-type ln-alice localnet
ovn-nbctl lsp-set-options ln-alice network_name=phys

# Create localnet port in outside
ovn-nbctl lsp-add outside ln-outside
ovn-nbctl lsp-set-addresses ln-outside unknown
ovn-nbctl lsp-set-type ln-outside localnet
ovn-nbctl lsp-set-options ln-outside network_name=phys

# Check that there is a logical flow in logical switch foo's pipeline
# to set the outport to rp-foo (which is expected).
OVS_WAIT_UNTIL([test 1 = `ovn-sbctl dump-flows foo | grep ls_in_l2_lkup | \
grep rp-foo | grep -v is_chassis_resident | grep priority=50 -c`])

# Set the option 'reside-on-redirect-chassis' for foo
check ovn-nbctl set logical_router_port foo options:reside-on-redirect-chassis=true
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Check that there is a logical flow in logical switch foo's pipeline
# to set the outport to rp-foo with the condition is_chassis_redirect.
ovn-sbctl dump-flows foo > sbflows
AT_CAPTURE_FILE([sbflows])
OVS_WAIT_UNTIL([test 1 = `grep ls_in_l2_lkup sbflows | \
grep rp-foo | grep is_chassis_resident | grep priority=50 -c`])

(echo "---------NB dump-----"
 ovn-nbctl show
 echo "---------------------"
 ovn-nbctl list logical_router
 echo "---------------------"
 ovn-nbctl list nat
 echo "---------------------"
 ovn-nbctl list logical_router_port
 echo "---------------------") > nbdump
AT_CAPTURE_FILE([nbdump])

(echo "---------SB dump-----"
 ovn-sbctl list datapath_binding
 echo "---------------------"
 ovn-sbctl list port_binding
 echo "---------------------"
 ovn-sbctl list chassis
 echo "---------------------") > sbdump
AT_CAPTURE_FILE([sbdump])

for chassis in hv1 hv2 hv3; do
    (as $chassis
     echo "------ $chassis dump ----------"
     ovs-vsctl show
     ovs-ofctl show br-int
     ovs-ofctl dump-flows br-int
     echo "--------------------------") > ${chassis}dump
done
AT_CAPTURE_FILE([hv1dump])
AT_CAPTURE_FILE([hv2dump])
AT_CAPTURE_FILE([hv3dump])

foo1_ip=$(ip_to_hex 192 168 1 2)
gw_ip=$(ip_to_hex 172 16 1 6)
dst_ip=$(ip_to_hex 8 8 8 8)
nexthop_ip=$(ip_to_hex 172 16 1 1)

foo1_mac="f00000010203"
foo_mac="000001010203"
gw_mac="000002010203"
nexthop_mac="f00000010204"

# Send ip packet from foo1 to 8.8.8.8
src_mac="f00000010203"
dst_mac="000001010203"
packet=${foo_mac}${foo1_mac}08004500001c0000000040110000${foo1_ip}${dst_ip}0035111100080000

# Wait for GARPs announcing gw IP to arrive
OVS_WAIT_UNTIL([
    test `as hv2 ovs-ofctl dump-flows br-int | grep table=66 | \
grep actions=mod_dl_dst:f0:00:00:01:02:04 | wc -l` -eq 1
    ])

# VLAN tagged packet with router port(192.168.1.1) MAC as destination MAC
# is expected on bridge connecting hv1 and hv2
expected=${foo_mac}${foo1_mac}8100000208004500001c0000000040110000${foo1_ip}${dst_ip}0035111100080000
echo $expected > hv1-br-ex_n2.expected

# Packet to Expect at outside1 i.e nexthop(172.16.1.1) port.
# As connection tracking not enabled for this test, snat can't be done on the packet.
# We still see foo1 as the source ip address. But source mac(gateway MAC) and
# dest mac(nexthop mac) are properly configured.
expected=${nexthop_mac}${gw_mac}08004500001c000000003f110100${foo1_ip}${dst_ip}0035111100080000
echo $expected > hv3-vif1.expected

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

as hv1 reset_pcap_file br-ex_n2 hv1/br-ex_n2
as hv3 reset_pcap_file hv3-vif1 hv3/vif1
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
sleep 2

# On hv1, table 37 check that no packet goes via the tunnel port
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=37 \
| grep "NXM_NX_TUN_ID" | grep -v n_packets=0 | wc -l], [0], [[0
]])

ip_packet() {
    grep "1010203f00000010203"
}

# Check vlan tagged packet on the bridge connecting hv1 and hv2 with the
# foo1's mac.
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-ex_n2-tx.pcap | ip_packet | uniq > hv1-br-ex_n2
cat hv1-br-ex_n2.expected > expout
AT_CHECK([sort hv1-br-ex_n2], [0], [expout])

# Check expected packet on nexthop interface
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv3/vif1-tx.pcap | grep ${foo1_ip}${dst_ip} | uniq > hv3-vif1
cat hv3-vif1.expected > expout
AT_CHECK([sort hv3-vif1], [0], [expout])

# Test the GARP for the router port ip - 192.168.1.1
ovn-nbctl --wait=sb ha-chassis-group-add hagrp1

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file br-ex_n2 hv2/br-ex_n2
as hv4 reset_pcap_file br-ex_n2 hv4/br-ex_n2

ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 hv2 30
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 hv4 20

hagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp1`
ovn-nbctl lrp-del-gateway-chassis alice hv2
ovn-nbctl --wait=sb set logical_router_port alice ha_chassis_group=$hagrp1_uuid

# When hv2 claims the gw router port cr-alice, it should send out
# GARP for 192.168.1.1 and it should be received by foo1 on hv1.

# foo1 (on hv1) should receive GARP without VLAN tag
exp_garp_on_foo1="ffffffffffff00000101020308060001080006040001000001010203c0a80101000000000000c0a80101"
echo $exp_garp_on_foo1 > foo1.expout

# ovn-controller on hv2 should send garp with VLAN tag
sent_garp="ffffffffffff0000010102038100000208060001080006040001000001010203c0a80101000000000000c0a80101"

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [foo1.expout])
# Wait until we receive atleast 1 packet
OVS_WAIT_UNTIL([test 1 = `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-ex_n2-tx.pcap | wc -l`])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-ex_n2-tx.pcap | head -1 > packets
echo $sent_garp > expout
AT_CHECK([cat packets], [0], [expout])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv4/br-ex_n2-tx.pcap > empty
AT_CHECK([cat empty], [0], [])

# Make hv4 master
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv4 reset_pcap_file br-ex_n2 hv4/br-ex_n2
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 hv4 40

# Wait till cr-alice is claimed by hv4
hv4_chassis=$(fetch_column Chassis _uuid name=hv4)
# check that the chassis redirect port has been claimed by the gw1 chassis
wait_row_count Port_Binding 1 logical_port=cr-alice chassis=$hv4_chassis 

# Reset the pcap file for hv2/br-ex_n2. From now on ovn-controller in hv2
# should not send GARPs for the router ports.
as hv2 reset_pcap_file br-ex_n2 hv2/br-ex_n2

echo $sent_garp > br-ex_n2.expout
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [foo1.expout])
OVN_CHECK_PACKETS([hv4/br-ex_n2-tx.pcap], [br-ex_n2.expout])

sleep 2

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-ex_n2-tx.pcap > empty
AT_CHECK([cat empty], [0], [])

OVN_CLEANUP([hv1],[hv2],[hv3], [hv4])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- IPv6 ND Router Solicitation responder])
AT_KEYWORDS([ovn-nd_ra])
ovn_start

# In this test case we create 1 lswitch with 3 VIF ports attached,
# and a lrouter connected to the lswitch.
# We generate the Router solicitation packet and verify the Router Advertisement
# reply packet from the ovn-controller.

# Create hypervisor and logical switch lsw0, logical router lr0, attach lsw0
# onto lr0, set Logical_Router_Port.ipv6_ra_configs:address_mode column to
# 'slaac' to allow lrp0 send RA for SLAAC mode.
ovn-nbctl ls-add lsw0
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lrp0 fa:16:3e:00:00:01 fdad:1234:5678::1/64
ovn-nbctl set Logical_Router_Port lrp0 ipv6_ra_configs:address_mode="slaac"
ovn-nbctl \
    -- lsp-add lsw0 lsp0 \
    -- set Logical_Switch_Port lsp0 type=router \
                     options:router-port=lrp0 \
                     addresses='"fa:16:3e:00:00:01 fdad:1234:5678::1"'
net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

ovn-nbctl lsp-add lsw0 lp1
ovn-nbctl lsp-set-addresses lp1 "fa:16:3e:00:00:02 10.0.0.12 fdad:1234:5678:0:f816:3eff:fe:2"
ovn-nbctl lsp-set-port-security lp1 "fa:16:3e:00:00:02 10.0.0.12 fdad:1234:5678:0:f816:3eff:fe:2"

ovn-nbctl lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp2 "fa:16:3e:00:00:03 10.0.0.13 fdad:1234:5678:0:f816:3eff:fe:3"
ovn-nbctl lsp-set-port-security lp2 "fa:16:3e:00:00:03 10.0.0.13 fdad:1234:5678:0:f816:3eff:fe:3"

ovn-nbctl lsp-add lsw0 lp3
ovn-nbctl lsp-set-addresses lp3 "fa:16:3e:00:00:04 10.0.0.14 fdad:1234:5678:0:f816:3eff:fe:4"
ovn-nbctl lsp-set-port-security lp3 "fa:16:3e:00:00:04 10.0.0.14 fdad:1234:5678:0:f816:3eff:fe:4"

# Add ACL rule for ICMPv6 on lsw0
ovn-nbctl acl-add lsw0 from-lport 1002 'ip6 && icmp6'  allow-related
ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp1" && ip6 && icmp6'  allow-related
ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp2" && ip6 && icmp6'  allow-related
ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp3" && ip6 && icmp6'  allow-related

ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=lp3 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

# Make sure that ovn-controller has installed the corresponding OF Flow.
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int | grep -c "ipv6_dst=ff02::2,nw_ttl=255,icmp_type=133,icmp_code=0"`])

# This shell function sends a Router Solicitation packet.
# test_ipv6_ra INPORT SRC_MAC SRC_LLA ADDR_MODE MTU RA_PREFIX_OPT
test_ipv6_ra() {
    local inport=$1 src_mac=$2 src_lla=$3 addr_mode=$4 mtu=$5 prefix_opt=$6
    local request=333300000002${src_mac}86dd6000000000103aff${src_lla}ff02000000000000000000000000000285000efc000000000101${src_mac}

    local len=24
    local mtu_opt=""
    if test $mtu != 0; then
        len=`expr $len + 8`
        mtu_opt=05010000${mtu}
    fi

    if test ${#prefix_opt} != 0; then
        prefix_opt=${prefix_opt}fdad1234567800000000000000000000
        len=`expr $len + ${#prefix_opt} / 2`
    fi

    len=$(printf "%x" $len)
    local lrp_mac=fa163e000001
    local lrp_lla=fe80000000000000f8163efffe000001
    local reply=${src_mac}${lrp_mac}86dd6000000000${len}3aff${lrp_lla}${src_lla}8600XXXXff${addr_mode}ffff00000000000000000101${lrp_mac}${mtu_opt}${prefix_opt}
    echo $reply >> $inport.expected

    as hv1 ovs-appctl netdev-dummy/receive hv1-vif${inport} $request
}

AT_CAPTURE_FILE([ofctl_monitor0.log])
as hv1 ovs-ofctl monitor br-int resume --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0.log

# MTU is not set and the address mode is set to slaac
addr_mode=00
default_prefix_option_config=030440c0ffffffffffffffff00000000
src_mac=fa163e000002
src_lla=fe80000000000000f8163efffe000002
test_ipv6_ra 1 $src_mac $src_lla $addr_mode 0 $default_prefix_option_config

# NXT_RESUME should be 1.
OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap  > 1.packets

cat 1.expected | cut -c -112 > expout
AT_CHECK([cat 1.packets | cut -c -112], [0], [expout])

# Skipping the ICMPv6 checksum.
cat 1.expected | cut -c 117- > expout
AT_CHECK([cat 1.packets | cut -c 117-], [0], [expout])

rm -f *.expected
reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
reset_pcap_file hv1-vif3 hv1/vif3

# Set the MTU to 1500, send_periodic to false, preference to LOW
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:mtu=1500
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:send_periodic="false"
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:router_preference="LOW"

# Make sure that ovn-controller has installed the corresponding OF Flow.
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int | grep -c "ipv6_dst=ff02::2,nw_ttl=255,icmp_type=133,icmp_code=0"`])

# addr_mode byte also includes router preference information
addr_mode=18
default_prefix_option_config=030440c0ffffffffffffffff00000000
src_mac=fa163e000003
src_lla=fe80000000000000f8163efffe000003
mtu=000005dc

test_ipv6_ra 2 $src_mac $src_lla $addr_mode $mtu $default_prefix_option_config

# NXT_RESUME should be 2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap  > 2.packets

cat 2.expected | cut -c -112 > expout
AT_CHECK([cat 2.packets | cut -c -112], [0], [expout])

# Skipping the ICMPv6 checksum.
cat 2.expected | cut -c 117- > expout
AT_CHECK([cat 2.packets | cut -c 117-], [0], [expout])

rm -f *.expected
reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
reset_pcap_file hv1-vif3 hv1/vif3

# Set the address mode to dhcpv6_stateful, router_preference to HIGH
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:address_mode=dhcpv6_stateful
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:router_preference="HIGH"
# Make sure that ovn-controller has installed the corresponding OF Flow.
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int | grep -c "ipv6_dst=ff02::2,nw_ttl=255,icmp_type=133,icmp_code=0"`])

# addr_mode byte also includes router preference information
addr_mode=88
default_prefix_option_config=03044080ffffffffffffffff00000000
src_mac=fa163e000004
src_lla=fe80000000000000f8163efffe000004
mtu=000005dc

test_ipv6_ra 3 $src_mac $src_lla $addr_mode $mtu $default_prefix_option_config

# NXT_RESUME should be 3.
OVS_WAIT_UNTIL([test 3 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif3-tx.pcap  > 3.packets

cat 3.expected | cut -c -112 > expout
AT_CHECK([cat 3.packets | cut -c -112], [0], [expout])

# Skipping the ICMPv6 checksum.
cat 3.expected | cut -c 117- > expout
AT_CHECK([cat 3.packets | cut -c 117-], [0], [expout])

rm -f *.expected
reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
reset_pcap_file hv1-vif3 hv1/vif3

# Set the address mode to dhcpv6_stateless, reset router preference to default
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:address_mode=dhcpv6_stateless
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:router_preference="MEDIUM"
# Make sure that ovn-controller has installed the corresponding OF Flow.
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int | grep -c "ipv6_dst=ff02::2,nw_ttl=255,icmp_type=133,icmp_code=0"`])

addr_mode=40
default_prefix_option_config=030440c0ffffffffffffffff00000000
src_mac=fa163e000002
src_lla=fe80000000000000f8163efffe000002
mtu=000005dc

test_ipv6_ra 1 $src_mac $src_lla $addr_mode $mtu $default_prefix_option_config

# NXT_RESUME should be 4.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap  > 1.packets

cat 1.expected | cut -c -112 > expout
AT_CHECK([cat 1.packets | cut -c -112], [0], [expout])

# Skipping the ICMPv6 checksum.
cat 1.expected | cut -c 117- > expout
AT_CHECK([cat 1.packets | cut -c 117-], [0], [expout])

rm -f *.expected
reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
reset_pcap_file hv1-vif3 hv1/vif3

# Set the address mode to invalid.
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:address_mode=invalid
# Make sure that ovn-controller has not installed any OF Flow for IPv6 ND RA.
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | grep -c "ipv6_dst=ff02::2,nw_ttl=255,icmp_type=133,icmp_code=0"`])

addr_mode=40
default_prefix_option_config=""
src_mac=fa163e000002
src_lla=fe80000000000000f8163efffe000002
mtu=000005dc

test_ipv6_ra 1 $src_mac $src_lla $addr_mode $mtu $default_prefix_option_config

# NXT_RESUME should be 4 only.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap  > 1.packets
AT_CHECK([cat 1.packets], [0], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- /32 router IP address])
ovn_start

# Logical network:
# 2 LS 'foo' and 'alice' connected via router R1.
# R1 connects to 'alice' with a /32 IP address. We use static routes and
# nexthop to push traffic to a logical port in switch 'alice'

ovn-nbctl lr-add R1

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:00:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
          options:router-port=foo addresses=\"00:00:00:01:02:03\"

# Connect alice to R1.
ovn-nbctl lrp-add R1 alice 00:00:00:01:02:04 172.16.1.1/32
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
          type=router options:router-port=alice addresses=\"00:00:00:01:02:04\"

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port alice1 in alice
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 10.0.0.2"

#install default route in R1 to use alice1's IP address as nexthop
ovn-nbctl lr-route-add R1 0.0.0.0/0 10.0.0.2 alice

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=alice1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Send ip packets between foo1 and alice1
src_mac="f00000010203"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 10 0 0 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

# Send the first packet to trigger a ARP response and population of
# mac_bindings table.
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
wait_row_count MAC_Binding 1 ip="10.0.0.2"
ovn-nbctl --wait=hv sync

# Packet to Expect at 'alice1'
src_mac="000000010204"
dst_mac="f00000010204"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 10 0 0 2`
echo "${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000" > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 1 lport/HV, localport ports])
ovn_start

ovn-nbctl ls-add ls1

# Add localport to the switch
ovn-nbctl lsp-add ls1 lp01
ovn-nbctl lsp-set-addresses lp01 f0:00:00:00:00:01
ovn-nbctl lsp-set-type lp01 localport

net_add n1

for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    ovs-vsctl add-port br-int vif01 -- \
        set Interface vif01 external-ids:iface-id=lp01 \
                              options:tx_pcap=hv${i}/vif01-tx.pcap \
                              options:rxq_pcap=hv${i}/vif01-rx.pcap \
                              ofport-request=${i}0

    ovs-vsctl add-port br-int vif${i}1 -- \
        set Interface vif${i}1 external-ids:iface-id=lp${i}1 \
                              options:tx_pcap=hv${i}/vif${i}1-tx.pcap \
                              options:rxq_pcap=hv${i}/vif${i}1-rx.pcap \
                              ofport-request=${i}1

    ovn-nbctl lsp-add ls1 lp${i}1
    ovn-nbctl lsp-set-addresses lp${i}1 f0:00:00:00:00:${i}1
    ovn-nbctl lsp-set-port-security lp${i}1 f0:00:00:00:00:${i}1

        OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp${i}1` = xup])
done

wait_for_ports_up
ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows

OVN_POPULATE_ARP

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}
#
# test_packet INPORT DST SRC ETHTYPE EOUT LOUT DEFHV
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  INPORT is specified as
# logical switch port numbers, e.g. 11 for vif11.
#
# EOUT is the end-to-end output port, that is, where the packet will end up
# after possibly bouncing through one or more localnet ports.  LOUT is the
# logical output port, which might be a localnet port, as seen by ovn-trace
# (which doesn't know what localnet ports are connected to and therefore can't
# figure out the end-to-end answer).
#
# DEFHV is the default hypervisor from where the packet is going to be sent
# if the source port is a localport.
for i in 1 2; do
    for j in 0 1; do
        : > $i$j.expected
    done
done
test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6 defhv=$7
    echo "$@"

    # First try tracing the packet.
    uflow="inport==\"lp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    if test $lout != drop; then
        echo "output(\"$lout\");"
    fi > expout
    AT_CAPTURE_FILE([trace])
    AT_CHECK([ovn-trace --all ls1 "$uflow" | tee trace | sed '1,/Minimal trace/d'], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    hv=`vif_to_hv $inport`
    # If hypervisor 0 (localport) use the defhv parameter
    if test $hv = hv0; then
        hv=$defhv
    fi
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    if test $eout != drop; then
        echo $packet >> ${eout#lp}.expected
    fi
}


# lp11 and lp21 are on different hypervisors
test_packet 11 f0:00:00:00:00:21 f0:00:00:00:00:11 1121 lp21 lp21
test_packet 21 f0:00:00:00:00:11 f0:00:00:00:00:21 2111 lp11 lp11

# Both VIFs should be able to reach the localport on their own HV
test_packet 11 f0:00:00:00:00:01 f0:00:00:00:00:11 1101 lp01 lp01
test_packet 21 f0:00:00:00:00:01 f0:00:00:00:00:21 2101 lp01 lp01

# Packet sent from localport on same hv should reach the vif
test_packet 01 f0:00:00:00:00:11 f0:00:00:00:00:01 0111 lp11 lp11 hv1
test_packet 01 f0:00:00:00:00:21 f0:00:00:00:00:01 0121 lp21 lp21 hv2

# Packet sent from localport on different hv should be dropped
test_packet 01 f0:00:00:00:00:21 f0:00:00:00:00:01 0121 drop lp21 hv1
test_packet 01 f0:00:00:00:00:11 f0:00:00:00:00:01 0111 drop lp11 hv2

# Now check the packets actually received against the ones expected.
for i in 1 2; do
    for j in 0 1; do
        OVN_CHECK_PACKETS([hv$i/vif$i$j-tx.pcap], [$i$j.expected])
    done
done

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- localport suppress gARP])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

check ovn-nbctl ls-add ls \
    -- lsp-add ls lp \
    -- lsp-set-type lp localport \
    -- lsp-set-addresses lp "00:00:00:00:00:01 10.0.0.1" \
    -- lsp-add ls ln \
    -- lsp-set-type ln localnet \
    -- lsp-set-options ln network_name=phys \
    -- lsp-add ls lsp \
    -- lsp-set-addresses lsp "00:00:00:00:00:02 10.0.0.2"

dnl First bind the localport.
check ovs-vsctl add-port br-int vif1 \
    -- set Interface vif1 external-ids:iface-id=lp
check ovn-nbctl --wait=hv sync

dnl Then bind the regular vif.
check ovs-vsctl add-port br-int vif2 \
    -- set Interface vif2 external-ids:iface-id=lsp \
        options:tx_pcap=hv1/vif2-tx.pcap \
        options:rxq_pcap=hv1/vif2-rx.pcap

wait_for_ports_up lsp
check ovn-nbctl --wait=hv sync

dnl Wait for at least two gARPs from lsp (10.0.0.2).
lsp_garp=ffffffffffff000000000002080600010800060400010000000000020a0000020000000000000a000002
OVS_WAIT_UNTIL([
    garps=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys-tx.pcap | grep ${lsp_garp} -c`
    test $garps -ge 2
])

dnl At this point it's safe to assume that ovn-controller skipped sending gARP
dnl for the localport.  Check that there are no other packets than the gARPs
dnl for the regular vif.
AT_CHECK([
    pkts=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys-tx.pcap | grep -v ${lsp_garp} -c`
    test 0 -eq $pkts
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 1 LR with HA distributed router gateway port])
ovn_start

net_add n1

# create gateways with external network connectivity

for i in 1 2; do
    sim_add gw$i
    as gw$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
done

ovn-nbctl ls-add inside
ovn-nbctl ls-add outside

# create hypervisors with a vif port each to an internal network

for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.1$i
    ovs-vsctl -- add-port br-int hv$i-vif1 -- \
        set interface hv$i-vif1 external-ids:iface-id=inside$i \
        options:tx_pcap=hv$i/vif1-tx.pcap \
        options:rxq_pcap=hv$i/vif1-rx.pcap \
        ofport-request=1

        ovn-nbctl lsp-add inside inside$i \
            -- lsp-set-addresses inside$i "f0:00:00:01:22:$i 192.168.1.10$i"

done

OVN_POPULATE_ARP

ovn-nbctl create Logical_Router name=R1

# Connect inside to R1
ovn-nbctl lrp-add R1 inside 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add inside rp-inside -- set Logical_Switch_Port rp-inside \
    type=router options:router-port=inside \
    -- lsp-set-addresses rp-inside router

# Connect outside to R1 as distributed router gateway port on gw1+gw2
ovn-nbctl lrp-add R1 outside 00:00:02:01:02:04 192.168.0.101/24

ovn-nbctl --id=@gc0 create Gateway_Chassis \
                    name=outside_gw1 chassis_name=gw1 priority=20 -- \
          --id=@gc1 create Gateway_Chassis \
                    name=outside_gw2 chassis_name=gw2 priority=10 -- \
          set Logical_Router_Port outside 'gateway_chassis=[@gc0,@gc1]'

ovn-nbctl lsp-add outside rp-outside -- set Logical_Switch_Port rp-outside \
    type=router options:router-port=outside \
    -- lsp-set-addresses rp-outside router

# Create localnet port in outside
ovn-nbctl lsp-add outside ln-outside
ovn-nbctl lsp-set-addresses ln-outside unknown
ovn-nbctl lsp-set-type ln-outside localnet
ovn-nbctl lsp-set-options ln-outside network_name=phys

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"
ovn-sbctl dump-flows
echo "---------------------"
ovn-sbctl list chassis
ovn-sbctl list encap
echo "---------------------"
echo "------ ha_Chassis_Group dump (SBDB) -------"
ovn-sbctl list HA_Chassis_Group
echo "------ ha_Chassis dump (SBDB) -------"
ovn-sbctl list HA_Chassis
echo "------ Port_Binding chassisredirect -------"
ovn-sbctl find Port_Binding type=chassisredirect
echo "-------------------------------------------"

# There should be one ha_chassis_group with the name "outside"
check_row_count HA_Chassis_Group 1 name=outside

# There should be 2 ha_chassis rows in SB DB.
check_row_count HA_Chassis 2 'chassis!=[[]]'

ha_ch=$(fetch_column HA_Chassis_Group ha_chassis)
check_column "$ha_ch" HA_Chassis _uuid 

for chassis in gw1 gw2 hv1 hv2; do
    as $chassis
    echo "------ $chassis dump ----------"
    ovs-ofctl show br-int
    ovs-ofctl dump-flows br-int
    echo "--------------------------"
done
bfd_dump() {
    for chassis in gw1 gw2 hv1 hv2; do
        as $chassis
        echo "------ $chassis dump (BFD)----"
        echo "BFD (from $chassis):"
        # dump BFD config and status to the other chassis
        for chassis2 in gw1 gw2 hv1 hv2; do
            if [[ "$chassis" != "$chassis2" ]]; then
                echo " -> $chassis2:"
                echo "   $(ovs-vsctl --bare --columns bfd,bfd_status find Interface name=ovn-$chassis2-0)"
            fi
        done
        echo "--------------------------"
    done
}

bfd_dump

hv1_gw1_ofport=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw1-0)
hv1_gw2_ofport=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw2-0)
hv2_gw1_ofport=$(as hv2 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw1-0)
hv2_gw2_ofport=$(as hv2 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw2-0)

echo $hv1_gw1_ofport
echo $hv1_gw2_ofport
echo $hv2_gw1_ofport
echo $hv2_gw2_ofport

echo "--- hv1 ---"
as hv1 ovs-ofctl dump-flows br-int table=37

echo "--- hv2 ---"
as hv2 ovs-ofctl dump-flows br-int table=37

gw1_chassis=$(fetch_column Chassis _uuid name=gw1)
gw2_chassis=$(fetch_column Chassis _uuid name=gw2)

OVS_WAIT_UNTIL([as hv1 ovs-ofctl dump-flows br-int table=37 | \
grep active_backup | grep slaves:$hv1_gw1_ofport,$hv1_gw2_ofport \
| wc -l], [0], [1
])

OVS_WAIT_UNTIL([as hv2 ovs-ofctl dump-flows br-int table=37 | \
grep active_backup | grep slaves:$hv2_gw1_ofport,$hv2_gw2_ofport \
| wc -l], [0], [1
])

# make sure that flows for handling the outside router port reside on gw1
OVS_WAIT_UNTIL([as gw1 ovs-ofctl dump-flows br-int table=25 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[1
]])
OVS_WAIT_UNTIL([as gw2 ovs-ofctl dump-flows br-int table=25 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[0
]])

# make sure ARP responder flows for outside router port reside on gw1 too
OVS_WAIT_UNTIL([as gw1 ovs-ofctl dump-flows br-int table=9 | \
grep arp_tpa=192.168.0.101 | wc -l], [0], [[1
]])
OVS_WAIT_UNTIL([as gw2 ovs-ofctl dump-flows br-int table=9 | grep arp_tpa=192.168.0.101 | wc -l], [0], [[0
]])

# check that the chassis redirect port has been claimed by the gw1 chassis
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw1_chassis

hv1_ch_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_ch_uuid=$(fetch_column Chassis _uuid name=hv2)
exp_ref_ch_list="$hv1_ch_uuid $hv2_ch_uuid"
wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# at this point, we invert the priority of the gw chassis between gw1 and gw2

ovn-nbctl --id=@gc0 create Gateway_Chassis \
                    name=outside_gw1 chassis_name=gw1 priority=10 -- \
          --id=@gc1 create Gateway_Chassis \
                    name=outside_gw2 chassis_name=gw2 priority=20 -- \
          set Logical_Router_Port outside 'gateway_chassis=[@gc0,@gc1]'


wait_for_ports_up
check ovn-nbctl --wait=hv sync

# we make sure that the hypervisors noticed, and inverted the slave ports
OVS_WAIT_UNTIL([as hv1 ovs-ofctl dump-flows br-int table=37 | \
grep active_backup | grep slaves:$hv1_gw2_ofport,$hv1_gw1_ofport \
| wc -l], [0], [1
])

OVS_WAIT_UNTIL([as hv2 ovs-ofctl dump-flows br-int table=37 | \
grep active_backup | grep slaves:$hv2_gw2_ofport,$hv2_gw1_ofport \
| wc -l], [0], [1
])

# check that the chassis redirect port has been reclaimed by the gw2 chassis
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw2_chassis

# check BFD enablement on tunnel ports from gw1 #########
as gw1
for chassis in gw2 hv1 hv2; do
    echo "checking gw1 -> $chassis"
    AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0],[0],
             [[enable=true
]])
done


# check BFD enablement on tunnel ports from gw2 ##########
as gw2
for chassis in gw1 hv1 hv2; do
    echo "checking gw2 -> $chassis"
    AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0],[0],
             [[enable=true
]])
done

# check BFD enablement on tunnel ports from hv1 ###########
as hv1
for chassis in gw1 gw2; do
    echo "checking hv1 -> $chassis"
    AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0],[0],
             [[enable=true
]])
done
# make sure BFD is not enabled to hv2, we don't need it
AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-hv2-0],[0],
         [[
]])


# check BFD enablement on tunnel ports from hv2 ##########
as hv2
for chassis in gw1 gw2; do
    echo "checking hv2 -> $chassis"
    AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0],[0],
             [[enable=true
]])
done
# make sure BFD is not enabled to hv1, we don't need it
AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-hv1-0],[0],
         [[
]])

# make sure that flows for handling the outside router port reside on gw2 now
OVS_WAIT_UNTIL([as gw2 ovs-ofctl dump-flows br-int table=25 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[1
]])
OVS_WAIT_UNTIL([as gw1 ovs-ofctl dump-flows br-int table=25 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[0
]])

# disconnect GW2 from the network, GW1 should take over
as gw2
port=${sandbox}_br-phys
as main ovs-vsctl del-port n1 $port

bfd_dump

# make sure that flows for handling the outside router port reside on gw2 now
OVS_WAIT_UNTIL([as gw1 ovs-ofctl dump-flows br-int table=25 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[1
]])
OVS_WAIT_UNTIL([as gw2 ovs-ofctl dump-flows br-int table=25 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[0
]])

# check that the chassis redirect port has been reclaimed by the gw1 chassis
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw1_chassis

ovn-nbctl --wait=hv set NB_Global . options:"bfd-min-rx"=2000
as gw2
for chassis in gw1 hv1 hv2; do
    echo "checking gw2 -> $chassis"
    OVS_WAIT_UNTIL([
    bfd_cfg=$(ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0)
    test "$bfd_cfg" = "enable=true min_rx=2000"
])
done
ovn-nbctl --wait=hv set NB_Global . options:"bfd-min-tx"=1500
for chassis in gw1 hv1 hv2; do
    echo "checking gw2 -> $chassis"
    OVS_WAIT_UNTIL([
    bfd_cfg=$(ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0)
    test "$bfd_cfg" = "enable=true min_rx=2000 min_tx=1500"
])
done
ovn-nbctl remove NB_Global . options "bfd-min-rx"
ovn-nbctl --wait=hv set NB_Global . options:"bfd-mult"=5
for chassis in gw1 hv1 hv2; do
    echo "checking gw2 -> $chassis"
    OVS_WAIT_UNTIL([
    bfd_cfg=$(ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0)
    test "$bfd_cfg" = "enable=true min_tx=1500 mult=5"
])
done

# Delete the inside1 vif. The ref_chassis in ha_chassis_group shouldn't have
# reference to hv1.
as hv1 ovs-vsctl del-port hv1-vif1

wait_column "$hv2_ch_uuid" HA_Chassis_Group ref_chassis

# Delete the inside2 vif.
ovn-sbctl show

echo "Deleting hv2-vif1"
as hv2 ovs-vsctl del-port hv2-vif1

# ref_chassis of ha_chassis_group should be empty
wait_column '' HA_Chassis_Group ref_chassis

# Delete the Gateway_Chassis for lrp - outside
ovn-nbctl clear Logical_Router_Port outside gateway_chassis

# There shoud be no ha_chassis_group rows in SB DB.
wait_row_count HA_Chassis_Group 0
wait_row_count HA_Chassis 0

ovn-nbctl remove NB_Global . options "bfd-min-rx"
ovn-nbctl remove NB_Global . options "bfd-min-tx"
ovn-nbctl remove NB_Global . options "bfd-mult"

# Now test with HA chassis group instead of Gateway chassis in NB DB
ovn-nbctl --wait=sb ha-chassis-group-add hagrp1

ovn-nbctl list ha_chassis_group
ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp1
hagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp1`
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 gw1 30
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 gw2 20

# ovn-northd should not create HA chassis group and HA chassis rows
# unless the HA chassis group in OVN NB DB is associated to
# a logical router port.
wait_row_count HA_Chassis 0

# Associate hagrp1 to outside logical router port
ovn-nbctl set Logical_Router_Port outside ha_chassis_group=$hagrp1_uuid

wait_row_count HA_Chassis_Group 1
wait_row_count HA_Chassis 2

OVS_WAIT_UNTIL([as hv1 ovs-ofctl dump-flows br-int table=37 | \
grep active_backup | grep slaves:$hv1_gw1_ofport,$hv1_gw2_ofport \
| wc -l], [0], [1
])

OVS_WAIT_UNTIL([as hv2 ovs-ofctl dump-flows br-int table=37 | \
grep active_backup | grep slaves:$hv2_gw1_ofport,$hv2_gw2_ofport \
| wc -l], [0], [1
])

# make sure that flows for handling the outside router port reside on gw1
OVS_WAIT_UNTIL([as gw1 ovs-ofctl dump-flows br-int table=24 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[1
]])
OVS_WAIT_UNTIL([as gw2 ovs-ofctl dump-flows br-int table=24 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[0
]])

# make sure ARP responder flows for outside router port reside on gw1 too
OVS_WAIT_UNTIL([as gw1 ovs-ofctl dump-flows br-int table=9 | \
grep arp_tpa=192.168.0.101 | wc -l], [0], [[1
]])
OVS_WAIT_UNTIL([as gw2 ovs-ofctl dump-flows br-int table=9 | grep arp_tpa=192.168.0.101 | wc -l], [0], [[0
]])

# check that the chassis redirect port has been claimed by the gw1 chassis
#
# XXX actually it doesn't happen, the test has always been wrong here
# because the following just checks that "wc -l" succeeds (and it always
# does):
#
#   OVS_WAIT_UNTIL([ovn-sbctl --columns chassis --bare find Port_Binding \
#   logical_port=cr-outside | grep $gw1_chassis | wc -l], [0],[[1
#   ]])
#
# If it were correct, then the following would be a good substitute:
#
#   wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw1_chassis

# Re add the ovs ports.
for i in 1 2; do
    as hv$i
    ovs-vsctl -- add-port br-int hv$i-vif1 -- \
        set interface hv$i-vif1 external-ids:iface-id=inside$i \
        options:tx_pcap=hv$i/vif1-tx.pcap \
        options:rxq_pcap=hv$i/vif1-rx.pcap \
        ofport-request=1
done

hv1_ch_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_ch_uuid=$(fetch_column Chassis _uuid name=hv2)
exp_ref_ch_list="$hv1_ch_uuid $hv2_ch_uuid"
wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# Increase the priority of gw2
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 gw2 40

OVS_WAIT_UNTIL([as hv1 ovs-ofctl dump-flows br-int table=37 | \
grep active_backup | grep slaves:$hv1_gw2_ofport,$hv1_gw1_ofport \
| wc -l], [0], [1
])

OVS_WAIT_UNTIL([as hv2 ovs-ofctl dump-flows br-int table=37 | \
grep active_backup | grep slaves:$hv2_gw2_ofport,$hv2_gw1_ofport \
| wc -l], [0], [1
])

# check that the chassis redirect port has been reclaimed by the gw2 chassis
#
# XXX actually it doesn't happen, the test has always been wrong here
# because the following just checks that "wc -l" succeeds (and it always
# does):
#
#   OVS_WAIT_UNTIL([ovn-sbctl --columns chassis --bare find Port_Binding \
#   logical_port=cr-outside | grep $gw2_chassis | wc -l], [0],[[1
#   ]])
#
# If it were correct, then the following would be a good substitute:
#
#   wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw2_chassis

# check BFD enablement on tunnel ports from gw1 #########
as gw1
for chassis in gw2 hv1 hv2; do
    echo "checking gw1 -> $chassis"
    AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0],[0],
             [[enable=true
]])
done

# check BFD enablement on tunnel ports from gw2 ##########
as gw2
for chassis in gw1 hv1 hv2; do
    echo "checking gw2 -> $chassis"
    AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0],[0],
             [[enable=true
]])
done

# check BFD enablement on tunnel ports from hv1 ###########
as hv1
for chassis in gw1 gw2; do
    echo "checking hv1 -> $chassis"
    AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0],[0],
             [[enable=true
]])
done
# make sure BFD is not enabled to hv2, we don't need it
AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-hv2-0],[0],
         [[
]])

# check BFD enablement on tunnel ports from hv2 ##########
as hv2
for chassis in gw1 gw2; do
    echo "checking hv2 -> $chassis"
    AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0],[0],
             [[enable=true
]])
done
# make sure BFD is not enabled to hv1, we don't need it
AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-hv1-0],[0],
         [[
]])

# make sure that flows for handling the outside router port reside on gw2 now
OVS_WAIT_UNTIL([as gw2 ovs-ofctl dump-flows br-int table=24 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[1
]])
OVS_WAIT_UNTIL([as gw1 ovs-ofctl dump-flows br-int table=24 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[0
]])

# disconnect GW2 from the network, GW1 should take over
as gw2
port=${sandbox}_br-phys
as main ovs-vsctl del-port n1 $port

bfd_dump

# make sure that flows for handling the outside router port reside on gw2 now
OVS_WAIT_UNTIL([as gw1 ovs-ofctl dump-flows br-int table=24 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[1
]])
OVS_WAIT_UNTIL([as gw2 ovs-ofctl dump-flows br-int table=24 | \
grep 00:00:02:01:02:04 | wc -l], [0], [[0
]])

# check that the chassis redirect port has been reclaimed by the gw1 chassis
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw1_chassis

OVN_CLEANUP([gw1],[gw2],[hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- send gratuitous ARP for NAT rules on HA distributed router])
ovn_start
ovn-nbctl ls-add ls0
ovn-nbctl ls-add ls1
ovn-nbctl create Logical_Router name=lr0
ovn-nbctl lrp-add lr0 lrp0 f0:00:00:00:00:01 192.168.0.100/24

ovn-nbctl --id=@gc0 create Gateway_Chassis \
                    name=outside_gw1 chassis_name=hv2 priority=10 -- \
          --id=@gc1 create Gateway_Chassis \
                    name=outside_gw2 chassis_name=hv3 priority=1 -- \
          set Logical_Router_Port lrp0 'gateway_chassis=[@gc0,@gc1]'

ovn-nbctl lsp-add ls0 lrp0-rp -- set Logical_Switch_Port lrp0-rp \
    type=router options:router-port=lrp0 addresses="router"
ovn-nbctl lrp-add lr0 lrp1 f0:00:00:00:00:02 10.0.0.1/24
ovn-nbctl lsp-add ls1 lrp1-rp -- set Logical_Switch_Port lrp1-rp \
    type=router options:router-port=lrp1 addresses="router"

# Add NAT rules
AT_CHECK([ovn-nbctl lr-nat-add lr0 snat 192.168.0.100 10.0.0.0/24])

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])
AT_CHECK([ovs-vsctl add-port br-phys snoopvif -- set Interface snoopvif options:tx_pcap=hv1/snoopvif-tx.pcap options:rxq_pcap=hv1/snoopvif-rx.pcap])

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
AT_CHECK([as hv2 ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])

sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
AT_CHECK([as hv3 ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])

# wait for earlier changes to take effect
wait_for_ports_up
check ovn-nbctl --wait=hv sync

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

as hv1 reset_pcap_file snoopvif hv1/snoopvif
as hv2 reset_pcap_file br-phys_n1 hv2/br-phys_n1
as hv3 reset_pcap_file br-phys_n1 hv3/br-phys_n1
# add nat-addresses option
ovn-nbctl --wait=hv lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"

# Wait for packets to be received through hv2.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 100])
trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

only_broadcast_from_lrp1() {
    grep "fffffffffffff00000000001"
}

garp="fffffffffffff0000000000108060001080006040001f00000000001c0a80064000000000000c0a80064"
echo $garp > expout

OVS_WAIT_UNTIL(
    [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap > rcv_text
     exp_rcvd=$(cat rcv_text | grep $garp | wc -l)
     echo "expected received = $exp_rcvd"
     test $exp_rcvd -ge 1])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq > hv1_snoop_tx
echo "packets on hv1-snoopvif:"
cat hv1_snoop_tx
AT_CHECK([sort hv1_snoop_tx], [0], [expout])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq > hv2_br_phys_tx
echo "packets on hv2 br-phys tx"
cat hv2_br_phys_tx
AT_CHECK([grep $garp hv2_br_phys_tx | sort], [0], [expout])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv3/br-phys_n1-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq > hv3_br_phys_tx
echo "packets on hv3 br-phys tx"
cat hv3_br_phys_tx
AT_CHECK([grep $garp hv3_br_phys_tx | sort], [0], [])


# at this point, we invert the priority of the gw chassis between hv2 and hv3

ovn-nbctl --wait=hv \
          --id=@gc0 create Gateway_Chassis \
                    name=outside_gw1 chassis_name=hv2 priority=1 -- \
          --id=@gc1 create Gateway_Chassis \
                    name=outside_gw2 chassis_name=hv3 priority=10 -- \
          set Logical_Router_Port lrp0 'gateway_chassis=[@gc0,@gc1]'


as hv1 reset_pcap_file snoopvif hv1/snoopvif
as hv2 reset_pcap_file br-phys_n1 hv2/br-phys_n1
as hv3 reset_pcap_file br-phys_n1 hv3/br-phys_n1

trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

# Wait for packets to be received.
OVS_WAIT_UNTIL(
    [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap > rcv_text
     exp_rcvd=$(cat rcv_text | grep $garp | wc -l)
     echo "expected received = $exp_rcvd"
     test $exp_rcvd -ge 1])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq >  hv1_snoopvif_tx
AT_CHECK([sort hv1_snoopvif_tx], [0], [expout])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv3/br-phys_n1-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq > hv3_br_phys_tx
AT_CHECK([grep $garp hv3_br_phys_tx | sort], [0], [expout])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq > hv2_br_phys_tx
AT_CHECK([grep $garp hv2_br_phys_tx | sort], [0], [])

# change localnet port tag.
AT_CHECK([ovn-nbctl set Logical_Switch_Port ln_port tag=2014])

# wait for earlier changes to take effect
OVS_WAIT_UNTIL([test 1 = `as hv2 ovs-ofctl dump-flows br-int table=65 | \
grep "actions=mod_vlan_vid:2014" | wc -l`
])

OVS_WAIT_UNTIL([test 1 = `as hv3 ovs-ofctl dump-flows br-int table=65 | \
grep "actions=mod_vlan_vid:2014" | wc -l`
])

# update nat-addresses option
ovn-nbctl --wait=hv clear logical_switch_port lrp0-rp options

#Wait until the Port_Binding.nat_addresses is cleared.
OVS_WAIT_UNTIL([test 0 = `ovn-sbctl --bare --columns nat_addresses find port_binding \
logical_port=lrp0-rp | grep is_chassis | wc -l`])

as hv1 reset_pcap_file snoopvif hv1/snoopvif
as hv2 reset_pcap_file br-phys_n1 hv2/br-phys_n1
as hv3 reset_pcap_file br-phys_n1 hv3/br-phys_n1

ovn-nbctl --wait=hv lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"

#Wait until the Port_Binding.nat_addresses is set.
OVS_WAIT_UNTIL([test 1 = `ovn-sbctl --bare --columns nat_addresses find port_binding \
logical_port=lrp0-rp | grep is_chassis | wc -l`])

# Wait for packets to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 100])
trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

garp="fffffffffffff00000000001810007de08060001080006040001f00000000001c0a80064000000000000c0a80064"
echo $garp > expout

OVS_WAIT_UNTIL(
    [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap > rcv_text
     exp_rcvd=$(cat rcv_text | grep $garp | wc -l)
     echo "expected received = $exp_rcvd"
     test $exp_rcvd -ge 1])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq >  hv1_snoopvif_tx
AT_CHECK([sort hv1_snoopvif_tx], [0], [expout])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv3/br-phys_n1-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq > hv3_br_phys_tx
AT_CHECK([grep $garp hv3_br_phys_tx | sort], [0], [expout])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq > hv2_br_phys_tx
AT_CHECK([grep $garp hv2_br_phys_tx | sort], [0], [])

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ensure one gw controller restart in HA doesn't bounce the master])
ovn_start

net_add n1

# create two gateways with external network connectivity
for i in 1 2; do
    sim_add gw$i
    as gw$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
done

ovn-nbctl ls-add inside
ovn-nbctl ls-add outside

# create one hypervisors with a vif port the internal network
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=inside1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl lsp-add inside inside1 \
        -- lsp-set-addresses inside1 "f0:00:00:01:22:01 192.168.1.101"


OVN_POPULATE_ARP

ovn-nbctl create Logical_Router name=R1

# Connect inside to R1
ovn-nbctl lrp-add R1 inside 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add inside rp-inside -- set Logical_Switch_Port rp-inside \
    type=router options:router-port=inside \
    -- lsp-set-addresses rp-inside router

# Connect outside to R1 as distributed router gateway port on gw1+gw2
ovn-nbctl lrp-add R1 outside 00:00:02:01:02:04 192.168.0.101/24

ovn-nbctl --id=@gc0 create Gateway_Chassis \
                    name=outside_gw1 chassis_name=gw1 priority=20 -- \
          --id=@gc1 create Gateway_Chassis \
                    name=outside_gw2 chassis_name=gw2 priority=10 -- \
          set Logical_Router_Port outside 'gateway_chassis=[@gc0,@gc1]'

ovn-nbctl lsp-add outside rp-outside -- set Logical_Switch_Port rp-outside \
    type=router options:router-port=outside \
    -- lsp-set-addresses rp-outside router

# Create localnet port in outside
ovn-nbctl lsp-add outside ln-outside
ovn-nbctl lsp-set-addresses ln-outside unknown
ovn-nbctl lsp-set-type ln-outside localnet
ovn-nbctl lsp-set-options ln-outside network_name=phys

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# currently when ovn-controller is restarted, the old entry is deleted
# and a new one is created, which leaves the Gateway_Chassis with
# an empty chassis for a while. NOTE: restarting ovn-controller in tests
# doesn't have the same effect because "name" is conserved, and the
# Chassis entry is not replaced.

gw2_chassis=$(ovn-sbctl --bare --columns=_uuid find Chassis name=gw2)
ovn-sbctl destroy Chassis $gw2_chassis

# Wait for the gw2_chassis row is recreated.
wait_row_count Chassis 1 name=gw2

# When gw2 chassis row is destroyed, it gets recreated. There
# is a small window in which gw2 may claim the cr-outside port if
# it has not established bfd tunnel with gw1.
# So make sure that, cr-outside is claimed by gw1 finally.
gw1_chassis=$(fetch_column Chassis _uuid name=gw1)
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw1_chassis

OVN_CLEANUP([gw1],[gw2],[hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- IPv6 Neighbor Solicitation for unknown MAC])
AT_KEYWORDS([ovn-nd_ns for unknown mac])
ovn_start

ovn-nbctl ls-add sw0_ip6
ovn-nbctl lsp-add sw0_ip6 sw0_ip6-port1
ovn-nbctl lsp-set-addresses sw0_ip6-port1 \
"50:64:00:00:00:02 aef0::5264:00ff:fe00:0002"

ovn-nbctl lsp-set-port-security sw0_ip6-port1 \
"50:64:00:00:00:02 aef0::5264:00ff:fe00:0002"

ovn-nbctl lr-add lr0_ip6
ovn-nbctl lrp-add lr0_ip6 lrp0_ip6 00:00:00:00:af:01 aef0:0:0:0:0:0:0:0/64
ovn-nbctl lsp-add sw0_ip6 lrp0_ip6-attachment
ovn-nbctl lsp-set-type lrp0_ip6-attachment router
ovn-nbctl lsp-set-addresses lrp0_ip6-attachment router
ovn-nbctl lsp-set-options lrp0_ip6-attachment router-port=lrp0_ip6
ovn-nbctl set logical_router_port lrp0_ip6 ipv6_ra_configs:address_mode=slaac

ovn-nbctl ls-add public
ovn-nbctl lsp-add public ln-public
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl lsp-set-options ln-public network_name=phys

ovn-nbctl lrp-add lr0_ip6 ip6_public 00:00:02:01:02:04 \
2001:db8:1:0:200:02ff:fe01:0204/64 \
-- lrp-set-gateway-chassis ip6_public hv1

# Install default static route.
ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
ip_prefix="\:\:/0" nexthop="2001\:db8\:1\:0\:200\:02ff\:fe01\:1305" \
-- add Logical_Router lr0_ip6 static_routes @lrt

ovn-nbctl lsp-add public rp-ip6_public -- set Logical_Switch_Port \
rp-ip6_public  type=router options:router-port=ip6_public \
-- lsp-set-addresses rp-ip6_public router

# Add a second router connected to "public" and make sure the NS packets
# from the first router are not looped on the pysical network and
# don't cross routing domains.
ovn-nbctl ls-add sw1_ip6
ovn-nbctl lsp-add sw1_ip6 sw1_ip6-port1
ovn-nbctl lsp-set-addresses sw1_ip6-port1 \
"50:64:00:00:01:02 aef1::5264:00ff:fe00:0002"

ovn-nbctl lr-add lr1_ip6
ovn-nbctl lrp-add lr1_ip6 00:00:00:01:af:01 aef1:0:0:0:0:0:0:0/64
ovn-nbctl lsp-add sw1_ip6 lrp1_ip6-attachment
ovn-nbctl lsp-set-type lrp1_ip6-attachment router
ovn-nbctl lsp-set-addresses lrp1_ip6-attachment router
ovn-nbctl lsp-set-options lrp1_ip6-attachment router-port=lrp1_ip6

ovn-nbctl lrp-add lr1_ip6 ip6_public_1 00:01:02:01:02:04 \
2002:db8:1:0:200:02ff:fe01:0204/64 \
-- lrp-set-gateway-chassis ip6_public_1 hv2

# Install default static route.
ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
ip_prefix="\:\:/0" nexthop="2002\:db8\:1\:0\:200\:02ff\:fe01\:1305" \
-- add Logical_Router lr1_ip6 static_routes @lrt

ovn-nbctl lsp-add public rp-ip6_public_1 -- set Logical_Switch_Port \
rp-ip6_public_1 type=router options:router-port=ip6_public_1 \
-- lsp-set-addresses rp-ip6_public_1 router

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0_ip6-port1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3

ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1_ip6-port1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

ovn-nbctl --wait=sb sync
wait_for_ports_up

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# There should be 2 Neighbor Advertisement flows for the router port
# aef0:: ip address in logical switch pipeline with action nd_na_router.
AT_CHECK([ovn-sbctl dump-flows sw0_ip6 | grep ls_in_arp_rsp | \
grep "nd_na_router" | wc -l], [0], [2
])

# There should be 4 Neighbor Advertisement flows with action nd_na_router
# in the router pipeline for the router lr0_ip6.
AT_CHECK([ovn-sbctl dump-flows lr0_ip6 | grep nd_na_router | \
wc -l], [0], [4
])

# Get the redirect chassis uuid.
chassis_uuid=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=cr-ip6_public chassis=$chassis_uuid

trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

# Test the IPv6 Neighbor Solicitation (NS) - nd_ns action for unknown MAC
# addresses. ovn-controller should generate an IPv6 NS request for IPv6
# packets whose MAC is unknown (in the ARP_REQUEST router pipeline stage.
# test_ipv6 INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
# This function sends ipv6 packet
test_ipv6() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local dst_mcast_mac=$6 mcast_node_ip=$7 nd_target=$8 nd_src_ip=$9

    local packet=${dst_mac}${src_mac}86dd6000000000083aff${src_ip}${dst_ip}
    packet=${packet}8000000000000000

    src_mac=000002010204
    expected_packet=${dst_mcast_mac}${src_mac}86dd6000000000203aff${nd_src_ip}
    expected_packet=${expected_packet}${mcast_node_ip}8700XXXX00000000
    expected_packet=${expected_packet}${nd_target}0101${src_mac}

    as hv1 ovs-appctl netdev-dummy/receive hv1-vif${inport} $packet
    rm -f ipv6_ns.expected
    echo $expected_packet >> ipv6_ns.expected
}

src_mac=506400000002
dst_mac=00000000af01
src_ip=aef0000000000000526400fffe000002
nd_src_ip=fe80000000000000020002fffe010204
dst_ip=20010db800010000020002fffe010205
dst_mcast_mac=3333ff010205
mcast_node_ip=ff0200000000000000000001ff010205
nd_target=20010db800010000020002fffe010205
# Send an IPv6 packet. Generated IPv6 Neighbor solicitation packet
# should be received by the ports attached to br-phys.
as hv1 test_ipv6 1 $src_mac $dst_mac $src_ip $dst_ip $dst_mcast_mac \
$mcast_node_ip $nd_target $nd_src_ip

OVS_WAIT_WHILE([test 24 = $(wc -c hv1/br-phys_n1-tx.pcap | cut -d " " -f1)])
OVS_WAIT_WHILE([test 24 = $(wc -c hv1/br-phys-tx.pcap | cut -d " " -f1)])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys_n1-tx.pcap | \
trim_zeros > 1.packets
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys-tx.pcap | \
trim_zeros > 2.packets

cat ipv6_ns.expected | cut -c -112 > expout
AT_CHECK([cat 1.packets | cut -c -112], [0], [expout])
AT_CHECK([cat 2.packets | cut -c -112], [0], [expout])

# Skipping the ICMPv6 checksum
cat ipv6_ns.expected | cut -c 117- > expout
AT_CHECK([cat 1.packets | cut -c 117-], [0], [expout])
AT_CHECK([cat 2.packets | cut -c 117-], [0], [expout])

# Check that NS packets are not flooded across routing domains. That means
# that hv2 should not send any packets across the physical network.
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap | \
trim_zeros > 2.packets
AT_CHECK([cat 2.packets], [0], [])

# Now send a packet with destination ip other than
# 2001:db8:1:0:200:02ff:fe01:0204/64 prefix.
as hv1
reset_pcap_file br-phys_n1 hv1/br-phys_n1
reset_pcap_file br-phys hv1/br-phys

src_mac=506400000002
dst_mac=00000000af01
src_ip=aef0000000000000526400fffe000002
dst_ip=20020ab8000100000200020000020306
# multicast mac of the nexthop IP - 2001:db8:1:0:200:02ff:fe01:1305
dst_mcast_mac=3333ff011305
mcast_node_ip=ff0200000000000000000001ff011305
nd_target=20010db800010000020002fffe011305
as hv1 test_ipv6 1 $src_mac $dst_mac $src_ip $dst_ip $dst_mcast_mac \
$mcast_node_ip $nd_target $nd_src_ip

OVS_WAIT_WHILE([test 24 = $(wc -c hv1/br-phys_n1-tx.pcap | cut -d " " -f1)])
OVS_WAIT_WHILE([test 24 = $(wc -c hv1/br-phys-tx.pcap | cut -d " " -f1)])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys_n1-tx.pcap | \
trim_zeros > 1.packets
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys-tx.pcap | \
trim_zeros > 2.packets

cat ipv6_ns.expected | cut -c -112 > expout
AT_CHECK([cat 1.packets | cut -c -112], [0], [expout])
AT_CHECK([cat 2.packets | cut -c -112], [0], [expout])

# Skipping the ICMPv6 checksum
cat ipv6_ns.expected | cut -c 117- > expout
AT_CHECK([cat 1.packets | cut -c 117-], [0], [expout])
AT_CHECK([cat 2.packets | cut -c 117-], [0], [expout])

# Check that NS packets are not flooded across routing domains. That means
# that hv2 should not send any packets across the physical network.
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap | \
trim_zeros > 2.packets
AT_CHECK([cat 2.packets], [0], [])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- options:requested-chassis for logical port])
ovn_start

net_add n1

ovn-nbctl ls-add ls0
ovn-nbctl lsp-add ls0 lsp0

# create two hypervisors, each with one vif port
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11
ovs-vsctl -- add-port br-int hv1-vif0 -- \
set Interface hv1-vif0 ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.12
ovs-vsctl -- add-port br-int hv2-vif0 -- \
set Interface hv2-vif0 ofport-request=1

# Allow only chassis hv1 to bind logical port lsp0.
ovn-nbctl lsp-set-options lsp0 requested-chassis=hv1

# Allow some time for ovn-northd and ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

# Retrieve hv1 and hv2 chassis UUIDs from southbound database
wait_row_count Chassis 1 name=hv1
wait_row_count Chassis 1 name=hv2
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)

# (1) Chassis hv2 should not bind lsp0 when requested-chassis is hv1.
echo "verifying that hv2 does not bind lsp0 when hv2 physical/logical mapping is added"
as hv2
ovs-vsctl set interface hv2-vif0 external-ids:iface-id=lsp0

OVS_WAIT_UNTIL([test 1 = $(grep -c "Not claiming lport lsp0" hv2/ovn-controller.log)])
wait_row_count Port_Binding 1 logical_port=lsp0 'chassis=[[]]'

# (2) Chassis hv2 should not add flows in OFTABLE_PHY_TO_LOG and OFTABLE_LOG_TO_PHY tables.
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [1], [])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=65 | grep output], [1], [])

# (3) Chassis hv1 should bind lsp0 when physical to logical mapping exists on hv1.
echo "verifying that hv1 binds lsp0 when hv1 physical/logical mapping is added"
as hv1
ovs-vsctl set interface hv1-vif0 external-ids:iface-id=lsp0

OVS_WAIT_UNTIL([test 1 = $(grep -c "Claiming lport lsp0" hv1/ovn-controller.log)])
check_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0

# (4) Chassis hv1 should add flows in OFTABLE_PHY_TO_LOG and OFTABLE_LOG_TO_PHY tables.
as hv1 ovs-ofctl dump-flows br-int
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [0], [ignore])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=65 | grep actions=output:1], [0], [ignore])

# (5) Chassis hv1 should release lsp0 binding and chassis hv2 should bind lsp0 when
# the requested chassis for lsp0 is changed from hv1 to hv2.
echo "verifying that lsp0 binding moves when requested-chassis is changed"

ovn-nbctl lsp-set-options lsp0 requested-chassis=hv2
OVS_WAIT_UNTIL([test 1 = $(grep -c "Releasing lport lsp0 from this chassis" hv1/ovn-controller.log)])
wait_column "$hv2_uuid" Port_Binding chassis logical_port=lsp0

# (6) Chassis hv2 should add flows and hv1 should not.
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [0], [ignore])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=65 | grep actions=output:1], [0], [ignore])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [1], [])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=65 | grep output], [1], [])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- options:requested-chassis with hostname])

ovn_start

ovn-nbctl ls-add ls0
ovn-nbctl lsp-add ls0 lsp0

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11
ovs-vsctl -- add-port br-int hv1-vif0 -- set Interface hv1-vif0 ofport-request=1

wait_row_count Chassis 1 name=hv1
hv1_hostname=$(fetch Chassis hostname name=hv1)
echo "hv1_hostname=${hv1_hostname}"
check ovn-nbctl --wait=hv lsp-set-options lsp0 requested-chassis=${hv1_hostname}
as hv1 ovs-vsctl set interface hv1-vif0 external-ids:iface-id=lsp0

hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
echo "hv1_uuid=${hv1_uuid}"
OVS_WAIT_UNTIL([test 1 = $(grep -c "Claiming lport lsp0" hv1/ovn-controller.log)])
wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [0], [ignore])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=65 | grep actions=output:1], [0], [ignore])

check ovn-nbctl --wait=hv lsp-set-options lsp0 requested-chassis=non-existant-chassis
OVS_WAIT_UNTIL([test 1 = $(grep -c "Releasing lport lsp0 from this chassis" hv1/ovn-controller.log)])
check ovn-nbctl --wait=hv sync
wait_column '' Port_Binding chasssi logical_port=lsp0
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [1], [])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=65 | grep output], [1], [])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- IPv6 periodic RA])
ovn_start

# This test sets up two hypervisors.
# hv1 and hv2 run ovn-controllers, and
# each has a VIF connected to the same
# logical switch in OVN. The logical
# switch is connected to a logical
# router port that is configured to send
# periodic router advertisements.
#
# The reason for having two ovn-controller
# hypervisors is to ensure that the
# periodic RAs being sent by each ovn-controller
# are kept to their local hypervisors. If the
# packets are not kept local, then each port
# will receive too many RAs.

net_add n1
sim_add hv1
sim_add hv2
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3

ovn-nbctl lr-add ro
ovn-nbctl lrp-add ro ro-sw 00:00:00:00:00:01 aef0:0:0:0:0:0:0:1/64

ovn-nbctl ls-add sw
ovn-nbctl lsp-add sw sw-ro
ovn-nbctl lsp-set-type sw-ro router
ovn-nbctl lsp-set-options sw-ro router-port=ro-sw
ovn-nbctl lsp-set-addresses sw-ro 00:00:00:00:00:01
ovn-nbctl lsp-add sw sw-p1
ovn-nbctl lsp-set-addresses sw-p1 "00:00:00:00:00:02 aef0::200:ff:fe00:2"
ovn-nbctl lsp-add sw sw-p2
ovn-nbctl lsp-set-addresses sw-p2 "00:00:00:00:00:03 aef0::200:ff:fe00:3"

ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:send_periodic=true
ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=slaac
ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=4
ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=3

for i in 1 2 ; do
    as hv$i
    ovs-vsctl -- add-port br-int hv$i-vif1 -- \
        set interface hv$i-vif1 external-ids:iface-id=sw-p$i \
        options:tx_pcap=hv$i/vif1-tx.pcap \
        options:rxq_pcap=hv$i/vif1-rx.pcap \
        ofport-request=1
done

OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up sw-p1` = xup])
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up sw-p2` = xup])

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap

}

construct_expected_ra() {
    local src_mac=000000000001
    local dst_mac=333300000001
    local src_addr=fe80000000000000020000fffe000001
    local dst_addr=ff020000000000000000000000000001

    local mtu=$1
    local ra_mo=$2
    local rdnss=$3
    local dnssl=$4
    local route_info=$5
    local ra_prefix_la=$6

    local slla=0101${src_mac}
    local mtu_opt=""
    if test $mtu != 0; then
        mtu_opt=05010000${mtu}
    fi
    shift 6

    local prefix=""
    while [[ $# -gt 0 ]] ; do
        local size=$1
        local net=$2
        prefix=${prefix}0304${size}${ra_prefix_la}ffffffffffffffff00000000${net}
        shift 2
    done

    local rdnss_opt=""
    if test $rdnss != 0; then
        rdnss_opt=19030000ffffffff${rdnss}
    fi
    local dnssl_opt=""
    if test $dnssl != 0; then
        dnssl_opt=1f030000ffffffff${dnssl}
    fi
    local route_info_opt=""
    if test $route_info != 0; then
        route_info_opt=${route_info}
    fi

    local ra=ff${ra_mo}ffff0000000000000000${slla}${mtu_opt}${prefix}${rdnss_opt}${dnssl_opt}${route_info_opt}
    local icmp=8600XXXX${ra}

    local ip_len=$(expr ${#icmp} / 2)
    ip_len=$(echo "$ip_len" | awk '{printf "%0.4x\n", $0}')

    local ip=60000000${ip_len}3aff${src_addr}${dst_addr}${icmp}
    local eth=${dst_mac}${src_mac}86dd${ip}
    local packet=${eth}
    echo $packet >> expected
}

ra_test() {
    construct_expected_ra $@

    for i in hv1 hv2 ; do
        as $i reset_pcap_file $i-vif1 $i/vif1

        OVS_WAIT_WHILE([test 24 = $(wc -c $i/vif1-tx.pcap | cut -d " " -f1)])

        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $i/vif1-tx.pcap > packets

        cat expected | cut -c -112 > expout
        AT_CHECK([cat packets | cut -c -112], [0], [expout])

        # Skip ICMPv6 checksum.
        cat expected | cut -c 117- > expout
        AT_CHECK([cat packets | cut -c 117-], [0], [expout])

        rm -f packets
        as $i reset_pcap_file $i-vif1 $i/vif1
    done

    rm -f expected
}

echo "Baseline test with no MTU"
ra_test 0 00 0 0 0 c0 40 aef00000000000000000000000000000

echo "Now make sure an MTU option makes it"
ovn-nbctl --wait=hv set Logical_Router_Port ro-sw ipv6_ra_configs:mtu=1500
ra_test 000005dc 00 0 0 0 c0 40 aef00000000000000000000000000000

echo "Now test for multiple network prefixes"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw networks='aef0\:\:1/64 fd0f\:\:1/48'
ra_test 000005dc 00 0 0 0 c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

echo "Test PRF for default gw"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw ipv6_ra_configs:router_preference="LOW"
ra_test 000005dc 18 0 0 0 c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

echo "Now test for RDNSS"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw ipv6_ra_configs:rdnss='aef0::11'
dns_addr=aef00000000000000000000000000011
ra_test 000005dc 18 $dns_addr 0 0 c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

echo "Now test for DNSSL"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw ipv6_ra_configs:dnssl="aa.bb.cc"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw ipv6_ra_configs:router_preference="HIGH"
dnssl=02616102626202636300000000000000
ra_test 000005dc 08 $dns_addr $dnssl 0 c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

echo "Now test Route Info option"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw ipv6_ra_configs:route_info="HIGH-aef1::11/48,LOW-aef2::11/96"
route_info=18023008ffffffffaef100000000000018036018ffffffffaef20000000000000000000000000000
ra_test 000005dc 08 $dns_addr $dnssl $route_info c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000
exit 0
echo "Test a different address mode now"
ovn-nbctl --wait=hv set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=dhcpv6_stateful
ra_test 000005dc 88 $dns_addr $dnssl $route_info 80 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

echo "And the other address mode"
ovn-nbctl --wait=hv set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=dhcpv6_stateless
ra_test 000005dc 48 $dns_addr $dnssl $route_info c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ACL reject rule test])
AT_KEYWORDS([acl-reject])
ovn_start

# test_ip_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST IP_CHKSUM EXP_IP_CHKSUM EXP_ICMP_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv4 packet with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHKSUM as specified.
# EXP_IP_CHKSUM and EXP_ICMP_CHKSUM are the ip and icmp checksums of the icmp destination
# unreachable frame generated from ACL rule hit
#
# INPORT is a lport number, e.g. 11 for vif11.
# HV is a hypervisor number
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_DST are each 8 hex digits.
# IP_CHKSUM, EXP_IP_CHSUM and EXP_ICMP_CHKSUM are each 4 hex digits
test_ip_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7
    local exp_ip_chksum=$8 exp_icmp_chksum=$9
    shift 9

    local ip_ttl=ff
    local packet=${eth_dst}${eth_src}08004500001400004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}
    local orig_pkt_in_reply=4500001400004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}
    local reply_icmp_ttl=ff
    local icmp_type_code_response=0301
    local icmp_data=00000000
    local reply_icmp_payload=${icmp_type_code_response}${exp_icmp_chksum}${icmp_data}
    local reply=${eth_src}${eth_dst}08004500003000004000${reply_icmp_ttl}01${exp_ip_chksum}${ipv4_dst}${ipv4_src}${reply_icmp_payload}
    echo $reply$orig_pkt_in_reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_ipv6_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST EXP_ICMP_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv6 packet with
# ETH_SRC, ETH_DST, IPV6_SRC, IPV6_DST as specified.
# EXP_ICMP_CHKSUM is the icmp6 checksums of the icmp6 destination unreachable frame generated from ACL rule hit
test_ipv6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6 exp_icmp_chksum=$7
    shift 7

    local ip6_hdr=6000000000083aff${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}0000000000000000

    local reply=${eth_src}${eth_dst}86dd6000000000383aff${ipv6_dst}${ipv6_src}0101${exp_icmp_chksum}00000000${ip6_hdr}0000000000000000
    echo $reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_tcp_syn_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST IP_CHKSUM TCP_SPORT TCP_DPORT TCP_CHKSUM EXP_IP_CHKSUM EXP_TCP_RST_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an TCP syn segment with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHKSUM, TCP_SPORT, TCP_DPORT, TCP_CHKSUM  as specified.
# EXP_IP_CHKSUM and EXP_TCP_RST_CHKSUM are the ip and tcp checksums of the tcp reset segment generated from ACL rule hit
#
# INPORT is an lport number, e.g. 11 for vif11.
# HV is an hypervisor number
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_DST are each 8 hex digits.
# TCP_SPORT and TCP_DPORT are 4 hex digits.
# IP_CHKSUM, TCP_CHKSUM, EXP_IP_CHSUM and EXP_TCP_RST_CHKSUM are each 4 hex digits
test_tcp_syn_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7
    local tcp_sport=$8 tcp_dport=$9 tcp_chksum=${10}
    local exp_ip_chksum=${11} exp_tcp_rst_chksum=${12}
    shift 12

    local ip_ttl=ff
    local packet=${eth_dst}${eth_src}08004500002800004000${ip_ttl}06${ip_chksum}${ipv4_src}${ipv4_dst}${tcp_sport}${tcp_dport}000000010000000050027210${tcp_chksum}0000

    local tcp_rst_ttl=3f
    local reply=${eth_src}${eth_dst}08004500002800004000${tcp_rst_ttl}06${exp_ip_chksum}${ipv4_dst}${ipv4_src}${tcp_dport}${tcp_sport}000000000000000250140000${exp_tcp_rst_chksum}0000
    echo $reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_sctp_init_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST IP_CHKSUM SCTP_SPORT SCTP_DPORT SCTP_INIT_TAG SCTP_CHKSUM EXP_IP_CHKSUM EXP_SCTP_ABORT_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an SCTP INIT chunk with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHKSUM, SCTP_SPORT, SCTP_DPORT, and SCTP_CHKSUM as specified.
# The INIT "initiate_tag" will be set to SCTP_INIT_TAG.
# EXP_IP_CHKSUM and EXP_SCTP_CHKSUM are the ip and sctp checksums of the SCTP ABORT chunk generated from the ACL rule hit
#
# INPORT is an lport number, e.g. 11 for vif11.
# HV is a hypervisor number.
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_DST are each 8 hex digits.
# SCTP_SPORT and SCTP_DPORT are 4 hex digits.
# IP_CHKSUM and EXP_IP_CHKSUM are 4 hex digits.
# SCTP_CHKSUM and EXP_SCTP_CHKSUM are 8 hex digits.
test_sctp_init_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7
    local sctp_sport=$8 sctp_dport=$9 sctp_init_tag=${10} sctp_chksum=${11}
    local exp_ip_chksum=${12} exp_sctp_abort_chksum=${13}

    local ip_ttl=ff
    local eth_hdr=${eth_dst}${eth_src}0800
    local ip_hdr=4500002500004000${ip_ttl}84${ip_chksum}${ipv4_src}${ipv4_dst}
    local sctp_hdr=${sctp_sport}${sctp_dport}00000000${sctp_chksum}
    local sctp_init=01000014${sctp_init_tag}0000000000010001${sctp_init_tag}

    local packet=${eth_hdr}${ip_hdr}${sctp_hdr}${sctp_init}

    local sctp_abort_ttl=3f
    local reply_eth_hdr=${eth_src}${eth_dst}0800
    local reply_ip_hdr=4500002400004000${sctp_abort_ttl}84${exp_ip_chksum}${ipv4_dst}${ipv4_src}
    local reply_sctp_hdr=${sctp_dport}${sctp_sport}${sctp_init_tag}${exp_sctp_abort_chksum}
    local reply_sctp_abort=06000004

    local reply=${reply_eth_hdr}${reply_ip_hdr}${reply_sctp_hdr}${reply_sctp_abort}
    echo $reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# Create hypervisors hv[123].
# Add vif1[123] to hv1, vif2[123] to hv2, vif3[123] to hv3.
# Add all of the vifs to a single logical switch sw0.

net_add n1
check ovn-nbctl ls-add sw0
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2 3; do
        ovn-nbctl lsp-add sw0 sw0-p$i$j -- \
                lsp-set-addresses sw0-p$i$j "00:00:00:00:00:$i$j 192.168.1.$i$j"

        check ovs-vsctl -- add-port br-int vif$i$j -- \
                set interface vif$i$j \
                external-ids:iface-id=sw0-p$i$j \
                options:tx_pcap=hv$i/vif$i$j-tx.pcap \
                options:rxq_pcap=hv$i/vif$i$j-rx.pcap \
                ofport-request=$i$j
    done
done

OVN_POPULATE_ARP

for i in 1 2 3; do
    : > vif${i}1.expected
done

check ovn-nbctl --log acl-add sw0 to-lport 1000 "outport == \"sw0-p12\"" reject
check ovn-nbctl --log acl-add sw0 from-lport 1000 "inport == \"sw0-p11\"" reject
check ovn-nbctl --log acl-add sw0 from-lport 1000 "inport == \"sw0-p21\"" reject

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

test_ip_packet 11 1 000000000011 000000000021 $(ip_to_hex 192 168 1 11) $(ip_to_hex 192 168 1 21) 0000 f85b f576
test_ip_packet 21 2 000000000021 000000000011 $(ip_to_hex 192 168 1 21) $(ip_to_hex 192 168 1 11) 0000 f85b f576
test_ip_packet 31 3 000000000031 000000000012 $(ip_to_hex 192 168 1 31) $(ip_to_hex 192 168 1 12) 0000 f850 f56b

test_ipv6_packet 11 1 000000000011 000000000021 fe80000000000000020001fffe000001 fe80000000000000020001fffe000002 617b

test_tcp_syn_packet 11 1 000000000011 000000000021 $(ip_to_hex 192 168 1 11) $(ip_to_hex 192 168 1 21) 0000 8b40 3039 0000 b85f 70e4
test_tcp_syn_packet 21 2 000000000021 000000000011 $(ip_to_hex 192 168 1 21) $(ip_to_hex 192 168 1 11) 0000 8b40 3039 0000 b85f 70e4
test_tcp_syn_packet 31 3 000000000031 000000000012 $(ip_to_hex 192 168 1 31) $(ip_to_hex 192 168 1 12) 0000 8b40 3039 0000 b854 70d9

test_sctp_init_packet 11 1 000000000011 000000000021 $(ip_to_hex 192 168 1 11) $(ip_to_hex 192 168 1 21) 0000 8b40 3039 00000001 82112601 b7e5 10fe95b6
test_sctp_init_packet 21 2 000000000021 000000000011 $(ip_to_hex 192 168 1 21) $(ip_to_hex 192 168 1 11) 0000 8b40 3039 00000002 C0379D5A b7e5 39f23aaf
test_sctp_init_packet 31 3 000000000031 000000000012 $(ip_to_hex 192 168 1 31) $(ip_to_hex 192 168 1 12) 0000 8b40 3039 00000003 028E263C b7da 7124045b

for i in 1 2 3; do
    OVN_CHECK_PACKETS([hv$i/vif${i}1-tx.pcap], [vif${i}1.expected])
done

OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Port Groups])
AT_KEYWORDS([ovnpg])
ovn_start

# Logical network:
#
# Three logical switches ls1, ls2, ls3.
# One logical router lr0 connected to ls[123],
# with nine subnets, three per logical switch:
#
#    lrp11 on ls1 for subnet 192.168.11.0/24
#    lrp12 on ls1 for subnet 192.168.12.0/24
#    lrp13 on ls1 for subnet 192.168.13.0/24
#    ...
#    lrp33 on ls3 for subnet 192.168.33.0/24
#
# 27 VIFs, 9 per LS, 3 per subnet: lp[123][123][123], where the first two
# digits are the subnet and the last digit distinguishes the VIF.
#
# This test will create two port groups and uses them in ACL.

get_lsp_uuid () {
    ovn-nbctl lsp-list ls${1%??} | grep lp$1 | awk '{ print $1 }'
}

pg1_ports=
pg2_ports=
for i in 1 2 3; do
    ovn-nbctl ls-add ls$i
    for j in 1 2 3; do
        for k in 1 2 3; do
            ovn-nbctl \
                -- lsp-add ls$i lp$i$j$k \
                -- lsp-set-addresses lp$i$j$k \
                   "f0:00:00:00:0$i:$j$k 192.168.$i$j.$k"
            # logical ports lp[12]?1 belongs to port group pg1
            if test $i != 3 && test $k = 1; then
                pg1_ports="$pg1_ports `get_lsp_uuid $i$j$k`"
            fi
            # logical ports lp[23]?2 belongs to port group pg2
            if test $i != 1 && test $k = 2; then
                pg2_ports="$pg2_ports `get_lsp_uuid $i$j$k`"
            fi
        done
    done
done

ovn-nbctl lr-add lr0
for i in 1 2 3; do
    for j in 1 2 3; do
        ovn-nbctl lrp-add lr0 lrp$i$j 00:00:00:00:ff:$i$j 192.168.$i$j.254/24
        ovn-nbctl \
            -- lsp-add ls$i lrp$i$j-attachment \
            -- set Logical_Switch_Port lrp$i$j-attachment type=router \
                             options:router-port=lrp$i$j \
                             addresses='"00:00:00:00:ff:'$i$j'"'
    done
done

ovn-nbctl create Port_Group name=pg1 ports="$pg1_ports"
ovn-nbctl create Port_Group name=pg2 ports="$pg2_ports"

# create ACLs on all lswitches to drop traffic from pg2 to pg1
ovn-nbctl acl-add ls1 to-lport 1001 'outport == @pg1 && ip4.src == $pg2_ip4' drop
ovn-nbctl acl-add ls2 to-lport 1001 'outport == @pg1 && ip4.src == $pg2_ip4' drop
ovn-nbctl acl-add ls3 to-lport 1001 'outport == @pg1 && ip4.src == $pg2_ip4' drop

# Physical network:
#
# Three hypervisors hv[123].
# lp?1[123] spread across hv[123]: lp?11 on hv1, lp?12 on hv2, lp?13 on hv3.
# lp?2[123] spread across hv[23]: lp?21 and lp?22 on hv2, lp?23 on hv3.
# lp?3[123] all on hv3.

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    case $1 in dnl (
        ?11) echo 1 ;; dnl (
        ?12 | ?21 | ?22) echo 2 ;; dnl (
        ?13 | ?23 | ?3?) echo 3 ;;
    esac
}

# Given the name of a logical port, prints the name of its logical router
# port, e.g. "vif_to_lrp 123" yields 12.
vif_to_lrp() {
    echo ${1%?}
}

# Given the name of a logical port, prints the name of its logical
# switch, e.g. "vif_to_ls 123" yields 1.
vif_to_ls() {
    echo ${1%??}
}

net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            hv=`vif_to_hv $i$j$k`
                as hv$hv ovs-vsctl \
                -- add-port br-int vif$i$j$k \
                -- set Interface vif$i$j$k \
                    external-ids:iface-id=lp$i$j$k \
                    options:tx_pcap=hv$hv/vif$i$j$k-tx.pcap \
                    options:rxq_pcap=hv$hv/vif$i$j$k-rx.pcap \
                    ofport-request=$i$j$k
        done
    done
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 123 for vif123.
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            : > $i$j$k.expected
        done
    done
done
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    #as $hv ovs-appctl ofproto/trace br-int in_port=$inport $packet
    in_ls=`vif_to_ls $inport`
    in_lrp=`vif_to_lrp $inport`
    for outport; do
        out_ls=`vif_to_ls $outport`
        if test $in_ls = $out_ls; then
            # Ports on the same logical switch receive exactly the same packet.
            echo $packet
        else
            # Routing decrements TTL and updates source and dest MAC
            # (and checksum).
            out_lrp=`vif_to_lrp $outport`
            echo f00000000${outport}00000000ff${out_lrp}08004500001c00000000"3f1101"00${src_ip}${dst_ip}0035111100080000
        fi >> $outport.expected
    done
}

as hv1 ovs-vsctl --columns=name,ofport list interface
as hv1 ovn-sbctl list port_binding
as hv1 ovn-sbctl list datapath_binding
as hv1 ovn-sbctl list port_group
as hv1 ovn-sbctl list address_set
as hv1 ovn-sbctl dump-flows
as hv1 ovs-ofctl dump-flows br-int

# Send IP packets between all pairs of source and destination ports,
# packets matches ACL (pg2 to pg1) should be dropped
for is in 1 2 3; do
  for js in 1 2 3; do
    for ks in 1 2 3; do
      bcast=
      s=$is$js$ks
      smac=f00000000$s
      sip=`ip_to_hex 192 168 $is$js $ks`
      for id in 1 2 3; do
          for jd in 1 2 3; do
              for kd in 1 2 3; do
                d=$id$jd$kd
                dip=`ip_to_hex 192 168 $id$jd $kd`
                if test $is = $id; then dmac=f00000000$d; else dmac=00000000ff$is$js; fi
                if test $d != $s; then unicast=$d; else unicast=; fi

                # packets matches ACL should be dropped
                if test $id != 3 && test $kd = 1; then
                    if test $is != 1 && test $ks = 2; then
                        unicast=
                    fi
                fi
                test_ip $s $smac $dmac $sip $dip $unicast #1
              done
          done
        done
      done
  done
done

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            OVN_CHECK_PACKETS([hv`vif_to_hv $i$j$k`/vif$i$j$k-tx.pcap],
                              [$i$j$k.expected])
        done
    done
done

# Gracefully terminate daemons
OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ACLs on Port Groups])
AT_KEYWORDS([ovnpg_acl])
ovn_start

# Logical network:
#
# Three logical switches ls1, ls2, ls3.
# One logical router lr0 connected to ls[123],
# with nine subnets, three per logical switch:
#
#    lrp11 on ls1 for subnet 192.168.11.0/24
#    lrp12 on ls1 for subnet 192.168.12.0/24
#    lrp13 on ls1 for subnet 192.168.13.0/24
#    ...
#    lrp33 on ls3 for subnet 192.168.33.0/24
#
# 27 VIFs, 9 per LS, 3 per subnet: lp[123][123][123], where the first two
# digits are the subnet and the last digit distinguishes the VIF.
#
# This test will create two port groups and ACLs will be applied on them.

get_lsp_uuid () {
    ovn-nbctl lsp-list ls${1%??} | grep lp$1 | awk '{ print $1 }'
}

pg1_ports=
pg2_ports=
for i in 1 2 3; do
    ovn-nbctl ls-add ls$i
    for j in 1 2 3; do
        for k in 1 2 3; do
            ovn-nbctl \
                -- lsp-add ls$i lp$i$j$k \
                -- lsp-set-addresses lp$i$j$k \
                   "f0:00:00:00:0$i:$j$k 192.168.$i$j.$k"
            # logical ports lp[12]?1 belongs to port group pg1
            if test $i != 3 && test $k = 1; then
                pg1_ports="$pg1_ports `get_lsp_uuid $i$j$k`"
            fi
            # logical ports lp[23]?2 belongs to port group pg2
            if test $i != 1 && test $k = 2; then
                pg2_ports="$pg2_ports `get_lsp_uuid $i$j$k`"
            fi
        done
    done
done

ovn-nbctl lr-add lr0
for i in 1 2 3; do
    for j in 1 2 3; do
        ovn-nbctl lrp-add lr0 lrp$i$j 00:00:00:00:ff:$i$j 192.168.$i$j.254/24
        ovn-nbctl \
            -- lsp-add ls$i lrp$i$j-attachment \
            -- set Logical_Switch_Port lrp$i$j-attachment type=router \
                             options:router-port=lrp$i$j \
                             addresses='"00:00:00:00:ff:'$i$j'"'
    done
done

ovn-nbctl create Port_Group name=pg1 ports="$pg1_ports"
ovn-nbctl create Port_Group name=pg2 ports="$pg2_ports"

# create ACLs on pg1 to drop traffic from pg2 to pg1
ovn-nbctl acl-add pg1 to-lport 1001 'outport == @pg1' drop
ovn-nbctl --type=port-group acl-add pg1 to-lport 1002 \
        'outport == @pg1 && ip4.src == $pg2_ip4' allow-related

# Physical network:
#
# Three hypervisors hv[123].
# lp?1[123] spread across hv[123]: lp?11 on hv1, lp?12 on hv2, lp?13 on hv3.
# lp?2[123] spread across hv[23]: lp?21 and lp?22 on hv2, lp?23 on hv3.
# lp?3[123] all on hv3.

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    case $1 in dnl (
        ?11) echo 1 ;; dnl (
        ?12 | ?21 | ?22) echo 2 ;; dnl (
        ?13 | ?23 | ?3?) echo 3 ;;
    esac
}

# Given the name of a logical port, prints the name of its logical router
# port, e.g. "vif_to_lrp 123" yields 12.
vif_to_lrp() {
    echo ${1%?}
}

# Given the name of a logical port, prints the name of its logical
# switch, e.g. "vif_to_ls 123" yields 1.
vif_to_ls() {
    echo ${1%??}
}

net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            hv=`vif_to_hv $i$j$k`
                as hv$hv ovs-vsctl \
                -- add-port br-int vif$i$j$k \
                -- set Interface vif$i$j$k \
                    external-ids:iface-id=lp$i$j$k \
                    options:tx_pcap=hv$hv/vif$i$j$k-tx.pcap \
                    options:rxq_pcap=hv$hv/vif$i$j$k-rx.pcap \
                    ofport-request=$i$j$k
        done
    done
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

lsp_to_mac() {
    echo f0:00:00:00:0${1:0:1}:${1:1:2}
}

lrp_to_mac() {
    echo 00:00:00:00:ff:$1
}

# test_icmp INPORT SRC_MAC DST_MAC SRC_IP DST_IP ICMP_TYPE OUTPORT...
#
# This shell function causes a ICMP packet to be received on INPORT.
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 123 for vif123.
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            : > $i$j$k.expected
        done
    done
done

test_icmp() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 icmp_type=$6
    local packet="inport==\"lp$inport\" && eth.src==$src_mac &&
                  eth.dst==$dst_mac && ip.ttl==64 && ip4.src==$src_ip
                  && ip4.dst==$dst_ip && icmp4.type==$icmp_type &&
                  icmp4.code==0"
    shift; shift; shift; shift; shift; shift
    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl -t ovn-controller inject-pkt "$packet"
    in_ls=`vif_to_ls $inport`
    in_lrp=`vif_to_lrp $inport`
    for outport; do
        out_ls=`vif_to_ls $outport`
        if test $in_ls = $out_ls; then
            # Ports on the same logical switch receive exactly the same packet.
            echo $packet | ovstest test-ovn expr-to-packets
        else
            # Routing decrements TTL and updates source and dest MAC
            # (and checksum).
            out_lrp=`vif_to_lrp $outport`
            exp_smac=`lrp_to_mac $out_lrp`
            exp_dmac=`lsp_to_mac $outport`
            exp_packet="eth.src==$exp_smac && eth.dst==$exp_dmac &&
                ip.ttl==63 && ip4.src==$src_ip && ip4.dst==$dst_ip &&
                icmp4.type==$icmp_type && icmp4.code==0"
            echo $exp_packet | ovstest test-ovn expr-to-packets

        fi >> $outport.expected
    done
}

as hv1 ovs-vsctl --columns=name,ofport list interface
as hv1 ovn-sbctl list port_binding
as hv1 ovn-sbctl list datapath_binding
as hv1 ovn-sbctl list port_group
as hv1 ovn-sbctl list address_set
as hv1 ovn-sbctl dump-flows
as hv1 ovs-ofctl dump-flows br-int

# Send IP packets between all pairs of source and destination ports,
# packets matches ACL1 but not ACL2 should be dropped
for is in 1 2 3; do
  for js in 1 2 3; do
    for ks in 1 2 3; do
      bcast=
      s=$is$js$ks
      slsp_mac=`lsp_to_mac $s`
      slrp_mac=`lrp_to_mac $is$js`
      sip=192.168.$is$js.$ks
      for id in 1 2 3; do
          for jd in 1 2 3; do
              for kd in 1 2 3; do
                d=$id$jd$kd
                dlsp_mac=`lsp_to_mac $d`
                dlrp_mac=`lrp_to_mac $id$jd`
                dip=192.168.$id$jd.$kd
                if test $is = $id; then dmac=$dlsp_mac; else dmac=$slrp_mac; fi
                if test $d != $s; then unicast=$d; else unicast=; fi

                # packets matches ACL1 but not ACL2 should be dropped
                if test $id != 3 && test $kd = 1; then
                    if test $is = 1 || test $ks != 2; then
                        unicast=
                    fi
                fi
                # icmp request (type = 8)
                test_icmp $s $slsp_mac $dmac $sip $dip 8 $unicast

                # if packets are not dropped, test the return traffic (icmp echo)
                # to make sure stateful works, too.
                if test x$unicast != x; then
                    if test $is = $id; then dmac=$slsp_mac; else dmac=$dlrp_mac; fi
                    # icmp echo (type = 0)
                    test_icmp $unicast $dlsp_mac $dmac $dip $sip 0 $s
                fi
              done
          done
        done
      done
  done
done

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            OVN_CHECK_PACKETS([hv`vif_to_hv $i$j$k`/vif$i$j$k-tx.pcap],
                              [$i$j$k.expected])
        done
    done
done

# Gracefully terminate daemons
OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Address Set generation from Port Groups (static addressing)])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 lp1
ovn-nbctl lsp-add ls1 lp2
ovn-nbctl lsp-add ls1 lp3

ovn-nbctl lsp-set-addresses lp1 "02:00:00:00:00:01 10.0.0.1 2001:db8::1"
ovn-nbctl lsp-set-addresses lp2 "02:00:00:00:00:02 10.0.0.2 2001:db8::2"
ovn-nbctl lsp-set-addresses lp3 "02:00:00:00:00:03 10.0.0.3 2001:db8::3"

ovn-nbctl create Port_Group name=pg1
ovn-nbctl create Port_Group name=pg2

ovn-nbctl --id=@p get Logical_Switch_Port lp1 -- add Port_Group pg1 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp2 -- add Port_Group pg1 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp2 -- add Port_Group pg2 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp3 -- add Port_Group pg2 ports @p

ovn-nbctl --wait=sb sync

dnl Check if port group address sets were populated with ports' addresses
check_column '10.0.0.1 10.0.0.2' Address_Set addresses name=pg1_ip4
check_column '10.0.0.2 10.0.0.3' Address_Set addresses name=pg2_ip4
check_column '2001:db8::1 2001:db8::2' Address_Set addresses name=pg1_ip6
check_column '2001:db8::2 2001:db8::3' Address_Set addresses name=pg2_ip6

ovn-nbctl --wait=sb lsp-set-addresses lp1 \
    "02:00:00:00:00:01 10.0.0.11 2001:db8::11"

dnl Check if updated address got propagated to the port group address sets
check_column '10.0.0.11 10.0.0.2' Address_Set addresses name=pg1_ip4
check_column '2001:db8::11 2001:db8::2' Address_Set addresses name=pg1_ip6

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Address Set generation from Port Groups (dynamic addressing)])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl ls-add ls3

ovn-nbctl set Logical_Switch ls1 \
    other_config:subnet=10.1.0.0/24 other_config:ipv6_prefix="2001:db8:1::"
ovn-nbctl set Logical_Switch ls2 \
    other_config:subnet=10.2.0.0/24 other_config:ipv6_prefix="2001:db8:2::"

# A prefix length may be specified, but only if it is /64.
ovn-nbctl set Logical_Switch ls3 \
    other_config:subnet=10.3.0.0/24 other_config:ipv6_prefix="2001:db8:3::/64"

ovn-nbctl lsp-add ls1 lp1
ovn-nbctl lsp-add ls2 lp2
ovn-nbctl lsp-add ls3 lp3

ovn-nbctl lsp-set-addresses lp1 "02:00:00:00:00:01 dynamic"
ovn-nbctl lsp-set-addresses lp2 "02:00:00:00:00:02 dynamic"
ovn-nbctl lsp-set-addresses lp3 "02:00:00:00:00:03 dynamic"

ovn-nbctl create Port_Group name=pg1
ovn-nbctl create Port_Group name=pg2

ovn-nbctl --id=@p get Logical_Switch_Port lp1 -- add Port_Group pg1 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp2 -- add Port_Group pg1 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp2 -- add Port_Group pg2 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp3 -- add Port_Group pg2 ports @p

ovn-nbctl --wait=sb sync

dnl Check if port group address sets were populated with ports' addresses
AT_CHECK(
  [ovn-sbctl get Address_Set pg1_ip4 addresses \
          -- get Address_Set pg2_ip4 addresses \
          -- get Address_Set pg1_ip6 addresses \
          -- get Address_Set pg2_ip6 addresses],
  [0],
  [[["10.1.0.2", "10.2.0.2"]]
[["10.2.0.2", "10.3.0.2"]]
[["2001:db8:1::ff:fe00:1", "2001:db8:2::ff:fe00:2"]]
[["2001:db8:2::ff:fe00:2", "2001:db8:3::ff:fe00:3"]]
])

dnl Check if updated address got propagated to the port group address sets
ovn-nbctl --wait=sb set Logical_Switch ls1 \
    other_config:subnet=10.11.0.0/24 other_config:ipv6_prefix="2001:db8:11::"
AT_CHECK(
  [ovn-sbctl get Address_Set pg1_ip4 addresses \
          -- get Address_Set pg2_ip4 addresses \
          -- get Address_Set pg1_ip6 addresses \
          -- get Address_Set pg2_ip6 addresses],
  [0],
  [[["10.11.0.2", "10.2.0.2"]]
[["10.2.0.2", "10.3.0.2"]]
[["2001:db8:11::ff:fe00:1", "2001:db8:2::ff:fe00:2"]]
[["2001:db8:2::ff:fe00:2", "2001:db8:3::ff:fe00:3"]]
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ACL conjunction])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

ovn-nbctl lsp-set-port-security ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02 10.0.0.6"

ovn-nbctl lsp-set-port-security ls1-lp2 "f0:00:00:00:00:02 10.0.0.6"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovn-nbctl create Address_Set name=set1 \
addresses=\"10.0.0.4\",\"10.0.0.5\",\"10.0.0.6\"
ovn-nbctl create Address_Set name=set2 \
addresses=\"10.0.0.7\",\"10.0.0.8\",\"10.0.0.9\"
ovn-nbctl acl-add ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == $set1' allow
check ovn-nbctl --wait=hv acl-add ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == $set2' drop

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes an ip packet to be received on INPORT.
# The packet's content has Ethernet destination DST and source SRC
# (each exactly 12 hex digits) and Ethernet type ETHTYPE (4 hex digits).
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 11 for vif11.
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}\
${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}


sip=`ip_to_hex 10 0 0 4`
dip=`ip_to_hex 10 0 0 6`

test_ip 1 f00000000001 f00000000002 $sip $dip 2

cat 2.expected > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [expout])

# There should be total of 9 flows present with conjunction action and 2 flows
# with conj match. Eg.
# table=44, priority=2001,conj_id=2,metadata=0x1 actions=resubmit(,45)
# table=44, priority=2001,conj_id=3,metadata=0x1 actions=drop
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.6 actions=conjunction(2,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(2,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.5 actions=conjunction(2,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.7 actions=conjunction(3,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.9 actions=conjunction(3,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.8 actions=conjunction(3,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.6 actions=conjunction(2,1/2),conjunction(3,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.4 actions=conjunction(2,1/2),conjunction(3,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.5 actions=conjunction(2,1/2),conjunction(3,1/2)

OVS_WAIT_UNTIL([test 9 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])
OVS_WAIT_UNTIL([test 3 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])
OVS_WAIT_UNTIL([test 2 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conj_id | wc -l`])

as hv1 ovs-ofctl dump-flows br-int

# Set the ip address for ls1-lp2 from set2 so that the drop ACL flow is hit.
ovn-nbctl lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02 10.0.0.7 20.0.0.4"
ovn-nbctl lsp-set-port-security ls1-lp2 "f0:00:00:00:00:02 10.0.0.7 20.0.0.4"

reset_pcap_file hv1-vif2 hv1/vif2

rm -f 2.packets

sip=`ip_to_hex 10 0 0 4`
dip=`ip_to_hex 10 0 0 7`

test_ip 1 f00000000001 f00000000002 $sip $dip

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [])

# Remove the first ACL, and verify that the conjunction flows are updated
# properly.
# There should be total of 6 flows present with conjunction action and 1 flow
# with conj match. Eg.
# table=44, priority=2001,conj_id=3,metadata=0x1 actions=drop
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.7 actions=conjunction(4,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.9 actions=conjunction(4,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.8 actions=conjunction(4,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.6 actions=conjunction(4,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.4 actions=conjunction(4,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.5 actions=conjunction(4,1/2)

ovn-nbctl acl-del ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == $set1'

OVS_WAIT_UNTIL([test 6 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conj_id | wc -l`])

# Add the ACL back
ovn-nbctl acl-add ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == $set1' allow
# Add one more ACL with more overlapping
ovn-nbctl acl-add ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == {10.0.0.9, 10.0.0.10}' drop

# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.8 actions=conjunction(4,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.7 actions=conjunction(4,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(5,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.5 actions=conjunction(5,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.6 actions=conjunction(5,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.9 actions=conjunction(4,1/2),conjunction(6,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.10 actions=conjunction(6,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.5 actions=conjunction(4,2/2),conjunction(5,2/2),conjunction(6,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.4 actions=conjunction(4,2/2),conjunction(5,2/2),conjunction(6,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.6 actions=conjunction(4,2/2),conjunction(5,2/2),conjunction(6,2/2)

OVS_WAIT_UNTIL([test 10 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])
OVS_WAIT_UNTIL([test 4 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])
OVS_WAIT_UNTIL([test 3 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction.*conjunction | wc -l`])

# Remove 10.0.0.7 from address set2. All flows should be updated properly.
ovn-nbctl set Address_Set set2 \
addresses=\"10.0.0.8\",\"10.0.0.9\"

# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(9,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.10 actions=conjunction(7,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.8 actions=conjunction(8,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.5 actions=conjunction(9,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.9 actions=conjunction(7,1/2),conjunction(8,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.6 actions=conjunction(9,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.5 actions=conjunction(7,2/2),conjunction(8,2/2),conjunction(9,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.6 actions=conjunction(7,2/2),conjunction(8,2/2),conjunction(9,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.4 actions=conjunction(7,2/2),conjunction(8,2/2),conjunction(9,2/2)

OVS_WAIT_UNTIL([test 9 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])
OVS_WAIT_UNTIL([test 4 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])
OVS_WAIT_UNTIL([test 3 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction.*conjunction | wc -l`])

# Remove an ACL again
ovn-nbctl acl-del ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == $set1'

wait_for_ports_up
ovn-nbctl --wait=hv sync
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.10 actions=conjunction(10,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.8 actions=conjunction(11,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.9 actions=conjunction(10,1/2),conjunction(11,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.5 actions=conjunction(10,2/2),conjunction(11,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.6 actions=conjunction(10,2/2),conjunction(11,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.4 actions=conjunction(10,2/2),conjunction(11,2/2)

OVS_WAIT_UNTIL([test 6 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])
OVS_WAIT_UNTIL([test 4 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction.*conjunction | wc -l`])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Superseding ACLs with conjunction])
ovn_start

check ovn-nbctl set nb_global . options:svc_monitor_mac=66:66:66:66:66:66
check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01" \
-- set logical_switch_port ls1-lp1 options:requested-tnl-key=1

check ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02" \
-- set logical_switch_port ls1-lp1 options:requested-tnl-key=2

net_add n1
sim_add hv1

as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes an ip packet to be received on INPORT.
# The packet's content has Ethernet destination DST and source SRC
# (each exactly 12 hex digits) and Ethernet type ETHTYPE (4 hex digits).
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 11 for vif11.
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}\
${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
    ovs-appctl ofproto/trace br-int in_port=hv1-vif1 "$packet" > trace
    for outport; do
        echo $packet >> $outport.expected
    done
}

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    check ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    check ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

# Add a default deny ACL and an allow ACL for specific IP traffic.
check ovn-nbctl acl-add ls1 to-lport 2 'arp' allow
check ovn-nbctl acl-add ls1 to-lport 1 'ip4' drop
check ovn-nbctl acl-add ls1 to-lport 3 '(ip4.src==10.0.0.1 || ip4.src==10.0.0.2) && (ip4.dst == 10.0.0.3 || ip4.dst == 10.0.0.4)' allow
check ovn-nbctl acl-add ls1 to-lport 3 '(ip4.src==10.0.0.1 || ip4.src==10.0.0.42) && (ip4.dst == 10.0.0.3 || ip4.dst == 10.0.0.4)' allow
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.3, 10.0.0.4 should be allowed.
for src in `seq 1 2`; do
    for dst in `seq 3 4`; do
        sip=`ip_to_hex 10 0 0 $src`
        dip=`ip_to_hex 10 0 0 $dst`

        test_ip 1 f00000000001 f00000000002 $sip $dip 2
    done
done

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.5 should be dropped.
dip=`ip_to_hex 10 0 0 5`
for src in `seq 1 2`; do
    sip=`ip_to_hex 10 0 0 $src`

    test_ip 1 f00000000001 f00000000002 $sip $dip
done

cat 2.expected > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [expout])
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 2.packets
> 2.expected

# Trigger recompute and make sure that the traffic still works as expected.
as hv1 ovn-appctl -t ovn-controller recompute

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.3, 10.0.0.4 should be allowed.
for src in `seq 1 2`; do
    for dst in `seq 3 4`; do
        sip=`ip_to_hex 10 0 0 $src`
        dip=`ip_to_hex 10 0 0 $dst`

        test_ip 1 f00000000001 f00000000002 $sip $dip 2
    done
done

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.5 should be dropped.
dip=`ip_to_hex 10 0 0 5`
for src in `seq 1 2`; do
    sip=`ip_to_hex 10 0 0 $src`

    test_ip 1 f00000000001 f00000000002 $sip $dip
done

cat 2.expected > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [expout])
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 2.packets
> 2.expected

# Add two less restrictive allow ACLs for src IP 10.0.0.1.
check ovn-nbctl acl-add ls1 to-lport 3 'ip4.src==10.0.0.1 || ip4.src==10.0.0.1' allow
check ovn-nbctl acl-add ls1 to-lport 3 'ip4.src==10.0.0.1' allow
check ovn-nbctl --wait=hv sync

# Check OVS flows, the less restrictive flows should have been installed.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=45 | ofctl_strip_all | \
    grep "priority=1003" | \
    sed 's/conjunction([[^)]]*)/conjunction()/g' | sort], [0], [dnl
 table=45, priority=1003,conj_id=2,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,conj_id=3,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.3 actions=conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.1 actions=resubmit(,46)
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.2 actions=conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.42 actions=conjunction()
])

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.3, 10.0.0.4 should be allowed.
for src in `seq 1 2`; do
    for dst in `seq 3 4`; do
        sip=`ip_to_hex 10 0 0 $src`
        dip=`ip_to_hex 10 0 0 $dst`

        test_ip 1 f00000000001 f00000000002 $sip $dip 2
    done
done

# Traffic 10.0.0.2 -> 10.0.0.5 should be dropped.
sip=`ip_to_hex 10 0 0 2`
dip=`ip_to_hex 10 0 0 5`
test_ip 1 f00000000001 f00000000002 $sip $dip

# Traffic 10.0.0.1 -> 10.0.0.5 should be allowed.
sip=`ip_to_hex 10 0 0 1`
dip=`ip_to_hex 10 0 0 5`
test_ip 1 f00000000001 f00000000002 $sip $dip 2

cat 2.expected > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [expout])
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 2.packets
> 2.expected

# Remove the first less restrictive allow ACL.
check ovn-nbctl acl-del ls1 to-lport 3 'ip4.src==10.0.0.1 || ip4.src==10.0.0.1'
check ovn-nbctl --wait=hv sync

# Check OVS flows, the second less restrictive allow ACL should have been installed.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=45 | ofctl_strip_all | \
    grep "priority=1003" | \
    sed 's/conjunction([[^)]]*)/conjunction()/g' | sort], [0], [dnl
 table=45, priority=1003,conj_id=2,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,conj_id=3,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.3 actions=conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.1 actions=resubmit(,46)
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.2 actions=conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.42 actions=conjunction()
])

# Remove the less restrictive allow ACL.
check ovn-nbctl acl-del ls1 to-lport 3 'ip4.src==10.0.0.1'
check ovn-nbctl --wait=hv sync

# Check OVS flows, the 10.0.0.1 conjunction should have been reinstalled.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=45 | ofctl_strip_all | \
    grep "priority=1003" | \
    sed 's/conjunction([[^)]]*)/conjunction()/g' | sort], [0], [dnl
 table=45, priority=1003,conj_id=2,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,conj_id=3,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.3 actions=conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.1 actions=conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.2 actions=conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.42 actions=conjunction()
])

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.3, 10.0.0.4 should be allowed.
for src in `seq 1 2`; do
    for dst in `seq 3 4`; do
        sip=`ip_to_hex 10 0 0 $src`
        dip=`ip_to_hex 10 0 0 $dst`

        test_ip 1 f00000000001 f00000000002 $sip $dip 2
    done
done

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.5 should be dropped.
dip=`ip_to_hex 10 0 0 5`
for src in `seq 1 2`; do
    sip=`ip_to_hex 10 0 0 $src`

    test_ip 1 f00000000001 f00000000002 $sip $dip
done

cat 2.expected > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [expout])

# Re-add the less restrictive allow ACL for src IP 10.0.0.1
check ovn-nbctl acl-add ls1 to-lport 3 'ip4.src==10.0.0.1' allow
check ovn-nbctl --wait=hv sync

# Check OVS flows, the less restrictive flows should have been installed.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=45 | ofctl_strip_all | \
   grep "priority=1003" | \
   sed 's/conjunction([[^)]]*)/conjunction()/g' | sort], [0], [dnl
 table=45, priority=1003,conj_id=2,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,conj_id=3,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.3 actions=conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.1 actions=resubmit(,46)
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.2 actions=conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.42 actions=conjunction()
])

# Add another ACL that overlaps with the existing less restrictive ones.
check ovn-nbctl acl-add ls1 to-lport 3 'udp || ((ip4.src==10.0.0.1 || ip4.src==10.0.0.2) && (ip4.dst == 10.0.0.3 || ip4.dst == 10.0.0.4))' allow
check ovn-nbctl --wait=hv sync

# Check OVS flows, the same conjunctive flows as above should still be there,
# with an additional conjunction action.
#
# New non-conjunctive flows should be added to match on 'udp'.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=45 | ofctl_strip_all | \
   grep "priority=1003" | \
   sed 's/conjunction([[^)]]*)/conjunction()/g' | sort], [0], [dnl
 table=45, priority=1003,conj_id=2,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,conj_id=3,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,conj_id=4,ip,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.3 actions=conjunction(),conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(),conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.1 actions=resubmit(,46)
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.2 actions=conjunction(),conjunction()
 table=45, priority=1003,ip,metadata=0x1,nw_src=10.0.0.42 actions=conjunction()
 table=45, priority=1003,udp,metadata=0x1 actions=resubmit(,46)
 table=45, priority=1003,udp6,metadata=0x1 actions=resubmit(,46)
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# 3 hypervisors, one logical switch, 3 logical ports per hypervisor
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- L2 Drop and Allow ACL w/ Stateful ACL])
ovn_start

# Create hypervisors hv[123].
# Add vif11 to hv1, vif21 to hv2, vif31 to hv3.
# Add all of the vifs to a single logical switch lsw0.
# Create Port Group with vif11 and vif21
# Create Address Set with vif11 and vif21's MAC addresses
# Test 1:
#  Create Drop ACL to drop all packets with ethertype 1234 between 11 and 21
#  No ACL for 31
#  Validate the drop ACL with and without any stateful rule on lsw0.
# Test 2:
#  Create Drop ACL to drop all packets between 11 and 21
#  Create higher priority ACL to allow packet with ethertype 1234 between 11 and 21
#  No ACL for 31
#  Validate the allow ACL with and without any stateful rule on lsw0.
#
ovn-nbctl ls-add lsw0
net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    ovs-vsctl add-port br-int vif${i}1 -- set Interface vif${i}1 external-ids:iface-id=lp${i}1 options:tx_pcap=hv$i/vif${i}1-tx.pcap options:rxq_pcap=hv$i/vif${i}1-rx.pcap ofport-request=${i}1
    ovn-nbctl lsp-add lsw0 lp${i}1
    ovn-nbctl lsp-set-addresses lp${i}1 "f0:00:00:00:00:${i}1 192.168.0.${i}1" unknown
done
#

get_lsp_uuid () {
    ovn-nbctl lsp-list lsw0 | grep $1 | awk '{ print $1 }'
}

# Create Port Group and corresponding Address set.
ovn-nbctl create Port_Group name=pg1 ports=`get_lsp_uuid lp11`,`get_lsp_uuid lp21`
ovn-nbctl create Address_Set name=set1 addresses=\"f0:00:00:00:00:11\",\"f0:00:00:00:00:21\"

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Make sure there is no attempt to adding duplicated flows by ovn-controller
AT_FAIL_IF([test -n "`grep duplicate hv1/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv2/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv3/ovn-controller.log`"])

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}

# test_packet INPORT DST SRC ETHTYPE OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 11 for vif11.
for i in 1 2 3; do
    : > ${i}1.expected
done
test_packet() {
    local inport=$1 packet=$2$3$4; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Test drop rule
# --------------
ovn-nbctl acl-del lsw0
check ovn-nbctl --wait=hv --log --severity=info --name=drop-acl acl-add lsw0 to-lport 5000 'outport == @pg1 && eth.src == $set1 && eth.type == 0x1234' drop
for sf in 0 1; do
    if test ${sf} = 1; then
        # Add a stateful rule and re-run the check to make sure the
        # drop rule is still effective..
        ovn-nbctl --wait=hv acl-add lsw0 from-lport 2000 'inport == "lp31" && ip' allow-related
    fi
    for is in 1 2 3; do
        s=${is}1
        for id in 1 2 3; do
            d=${id}1

            if test $d != $s;
            then
                if test ${is} = 3 || test ${id} = 3; then
                    test_packet $s f000000000$d f000000000$s 1234 $d # Allow to/from 31
                else
                    test_packet $s f000000000$d f000000000$s 1234    # Drop between 11 and 21
                fi
            fi
        done

        # Broadcast and multicast.
        if test ${is} = 3; then
            bcast="11 21" # Allow from 3
        else
            bcast="31"   # Allow only to 31 from 11 or 21.
        fi
        test_packet $s ffffffffffff f000000000$s 1234 $bcast
        test_packet $s 010000000000 f000000000$s 1234 $bcast
    done
done

# Test allow rule
#----------------
ovn-nbctl acl-del lsw0
# drop all packets to 11 and 21.
ovn-nbctl acl-add lsw0 to-lport 5000 'outport == @pg1 && eth.src == $set1' drop
# allow 0x1234 between 11 and 21
check ovn-nbctl --wait=hv --log --severity=info --name=allow-acl acl-add lsw0 to-lport 6000 'outport == @pg1 && eth.src == $set1 && eth.type == 0x1234' allow
for sf in 0 1; do
    if test ${sf} = 1; then
        # Add a stateful rule and re-run the check to make sure the
        # allow rule is still effective..
        check ovn-nbctl --wait=hv acl-add lsw0 from-lport 2000  'inport == "lp31" && ip' allow-related
    fi
    # dump information and flows with counters
    ovn-sbctl dump-flows -- list multicast_group > sbflows$sf
    AT_CAPTURE_FILE([sbflows0])
    AT_CAPTURE_FILE([sbflows1])
    for is in 1 2 3; do
        s=${is}1
        for id in 1 2 3; do
            d=${id}1

            if test $d != $s;
            then
                test_packet $s f000000000$d f000000000$s 1234 $d # allow 1234 to 11, 21, and 31
            fi
        done

        # Broadcast and multicast. Allow from one to the other 2.
        if test ${is} = 1; then
            bcast="21 31"
        elif test ${is} = 2; then
            bcast="11 31"
        else
            bcast="11 21"
        fi
        test_packet $s ffffffffffff f000000000$s 1234 $bcast
        test_packet $s 010000000000 f000000000$s 1234 $bcast
    done
done

as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int > offlows1
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int > offlows2
as hv3 ovs-ofctl -O OpenFlow13 dump-flows br-int > offlows3

# Now check the packets actually received against the ones expected.
AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
check_packets() {
    > expected
    > received
    for i in 1 2 3; do
        echo "--- hv$i vif${i}1" | tee -a expected >> received
        sort ${i}1.expected >> expected
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv$i/vif${i}1-tx.pcap | sort >> received
        echo | tee -a expected >> received
    done

    # need to verify the log for ACL hit as well, since in the allow case
    # (unlike the drop case) it is tricky to pass just with the expected;
    # since with the stateful rule the packet will still get by (default
    # rule) even if it doesn't hit the allow rule.
    # The hit count for the ACL is 6 (1 unicast + 2 non-unicast) * 2
    # (with/without stateful rule) for hv1 and hv2, each.
    cat >>expected <<EOF
--- acl logging
hv1_drop hit 6
hv2_drop hit 6
hv1_allow hit 6
hv2_allow hit 6
EOF

cat >>received <<EOF
--- acl logging
hv1_drop hit `grep -c 'acl_log.*|INFO|name="drop-acl"' hv1/ovn-controller.log`
hv2_drop hit `grep -c 'acl_log.*|INFO|name="drop-acl"' hv2/ovn-controller.log`
hv1_allow hit `grep -c 'acl_log.*|INFO|name="allow-acl"' hv1/ovn-controller.log`
hv2_allow hit `grep -c 'acl_log.*|INFO|name="allow-acl"' hv2/ovn-controller.log`
EOF

    $at_diff expected received >/dev/null
}
OVS_WAIT_UNTIL([check_packets], [$at_diff -F'^---' expected received])

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- TTL exceeded])
AT_KEYWORDS([ttl-exceeded])
ovn_start

# test_ip_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST IPV4_ROUTER IP_CHKSUM EXP_IP_CHKSUM EXP_ICMP_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv4 packet with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHKSUM as specified and TTL set to 1.
# EXP_IP_CHKSUM and EXP_ICMP_CHKSUM are the ip and icmp checksums of the icmp time exceeded frame
# generated by OVN logical router
#
# INPORT is a lport number, e.g. 11 for vif11.
# HV is a hypervisor number
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC, IPV4_DST and IPV4_ROUTER are each 8 hex digits.
# IP_CHKSUM, EXP_IP_CHSUM and EXP_ICMP_CHKSUM are each 4 hex digits
test_ip_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_router=$7 ip_chksum=$8
    local exp_ip_chksum=$9 exp_icmp_chksum=${10}
    shift 10

    local ip_ttl=01
    local packet=${eth_dst}${eth_src}08004500001400004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}
    local orig_pkt_in_reply=4500001400004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}
    local reply_icmp_ttl=fe
    local icmp_type_code_response=0b00
    local icmp_data=00000000
    local reply_icmp_payload=${icmp_type_code_response}${exp_icmp_chksum}${icmp_data}
    local reply=${eth_src}${eth_dst}08004500003000004000${reply_icmp_ttl}01${exp_ip_chksum}${ip_router}${ipv4_src}${reply_icmp_payload}
    echo $reply$orig_pkt_in_reply >> vif$inport.expected

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_ip6_packet INPORT HV ETH_SRC ETH_DST IPV6_SRC IPV6_DST IPV6_ROUTER EXP_ICMP_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv6
# packet with ETH_SRC, ETH_DST, IPV6_SRC and IPV6_DST as specified.
# IPV6_ROUTER and EXP_ICMP_CHKSUM are the source IP and checksum of the icmpv6 ttl exceeded
# packet sent by OVN logical router
test_ip6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6 ipv6_router=$7 exp_icmp_chksum=$8
    shift 8

    local ip6_hdr=6000000000151101${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}dbb8303900155bac6b646f65206676676e6d66720a

    local reply=${eth_src}${eth_dst}86dd6000000000453afe${ipv6_router}${ipv6_src}0300${exp_icmp_chksum}00000000${ip6_hdr}dbb8303900155bac6b646f65206676676e6d66720a
    echo $reply >> vif$inport.expected

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

for i in 1 2; do
    net_add n$i
    ovn-nbctl ls-add sw$i

    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n$i br-phys 192.168.$i.1

    ovn-nbctl lsp-add sw$i sw$i-p${i}0 -- \
        lsp-set-addresses sw$i-p${i}0 "00:00:00:00:00:0$i 192.168.$i.1 2001:db8:$i::11"

    ovs-vsctl -- add-port br-int vif$i -- \
        set interface vif$i \
        external-ids:iface-id=sw$i-p${i}0 \
            options:tx_pcap=hv$i/vif$i-tx.pcap \
            options:rxq_pcap=hv$i/vif$i-rx.pcap \
            ofport-request=$i
done

ovn-nbctl lr-add lr0
for i in 1 2; do
    ovn-nbctl lrp-add lr0 lrp$i 00:00:00:00:ff:0$i 192.168.$i.254/24 2001:db8:$i::1/64
    ovn-nbctl -- lsp-add sw$i lrp$i-attachment \
              -- set Logical_Switch_Port lrp$i-attachment type=router \
                options:router-port=lrp$i addresses='"00:00:00:00:ff:0'$i' 192.168.'$i'.254 2001:db8:'$i'::1"'
done

OVN_POPULATE_ARP
# allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
ovn-nbctl --wait=hv sync

test_ip_packet 1 1 000000000001 00000000ff01 $(ip_to_hex 192 168 1 1) $(ip_to_hex 192 168 2 1) $(ip_to_hex 192 168 1 254) 0000 f87c ea96
test_ip6_packet 1 1 000000000001 00000000ff01 20010db8000100000000000000000011 20010db8000200000000000000000011 20010db8000100000000000000000001 1c22
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [vif1.expected])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- router port unreachable])
AT_KEYWORDS([router-port-unreachable])
ovn_start

# test_ip_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_ROUTER L4_PROTCOL IP_CHKSUM EXP_IP_CHKSUM EXP_ICMP_CHKSUM EXP_ICMP_CODE
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv4 packet with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_ROUTER, L4_PROTCOL, IP_CHKSUM as specified.
# EXP_IP_CHKSUM and EXP_ICMP_CHKSUM are the ip and icmp checksums of the icmp frame generated by OVN logical router
# EXP_ICMP_CODE are code and type of the icmp frame generated by OVN logical router
#
# INPORT is a lport number, e.g. 11 for vif11.
# HV is a hypervisor number
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_ROUTER are each 8 hex digits.
# IP_CHKSUM, EXP_IP_CHSUM and EXP_ICMP_CHKSUM are each 4 hex digits
test_ip_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ip_router=$6 l4_proto=$7 ip_chksum=$8
    local exp_ip_chksum=$9 exp_icmp_chksum=${10} exp_icmp_code=${11}
    shift 11

    local ip_ttl=ff
    local packet=${eth_dst}${eth_src}08004500001400004000${ip_ttl}${l4_proto}${ip_chksum}${ipv4_src}${ip_router}
    local orig_pkt_in_reply=4500001400004000${ip_ttl}${l4_proto}${ip_chksum}${ipv4_src}${ip_router}
    local reply_icmp_ttl=fe
    local icmp_data=00000000
    local reply_icmp_payload=${exp_icmp_code}${exp_icmp_chksum}${icmp_data}
    local reply=${eth_src}${eth_dst}08004500003000004000${reply_icmp_ttl}01${exp_ip_chksum}${ip_router}${ipv4_src}${reply_icmp_payload}
    echo $reply$orig_pkt_in_reply >> vif$inport.expected

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_tcp_syn_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_ROUTER IP_CHKSUM TCP_SPORT TCP_DPORT TCP_CHKSUM EXP_IP_CHKSUM EXP_TCP_RST_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an TCP syn segment with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_ROUTER, IP_CHKSUM, TCP_SPORT, TCP_DPORT, TCP_CHKSUM  as specified.
# EXP_IP_CHKSUM and EXP_TCP_RST_CHKSUM are the ip and tcp checksums of the tcp reset segment generated by OVN logical router
#
# INPORT is an lport number, e.g. 11 for vif11.
# HV is an hypervisor number
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_ROUTER are each 8 hex digits.
# TCP_SPORT and TCP_DPORT are 4 hex digits.
# IP_CHKSUM, TCP_CHKSUM, EXP_IP_CHSUM and EXP_TCP_RST_CHKSUM are each 4 hex digits
test_tcp_syn_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ip_router=$6 ip_chksum=$7
    local tcp_sport=$8 tcp_dport=$9 tcp_chksum=${10}
    local exp_ip_chksum=${11} exp_tcp_rst_chksum=${12}
    shift 12

    local ip_ttl=ff
    local packet=${eth_dst}${eth_src}08004500002800004000${ip_ttl}06${ip_chksum}${ipv4_src}${ip_router}${tcp_sport}${tcp_dport}000000010000000050027210${tcp_chksum}0000

    local tcp_rst_ttl=3e
    local reply=${eth_src}${eth_dst}08004500002800004000${tcp_rst_ttl}06${exp_ip_chksum}${ip_router}${ipv4_src}${tcp_dport}${tcp_sport}000000000000000250140000${exp_tcp_rst_chksum}0000
    echo $reply >> vif$inport.expected

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_sctp_init_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST IP_CHKSUM SCTP_SPORT SCTP_DPORT SCTP_INIT_TAG SCTP_CHKSUM EXP_IP_CHKSUM EXP_SCTP_ABORT_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an SCTP INIT chunk with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHKSUM, SCTP_SPORT, SCTP_DPORT, and SCTP_CHKSUM as specified.
# The INIT "initiate_tag" will be set to SCTP_INIT_TAG.
# EXP_IP_CHKSUM and EXP_SCTP_CHKSUM are the ip and sctp checksums of the SCTP ABORT chunk generated by OVN logical router
#
# INPORT is an lport number, e.g. 1 for vif1.
# HV is a hypervisor number.
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_DST are each 8 hex digits.
# SCTP_SPORT and SCTP_DPORT are 4 hex digits.
# IP_CHKSUM and EXP_IP_CHKSUM are 4 hex digits.
# SCTP_CHKSUM and EXP_SCTP_CHKSUM are 8 hex digits.
test_sctp_init_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7
    local sctp_sport=$8 sctp_dport=$9 sctp_init_tag=${10} sctp_chksum=${11}
    local exp_ip_chksum=${12} exp_sctp_abort_chksum=${13}

    local ip_ttl=ff
    local eth_hdr=${eth_dst}${eth_src}0800
    local ip_hdr=4500002500004000${ip_ttl}84${ip_chksum}${ipv4_src}${ipv4_dst}
    local sctp_hdr=${sctp_sport}${sctp_dport}00000000${sctp_chksum}
    local sctp_init=01000014${sctp_init_tag}0000000000010001${sctp_init_tag}

    local packet=${eth_hdr}${ip_hdr}${sctp_hdr}${sctp_init}

    local sctp_abort_ttl=3e
    local reply_eth_hdr=${eth_src}${eth_dst}0800
    local reply_ip_hdr=4500002400004000${sctp_abort_ttl}84${exp_ip_chksum}${ipv4_dst}${ipv4_src}
    local reply_sctp_hdr=${sctp_dport}${sctp_sport}${sctp_init_tag}${exp_sctp_abort_chksum}
    local reply_sctp_abort=06000004

    local reply=${reply_eth_hdr}${reply_ip_hdr}${reply_sctp_hdr}${reply_sctp_abort}
    echo $reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_tcp6_packet INPORT HV ETH_SRC ETH_DST IPV6_SRC IPV6_ROUTER TCP_SPORT TCP_DPORT TCP_CHKSUM EXP_TCP_RST_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is a TCP syn segment with
# ETH_SRC, ETH_DST, IPV6_SRC, IPV6_ROUTER, TCP_SPORT, TCP_DPORT and TCP_CHKSUM as specified.
# EXP_TCP_RST_CHKSUM is the tcp checksums of the tcp reset segment generated by OVN logical router
test_tcp6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_router=$6
    local tcp_sport=$7 tcp_dport=$8 tcp_chksum=$9
    local exp_tcp_rst_chksum=${10}
    shift 10

    local ip6_hdr=60000000001406ff${ipv6_src}${ipv6_router}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}${tcp_sport}${tcp_dport}000000010000000050027210${tcp_chksum}0000

    local reply=${eth_src}${eth_dst}86dd600000000014063e${ipv6_router}${ipv6_src}${tcp_dport}${tcp_sport}000000000000000250140000${exp_tcp_rst_chksum}0000
    echo $reply >> vif$inport.expected

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_tcp6_packet INPORT HV ETH_SRC ETH_DST IPV6_SRC IPV6_ROUTER SCTP_SPORT SCTP_DPORT SCTP_INIT_TAG SCTP_CHKSUM EXP_SCTP_ABORT_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an SCTP INIT chunk with
# ETH_SRC, ETH_DST, IPV6_SRC, IPV6_ROUTER, SCTP_SPORT, SCTP_DPORT and SCTP_CHKSUM as specified.
# The INIT "initiate_tag" will be set to SCTP_INIT_TAG.
# EXP_SCTP_CHKSUM is the sctp checksum of the SCTP ABORT chunk generated by OVN logical router
test_sctp6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_router=$6
    local sctp_sport=$7 sctp_dport=$8 sctp_init_tag=$9 sctp_chksum=${10}
    local exp_sctp_abort_chksum=${11}
    shift 11

    local eth_hdr=${eth_dst}${eth_src}86dd
    local ip_hdr=60000000002084ff${ipv6_src}${ipv6_router}
    local sctp_hdr=${sctp_sport}${sctp_dport}00000000${sctp_chksum}
    local sctp_init=01000014${sctp_init_tag}0000000000010001${sctp_init_tag}

    local packet=${eth_hdr}${ip_hdr}${sctp_hdr}${sctp_init}

    local reply_eth_hdr=${eth_src}${eth_dst}86dd
    local reply_ip_hdr=600000000010843e${ipv6_router}${ipv6_src}
    local reply_sctp_hdr=${sctp_dport}${sctp_sport}${sctp_init_tag}${exp_sctp_abort_chksum}
    local reply_sctp_abort=06000004

    local reply=${reply_eth_hdr}${reply_ip_hdr}${reply_sctp_hdr}${reply_sctp_abort}
    echo $reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_ip6_packet INPORT HV ETH_SRC ETH_DST IPV6_SRC IPV6_DST IPV6_PROTO IPV6_LEN DATA EXP_ICMP_CODE EXP_ICMP_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv6
# packet with ETH_SRC, ETH_DST, IPV6_SRC, IPV6_DST, IPV6_PROTO, IPV6_LEN and DATA as specified.
# EXP_ICMP_CODE and EXP_ICMP_CHKSUM are the code and checksum of the icmp6 packet sent by OVN logical router
test_ip6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6 ipv6_proto=$7 ipv6_len=$8 data=$9
    local exp_icmp_code=${10} exp_icmp_chksum=${11}
    shift 11

    local ip6_hdr=60000000${ipv6_len}${ipv6_proto}ff${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}${data}

    local reply_ip_len=`expr 48 + ${#data} / 2`
    reply_ip_len=$(printf "%x" $reply_ip_len)
    local reply=${eth_src}${eth_dst}86dd6000000000${reply_ip_len}3afe${ipv6_dst}${ipv6_src}${exp_icmp_code}${exp_icmp_chksum}00000000${ip6_hdr}${data}
    echo $reply >> vif$inport.expected

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

for i in 1 2; do
    net_add n$i
    ovn-nbctl ls-add sw$i

    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n$i br-phys 192.168.$i.1

    ovn-nbctl lsp-add sw$i sw$i-p${i}0 -- \
        lsp-set-addresses sw$i-p${i}0 "00:00:00:00:00:0$i 192.168.$i.1 2001:db8:$i::11"

    ovs-vsctl -- add-port br-int vif$i -- \
        set interface vif$i \
        external-ids:iface-id=sw$i-p${i}0 \
            options:tx_pcap=hv$i/vif$i-tx.pcap \
            options:rxq_pcap=hv$i/vif$i-rx.pcap \
            ofport-request=$i
done

ovn-nbctl lr-add lr0
for i in 1 2; do
    ovn-nbctl lrp-add lr0 lrp$i 00:00:00:00:ff:0$i 192.168.$i.254/24 2001:db8:$i::1/64
    ovn-nbctl -- lsp-add sw$i lrp$i-attachment \
              -- set Logical_Switch_Port lrp$i-attachment type=router \
                options:router-port=lrp$i addresses='"00:00:00:00:ff:0'$i' 192.168.'$i'.254 2001:db8:'$i'::1"'
done

OVN_POPULATE_ARP
# allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

test_ip_packet 1 1 000000000001 00000000ff01 $(ip_to_hex 192 168 1 1) $(ip_to_hex 192 168 1 254) 11 0000 f87c f485 0303
test_ip6_packet 1 1 000000000001 00000000ff01 20010db8000100000000000000000011 20010db8000100000000000000000001 11 0015 dbb8303900155bac6b646f65206676676e6d66720a 0104 1d31
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [vif1.expected])

test_tcp_syn_packet 2 2 000000000002 00000000ff02 $(ip_to_hex 192 168 2 1) $(ip_to_hex 192 168 2 254) 0000 8b40 3039 0000 b680 6e05
test_sctp_init_packet 2 2 000000000002 00000000ff02 $(ip_to_hex 192 168 2 1) $(ip_to_hex 192 168 2 254) 0000 8b40 3039 00000001 82112601 b606 10fe95b6
test_tcp6_packet 2 2 000000000002 00000000ff02 20010db8000200000000000000000011 20010db8000200000000000000000001 8b40 3039 0000 98cd
test_sctp6_packet 2 2 000000000002 00000000ff02 20010db8000200000000000000000011 20010db8000200000000000000000001 8b40 3039 00000002 C0379D5A 39f23aaf
OVN_CHECK_PACKETS([hv2/vif2-tx.pcap], [vif2.expected])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ovn-controller exit])
ovn_start
# Logical network:
# One Logical Router: ro, with two logical switches sw1 and sw2.
# sw1 is for subnet 10.0.0.0/8
# sw2 is for subnet 20.0.0.0/8
# sw1 has a single port bound on hv1
# sw2 has a single port bound on hv2

ovn-nbctl lr-add ro
ovn-nbctl ls-add sw1
ovn-nbctl ls-add sw2

sw1_ro_mac=00:00:10:00:00:01
sw1_ro_ip=10.0.0.1
sw2_ro_mac=00:00:20:00:00:01
sw2_ro_ip=20.0.0.1
sw1_p1_mac=00:00:10:00:00:02
sw1_p1_ip=10.0.0.2
sw2_p1_mac=00:00:20:00:00:02
sw2_p1_ip=20.0.0.2

ovn-nbctl lrp-add ro ro-sw1 $sw1_ro_mac ${sw1_ro_ip}/8
ovn-nbctl lrp-add ro ro-sw2 $sw2_ro_mac ${sw2_ro_ip}/8
ovn-nbctl lsp-add sw1 sw1-ro -- set Logical_Switch_Port sw1-ro type=router \
  options:router-port=ro-sw1 addresses=\"$sw1_ro_mac\"
ovn-nbctl lsp-add sw2 sw2-ro -- set Logical_Switch_Port sw2-ro type=router \
  options:router-port=ro-sw2 addresses=\"$sw2_ro_mac\"

ovn-nbctl lsp-add sw1 sw1-p1 \
-- lsp-set-addresses sw1-p1 "$sw1_p1_mac $sw1_p1_ip"

ovn-nbctl lsp-add sw2 sw2-p1 \
-- lsp-set-addresses sw2-p1 "$sw2_p1_mac $sw2_p1_ip"

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw2-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

packet="inport==\"sw1-p1\" && eth.src==$sw1_p1_mac && eth.dst==$sw1_ro_mac &&
       ip4 && ip.ttl==64 && ip4.src==$sw1_p1_ip && ip4.dst==$sw2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"

# Start by Sending the packet and make sure it makes it there as expected
as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"

# Expected packet has TTL decreased by 1
expected="eth.src==$sw2_ro_mac && eth.dst==$sw2_p1_mac &&
       ip4 && ip.ttl==63 && ip4.src==$sw1_p1_ip && ip4.dst==$sw2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Stop ovn-controller on hv2
as hv2 ovs-appctl -t ovn-controller exit

# Now send the packet again. This time, it should not arrive.
as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Start ovn-controller again just so OVN_CLEANUP doesn't complain
as hv2 start_daemon ovn-controller

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- external logical port])
ovn_start

net_add n1
sim_add hv1
sim_add hv2
sim_add hv3

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4 ae70::4"

# Add a couple of external logical port
ovn-nbctl lsp-add ls1 ls1-lp_ext1 \
-- lsp-set-addresses ls1-lp_ext1 "f0:00:00:00:00:03 10.0.0.6 ae70::6"
ovn-nbctl lsp-set-port-security ls1-lp_ext1 \
"f0:00:00:00:00:03 10.0.0.6 ae70::6"
ovn-nbctl lsp-set-type ls1-lp_ext1 external

ovn-nbctl lsp-add ls1 ls1-lp_ext2 \
-- lsp-set-addresses ls1-lp_ext2 "f0:00:00:00:00:04 10.0.0.7 ae70::7"
ovn-nbctl lsp-set-port-security ls1-lp_ext2 \
"f0:00:00:00:00:04 10.0.0.7 ae70::8"
ovn-nbctl lsp-set-type ls1-lp_ext2 external

d1="$(ovn-nbctl create DHCP_Options cidr=10.0.0.0/24 \
options="\"server_id\"=\"10.0.0.1\" \"server_mac\"=\"ff:10:00:00:00:01\" \
\"lease_time\"=\"3600\" \"router\"=\"10.0.0.1\"")"

d2="$(ovn-nbctl create DHCP_Options cidr="ae70\:\:/64" \
options="\"server_id\"=\"00:00:00:10:00:01\"")"

ovn-nbctl lsp-set-dhcpv4-options ls1-lp1 ${d1}
ovn-nbctl lsp-set-dhcpv4-options ls1-lp_ext1 ${d1}
ovn-nbctl lsp-set-dhcpv4-options ls1-lp_ext2 ${d1}

ovn-nbctl lsp-set-dhcpv6-options ls1-lp1 ${d2}
ovn-nbctl lsp-set-dhcpv6-options ls1-lp_ext1 ${d2}
ovn-nbctl lsp-set-dhcpv6-options ls1-lp_ext2 ${d2}

# Create a logical router and connect it to ls1
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-ls1 a0:10:00:00:00:01 10.0.0.1/24
ovn-nbctl lsp-add ls1 ls1-lr0
ovn-nbctl set Logical_Switch_Port ls1-lr0 type=router \
    options:router-port=lr0-ls1 addresses=router

# Create HA chassis group
ovn-nbctl ha-chassis-group-add hagrp1
ovn-nbctl ha-chassis-group-add-chassis hagrp1 hv1 30
ovn-nbctl --wait=sb sync

hagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name="hagrp1"`

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-phys hv1-ext1 -- \
    set interface hv1-ext1 options:tx_pcap=hv1/ext1-tx.pcap \
    options:rxq_pcap=hv1/ext1-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-phys hv2-ext2 -- \
    set interface hv2-ext2 options:tx_pcap=hv2/ext2-tx.pcap \
    options:rxq_pcap=hv2/ext2-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl -- add-port br-phys hv3-ext3 -- \
    set interface hv3-ext3 options:tx_pcap=hv3/ext3-tx.pcap \
    options:rxq_pcap=hv3/ext3-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

# No DHCPv4/v6 flows for the external port - ls1-lp_ext1 - 10.0.0.6 in hv1 and
# hv2 as ha-chassis-group is not set and no localnet port added to ls1.
AT_CHECK([ovn-sbctl dump-flows ls1 | grep "offerip = 10.0.0.6" | \
wc -l], [0], [0
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep table=23 | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | grep table=23 | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep table=23 | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | grep table=23 | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | wc -l], [0], [0
])

hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)
hv3_uuid=$(fetch_column Chassis _uuid name=hv3)

# The port_binding row for ls1-lp_ext1 should have empty chassis
check_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis='[[]]'

# Associate hagrp1 ha-chassis-group to ls1-lp_ext1
ovn-nbctl --wait=hv set Logical_Switch_Port ls1-lp_ext1 \
ha-chassis-group=$hagrp1_uuid

# Get the hagrp1 uuid in SB DB.
sb_hagrp1_uuid=$(fetch_column HA_Chassis_Group _uuid name=hagrp1)

# Wait till ls1-lp_ext1 port_binding has ha_chassis_group set
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 ha_chassis_group=$sb_hagrp1_uuid

# No DHCPv4/v6 flows for the external port - ls1-lp_ext1 - 10.0.0.6 in hv1 and hv2
# as no localnet port added to ls1 yet.
#
# This used to be specific to a particular OpenFlow table, but that can
# easily shift around as OVN evolves, so it's been removed to avoid
# gratuitous breakage.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | wc -l], [0], [0
])

# Add the localnet port to the logical switch ls1
ovn-nbctl lsp-add ls1 ln-public
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl --wait=hv lsp-set-options ln-public network_name=phys

ln_public_key=$(fetch_column Port_Binding tunnel_key logical_port=ln-public)

# The ls1-lp_ext1 should be bound to hv1 as only hv1 is part of the
# ha chassis group.
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv1_uuid

wait_for_ports_up ls1-lp_ext1

# There should be DHCPv4/v6 OF flows for the ls1-lp_ext1 port in hv1
(ovn-sbctl dump-flows lr0; ovn-sbctl dump-flows ls1) > sbflows
as hv1 ovs-ofctl dump-flows br-int > brintflows
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | grep reg14=0x$ln_public_key | \
wc -l], [0], [3
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | \
grep reg14=0x$ln_public_key | wc -l], [0], [1
])

# There should be no DHCPv4/v6 flows for ls1-lp_ext1 on hv2
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | wc -l], [0], [0
])

# No DHCPv4/v6 flows for the external port - ls1-lp_ext2 - 10.0.0.7 in hv1 and
# hv2 as requested-chassis option is not set.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.07" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.07" | wc -l], [0], [0
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.07" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.07" | wc -l], [0], [0
])

as hv1
ovs-vsctl show

# This shell function sends a DHCP request packet
# test_dhcp INPORT SRC_MAC DHCP_TYPE BROADCAST OFFER_IP ...
test_dhcp() {
    local inport=$1 src_mac=$2 dhcp_type=$3 broadcast=$4 offer_ip=$5 use_ip=$6
    shift; shift; shift; shift; shift; shift;

    if test $use_ip != 0; then
        src_ip=$1
        dst_ip=$2
        shift; shift;
    else
        src_ip=`ip_to_hex 0 0 0 0`
        dst_ip=`ip_to_hex 255 255 255 255`
    fi

    if test $broadcast != 0; then
        flags=8000
        reply_dst_ip=`ip_to_hex 255 255 255 255`
    else
        flags=0000
        reply_dst_ip=${offer_ip}
    fi

    local request=ffffffffffff${src_mac}0800451001100000000080110000${src_ip}${dst_ip}
    # udp header and dhcp header
    request=${request}0044004300fc0000
    request=${request}010106006359aa760000${flags}00000000000000000000000000000000${src_mac}
    # client hardware padding
    request=${request}00000000000000000000
    # server hostname
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    # boot file name
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    # dhcp magic cookie
    request=${request}63825363
    # dhcp message type
    request=${request}3501${dhcp_type}ff

    local srv_mac=$1 srv_ip=$2 expected_dhcp_opts=$3
    # total IP length will be the IP length of the request packet
    # (which is 272 in our case) + 8 (padding bytes) + (expected_dhcp_opts / 2)
    ip_len=`expr 280 + ${#expected_dhcp_opts} / 2`
    udp_len=`expr $ip_len - 20`
    ip_len=$(printf "%x" $ip_len)
    udp_len=$(printf "%x" $udp_len)
    # $ip_len var will be in 3 digits i.e 134. So adding a '0' before $ip_len
    local reply=${src_mac}${srv_mac}080045100${ip_len}000000008011XXXX${srv_ip}${reply_dst_ip}
    # udp header and dhcp header.
    # $udp_len var will be in 3 digits. So adding a '0' before $udp_len
    reply=${reply}004300440${udp_len}0000020106006359aa760000${flags}00000000
    # your ip address
    reply=${reply}${offer_ip}
    # next server ip address, relay agent ip address, client mac address
    reply=${reply}0000000000000000${src_mac}
    # client hardware padding
    reply=${reply}00000000000000000000
    # server hostname
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    # boot file name
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    # dhcp magic cookie
    reply=${reply}63825363
    # dhcp message type
    local dhcp_reply_type=02
    if test $dhcp_type = 03; then
        dhcp_reply_type=05
    fi
    reply=${reply}3501${dhcp_reply_type}${expected_dhcp_opts}00000000ff00000000
    echo $reply >> ext1_v4.expected

    as hv1 ovs-appctl netdev-dummy/receive hv${inport}-ext${inport} $request
}


trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

# This shell function sends a DHCPv6 request packet
# test_dhcpv6 INPORT SRC_MAC SRC_LLA DHCPv6_MSG_TYPE OFFER_IP OUTPORT...
# The OUTPORTs (zero or more) list the VIFs on which the original DHCPv6
# packet should be received twice (one from ovn-controller and the other
# from the "ovs-ofctl monitor br-int resume"
test_dhcpv6() {
    local inport=$1 src_mac=$2 src_lla=$3 msg_code=$4 offer_ip=$5
    local req_pkt_in_expected=$6
    local request=ffffffffffff${src_mac}86dd00000000002a1101${src_lla}
    # dst ip ff02::1:2
    request=${request}ff020000000000000000000000010002
    # udp header and dhcpv6 header
    request=${request}02220223002affff${msg_code}010203
    # Client identifier
    request=${request}0001000a00030001${src_mac}
    # IA-NA (Identity Association for Non Temporary Address)
    request=${request}0003000c0102030400000e1000001518
    shift; shift; shift; shift; shift;

    local server_mac=000000100001
    local server_lla=fe80000000000000020000fffe100001
    local reply_code=07
    if test $msg_code = 01; then
        reply_code=02
    fi
    local msg_len=54
    if test $offer_ip = 1; then
        msg_len=28
    fi
    local reply=${src_mac}${server_mac}86dd0000000000${msg_len}1101
    reply=${reply}${server_lla}${src_lla}

    # udp header and dhcpv6 header
    reply=${reply}0223022200${msg_len}ffff${reply_code}010203
    # Client identifier
    reply=${reply}0001000a00030001${src_mac}
    # IA-NA
    if test $offer_ip != 1; then
        reply=${reply}0003002801020304ffffffffffffffff00050018${offer_ip}
        reply=${reply}ffffffffffffffff
    fi
    # Server identifier
    reply=${reply}0002000a00030001${server_mac}

    echo $reply | trim_zeros >> ext${inport}_v6.expected
    # The inport also receives the request packet since it is connected
    # to the br-phys.
    #echo $request >> ext${inport}_v6.expected

    as hv1 ovs-appctl netdev-dummy/receive hv${inport}-ext${inport} $request
}

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

AT_CAPTURE_FILE([ofctl_monitor0_hv1.log])
as hv1 ovs-ofctl monitor br-int resume --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0_hv1.log

AT_CAPTURE_FILE([ofctl_monitor0_hv2.log])
as hv2 ovs-ofctl monitor br-int resume --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0_hv2.log

AT_CAPTURE_FILE([ofctl_monitor0_hv3.log])
as hv3 ovs-ofctl monitor br-int resume --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0_hv3.log

as hv1
reset_pcap_file hv1-ext1 hv1/ext1

# Send DHCPDISCOVER.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
server_mac=ff1000000001
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 1 f00000000003 01 0 $offer_ip 0 $server_mac $server_ip \
$expected_dhcp_opts

# NXT_RESUMEs should be 1 in hv1.
OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 0 in hv2.
OVS_WAIT_UNTIL([test 0 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ext1-tx.pcap > ext1_v4.packets
cat ext1_v4.expected | cut -c -48 > expout
AT_CHECK([cat ext1_v4.packets | cut -c -48], [0], [expout])
# Skipping the IPv4 checksum.
cat ext1_v4.expected | cut -c 53- > expout
AT_CHECK([cat ext1_v4.packets | cut -c 53-], [0], [expout])

# ovs-ofctl also resumes the packets and this causes other ports to receive
# the DHCP request packet. So reset the pcap files so that its easier to test.
as hv1
reset_pcap_file hv1-ext1 hv1/ext1

rm -f ext1_v4.expected
rm -f ext1_v4.packets

# Send DHCPv6 request
src_mac=f00000000003
src_lla=fe80000000000000f20000fffe000003
offer_ip=ae700000000000000000000000000006
test_dhcpv6 1 $src_mac $src_lla 01 $offer_ip

# NXT_RESUMEs should be 2 in hv1.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 0 in hv2.
OVS_WAIT_UNTIL([test 0 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ext1-tx.pcap | \
sort > ext1_v6.packets
cat ext1_v6.expected | cut -c -120 > expout
AT_CHECK([cat ext1_v6.packets | cut -c -120], [0], [expout])
# Skipping the UDP checksum
cat ext1_v6.expected | cut -c 125- > expout
AT_CHECK([cat ext1_v6.packets | cut -c 125-], [0], [expout])

rm -f ext1_v6.expected
rm -f ext1_v6.packets

as hv1
reset_pcap_file hv1-ext1 hv1/ext1

# Delete the ha-chassis hv1.
ovn-nbctl ha-chassis-group-remove-chassis hagrp1 hv1
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis='[[]]'

# Add hv2 to the ha chassis group
ovn-nbctl --wait=hv ha-chassis-group-add-chassis hagrp1 hv2 20

ovn-sbctl list ha_chassis_group
ovn-sbctl list ha_chassis

ovn-sbctl find port_binding logical_port=ls1-lp_ext1

# The ls1-lp_ext1 should be bound to hv2
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv2_uuid
wait_for_ports_up ls1-lp_ext1

# There should be OF flows for DHCP4/v6 for the ls1-lp_ext1 port in hv2
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | grep reg14=0x$ln_public_key | \
wc -l], [0], [3
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | \
grep reg14=0x$ln_public_key | wc -l], [0], [1
])

# There should be no DHCPv4/v6 flows for ls1-lp_ext1 on hv1
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | \
grep reg14=0x$ln_public_key | wc -l], [0], [0
])

# Send DHCPDISCOVER again for hv1/ext1. The DHCP response should come from
# hv2 ovn-controller.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
server_mac=ff1000000001
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 1 f00000000003 01 0 $offer_ip 0 $server_mac $server_ip \
$expected_dhcp_opts

# NXT_RESUMEs should be 2 in hv1.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 1 in hv2.
OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ext1-tx.pcap > ext1_v4.packets
cat ext1_v4.expected | cut -c -48 > expout
AT_CHECK([cat ext1_v4.packets | cut -c -48], [0], [expout])
# Skipping the IPv4 checksum.
cat ext1_v4.expected | cut -c 53- > expout
AT_CHECK([cat ext1_v4.packets | cut -c 53-], [0], [expout])

# ovs-ofctl also resumes the packets and this causes other ports to receive
# the DHCP request packet. So reset the pcap files so that its easier to test.
as hv1
reset_pcap_file hv1-ext1 hv1/ext1

rm -f ext1_v4.expected

# Send DHCPv6 request again
src_mac=f00000000003
src_lla=fe80000000000000f20000fffe000003
offer_ip=ae700000000000000000000000000006
test_dhcpv6 1 $src_mac $src_lla 01 $offer_ip 1

# NXT_RESUMEs should be 2 in hv1.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ext1-tx.pcap | \
sort > ext1_v6.packets
cat ext1_v6.expected | cut -c -120 > expout
AT_CHECK([cat ext1_v6.packets | cut -c -120], [0], [expout])
# Skipping the UDP checksum
cat ext1_v6.expected | cut -c 125- > expout
AT_CHECK([cat ext1_v6.packets | cut -c 125-], [0], [expout])

rm -f ext1_v6.expected
rm -f ext1_v6.packets

as hv1
ovs-vsctl show
reset_pcap_file hv1-ext1 hv1/ext1
reset_pcap_file br-phys_n1 hv1/br-phys_n1
reset_pcap_file br-phys hv1/br-phys

as hv2
ovs-vsctl show
reset_pcap_file hv2-ext2 hv2/ext2
reset_pcap_file br-phys_n1 hv2/br-phys_n1
reset_pcap_file br-phys hv2/br-phys

# From  ls1-lp_ext1, send ARP request for the router ip. The ARP
# response should come from the router pipeline of hv2.
ext1_mac=f00000000003
router_mac=a01000000001
ext1_ip=`ip_to_hex 10 0 0 6`
router_ip=`ip_to_hex 10 0 0 1`
arp_request=ffffffffffff${ext1_mac}08060001080006040001${ext1_mac}${ext1_ip}000000000000${router_ip}

as hv1 ovs-appctl netdev-dummy/receive hv1-ext1 $arp_request
expected_response=${src_mac}${router_mac}08060001080006040002${router_mac}${router_ip}${ext1_mac}${ext1_ip}
echo $expected_response > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ext1-tx.pcap > ext1_arp_resp
AT_CHECK([cat ext1_arp_resp], [0], [expout])

# Verify that the response came from hv2
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap > ext1_arp_resp
AT_CHECK([cat ext1_arp_resp], [0], [expout])

# Now add 3 ha chassis to the ha chassis group
ovn-nbctl ha-chassis-group-add-chassis hagrp1 hv1 30
ovn-nbctl ha-chassis-group-add-chassis hagrp1 hv2 20
ovn-nbctl ha-chassis-group-add-chassis hagrp1 hv3 10

# hv1 should be master and claim ls1-lp_ext1
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv1_uuid
wait_for_ports_up ls1-lp_ext1

as hv1
ovs-vsctl show
reset_pcap_file hv1-ext1 hv1/ext1
reset_pcap_file br-phys_n1 hv1/br-phys_n1
reset_pcap_file br-phys hv1/br-phys

as hv2
ovs-vsctl show
reset_pcap_file hv2-ext2 hv2/ext2
reset_pcap_file br-phys_n1 hv2/br-phys_n1
reset_pcap_file br-phys hv2/br-phys

as hv3
ovs-vsctl show
reset_pcap_file hv3-ext3 hv3/ext3
reset_pcap_file br-phys_n1 hv3/br-phys_n1
reset_pcap_file br-phys hv3/br-phys

# Send DHCPDISCOVER.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
server_mac=ff1000000001
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 1 f00000000003 01 0 $offer_ip 0 $server_mac $server_ip \
$expected_dhcp_opts

# NXT_RESUMEs should be 3 in hv1.
OVS_WAIT_UNTIL([test 3 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ext1-tx.pcap > ext1_v4.packets
cat ext1_v4.expected | cut -c -48 > expout
AT_CHECK([cat ext1_v4.packets | cut -c -48], [0], [expout])
# Skipping the IPv4 checksum.
cat ext1_v4.expected | cut -c 53- > expout
AT_CHECK([cat ext1_v4.packets | cut -c 53-], [0], [expout])

# ovs-ofctl also resumes the packets and this causes other ports to receive
# the DHCP request packet. So reset the pcap files so that its easier to test.
as hv1
reset_pcap_file hv1-ext1 hv1/ext1

rm -f ext1_v4.expected
rm -f ext1_v4.packets

# Send DHCPv6 request
src_mac=f00000000003
src_lla=fe80000000000000f20000fffe000003
offer_ip=ae700000000000000000000000000006
test_dhcpv6 1 $src_mac $src_lla 01 $offer_ip

# NXT_RESUMEs should be 4 in hv1.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ext1-tx.pcap | \
sort > ext1_v6.packets
cat ext1_v6.expected | cut -c -120 > expout
AT_CHECK([cat ext1_v6.packets | cut -c -120], [0], [expout])
# Skipping the UDP checksum
cat ext1_v6.expected | cut -c 125- > expout
AT_CHECK([cat ext1_v6.packets | cut -c 125-], [0], [expout])

rm -f ext1_v6.expected
rm -f ext1_v6.packets
as hv1 reset_pcap_file hv1-ext1 hv1/ext1

# Now increase the priority of hv3 so it becomes master.
ovn-nbctl ha-chassis-group-add-chassis hagrp1 hv3 50

# hv3 should be master and claim ls1-lp_ext1
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv3_uuid
wait_for_ports_up ls1-lp_ext1

as hv1
ovs-vsctl show
reset_pcap_file hv1-ext1 hv1/ext1
reset_pcap_file br-phys_n1 hv1/br-phys_n1
reset_pcap_file br-phys hv1/br-phys

as hv2
ovs-vsctl show
reset_pcap_file hv2-ext2 hv2/ext2
reset_pcap_file br-phys_n1 hv2/br-phys_n1
reset_pcap_file br-phys hv2/br-phys

as hv2
ovs-vsctl show
reset_pcap_file hv3-ext3 hv3/ext3
reset_pcap_file br-phys_n1 hv3/br-phys_n1
reset_pcap_file br-phys hv3/br-phys

# Send DHCPDISCOVER.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
server_mac=ff1000000001
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 1 f00000000003 01 0 $offer_ip 0 $server_mac $server_ip \
$expected_dhcp_opts

# NXT_RESUMEs should be 4 in hv1.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 1 in hv3.
OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor0_hv3.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ext1-tx.pcap > ext1_v4.packets
cat ext1_v4.expected | cut -c -48 > expout
AT_CHECK([cat ext1_v4.packets | cut -c -48], [0], [expout])
# Skipping the IPv4 checksum.
cat ext1_v4.expected | cut -c 53- > expout
AT_CHECK([cat ext1_v4.packets | cut -c 53-], [0], [expout])

# ovs-ofctl also resumes the packets and this causes other ports to receive
# the DHCP request packet. So reset the pcap files so that its easier to test.
as hv1
reset_pcap_file hv1-ext1 hv1/ext1

rm -f ext1_v4.expected
rm -f ext1_v4.packets

# Send DHCPv6 request
src_mac=f00000000003
src_lla=fe80000000000000f20000fffe000003
offer_ip=ae700000000000000000000000000006
test_dhcpv6 1 $src_mac $src_lla 01 $offer_ip

# NXT_RESUMEs should be 4 in hv1.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv3.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv3.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ext1-tx.pcap | \
sort > ext1_v6.packets
cat ext1_v6.expected | cut -c -120 > expout
AT_CHECK([cat ext1_v6.packets | cut -c -120], [0], [expout])
# Skipping the UDP checksum
cat ext1_v6.expected | cut -c 125- > expout
AT_CHECK([cat ext1_v6.packets | cut -c 125-], [0], [expout])

# disconnect hv3 from the network, hv1 should take over
as hv3
port=${sandbox}_br-phys
as main ovs-vsctl del-port n1 $port

# hv1 should be master and claim ls1-lp_ext1
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv1_uuid
wait_for_ports_up ls1-lp_ext1

# There should be a flow in hv2 to drop traffic from ls1-lp_ext1 destined
# to router mac.
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int \
table=30,dl_src=f0:00:00:00:00:03,dl_dst=a0:10:00:00:00:01 | \
grep -c "actions=drop"], [0], [1
])

# Stop ovn-controllers on hv1 and hv3.
as hv1 ovn-appctl -t ovn-controller exit
as hv3 ovn-appctl -t ovn-controller exit

# hv2 should be master and claim ls1-lp_ext1
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv2_uuid
wait_for_ports_up ls1-lp_ext1

as hv1
OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as hv3
OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

OVN_CLEANUP([hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Address Set Incremental Processing])
AT_KEYWORDS([ovn_as_inc])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

ovn-nbctl ls-add ls1
for i in 1 2; do
    ovn-nbctl lsp-add ls1 lp$i \
        -- lsp-set-addresses lp$i "f0:00:00:00:00:0$i 192.168.1.$i"
    as hv1 ovs-vsctl \
        -- add-port br-int vif$i \
        -- set Interface vif$i \
            external-ids:iface-id=lp$i
done

for i in 1 2 3; do
    as1_uuid=`ovn-nbctl --wait=hv create addr name=as1`
    as2_uuid=`ovn-nbctl --wait=hv create addr name=as2`
    ovn-nbctl --wait=hv acl-add ls1 to-lport 200 \
            'outport=="lp1" && ip4 && ip4.src == {$as1, $as2}' allow-related
    ovn-nbctl --wait=hv set addr as1 addresses="10.1.2.10"
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.10"], [0], [ignore])

    # Update address set as1
    ovn-nbctl --wait=hv set addr as1 addresses="10.1.2.10 10.1.2.11"
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.11"], [0], [ignore])

    # Update address set as2
    ovn-nbctl --wait=hv set addr as2 addresses="10.1.2.12 10.1.2.13"
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.12"], [0], [ignore])

    # Add another ACL referencing as1
    n_flows_before=`ovs-ofctl dump-flows br-int | grep "10.1.2.10" | wc -l`
    ovn-nbctl --wait=hv acl-add ls1 to-lport 200 \
            'outport=="lp2" && ip4 && ip4.src == $as1' allow-related
    n_flows_after=`ovs-ofctl dump-flows br-int | grep "10.1.2.10" | wc -l`
    AT_CHECK([test $(expr $n_flows_before \* 2) = $n_flows_after], [0], [ignore])

    # Trigger full recompute. Creating a chassis would trigger full recompute.
    ovn-sbctl chassis-add tst geneve 127.0.0.4
    ovn-sbctl chassis-del tst

    # Remove an ACL
    ovn-nbctl --wait=hv acl-del ls1 to-lport 200 \
            'outport=="lp2" && ip4 && ip4.src == $as1'
    n_flows_after=`ovs-ofctl dump-flows br-int | grep "10.1.2.10" | wc -l`
    AT_CHECK([test $n_flows_before = $n_flows_after], [0], [ignore])

    # Remove as1 while it is still used by an ACL, the lflows should be reparsed and
    # parsing should fail.
    echo "before del as1"
    ovn-nbctl list addr | grep as1
    ovn-nbctl --wait=hv destroy addr $as1_uuid
    echo "after del as1"
    ovn-nbctl list addr | grep as1
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.10"], [1], [ignore])
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.12"], [1], [ignore])

    # Recreate as1
    as1_uuid=`ovn-nbctl --wait=hv create addr name=as1`
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.12"], [0], [ignore])

    # Remove ACLs and address sets
    ovn-nbctl --wait=hv destroy addr $as1_uuid -- destroy addr $as2_uuid
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.12"], [1], [ignore])

    ovn-nbctl --wait=hv acl-del ls1
done

# Gracefully terminate daemons
OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ovn-controller restart])
ovn_start

# Logical network:
# One Logical Router: ro, with two logical switches sw1 and sw2.
# sw1 is for subnet 10.0.0.0/8
# sw2 is for subnet 20.0.0.0/8
# sw1 has a single port bound on hv1
# sw2 has a single port bound on hv2

ovn-nbctl lr-add ro
ovn-nbctl ls-add sw1
ovn-nbctl ls-add sw2

sw1_ro_mac=00:00:10:00:00:01
sw1_ro_ip=10.0.0.1
sw2_ro_mac=00:00:20:00:00:01
sw2_ro_ip=20.0.0.1
sw1_p1_mac=00:00:10:00:00:02
sw1_p1_ip=10.0.0.2
sw2_p1_mac=00:00:20:00:00:02
sw2_p1_ip=20.0.0.2

ovn-nbctl lrp-add ro ro-sw1 $sw1_ro_mac ${sw1_ro_ip}/8
ovn-nbctl lrp-add ro ro-sw2 $sw2_ro_mac ${sw2_ro_ip}/8
ovn-nbctl lsp-add sw1 sw1-ro -- set Logical_Switch_Port sw1-ro type=router \
  options:router-port=ro-sw1 addresses=\"$sw1_ro_mac\"
ovn-nbctl lsp-add sw2 sw2-ro -- set Logical_Switch_Port sw2-ro type=router \
  options:router-port=ro-sw2 addresses=\"$sw2_ro_mac\"

ovn-nbctl lsp-add sw1 sw1-p1 \
-- lsp-set-addresses sw1-p1 "$sw1_p1_mac $sw1_p1_ip"

ovn-nbctl lsp-add sw2 sw2-p1 \
-- lsp-set-addresses sw2-p1 "$sw2_p1_mac $sw2_p1_ip"

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw2-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

packet="inport==\"sw1-p1\" && eth.src==$sw1_p1_mac && eth.dst==$sw1_ro_mac &&
       ip4 && ip.ttl==64 && ip4.src==$sw1_p1_ip && ip4.dst==$sw2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"

# Start by Sending the packet and make sure it makes it there as expected
as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"

# Expected packet has TTL decreased by 1
expected="eth.src==$sw2_ro_mac && eth.dst==$sw2_p1_mac &&
       ip4 && ip.ttl==63 && ip4.src==$sw1_p1_ip && ip4.dst==$sw2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Stop ovn-controller on hv2 with --restart flag
as hv2 ovs-appctl -t ovn-controller exit --restart

# Now send the packet again. This time, it should still arrive
as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"

cat expected expected > expected2

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected2])

# Start ovn-controller again just so OVN_CLEANUP doesn't complain
as hv2 start_daemon ovn-controller

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ovn-nbctl duplicate addresses])
ovn_start

# Set up a switch with some switch ports of varying address types
ovn-nbctl ls-add sw1
ovn-nbctl set logical_switch sw1 other_config:subnet=192.168.0.0/24

ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-add sw1 sw1-p2
ovn-nbctl lsp-add sw1 sw1-p3
ovn-nbctl lsp-add sw1 sw1-p4
ovn-nbctl --wait=sb lsp-add sw1 sw1-p5

check ovn-nbctl --wait=sb lsp-set-addresses sw1-p1 "00:00:00:00:00:01 10.0.0.1 aef0::1" "00:00:00:00:00:02 10.0.0.2 aef0::2"
check ovn-nbctl --wait=sb lsp-set-addresses sw1-p2 "00:00:00:00:00:03 dynamic"
check ovn-nbctl --wait=sb lsp-set-addresses sw1-p3 "dynamic"
check ovn-nbctl --wait=sb lsp-set-addresses sw1-p4 "router"
check ovn-nbctl --wait=sb lsp-set-addresses sw1-p5 "unknown"

ovn-nbctl list logical_switch_port

# Now try to add duplicate addresses on a new port. These should all fail
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 10.0.0.1"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv4 address '10.0.0.1' found on logical switch port 'sw1-p1'
])
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 10.0.0.2"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv4 address '10.0.0.2' found on logical switch port 'sw1-p1'
])
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 aef0::1"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv6 address 'aef0::1' found on logical switch port 'sw1-p1'
])
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 aef0::2"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv6 address 'aef0::2' found on logical switch port 'sw1-p1'
])
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 192.168.0.2"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv4 address '192.168.0.2' found on logical switch port 'sw1-p2'
])
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 192.168.0.3"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv4 address '192.168.0.3' found on logical switch port 'sw1-p3'
])

# Now try re-setting sw1-p1. This should succeed
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p1 "00:00:00:00:00:01 10.0.0.1 aef0::1"])

# Now create a new switch and try setting IP addresses the same as the
# first switch. This should succeed.
ovn-nbctl ls-add sw2
ovn-nbctl lsp-add sw2 sw2-p1

AT_CHECK([ovn-nbctl lsp-set-addresses sw2-p1 "00:00:00:00:00:04 10.0.0.1"])
AT_CHECK([ovn-nbctl lsp-set-addresses sw2-p1 "00:00:00:00:00:04 192.168.0.2"])
AT_CHECK([ovn-nbctl lsp-set-addresses sw2-p1 "00:00:00:00:00:04 192.168.0.3"])
AT_CHECK([ovn-nbctl lsp-set-addresses sw2-p1 "00:00:00:00:00:04 aef0::1"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- router - check packet length - icmp defrag])
AT_KEYWORDS([check packet length])
ovn_start

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-port1
ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 10.0.0.3 1000::3"

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::1/64
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl ls-add public
ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24 2000::1/64
ovn-nbctl lsp-add public public-lr0
ovn-nbctl lsp-set-type public-lr0 router
ovn-nbctl lsp-set-addresses public-lr0 router
ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
ovn-nbctl lsp-add public ln-public
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-options ln-public network_name=phys

ovn-nbctl lrp-set-gateway-chassis lr0-public hv1 20
ovn-nbctl lr-nat-add lr0 snat 172.168.0.100 10.0.0.0/24
ovn-nbctl lr-nat-add lr0 snat 2000::1 1000::/64

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-port1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

reset_pcap_file() {
     local iface=$1
     local pcap_file=$2
     ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
 options:rxq_pcap=dummy-rx.pcap
     rm -f ${pcap_file}*.pcap
     ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
 options:rxq_pcap=${pcap_file}-rx.pcap
}

test_ip_packet_larger() {
    local mtu=$1

    # Send ip packet from sw0-port1 to outside
    src_mac="505400000001" # sw-port1 mac
    dst_mac="00000000ff01" # sw0-lr0 mac (internal router leg)
    src_ip=`ip_to_hex 10 0 0 3`
    dst_ip=`ip_to_hex 172 168 0 3`
    # Set the packet length to 118.
    pkt_len=0076
    packet=${dst_mac}${src_mac}08004500${pkt_len}000000004001c3d9
    orig_packet_l3=${src_ip}${dst_ip}0304000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000

    packet=${packet}${orig_packet_l3}

    gw_ip_garp=ffffffffffff00002020121308060001080006040001000020201213aca80064000000000000aca80064

    packet_bytes=$(expr ${#packet} / 2)
    mtu_needed=$(expr ${packet_bytes} - 18)

    # If icmp_pmtu_reply_expected is 0, it means the packet is lesser than
    # the gateway mtu and should be delivered to the provider bridge via the
    # localnet port.
    # If icmp_pmtu_reply_expected is 1, it means the packet is larger than
    # the gateway mtu and ovn-controller should drop the packet and instead
    # generate ICMPv4  Destination Unreachable message with pmtu set to 100.
    if test $mtu -ge $mtu_needed; then
        # Packet to expect at br-phys.
        src_mac="000020201213"
        dst_mac="00000012af11"
        src_ip=`ip_to_hex 10 0 0 3`
        dst_ip=`ip_to_hex 172 168 0 3`
        expected=${dst_mac}${src_mac}08004500${pkt_len}000000003f01c4d9
        expected=${expected}${src_ip}${dst_ip}0304000000000000
        expected=${expected}000000000000000000000000000000000000
        expected=${expected}000000000000000000000000000000000000
        expected=${expected}000000000000000000000000000000000000
        expected=${expected}000000000000000000000000000000000000
        expected=${expected}000000000000000000000000000000000000
        echo $expected > br_phys_n1.expected
        echo $gw_ip_garp >> br_phys_n1.expected
    else
        src_ip=`ip_to_hex 10 0 0 1`
        dst_ip=`ip_to_hex 10 0 0 3`
        # pkt len should be 146 (28 (icmp packet) + 118 (orig ip + payload))
        reply_pkt_len=0092
        ip_csum=f993
        icmp_reply=${src_mac}${dst_mac}08004500${reply_pkt_len}00004000fe016867
        icmp_reply=${icmp_reply}${src_ip}${dst_ip}0304${ip_csum}0000$(printf "%04x" $mtu)
        icmp_reply=${icmp_reply}4500${pkt_len}000000003f01c4d9
        icmp_reply=${icmp_reply}${orig_packet_l3}
        echo $icmp_reply > hv1-vif1.expected
    fi

    as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
    as hv1 reset_pcap_file hv1-vif1 hv1/vif1

    # Send packet from sw0-port1 to outside
    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

    if test $mtu -ge $mtu_needed; then
        OVN_CHECK_PACKETS([hv1/br-phys_n1-tx.pcap], [br_phys_n1.expected])
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap  > pkts
        # hv1/vif1-tx.pcap can receive the GARP packet generated by ovn-controller
        # for the gateway router port. So ignore this packet.
        cat pkts | grep -v $gw_ip_garp > packets
        AT_CHECK([cat packets], [0], [])
    else
        OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [hv1-vif1.expected])
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys_n1-tx.pcap  > \
        pkts
        # hv1/br-phys_n1-tx.pcap can receive the GARP packet generated by ovn-controller
        # for the gateway router port. So ignore this packet.
        cat pkts | grep -v $gw_ip_garp > packets
        AT_CHECK([cat packets], [0], [])
    fi
}

test_ip6_packet_larger() {
    local mtu=$1

    local eth_src=505400000001
    local eth_dst=00000000ff01

    local ipv6_src=10000000000000000000000000000003
    local ipv6_dst=20000000000000000000000000000002
    local ipv6_rt=10000000000000000000000000000001

    local payload=0000000000000000000000000000000000000000
    local payload=${payload}0000000000000000000000000000000000000000
    local payload=${payload}0000000000000000000000000000000000000000
    local payload=${payload}0000000000000000000000000000000000000000

    local ip6_hdr=6000000000583aff${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}8000ec7662f00001${payload}

    as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
    as hv1 reset_pcap_file hv1-vif1 hv1/vif1

    # Send packet from sw0-port1 to outside
    tcpdump_hex ">> sending packet:" $packet
    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
    AT_CHECK([as hv1 ovs-appctl ofproto/trace br-int in_port=hv1-vif1 $packet > trace-$mtu],
             [0], [ignore])
    AT_CAPTURE_FILE([trace-$mtu])

    packet_bytes=$(expr ${#packet} / 2)
    mtu_needed=$(expr ${packet_bytes} - 18)
    if test $mtu -lt $mtu_needed; then
        # First construct the inner IPv6 packet.
        inner_ip6=6000000000583afe${ipv6_src}${ipv6_dst}
        inner_icmp6=8000000062f00001
        inner_icmp6_and_payload=$(icmp6_csum_inplace ${inner_icmp6}${payload} ${inner_ip6})
        inner_packet=${inner_ip6}${inner_icmp6_and_payload}
        
        # Then the outer.
        outer_ip6=6000000000883afe${ipv6_rt}${ipv6_src}
        outer_icmp6_and_payload=$(icmp6_csum_inplace 020000000000$(printf "%04x" $mtu)${inner_packet} $outer_ip6)
        outer_packet=${outer_ip6}${outer_icmp6_and_payload}

        icmp6_reply=${eth_src}${eth_dst}86dd${outer_packet}

        echo
        tcpdump_hex ">> expecting reply packet" $icmp6_reply

        # The "trace" above sends a second packets as a side effect.
        (echo $icmp6_reply; echo $icmp6_reply) > hv1-vif1.expected

        OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [hv1-vif1.expected])
    fi
}

wait_for_ports_up
ovn-nbctl --wait=hv sync

ovn-nbctl show > nbdump
AT_CAPTURE_FILE([nbdump])

ovn-sbctl show > sbdump
AT_CAPTURE_FILE([sbdump])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int  \
| grep "check_pkt_larger" | wc -l], [0], [[0
]])
dp_uuid=$(ovn-sbctl find datapath_binding | grep sw0 -B2 | grep _uuid | \
awk '{print $3}')
ovn-sbctl create MAC_Binding ip=172.168.0.3 datapath=$dp_uuid \
logical_port=lr0-public mac="00\:00\:00\:12\:af\:11"

# Try different gateway mtus and send a 142-byte packet (corresponding
# to a 124-byte MTU).  If the MTU is less than 124, ovn-controller
# should send icmp host not reachable with pmtu set to $mtu.
for mtu in 100 500 118; do
    AS_BOX([testing mtu $mtu])
    check ovn-nbctl --wait=hv set logical_router_port lr0-public options:gateway_mtu=$mtu
    ovn-sbctl dump-flows > sbflows-$mtu
    AT_CAPTURE_FILE([sbflows-$mtu])

    OVS_WAIT_FOR_OUTPUT([
        as hv1 ovs-ofctl dump-flows br-int > br-int-flows-$mtu
        AT_CAPTURE_FILE([br-int-flows-$mtu])
        grep "check_pkt_larger($(expr $mtu + 18))" br-int-flows-$mtu | wc -l], [0], [1
])

    AS_BOX([testing mtu $mtu - IPv4])
    test_ip_packet_larger $mtu

    AS_BOX([testing mtu $mtu - IPv6])
    test_ip6_packet_larger $mtu
done

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- IP packet buffering])
AT_KEYWORDS([ip-buffering])
ovn_start

# Logical network:
# One LR lr0 that has switches sw0 (192.168.1.0/24) and
# sw1 (172.16.1.0/24) connected to it.
#
# Physical network:
# Tw0 hypervisors hv[12].
# hv1 hosts vif sw0-p0.
# hv2 hosts vif sw1-p0 and sw0-p1

send_icmp_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7 data=$8
    shift 8

    local ip_ttl=ff
    local ip_len=001c
    local packet=${eth_dst}${eth_src}08004500${ip_len}00004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}${data}
    as hv$hv ovs-appctl netdev-dummy/receive hv$hv-vif$inport $packet
}

send_icmp6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6 ipv6_router=$7 exp_icmp_chksum=$8
    shift 8

    local ip6_hdr=6000000000083aff${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}8000dcb662f00001

    as hv$hv ovs-appctl netdev-dummy/receive hv$hv-vif$inport $packet
}

get_arp_req() {
    local eth_src=$1 spa=$2 tpa=$3
    local request=ffffffffffff${eth_src}08060001080006040001${eth_src}${spa}000000000000${tpa}
    echo $request
}

send_arp_reply() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040002${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

send_na() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 src_ip=$5 dst_ip=$6
    local ip6_hdr=6000000000203aff${src_ip}${dst_ip}
    local request=${eth_dst}${eth_src}86dd${ip6_hdr}8800d78440000000${src_ip}0201${eth_src}

    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

get_nd() {
    local eth_src=$1 src_ip=$2 dst_ip=$3 ta=$4
    local ip6_hdr=6000000000203aff${src_ip}${dst_ip}
    request=3333ff000010${eth_src}86dd${ip6_hdr}870051f400000000${ta}0101${eth_src}

    echo $request
}

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p0 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p0 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=2
ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=3

ovn-nbctl create Logical_Router name=lr0
ovn-nbctl ls-add sw0
ovn-nbctl ls-add sw1

ovn-nbctl lrp-add lr0 sw0 00:00:01:01:02:03 192.168.1.1/24 2001:0:0:0:0:0:0:1/64
ovn-nbctl lsp-add sw0 rp-sw0 -- set Logical_Switch_Port rp-sw0 \
    type=router options:router-port=sw0 \
    -- lsp-set-addresses rp-sw0 router

ovn-nbctl lrp-add lr0 sw1 00:00:02:01:02:03 172.16.1.1/24 2002:0:0:0:0:0:0:1/64 \
    -- lrp-set-gateway-chassis sw1 hv2
ovn-nbctl lsp-add sw1 rp-sw1 -- set Logical_Switch_Port rp-sw1 \
    type=router options:router-port=sw1 \
    -- lsp-set-addresses rp-sw1 router

ovn-nbctl lsp-add sw0 sw0-p0 \
    -- lsp-set-addresses sw0-p0 "f0:00:00:01:02:03 192.168.1.2 2001::2"

ovn-nbctl lsp-add sw0 sw0-p1 \
    -- lsp-set-addresses sw0-p1 "f0:00:00:11:02:03 192.168.1.3 2001::3"

ovn-nbctl lsp-add sw1 sw1-p0 \
    -- lsp-set-addresses sw1-p0 unknown

ovn-nbctl lr-nat-add lr0 snat 172.16.1.1 192.168.1.0/24
ovn-nbctl lr-nat-add lr0 snat 2002::1 2001::/64

OVN_POPULATE_ARP
wait_for_ports_up
ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

src_mac=f00000010203
src_ip=$(ip_to_hex 192 168 1 2)
src_ip6=20010000000000000000000000000002

router_mac0=000001010203
router_mac1=000002010203
router_ip=$(ip_to_hex 172 16 1 1)
router_ip6=20020000000000000000000000000001

nd_src_ip6=fe80000000000000020002fffe010203

dst_mac=001122334455
dst_ip=$(ip_to_hex 172 16 1 10)
dst_ip6=20020000000000000000000000000010

data=0800bee4391a0001

send_icmp_packet 1 1 $src_mac $router_mac0 $src_ip $dst_ip 0d1c $data
send_arp_reply 2 1 $dst_mac $router_mac1 $dst_ip $router_ip
echo $(get_arp_req $router_mac1 $router_ip $dst_ip) > expected
echo "${dst_mac}${router_mac1}08004500001c00004000fe0122b5${router_ip}${dst_ip}${data}" >> expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

nd_ip=ff0200000000000000000001ff000010
ip6_hdr=6000000000083afe${router_ip6}${dst_ip6}

send_icmp6_packet 1 1 $src_mac $router_mac0 $src_ip6 $dst_ip6
echo $(get_nd $router_mac1 $nd_src_ip6 $nd_ip $dst_ip6) >> expected
echo "${dst_mac}${router_mac1}86dd${ip6_hdr}8000dcb662f00001" >> expected
send_na 2 1 $dst_mac $router_mac1 $dst_ip6 $router_ip6

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Create FIP on sw0-p0, add a route on logical router pipeline and
# ARP request for a unkwon destination is sent using FIP MAC/IP
ovn-nbctl lr-nat-del lr0 snat
ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.16.1.2 192.168.1.3 sw0-p1 f0:00:00:01:02:04
ovn-nbctl lr-route-add lr0 172.16.2.0/24 172.16.1.11
ovn-nbctl --wait=hv sync
ovn-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

# create a route policy for pkt marking
check ovn-nbctl lr-policy-add lr0 2000 "ip4.src == 192.168.1.3" allow
policy=$(fetch_column nb:Logical_Router_Policy _uuid priority=2000)
check ovn-nbctl set logical_router_policy $policy options:pkt_mark=100
as hv2
# add a flow in egress pipeline to check pkt marking
ovs-ofctl --protocols=OpenFlow13 add-flow br-int "table=37,priority=200,ip,nw_src=172.16.1.2,pkt_mark=0x64 actions=resubmit(,38)"

dst_ip=$(ip_to_hex 172 16 2 10)
fip_ip=$(ip_to_hex 172 16 1 2)
src_ip=$(ip_to_hex 192 168 1 3)
gw_router_ip=$(ip_to_hex 172 16 1 11)
gw_router_mac=f00000010a0a
send_icmp_packet 2 2 f00000110203 $router_mac0 $src_ip $dst_ip 0c1b $data
echo $(get_arp_req f00000010204 $fip_ip $gw_router_ip) >> expected
send_arp_reply 2 1 $gw_router_mac f00000010204 $gw_router_ip $fip_ip
echo "${gw_router_mac}f0000001020408004500001c00004000fe0121b4${fip_ip}${dst_ip}${data}" >> expected

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=37 | grep pkt_mark=0x64 | grep -q n_packets=1],[0])

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- neighbor update on same HV])
ovn_start

# Logical network:
# A public switch (pub) with a localnet port connected to two LRs (lr0 and lr1)
# each with a distributed gateway port.
# Two VMs: lp0 on sw0 connected to lr0
#          lp1 on sw1 connected to lr1
#
# This test adds a floating IP to each VM so when they are bound to the same
# hypervisor, it checks that the GARP sent by ovn-controller causes the
# MAC_Binding entries to be updated properly on each logical router.
# It will also capture packets on the physical interface to make sure that the
# GARPs have been sent out to the external network as well.

# Create logical switches
check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add pub

# Created localnet port on public switch
check ovn-nbctl lsp-add pub ln-pub
check ovn-nbctl lsp-set-type ln-pub localnet
check ovn-nbctl lsp-set-addresses ln-pub unknown
check ovn-nbctl lsp-set-options ln-pub network_name=phys

# Create logical routers and connect them to public switch
AT_CHECK([(ovn-nbctl create Logical_Router name=lr0;
           ovn-nbctl create Logical_Router name=lr1) | uuidfilt], [0], [<0>
<1>
])

check ovn-nbctl lrp-add lr0 lr0-pub f0:00:00:00:00:01 172.24.4.220/24
check ovn-nbctl lsp-add pub pub-lr0 -- set Logical_Switch_Port pub-lr0 \
    type=router options:router-port=lr0-pub options:nat-addresses="router" addresses="router"
check ovn-nbctl lrp-add lr1 lr1-pub f0:00:00:00:01:01 172.24.4.221/24
check ovn-nbctl lsp-add pub pub-lr1 -- set Logical_Switch_Port pub-lr1 \
    type=router options:router-port=lr1-pub options:nat-addresses="router" addresses="router"

check ovn-nbctl lrp-set-gateway-chassis lr0-pub hv1 10
check ovn-nbctl lrp-set-gateway-chassis lr1-pub hv1 10

# Connect sw0 and sw1 to lr0 and lr1
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.254/24
check ovn-nbctl lsp-add sw0 sw0-lr0 -- set Logical_Switch_Port sw0-lr0 type=router \
    options:router-port=lr0-sw0 addresses="router"
check ovn-nbctl lrp-add lr1 lr1-sw1 00:00:00:00:ff:02 20.0.0.254/24
check ovn-nbctl lsp-add sw1 sw1-lr1 -- set Logical_Switch_Port sw1-lr1 type=router \
    options:router-port=lr1-sw1 addresses="router"


# Add SNAT rules
check ovn-nbctl lr-nat-add lr0 snat 172.24.4.220 10.0.0.0/24
check ovn-nbctl lr-nat-add lr1 snat 172.24.4.221 20.0.0.0/24

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 172.24.4.1
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

check ovs-vsctl add-port br-int vif0 -- set Interface vif0 external-ids:iface-id=lp0
check ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1

check ovn-nbctl lsp-add sw0 lp0
check ovn-nbctl lsp-add sw1 lp1
check ovn-nbctl lsp-set-addresses lp0 "50:54:00:00:00:01 10.0.0.10"
check ovn-nbctl lsp-set-addresses lp1 "50:54:00:00:00:02 20.0.0.10"

OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp0` = xup])
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp1` = xup])

# Create two floating IPs, one for each VIF
check ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.24.4.100 10.0.0.10
check ovn-nbctl lr-nat-add lr1 dnat_and_snat 172.24.4.200 20.0.0.10

# Check that the MAC_Binding entries have been properly created
wait_row_count MAC_Binding 1 logical_port=lr0-pub ip=172.24.4.200
wait_row_count MAC_Binding 1 logical_port=lr1-pub ip=172.24.4.100

# Check that the GARPs went also to the external physical network
# Wait until at least 4 packets have arrived and copy them to a separate file as
# more GARPs are expected in the capture in order to avoid race conditions.
#
# The expected output is:
# GARP for lp0 172.24.4.100 on lr0-pub MAC (f0:00:00:00:00:01)
# GARP for 172.24.4.220 on lr0-pub (f0:00:00:00:00:01)
#GARP for lp1 172.24.4.200 on lr1-pub MAC (f0:00:00:00:01:01)
# GARP for 172.24.4.221 on lr1-pub (f0:00:00:00:01:01)

OVS_WAIT_FOR_OUTPUT(
  [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys-tx.pcap | sort | uniq],
  [0],
  [fffffffffffff0000000000108060001080006040001f00000000001ac180464000000000000ac180464
fffffffffffff0000000000108060001080006040001f00000000001ac1804dc000000000000ac1804dc
fffffffffffff0000000010108060001080006040001f00000000101ac1804c8000000000000ac1804c8
fffffffffffff0000000010108060001080006040001f00000000101ac1804dd000000000000ac1804dd
])

# Now make sure that always_learn_from_arp_request=false is also honored
# for locally injected mac bindings.
check ovn-nbctl set logical_router lr0 options:always_learn_from_arp_request=false
check ovn-nbctl set logical_router lr1 options:always_learn_from_arp_request=false
check ovn-nbctl --wait=hv sync

# Recreate two floating IPs, one for each VIF.
check ovn-nbctl lr-nat-del lr0 dnat_and_snat 172.24.4.100
check ovn-nbctl lr-nat-del lr1 dnat_and_snat 172.24.4.200

check ovn-sbctl --all destroy mac_binding

# Create a mac_binding entry on lr0-pub for 172.24.4.200 with a
# wrong mac, expecting it to be updated with the real mac.
lr0_dp=$(fetch_column Datapath_Binding _uuid external_ids:name=lr0)
ovn-sbctl create mac_binding datapath=$lr0_dp logical_port=lr0-pub \
    ip=172.24.4.200 mac=\"aa:aa:aa:aa:aa:aa\"

check ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.24.4.100 10.0.0.10
check ovn-nbctl lr-nat-add lr1 dnat_and_snat 172.24.4.200 20.0.0.10
check ovn-nbctl --wait=hv sync

check_row_count MAC_Binding 1 logical_port=lr0-pub ip=172.24.4.200
check_row_count MAC_Binding 0 logical_port=lr1-pub ip=172.24.4.100
check_column "f0:00:00:00:01:01" MAC_Binding mac logical_port=lr0-pub \
                                                 ip=172.24.4.200

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ipam to non-ipam])
ovn_start

ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="0a:00:00:00:00:00"
ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 p0 -- lsp-set-addresses p0 dynamic
ovn-nbctl --wait=sb add Logical-Switch sw0 other_config subnet=192.168.1.0/24

AT_CHECK([ovn-nbctl get Logical-Switch-Port p0 dynamic_addresses], [0],
    ["0a:00:00:a8:01:03 192.168.1.2"
])

ovn-nbctl --wait=sb lsp-set-addresses p0 router

ovn-nbctl get Logical-Switch-Port p0 dynamic_addresses

AT_CHECK([ovn-nbctl get Logical-Switch-Port p0 dynamic_addresses], [0], [[[]]
])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ipam router ports])
ovn_start

ovn-nbctl ls-add sw
ovn-nbctl set logical_switch sw other-config:subnet=192.168.1.0/24

for i in 2 3 4; do
    ovn-nbctl lr-add ro$i
    ovn-nbctl lsp-add sw swp$i
    ovn-nbctl --wait=sb lsp-set-addresses swp$i "02:00:00:00:00:0$i dynamic"
    cidr=$(ovn-nbctl get logical_switch_port swp$i dynamic_addresses |cut -f2 -d' '|cut -f1 -d\")
    ovn-nbctl lrp-add ro$i rop$i 02:00:00:00:00:0$i $cidr/24 -- set logical_switch_port swp$i type=router options:router-port=rop$i addresses=router;
    AT_CHECK_UNQUOTED([ovn-nbctl get logical_router_port rop$i networks], [0], [[["192.168.1.$i/24"]]
])
done

ovn-nbctl list logical_switch_port
ovn-nbctl list logical_router_port

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- test transport zones])
ovn_start

net_add n1
for i in 1 2 3 4 5; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.$i.1
done

dnl Wait for the changes to be propagated
wait_for_ports_up
check ovn-nbctl --wait=hv sync

dnl Assert that each Chassis has a tunnel formed to every other Chassis
as hv1
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv2-0
ovn-hv3-0
ovn-hv4-0
ovn-hv5-0
]])

as hv2
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv3-0
ovn-hv4-0
ovn-hv5-0
]])

as hv3
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv4-0
ovn-hv5-0
]])

as hv4
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv3-0
ovn-hv5-0
]])

as hv5
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv3-0
ovn-hv4-0
]])

dnl Let's now add some Chassis to different transport zones
dnl * hv1: Will be part of two transport zones: tz1 and tz2 so it
dnl   should have tunnels formed between the other two Chassis (hv2 and hv3)
dnl
dnl * hv2: Will be part of one transport zone: tz1. It should have a tunnel
dnl   to hv1 but not to hv3
dnl
dnl * hv3: Will be part of one transport zone: tz2. It should have a tunnel
dnl   to hv1 but not to hv2
dnl
dnl * hv4 and hv5: Will not have any TZ set so they will keep the tunnels
dnl   between themselves and remove the tunnels to other Chassis which now
dnl   belongs to some TZs
dnl
as hv1
ovs-vsctl set open . external-ids:ovn-transport-zones=tz1,tz2

as hv2
ovs-vsctl set open . external-ids:ovn-transport-zones=tz1

as hv3
ovs-vsctl set open . external-ids:ovn-transport-zones=tz2

dnl Wait for the changes to be propagated
check ovn-nbctl --wait=hv sync

as hv1
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv2-0
ovn-hv3-0
]])

as hv2
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
]])

as hv3
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
]])

as hv4
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv5-0
]])

as hv5
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv4-0
]])

dnl Removing the transport zones should make all Chassis to create
dnl tunnels between every other Chassis again
for i in 1 2 3; do
    as hv$i
    ovs-vsctl remove open . external-ids ovn-transport-zones
done

dnl Wait for the changes to be propagated
check ovn-nbctl --wait=hv sync

as hv1
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv2-0
ovn-hv3-0
ovn-hv4-0
ovn-hv5-0
]])

as hv2
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv3-0
ovn-hv4-0
ovn-hv5-0
]])

as hv3
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv4-0
ovn-hv5-0
]])

as hv4
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv3-0
ovn-hv5-0
]])

as hv5
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv3-0
ovn-hv4-0
]])

OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 2 HVs, 2 lports/HV, localnet ports, DVR chassis mac])
ovn_start


# In this test cases we create 2 switches, all connected to same
# physical network (through br-phys on each HV). Each switch has
# 1 VIF. Each HV has 1 VIF port. The first digit
# of VIF port name indicates the hypervisor it is bound to, e.g.
# lp23 means VIF 3 on hv2.
#
# Each switch's VLAN tag and their logical switch ports are:
#   - ls1:
#       - tagged with VLAN 101
#       - ports: lp11
#   - ls2:
#       - tagged with VLAN 201
#       - ports: lp22
#
# Note: a localnet port is created for each switch to connect to
# physical network.

for i in 1 2; do
    ls_name=ls$i
    ovn-nbctl ls-add $ls_name
    ln_port_name=ln$i
    if test $i -eq 1; then
        ovn-nbctl lsp-add $ls_name $ln_port_name "" 101
    elif test $i -eq 2; then
        ovn-nbctl lsp-add $ls_name $ln_port_name "" 201
    fi
    ovn-nbctl lsp-set-addresses $ln_port_name unknown
    ovn-nbctl lsp-set-type $ln_port_name localnet
    ovn-nbctl lsp-set-options $ln_port_name network_name=phys
done

# lsp_to_ls LSP
#
# Prints the name of the logical switch that contains LSP.
lsp_to_ls () {
    case $1 in dnl (
        lp?[[11]]) echo ls1 ;; dnl (
        lp?[[12]]) echo ls2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_ls () {
    case $1 in dnl (
        vif?[[11]]) echo ls1 ;; dnl (
        vif?[[12]]) echo ls2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

hv_to_num () {
    case $1 in dnl (
        hv1) echo 1 ;; dnl (
        hv2) echo 2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_num () {
    case $1 in dnl (
        vif22) echo 22 ;; dnl (
        vif21) echo 21 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_hv () {
    case $1 in dnl (
        vif[[1]]?) echo hv1 ;; dnl (
        vif[[2]]?) echo hv2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_lrp () {
    echo router-to-`vif_to_ls $1`
}

hv_to_chassis_mac () {
     case $1 in dnl (
        hv[[1]]) echo aa:bb:cc:dd:ee:11 ;; dnl (
        hv[[2]]) echo aa:bb:cc:dd:ee:22 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

lrp_to_lrp_mac () {
     case $1 in dnl (
        router-to-ls[[1]]) echo 000001010203 ;; dnl (
        router-to-ls[[2]]) echo 000001010205 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:$i$i"
    ovn_attach n1 br-phys 192.168.0.$i

    ovs-vsctl add-port br-int vif$i$i -- \
        set Interface vif$i$i external-ids:iface-id=lp$i$i \
                              options:tx_pcap=hv$i/vif$i$i-tx.pcap \
                              options:rxq_pcap=hv$i/vif$i$i-rx.pcap \
                              ofport-request=$i$i

    lsp_name=lp$i$i
    ls_name=$(lsp_to_ls $lsp_name)

    ovn-nbctl lsp-add $ls_name $lsp_name
    ovn-nbctl lsp-set-addresses $lsp_name "f0:00:00:00:00:$i$i 192.168.$i.$i"
    ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:$i$i

    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])

done

ovn-nbctl lr-add router
ovn-nbctl lrp-add router router-to-ls1 00:00:01:01:02:03 192.168.1.3/24
ovn-nbctl lrp-add router router-to-ls2 00:00:01:01:02:05 192.168.2.3/24

ovn-nbctl lsp-add ls1 ls1-to-router -- set Logical_Switch_Port ls1-to-router type=router options:router-port=router-to-ls1 -- lsp-set-addresses ls1-to-router router
ovn-nbctl lsp-add ls2 ls2-to-router -- set Logical_Switch_Port ls2-to-router type=router options:router-port=router-to-ls2 -- lsp-set-addresses ls2-to-router router

wait_for_ports_up
ovn-nbctl --wait=sb sync
#ovn-sbctl dump-flows

ovn-nbctl show
ovn-sbctl show

OVN_POPULATE_ARP

test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    hv_num=`hv_to_num $hv`
    chassis_mac=`hv_to_chassis_mac $hv`
    as $hv ovs-appctl netdev-dummy/receive $inport $packet
    #as $hv ovs-appctl ofproto/trace br-int in_port=$inport $packet
    in_ls=`vif_to_ls $inport`
    in_lrp=`vif_to_lrp $inport`
    for outport; do
        out_ls=`vif_to_ls $outport`
        if test $in_ls = $out_ls; then
            # Ports on the same logical switch receive exactly the same packet.
            echo $packet
        else
            # Routing decrements TTL and updates source and dest MAC
            # (and checksum).
            outport_num=`vif_to_num $outport`
            out_lrp=`vif_to_lrp $outport`
            lrp_mac=`lrp_to_lrp_mac $out_lrp`
            echo f000000000${outport_num}${lrp_mac}08004500001c00000000"3f1101"00${src_ip}${dst_ip}0035111100080000

        fi >> $outport.expected
    done
}

# Dump a bunch of info helpful for debugging if there's a failure.

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-vsctl list Open_Vswitch

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-vsctl list Open_Vswitch

echo "Send traffic"
sip=`ip_to_hex 192 168 1 1`
dip=`ip_to_hex 192 168 2 2`
test_ip vif11 f00000000011  000001010203 $sip $dip vif22

echo "----------- Post Traffic hv1 dump -----------"
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int
as hv1 ovs-appctl fdb/show br-phys

echo "----------- Post Traffic hv2 dump -----------"
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int
as hv2 ovs-appctl fdb/show br-phys

OVN_CHECK_PACKETS([hv2/vif22-tx.pcap], [vif22.expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- virtual ports])
AT_KEYWORDS([virtual ports])
ovn_start

send_garp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

send_arp_reply() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040002${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p3 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2
ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=2

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-vir
ovn-nbctl lsp-set-addresses sw0-vir "50:54:00:00:00:10 10.0.0.10"
ovn-nbctl lsp-set-port-security sw0-vir "50:54:00:00:00:10 10.0.0.10"
ovn-nbctl lsp-set-type sw0-vir virtual
ovn-nbctl set logical_switch_port sw0-vir options:virtual-ip=10.0.0.10
ovn-nbctl set logical_switch_port sw0-vir options:virtual-parents=sw0-p1,sw0-p2,sw0-p3

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3 10.0.0.10"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4 10.0.0.10"

ovn-nbctl lsp-add sw0 sw0-p3
ovn-nbctl lsp-set-addresses sw0-p3 "50:54:00:00:00:05 10.0.0.5"
ovn-nbctl lsp-set-port-security sw0-p3 "50:54:00:00:00:05 10.0.0.5 10.0.0.10"

# Create the second logical switch with one port
ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create a logical router and attach both logical switches
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

OVN_POPULATE_ARP

# Delete sw0-vir and add again.
ovn-nbctl lsp-del sw0-vir

ovn-nbctl lsp-add sw0 sw0-vir
ovn-nbctl lsp-set-addresses sw0-vir "50:54:00:00:00:10 10.0.0.10"
ovn-nbctl lsp-set-port-security sw0-vir "50:54:00:00:00:10 10.0.0.10"
ovn-nbctl lsp-set-type sw0-vir virtual
ovn-nbctl set logical_switch_port sw0-vir options:virtual-ip=10.0.0.10
ovn-nbctl set logical_switch_port sw0-vir options:virtual-parents=sw0-p1,sw0-p2,sw0-p3

wait_for_ports_up
ovn-nbctl --wait=hv sync

# Check that logical flows are added for sw0-vir in lsp_in_arp_rsp pipeline
# with bind_vport action.

ovn-sbctl dump-flows sw0 > sw0-flows
AT_CAPTURE_FILE([sw0-flows])

AT_CHECK([grep ls_in_arp_rsp sw0-flows | grep bind_vport | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p1" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p2" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p3" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
])

ovn-sbctl dump-flows lr0 > lr0-flows
AT_CAPTURE_FILE([lr0-flows])

# Since the sw0-vir is not claimed by any chassis, eth.dst should be set to
# zero if the ip4.dst is the virtual ip in the router pipeline.
AT_CHECK([grep lr_in_arp_resolve lr0-flows | grep "reg0 == 10.0.0.10" | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_arp_resolve  ), priority=100  , match=(outport == "lr0-sw0" && reg0 == 10.0.0.10), action=(eth.dst = 00:00:00:00:00:00; next;)
])

hv1_ch_uuid=`ovn-sbctl --bare --columns _uuid find chassis name="hv1"`
hv2_ch_uuid=`ovn-sbctl --bare --columns _uuid find chassis name="hv2"`

AT_CHECK([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x], [0], [])

AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = x])

# Try to bind sw0-vir directly to an OVS port. This should be ignored by
# ovn-controller.
as hv1
ovs-vsctl set interface hv1-vif3 external-ids:iface-id=sw0-vir

AT_CHECK([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x], [0], [])

# Cleanup hv1-vif3.
as hv1
ovs-vsctl del-port hv1-vif3

AT_CHECK([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x], [0], [])

# From sw0-p0 send GARP for 10.0.0.10. hv1 should claim sw0-vir
# and sw0-p1 should be its virtual_parent.
eth_src=505400000003
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 10)
send_garp 1 1 $eth_src $eth_dst $spa $tpa

wait_row_count Port_Binding 1 logical_port=sw0-vir chassis=$hv1_ch_uuid
check_row_count Port_Binding 1 logical_port=sw0-vir virtual_parent=sw0-p1
wait_for_ports_up sw0-vir
check ovn-nbctl --wait=hv sync

# There should be an arp resolve flow to resolve the virtual_ip with the
# sw0-p1's MAC.
ovn-sbctl dump-flows lr0 > lr0-flows2
AT_CAPTURE_FILE([lr0-flows2])
AT_CHECK([grep lr_in_arp_resolve lr0-flows2 | grep "reg0 == 10.0.0.10" | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_arp_resolve  ), priority=100  , match=(outport == "lr0-sw0" && reg0 == 10.0.0.10), action=(eth.dst = 50:54:00:00:00:03; next;)
])

# Forcibly clear virtual_parent. ovn-controller should release the binding
# gracefully.
pb_uuid=$(ovn-sbctl --bare --columns _uuid find port_binding logical_port=sw0-vir)
ovn-sbctl clear port_binding $pb_uuid virtual_parent

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x])

wait_row_count nb:Logical_Switch_Port 1 up=false name=sw0-vir

# From sw0-p0 resend GARP for 10.0.0.10. hv1 should reclaim sw0-vir
# and sw0-p1 should be its virtual_parent.
send_garp 1 1 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x$hv1_ch_uuid], [0], [])

AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = xsw0-p1])

wait_for_ports_up sw0-vir

# From sw0-p3 send GARP for 10.0.0.10. hv1 should claim sw0-vir
# and sw0-p3 should be its virtual_parent.
eth_src=505400000005
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 10)
send_garp 1 2 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x$hv1_ch_uuid], [0], [])

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = xsw0-p3])

wait_for_ports_up sw0-vir

# There should be an arp resolve flow to resolve the virtual_ip with the
# sw0-p2's MAC.
sleep 1
ovn-sbctl dump-flows lr0 > lr0-flows3
AT_CAPTURE_FILE([lr0-flows3])
cp ovn-sb/ovn-sb.db lr0-flows3.db
AT_CHECK([grep lr_in_arp_resolve lr0-flows3 | grep "reg0 == 10.0.0.10"  | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_arp_resolve  ), priority=100  , match=(outport == "lr0-sw0" && reg0 == 10.0.0.10), action=(eth.dst = 50:54:00:00:00:05; next;)
])

# send the garp from sw0-p2 (in hv2). hv2 should claim sw0-vir
# and sw0-p2 shpuld be its virtual_parent.
eth_src=505400000004
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 10)
send_garp 2 1 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x$hv2_ch_uuid], [0], [])

AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = xsw0-p2])

wait_for_ports_up sw0-vir

# There should be an arp resolve flow to resolve the virtual_ip with the
# sw0-p3's MAC.
sleep 1
ovn-sbctl dump-flows lr0 > lr0-flows4
AT_CAPTURE_FILE([lr0-flows4])
AT_CHECK([grep lr_in_arp_resolve lr0-flows4 | grep "reg0 == 10.0.0.10" | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_arp_resolve  ), priority=100  , match=(outport == "lr0-sw0" && reg0 == 10.0.0.10), action=(eth.dst = 50:54:00:00:00:04; next;)
])

# Now send arp reply from sw0-p1. hv1 should claim sw0-vir
# and sw0-p1 shpuld be its virtual_parent.
eth_src=505400000003
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 4)
send_arp_reply 1 1 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x$hv1_ch_uuid], [0], [])
sleep 1

AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = xsw0-p1])

wait_for_ports_up sw0-vir

ovn-sbctl dump-flows lr0 > lr0-flows5
AT_CAPTURE_FILE([lr0-flows5])
AT_CHECK([grep lr_in_arp_resolve lr0-flows5 | grep "reg0 == 10.0.0.10" | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_arp_resolve  ), priority=100  , match=(outport == "lr0-sw0" && reg0 == 10.0.0.10), action=(eth.dst = 50:54:00:00:00:03; next;)
])

# Delete hv1-vif1 port. hv1 should release sw0-vir
as hv1 ovs-vsctl del-port hv1-vif1

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x], [0], [])
sleep 1

AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = x])

wait_row_count nb:Logical_Switch_Port 1 up=false name=sw0-vir

# Since the sw0-vir is not claimed by any chassis, eth.dst should be set to
# zero if the ip4.dst is the virtual ip.
ovn-sbctl dump-flows lr0 > lr0-flows6
AT_CAPTURE_FILE([lr0-flows6])
AT_CHECK([grep lr_in_arp_resolve lr0-flows6 | grep "reg0 == 10.0.0.10" | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_arp_resolve  ), priority=100  , match=(outport == "lr0-sw0" && reg0 == 10.0.0.10), action=(eth.dst = 00:00:00:00:00:00; next;)
])

# Now send arp reply from sw0-p2. hv2 should claim sw0-vir
# and sw0-p2 should be its virtual_parent.
eth_src=505400000004
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 3)
send_arp_reply 2 1 $eth_src $eth_dst $spa $tpa
sleep 1

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x$hv2_ch_uuid], [0], [])
sleep 1
AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = xsw0-p2])

wait_for_ports_up sw0-vir

ovn-sbctl dump-flows lr0 > lr0-flows7
AT_CAPTURE_FILE([lr0-flows7])
AT_CHECK([grep lr_in_arp_resolve lr0-flows7 | grep "reg0 == 10.0.0.10" | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_arp_resolve  ), priority=100  , match=(outport == "lr0-sw0" && reg0 == 10.0.0.10), action=(eth.dst = 50:54:00:00:00:04; next;)
])

# Delete sw0-p2 logical port
ovn-nbctl lsp-del sw0-p2

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x], [0], [])
AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = x])

wait_row_count nb:Logical_Switch_Port 1 up=false name=sw0-vir

# Clear virtual_ip column of sw0-vir. There should be no bind_vport flows.
ovn-nbctl --wait=hv remove logical_switch_port sw0-vir options virtual-ip

ovn-sbctl dump-flows sw0 > sw0-flows2
AT_CAPTURE_FILE([sw0-flows2])
AT_CHECK([grep ls_in_arp_rsp sw0-flows2 | grep bind_vport], [1])

# Add back virtual_ip and clear virtual_parents.
ovn-nbctl --wait=hv set logical_switch_port sw0-vir options:virtual-ip=10.0.0.10

ovn-sbctl dump-flows sw0 > sw0-flows3
AT_CAPTURE_FILE([sw0-flows3])
AT_CHECK([grep ls_in_arp_rsp sw0-flows3 | grep bind_vport | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p1" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p3" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
])

ovn-nbctl --wait=hv remove logical_switch_port sw0-vir options virtual-parents
ovn-sbctl dump-flows sw0 > sw0-flows4
AT_CAPTURE_FILE([sw0-flows4])
AT_CHECK([grep ls_in_arp_rsp sw0-flows4 | grep bind_vport], [1])

ovn-sbctl dump-flows lr0 > lr0-flows8
AT_CAPTURE_FILE([lr0-flows8])
AT_CHECK([grep lr_in_arp_resolve lr0-flows8 | grep "reg0 == 10.0.0.10"], [1])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# Run ovn-nbctl in daemon mode, change to a backup database and verify that
# an insert operation is not allowed.
AT_SETUP([ovn -- can't write to a backup database server instance])
ovn_start
on_exit 'kill $(cat ovn-nbctl.pid)'
export OVN_NB_DAEMON=$(ovn-nbctl --pidfile --detach)

AT_CHECK([ovn-nbctl ls-add sw0])
as ovn-nb
AT_CHECK([ovs-appctl -t ovsdb-server ovsdb-server/sync-status | grep active | wc -l], [0], [1
])
ovs-appctl -t ovsdb-server ovsdb-server/set-active-ovsdb-server tcp:192.0.2.2:6641
ovs-appctl -t ovsdb-server ovsdb-server/connect-active-ovsdb-server
AT_CHECK([ovs-appctl -t ovsdb-server ovsdb-server/sync-status | grep -c backup], [0], [1
])
AT_CHECK([ovn-nbctl ls-add sw1], [1], [ignore],
[ovn-nbctl: transaction error: {"details":"insert operation not allowed when database server is in read only mode","error":"not allowed"}
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- controller event])
AT_KEYWORDS([ovn_controller_event])
ovn_start

# Create hypervisors hv[12].
# Add vif1[12] to hv1, vif2[12] to hv2
# Add all of the vifs to a single logical switch sw0.
# Create logical router lr0

net_add n1

ovn-nbctl create Logical_Router name=lr0 options:chassis=hv1
for i in 0 1; do
    idx=$((i+1))
    ovn-nbctl ls-add sw$i
    ovn-nbctl lrp-add lr0 lrp$i 00:00:00:00:ff:0$idx 192.168.$idx.254/24 200$idx::a/64
    ovn-nbctl \
        -- lsp-add sw$i lrp$i-attachment \
        -- set Logical_Switch_Port lrp$i-attachment type=router \
                         options:router-port=lrp$i \
                         addresses='"00:00:00:00:ff:'0$idx'"'
done

for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2; do
        ovn-nbctl lsp-add sw0 sw0-p$i$j -- \
                lsp-set-addresses sw0-p$i$j "00:00:00:00:00:$i$j 192.168.1.$i$j 2001::$i$j"

        ovs-vsctl -- add-port br-int vif$i$j -- \
                set interface vif$i$j \
                external-ids:iface-id=sw0-p$i$j \
                options:tx_pcap=hv$i/vif$i$j-tx.pcap \
                options:rxq_pcap=hv$i/vif$i$j-rx.pcap \
                ofport-request=$i$j
    done
done

as hv1
ovn-nbctl lsp-add sw1 sw1-p0 \
    -- lsp-set-addresses sw1-p0 "00:00:00:00:00:33 192.168.2.11 2002::1"
ovs-vsctl -- add-port br-int vif33 -- \
        set interface vif33 \
        external-ids:iface-id=sw1-p0 \
        options:tx_pcap=hv$i/vif33-tx.pcap \
        options:rxq_pcap=hv$i/vif33-rx.pcap \
        ofport-request=33

ovn-nbctl --event lb-add lb0 192.168.1.100:80 ""
ovn-nbctl ls-lb-add sw0 lb0
uuid_lb0=$(ovn-nbctl --bare --columns=_uuid find load_balancer name=lb0)

ovn-nbctl --event lb-add lb1 192.168.2.100:80 ""
ovn-nbctl lr-lb-add lr0 lb1
uuid_lb1=$(ovn-nbctl --bare --columns=_uuid find load_balancer name=lb1)

ovn-nbctl --event lb-add lb2 [[2001::10]]:50051 ""
ovn-nbctl ls-lb-add sw0 lb2
uuid_lb2=$(ovn-nbctl --bare --columns=_uuid find load_balancer name=lb2)

ovn-nbctl --wait=hv meter-add event-elb drop 100 pktps 10

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync
ovn-sbctl lflow-list > sbflows
AT_CAPTURE_FILE([sbflows])
as hv1 ovs-ofctl dump-flows br-int > offlows
AT_CAPTURE_FILE([offlows])

packet0="inport==\"sw0-p11\" && eth.src==00:00:00:00:00:11 && eth.dst==00:00:00:00:00:21 &&
         ip4 && ip.ttl==64 && ip4.src==192.168.1.11 && ip4.dst==192.168.1.100 &&
         tcp && tcp.src==10000 && tcp.dst==80"
as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet0"

ovn-sbctl list controller_event > events
AT_CAPTURE_FILE([events])
uuid=$(awk '/_uuid/{print $3}' < events)
echo uuid=$uuid
AT_CHECK([test -n "$uuid"])
AT_CHECK([ovn-sbctl get controller_event $uuid event_type], [0], [dnl
empty_lb_backends
])
AT_CHECK([ovn-sbctl get controller_event $uuid event_info:vip], [0], [dnl
"192.168.1.100:80"
])
AT_CHECK([ovn-sbctl get controller_event $uuid event_info:protocol], [0], [dnl
tcp
])
AT_CHECK_UNQUOTED([ovn-sbctl get controller_event $uuid event_info:load_balancer], [0], [dnl
"$uuid_lb0"
])
AT_CHECK([ovn-sbctl get controller_event $uuid seq_num], [0], [dnl
1
])

ovn-sbctl destroy controller_event $uuid
packet1="inport==\"sw1-p0\" && eth.src==00:00:00:00:00:33 && eth.dst==00:00:00:00:ff:02 &&
         ip4 && ip.ttl==64 && ip4.src==192.168.2.11 && ip4.dst==192.168.2.100 &&
         tcp && tcp.src==10000 && tcp.dst==80"

as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet1"
ovn-sbctl list controller_event
uuid=$(ovn-sbctl list controller_event | awk '/_uuid/{print $3}')
AT_CHECK([ovn-sbctl get controller_event $uuid event_type], [0], [dnl
empty_lb_backends
])
AT_CHECK([ovn-sbctl get controller_event $uuid event_info:vip], [0], [dnl
"192.168.2.100:80"
])
ovn-sbctl destroy controller_event $uuid

packet2="inport==\"sw0-p11\" && eth.src==00:00:00:00:00:11 && eth.dst==00:00:00:00:00:21 &&
         ip6 && ip.ttl==64 && ip6.src==2001::11 && ip6.dst==2001::10 &&
         tcp && tcp.src==10000 && tcp.dst==50051"

as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet2"
ovn-sbctl list controller_event
uuid=$(ovn-sbctl list controller_event | awk '/_uuid/{print $3}')

AT_CHECK([ovn-sbctl get controller_event $uuid event_type], [0], [dnl
empty_lb_backends
])
AT_CHECK([ovn-sbctl get controller_event $uuid event_info:vip], [0], [dnl
"[[2001::10]]:50051"
])
AT_CHECK_UNQUOTED([ovn-sbctl get controller_event $uuid event_info:load_balancer], [0], [dnl
"$uuid_lb2"
])

AT_CHECK_UNQUOTED([ovn-trace sw0 'inport == "sw0-p11" && eth.src == 00:00:00:00:00:11 && ip4.dst == 192.168.1.100 && tcp && tcp.dst == 80' | grep -q 'event = "empty_lb_backends"'], [0])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- IGMP snoop/querier/relay])
AT_KEYWORDS([snoop query querier relay])

ovn_start

# Logical network:
# Three logical switches (sw1-sw3) connected to a logical router (rtr).
# sw1:
#   - subnet 10.0.0.0/8
#   - 2 ports bound on hv1 (sw1-p11, sw1-p12)
#   - 2 ports bound on hv2 (sw1-p21, sw1-p22)
# sw2:
#   - subnet 20.0.0.0/8
#   - 1 port bound on hv1 (sw2-p1)
#   - 1 port bound on hv2 (sw2-p2)
#   - IGMP Querier from 20.0.0.254
# sw3:
#   - subnet 30.0.0.0/8
#   - 1 port bound on hv1 (sw3-p1)
#   - 1 port bound on hv2 (sw3-p2)
#   - 1 localnet port (sw3-ln)

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    check ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    check ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

#
# send_igmp_v3_report INPORT HV ETH_SRC IP_SRC IP_CSUM GROUP REC_TYPE
#                     IGMP_CSUM OUTFILE
#
# This shell function causes an IGMPv3 report to be received on INPORT of HV.
# The packet's content has Ethernet destination 01:00:5E:00:00:22 and source
# ETH_SRC (exactly 12 hex digits). Ethernet type is set to IP.
# GROUP is the IP multicast group to be joined/to leave (based on REC_TYPE).
# REC_TYPE == 04: join GROUP
# REC_TYPE == 03: leave GROUP
# The packet hexdump is also stored in OUTFILE.
#
send_igmp_v3_report() {
    local inport=$1 hv=$2 eth_src=$3 ip_src=$4 ip_chksum=$5 group=$6
    local rec_type=$7 igmp_chksum=$8 outfile=$9

    local eth_dst=01005e000016
    local ip_dst=$(ip_to_hex 224 0 0 22)
    local ip_ttl=01
    local ip_ra_opt=94040000

    local igmp_type=2200
    local num_rec=00000001
    local aux_dlen=00
    local num_src=0000

    local eth=${eth_dst}${eth_src}0800
    local ip=46c0002800004000${ip_ttl}02${ip_chksum}${ip_src}${ip_dst}${ip_ra_opt}
    local igmp=${igmp_type}${igmp_chksum}${num_rec}${rec_type}${aux_dlen}${num_src}${group}
    local packet=${eth}${ip}${igmp}

    echo ${packet} >> ${outfile}
    check as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

#
# store_igmp_v3_query ETH_SRC IP_SRC IP_CSUM OUTFILE
#
# This shell function builds an IGMPv3 general query from ETH_SRC and IP_SRC
# and stores the hexdump of the packet in OUTFILE.
#
store_igmp_v3_query() {
    local eth_src=$1 ip_src=$2 ip_chksum=$3 outfile=$4

    local eth_dst=01005e000001
    local ip_dst=$(ip_to_hex 224 0 0 1)
    local ip_ttl=01
    local igmp_type=11
    local max_resp=0a
    local igmp_chksum=eeeb
    local addr=00000000

    local eth=${eth_dst}${eth_src}0800
    local ip=4500002000004000${ip_ttl}02${ip_chksum}${ip_src}${ip_dst}
    local igmp=${igmp_type}${max_resp}${igmp_chksum}${addr}000a0000
    local packet=${eth}${ip}${igmp}

    echo ${packet} >> ${outfile}
}

#
# send_ip_multicast_pkt INPORT HV ETH_SRC ETH_DST IP_SRC IP_DST IP_LEN TTL
#    IP_CHKSUM IP_PROTO DATA
#
# This shell function causes an IP multicast packet to be received on INPORT
# of HV.
# The hexdump of the packet is stored in OUTFILE.
#
send_ip_multicast_pkt() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4
    local ip_src=$5 ip_dst=$6 ip_len=$7 ip_ttl=$8 ip_chksum=$9 proto=${10}
    local data=${11}

    local eth=${eth_dst}${eth_src}0800
    local ip=450000${ip_len}95f14000${ip_ttl}${proto}${ip_chksum}${ip_src}${ip_dst}
    local packet=${eth}${ip}${data}

    check as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

#
# store_ip_multicast_pkt ETH_SRC ETH_DST IP_SRC IP_DST IP_LEN TTL
#    IP_CHKSUM IP_PROTO DATA OUTFILE
#
# This shell function builds an IP multicast packet and stores the hexdump of
# the packet in OUTFILE.
#
store_ip_multicast_pkt() {
    local eth_src=$1 eth_dst=$2
    local ip_src=$3 ip_dst=$4 ip_len=$5 ip_ttl=$6 ip_chksum=$7 proto=$8
    local data=$9 outfile=${10}

    local eth=${eth_dst}${eth_src}0800
    local ip=450000${ip_len}95f14000${ip_ttl}${proto}${ip_chksum}${ip_src}${ip_dst}
    local packet=${eth}${ip}${data}

    echo ${packet} >> ${outfile}
}

ovn-nbctl ls-add sw1
ovn-nbctl ls-add sw2
ovn-nbctl ls-add sw3

ovn-nbctl lsp-add sw1 sw1-p11
ovn-nbctl lsp-add sw1 sw1-p12
ovn-nbctl lsp-add sw1 sw1-p21
ovn-nbctl lsp-add sw1 sw1-p22
ovn-nbctl lsp-add sw2 sw2-p1
ovn-nbctl lsp-add sw2 sw2-p2
ovn-nbctl lsp-add sw3 sw3-p1
ovn-nbctl lsp-add sw3 sw3-p2
ovn-nbctl lsp-add sw3 sw3-ln                    \
    -- lsp-set-type sw3-ln localnet             \
    -- lsp-set-options sw3-ln network_name=phys

ovn-nbctl lr-add rtr
ovn-nbctl lrp-add rtr rtr-sw1 00:00:00:00:01:00 10.0.0.254/24
ovn-nbctl lrp-add rtr rtr-sw2 00:00:00:00:02:00 20.0.0.254/24
ovn-nbctl lrp-add rtr rtr-sw3 00:00:00:00:03:00 30.0.0.254/24

ovn-nbctl lsp-add sw1 sw1-rtr                      \
    -- lsp-set-type sw1-rtr router                 \
    -- lsp-set-addresses sw1-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw1-rtr router-port=rtr-sw1
check ovn-nbctl lsp-add sw2 sw2-rtr                \
    -- lsp-set-type sw2-rtr router                 \
    -- lsp-set-addresses sw2-rtr 00:00:00:00:02:00 \
    -- lsp-set-options sw2-rtr router-port=rtr-sw2
check ovn-nbctl lsp-add sw3 sw3-rtr                \
    -- lsp-set-type sw3-rtr router                 \
    -- lsp-set-addresses sw3-rtr 00:00:00:00:03:00 \
    -- lsp-set-options sw3-rtr router-port=rtr-sw3

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p11 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p12 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=sw2-p1 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif4 -- \
    set interface hv1-vif4 external-ids:iface-id=sw3-p1 \
    options:tx_pcap=hv1/vif4-tx.pcap \
    options:rxq_pcap=hv1/vif4-rx.pcap \
    ofport-request=1
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p21 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw1-p22 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif3 -- \
    set interface hv2-vif3 external-ids:iface-id=sw2-p2 \
    options:tx_pcap=hv2/vif3-tx.pcap \
    options:rxq_pcap=hv2/vif3-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif4 -- \
    set interface hv2-vif4 external-ids:iface-id=sw3-p2 \
    options:tx_pcap=hv2/vif4-tx.pcap \
    options:rxq_pcap=hv2/vif4-rx.pcap \
    ofport-request=1
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

OVN_POPULATE_ARP

# Enable IGMP snooping on sw1.
check ovn-nbctl --wait=hv set Logical_Switch sw1       \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"

AT_CAPTURE_FILE([sbflows])
cp ovn-sb/ovn-sb.db ovn-sb.db
ovn-sbctl dump-flows > sbflows

# No IGMP query should be generated by sw1 (mcast_querier="false").
# (Therefore everything is expected to be empty.)
AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
> expected
> received
for i in 1 2; do
    for j in 1 2; do
        pcap=hv$i/vif$j-tx.pcap
        echo "--- $pcap" | tee -a expected >> received
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | sort >> received
        echo | tee -a expected >> received
    done
done
check $at_diff -F'^---' expected received

check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([sbflows2])
cp ovn-sb/ovn-sb.db ovn-sb2.db
ovn-sbctl dump-flows > sbflows2

# Inject IGMP Join for 239.0.1.68 on sw1-p11.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null
# Inject IGMP Join for 239.0.1.68 on sw1-p21.
send_igmp_v3_report hv2-vif1 hv2 000000000002 $(ip_to_hex 10 0 0 2) f9f9 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Check that the IGMP Group is learned on both hv.
wait_row_count IGMP_Group 2 address=239.0.1.68
check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([sbflows3])
cp ovn-sb/ovn-sb.db ovn-sb3.db
ovn-sbctl dump-flows > sbflows3

AS_BOX([IGMP traffic test 1])
# Send traffic and make sure it gets forwarded only on the two ports that
# joined.
> expected
> expected_empty
send_ip_multicast_pkt hv1-vif2 hv1 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000 expected

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Inject IGMP Leave for 239.0.1.68 on sw1-p11.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 03 eab9 \
    /dev/null

# Check IGMP_Group table on both HV.
wait_row_count IGMP_Group 1 address=239.0.1.68
check ovn-nbctl --wait=hv sync

AS_BOX([IGMP traffic test 2])
# Send traffic and make sure it gets forwarded only on the port that joined.
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
> expected
> expected_empty
send_ip_multicast_pkt hv1-vif2 hv1 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000 expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Flush IGMP groups.
check ovn-sbctl ip-multicast-flush sw1
wait_row_count IGMP_Group 0 address=239.0.1.68
check ovn-nbctl --wait=hv sync

# Check that traffic for 224.0.0.X is flooded even if some hosts register for
# it.
# Inject IGMP Join for 224.0.0.42 on sw1-p11.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 224 0 0 42) 04 f9d3 \
    /dev/null

# Check that the IGMP Group is learned.
wait_row_count IGMP_Group 1 address=224.0.0.42

AS_BOX([IGMP traffic test 3])
# Send traffic and make sure it gets flooded to all ports.
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
> expected
send_ip_multicast_pkt hv1-vif2 hv1 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 224 0 0 42) 1e 01 f989 11 \
    e518e518000a4b540000
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 224 0 0 42) 1e 01 f989 11 \
    e518e518000a4b540000 expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv2/vif2-tx.pcap expected'],
  [$at_diff -F'^---' exp rcv])

# Enable IGMP snooping and querier on sw2 and set query interval to minimum.
check ovn-nbctl set Logical_Switch sw2 \
    other_config:mcast_snoop="true" \
    other_config:mcast_querier="true" \
    other_config:mcast_query_interval=1 \
    other_config:mcast_eth_src="00:00:00:00:02:fe" \
    other_config:mcast_ip4_src="20.0.0.254"

AS_BOX([IGMP traffic test 4])
# Wait for 1 query interval (1 sec) and check that two queries are generated.
> expected
store_igmp_v3_query 0000000002fe $(ip_to_hex 20 0 0 254) 84dd expected
store_igmp_v3_query 0000000002fe $(ip_to_hex 20 0 0 254) 84dd expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif3-tx.pcap expected' \
                 'hv2/vif3-tx.pcap expected'],
  [$at_diff -F'^---' exp rcv])

# Disable IGMP querier on sw2.
check ovn-nbctl set Logical_Switch sw2 \
    other_config:mcast_querier="false"

# Enable IGMP snooping on sw3.
check ovn-nbctl set Logical_Switch sw3       \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"

check ovn-nbctl --wait=hv sync

AS_BOX([IGMP traffic test 5])
# Send traffic from sw3 and make sure rtr doesn't relay it.
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip_multicast_pkt hv2-vif4 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000

# Sleep a bit to make sure no traffic is received and then check.
sleep 1
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_empty' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Enable IGMP relay on rtr
check ovn-nbctl set logical_router rtr \
    options:mcast_relay="true"

# Inject IGMP Join for 239.0.1.68 on sw1-p11.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null
# Inject IGMP Join for 239.0.1.68 on sw2-p2.
send_igmp_v3_report hv2-vif3 hv2 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Check that the IGMP Group is learned by all switches.
wait_row_count IGMP_Group 2 address=239.0.1.68
check ovn-nbctl --wait=hv sync

AS_BOX([IGMP traffic test 6])
# Send traffic from sw3 and make sure it is relayed by rtr.
# to ports that joined.
> expected_routed_sw1
> expected_routed_sw2
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip_multicast_pkt hv2-vif4 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000100 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw1
store_ip_multicast_pkt \
    000000000200 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_routed_sw1' \
                 'hv2/vif3-tx.pcap expected_routed_sw2' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Inject IGMP Join for 239.0.1.68 on sw3-p1.
send_igmp_v3_report hv1-vif4 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Check that the IGMP Group is learned by all switches.
wait_row_count IGMP_Group 3 address=239.0.1.68
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows4
AT_CAPTURE_FILE([sbflows4])

ovn-sbctl -f csv --columns=datapath,name,ports,tunnel_key list Multicast_Group > mcgroups4
AT_CAPTURE_FILE([mcgroups4])

AS_BOX([IGMP traffic test 7])
# Send traffic from sw3 and make sure it is relayed by rtr
# to ports that joined.
> expected_routed_sw1
> expected_routed_sw2
> expected_switched
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip_multicast_pkt hv2-vif4 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000100 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw1
store_ip_multicast_pkt \
    000000000200 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw2
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000 expected_switched

# TODO: IGMP Relay duplicates IP multicast packets in some conditions, for
# more details see TODO.rst, section "IP Multicast Relay". Once that issue is
# fixed the duplicated packets should not appear anymore.
store_ip_multicast_pkt \
    000000000100 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw1
store_ip_multicast_pkt \
    000000000200 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_routed_sw1' \
                 'hv2/vif3-tx.pcap expected_routed_sw2' \
                 'hv1/vif4-tx.pcap expected_switched' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Flush IGMP groups.
ovn-sbctl ip-multicast-flush sw1
ovn-sbctl ip-multicast-flush sw2
ovn-sbctl ip-multicast-flush sw3
wait_row_count IGMP_Group 0 address=239.0.1.68
check ovn-nbctl --wait=hv sync

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

> expected_empty
> expected_switched
> expected_routed
> expected_reports

# Enable mcast_flood on sw1-p11
ovn-nbctl set Logical_Switch_Port sw1-p11 options:mcast_flood='true'

# Enable mcast_flood_reports on sw1-p21
ovn-nbctl set Logical_Switch_Port sw1-p21 options:mcast_flood_reports='true'
# Enable mcast_flood on rtr-sw2
ovn-nbctl set Logical_Router_Port rtr-sw2 options:mcast_flood='true'
# Enable mcast_flood on sw2-p1
ovn-nbctl set Logical_Switch_Port sw2-p1 options:mcast_flood='true'

ovn-nbctl --wait=hv sync

# Inject IGMP Join for 239.0.1.68 on sw1-p12.
send_igmp_v3_report hv1-vif2 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    expected_reports

# Check that the IGMP Group is learned.
wait_row_count IGMP_Group 1 address=239.0.1.68
check ovn-nbctl --wait=hv sync

AS_BOX([IGMP traffic test 8])
# Send traffic from sw1-p21
send_ip_multicast_pkt hv2-vif1 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000 expected_switched
store_ip_multicast_pkt \
    000000000200 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed


# Check that traffic is switched to sw1-p11 and sw1-p12
# Check that IGMP join is flooded on sw1-p21
# Check that traffic is routed by rtr to rtr-sw2 and then switched to sw2-p1
AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_switched' \
                 'hv1/vif2-tx.pcap expected_switched' \
                 'hv1/vif3-tx.pcap expected_routed' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_reports' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# With ovn-monitor-all=true, make sure ovn-controllers don't delete each
# other's IGMP_Group records.

# Add a new chassis with no local datapaths.
net_add n3
sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n3 br-phys 192.168.0.3

# Enable ovn-monitor-all on all chassis.
as hv1 ovs-vsctl set open . external_ids:ovn-monitor-all=true
as hv2 ovs-vsctl set open . external_ids:ovn-monitor-all=true
as hv3 ovs-vsctl set open . external_ids:ovn-monitor-all=true

# Wait until ovn-monitor-all is processed by ovn-controller.
wait_row_count Chassis 1 name=hv1 other_config:ovn-monitor-all='"true"'
wait_row_count Chassis 1 name=hv2 other_config:ovn-monitor-all='"true"'
wait_row_count Chassis 1 name=hv3 other_config:ovn-monitor-all='"true"'

# Inject a fake IGMP_Group entry.
dp=$(fetch_column Datapath_Binding _uuid external_ids:name=sw2)
ch=$(fetch_column Chassis _uuid name=hv3)
ovn-sbctl create IGMP_Group address=239.0.1.42 datapath=$dp chassis=$ch

ovn-nbctl --wait=hv sync
wait_row_count IGMP_Group 1 address=239.0.1.68
wait_row_count IGMP_Group 1 address=239.0.1.42

OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- MLD snoop/querier/relay])
AT_KEYWORDS([snoop query querier relay])

ovn_start

# Logical network:
# Three logical switches (sw1-sw3) connected to a logical router (rtr).
# sw1:
#   - subnet 10::/64
#   - 2 ports bound on hv1 (sw1-p11, sw1-p12)
#   - 2 ports bound on hv2 (sw1-p21, sw1-p22)
# sw2:
#   - subnet 20::/64
#   - 1 port bound on hv1 (sw2-p1)
#   - 1 port bound on hv2 (sw2-p2)
#   - MLD Querier from 20::fe
# sw3:
#   - subnet 30::/64
#   - 1 port bound on hv1 (sw3-p1)
#   - 1 port bound on hv2 (sw3-p2)
#   - 1 localnet port (sw3-ln)

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    check ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    check ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

#
# send_mld_v2_report INPORT HV ETH_SRC IP_SRC GROUP REC_TYPE
#                    MLD_CSUM OUTFILE
#
# This shell function causes an MLDv2 report to be received on INPORT of HV.
# The packet's content has Ethernet destination 33:33:00:00:00:16 and source
# ETH_SRC (exactly 12 hex digits). Ethernet type is set to IPv6.
# GROUP is the IPv6 multicast group to be joined/to leave (based on REC_TYPE).
# REC_TYPE == 04: join GROUP
# REC_TYPE == 03: leave GROUP
# The packet hexdump is also stored in OUTFILE.
#
send_mld_v2_report() {
    local inport=$1 hv=$2 eth_src=$3 ip_src=$4 group=$5
    local rec_type=$6 mld_chksum=$7 outfile=$8

    local eth_dst=333300000016
    local ip_dst=ff020000000000000000000000000016
    local ip_ttl=01
    local ip_ra_opt=3a00050200000100

    local mld_type=8f
    local mld_code=00
    local num_rec=0001
    local aux_dlen=00
    local num_src=0000

    local eth=${eth_dst}${eth_src}86dd
    local ip=60000000002400${ip_ttl}${ip_src}${ip_dst}${ip_ra_opt}
    local mld=${mld_type}${mld_code}${mld_chksum}0000${num_rec}${rec_type}${aux_dlen}${num_src}${group}
    local packet=${eth}${ip}${mld}

    echo ${packet} >> ${outfile}
    check as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

#
# store_mld_query ETH_SRC IP_SRC OUTFILE
#
# This shell function builds an MLD general query from ETH_SRC and IP_SRC
# and stores the hexdump of the packet in OUTFILE.
#
store_mld_query() {
    local eth_src=$1 ip_src=$2 outfile=$3

    local eth_dst=333300000000
    local ip_dst=ff020000000000000000000000000001
    local ip_ttl=01
    local ip_ra_opt=3a00050200000000

    local mld_type=82
    local mld_code=00
    local max_resp=03e8
    local mld_chksum=7b3d
    local addr=00000000000000000000000000000000

    local eth=${eth_dst}${eth_src}86dd
    local ip=60000000002400${ip_ttl}${ip_src}${ip_dst}${ip_ra_opt}
    local mld=${mld_type}${mld_code}${mld_chksum}${max_resp}0000${addr}00010000
    local packet=${eth}${ip}${mld}

    echo ${packet} >> ${outfile}
}

#
# send_ip_multicast_pkt INPORT HV ETH_SRC ETH_DST IP_SRC IP_DST IP_LEN TTL
#    IP_PROTO DATA
#
# This shell function causes an IP multicast packet to be received on INPORT
# of HV.
#
send_ip_multicast_pkt() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4
    local ip_src=$5 ip_dst=$6 ip_len=$7 ip_ttl=$8 proto=$9
    local data=${10}

    local eth=${eth_dst}${eth_src}86dd
    local ip=60000000${ip_len}${proto}${ip_ttl}${ip_src}${ip_dst}
    local packet=${eth}${ip}${data}

    check as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

#
# store_ip_multicast_pkt ETH_SRC ETH_DST IP_SRC IP_DST IP_LEN TTL
#    IP_PROTO DATA OUTFILE
#
# This shell function builds an IP multicast packet and stores the hexdump of
# the packet in OUTFILE.
#
store_ip_multicast_pkt() {
    local eth_src=$1 eth_dst=$2
    local ip_src=$3 ip_dst=$4 ip_len=$5 ip_ttl=$6 proto=$7
    local data=$8 outfile=$9

    local eth=${eth_dst}${eth_src}86dd
    local ip=60000000${ip_len}${proto}${ip_ttl}${ip_src}${ip_dst}
    local packet=${eth}${ip}${data}

    echo ${packet} >> ${outfile}
}

check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add sw2
check ovn-nbctl ls-add sw3

check ovn-nbctl lsp-add sw1 sw1-p11
check ovn-nbctl lsp-add sw1 sw1-p12
check ovn-nbctl lsp-add sw1 sw1-p21
check ovn-nbctl lsp-add sw1 sw1-p22
check ovn-nbctl lsp-add sw2 sw2-p1
check ovn-nbctl lsp-add sw2 sw2-p2
check ovn-nbctl lsp-add sw3 sw3-p1
check ovn-nbctl lsp-add sw3 sw3-p2
check ovn-nbctl lsp-add sw3 sw3-ln              \
    -- lsp-set-type sw3-ln localnet             \
    -- lsp-set-options sw3-ln network_name=phys

check ovn-nbctl lr-add rtr
check ovn-nbctl lrp-add rtr rtr-sw1 00:00:00:00:01:00 10::fe/64
check ovn-nbctl lrp-add rtr rtr-sw2 00:00:00:00:02:00 20::fe/64
check ovn-nbctl lrp-add rtr rtr-sw3 00:00:00:00:03:00 30::fe/64

check ovn-nbctl lsp-add sw1 sw1-rtr                \
    -- lsp-set-type sw1-rtr router                 \
    -- lsp-set-addresses sw1-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw1-rtr router-port=rtr-sw1
check ovn-nbctl lsp-add sw2 sw2-rtr                \
    -- lsp-set-type sw2-rtr router                 \
    -- lsp-set-addresses sw2-rtr 00:00:00:00:02:00 \
    -- lsp-set-options sw2-rtr router-port=rtr-sw2
check ovn-nbctl lsp-add sw3 sw3-rtr                \
    -- lsp-set-type sw3-rtr router                 \
    -- lsp-set-addresses sw3-rtr 00:00:00:00:03:00 \
    -- lsp-set-options sw3-rtr router-port=rtr-sw3

# Conntrack marks all IPv6 Neighbor Discovery and MLD packets as invalid,
# make sure to test that conntrack is bypassed for MLD by adding an empty
# allow-related ACL and an empty load balancer.
check ovn-nbctl acl-add sw1 from-lport 1 "1" allow-related
check ovn-nbctl acl-add sw2 from-lport 1 "1" allow-related
check ovn-nbctl acl-add sw3 from-lport 1 "1" allow-related
check ovn-nbctl acl-add sw1 to-lport 1 "1" allow-related
check ovn-nbctl acl-add sw2 to-lport 1 "1" allow-related
check ovn-nbctl acl-add sw3 to-lport 1 "1" allow-related

check ovn-nbctl lb-add lb0 [[4242::1]]:80 "[[4242::2]]:80"
check ovn-nbctl ls-lb-add sw1 lb0
check ovn-nbctl ls-lb-add sw2 lb0
check ovn-nbctl ls-lb-add sw3 lb0

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p11 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p12 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=sw2-p1 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif4 -- \
    set interface hv1-vif4 external-ids:iface-id=sw3-p1 \
    options:tx_pcap=hv1/vif4-tx.pcap \
    options:rxq_pcap=hv1/vif4-rx.pcap \
    ofport-request=1
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p21 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw1-p22 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif3 -- \
    set interface hv2-vif3 external-ids:iface-id=sw2-p2 \
    options:tx_pcap=hv2/vif3-tx.pcap \
    options:rxq_pcap=hv2/vif3-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif4 -- \
    set interface hv2-vif4 external-ids:iface-id=sw3-p2 \
    options:tx_pcap=hv2/vif4-tx.pcap \
    options:rxq_pcap=hv2/vif4-rx.pcap \
    ofport-request=1
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

wait_for_ports_up
check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([sbflows])
ovn-sbctl dump-flows > sbflows

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    if test "$1" = --uniq; then
        sort="sort -u"; shift
    else
        sort=sort
    fi
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        $sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | $sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

OVN_POPULATE_ARP

# Enable multicast snooping on sw1.
check ovn-nbctl --wait=hv set Logical_Switch sw1 \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"

# No IGMP/MLD query should be generated by sw1 (mcast_querier="false").
> expected
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv2/vif2-tx.pcap expected'],
  [$at_diff -F'^---' exp rcv])

check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([sbflows2])
ovn-sbctl dump-flows > sbflows2

# Inject MLD Join for ff0a:dead:beef::1 on sw1-p11.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null
# Inject MLD Join for ff0a:dead:beef::1 on sw1-p21.
send_mld_v2_report hv2-vif1 hv2 \
    000000000002 10000000000000000000000000000002 \
    ff0adeadbeef00000000000000000001 04 c0e3 \
    /dev/null

# Check that the IP multicast group is learned on both hv.
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'

# This gives the ovn-controller nodes a chance to see the new IGMP_Group.
check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([sbflows3])
ovn-sbctl dump-flows > sbflows3

# Send traffic and make sure it gets forwarded only on the two ports that
# joined.
> expected
> expected_empty
send_ip_multicast_pkt hv1-vif2 hv1 \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a

store_ip_multicast_pkt \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Inject MLD Leave for ff0a:dead:beef::1 on sw1-p11.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 03 c1e4 \
    /dev/null

# Check IGMP_Group table on both HV.
wait_row_count IGMP_Group 1 address='"ff0a:dead:beef::1"'

# Send traffic and make sure it gets forwarded only on the port that joined.
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
> expected
> expected_empty
send_ip_multicast_pkt hv1-vif2 hv1 \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a

store_ip_multicast_pkt \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Flush IP multicast groups.
check ovn-sbctl ip-multicast-flush sw1
wait_row_count IGMP_Group 0 address='"ff0a:dead:beef::1"'

# Check that traffic for "all-hosts" is flooded even if some hosts register
# for it.
# Inject MLD Join for ff02::1 on sw1-p11.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff020000000000000000000000000001 04 5e8a \
    /dev/null

# Check that the Multicast Group is learned.
wait_row_count IGMP_Group 1 address='"ff02::1"'

# Send traffic and make sure it gets flooded to all ports.
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
> expected
send_ip_multicast_pkt hv1-vif2 hv1 \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff020000000000000000000000000001 \
    000e 01 11 \
    93407a69000eb90361736461640a
store_ip_multicast_pkt \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff020000000000000000000000000001 \
    000e 01 11 \
    93407a69000eb90361736461640a \
    expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv2/vif2-tx.pcap expected'],
  [$at_diff -F'^---' exp rcv])

# Enable multicast snooping and querier on sw2 and set query interval to
# minimum.
check ovn-nbctl --wait=hv set Logical_Switch sw2 \
    other_config:mcast_snoop="true" \
    other_config:mcast_querier="true" \
    other_config:mcast_query_interval=1 \
    other_config:mcast_eth_src="00:00:00:00:02:fe" \
    other_config:mcast_ip6_src="fe80::fe"

AT_CAPTURE_FILE([sbflows4])
ovn-sbctl dump-flows > sbflows4

# Check that multiple queries are generated over time.
> expected
store_mld_query 0000000002fe fe8000000000000000000000000000fe expected
store_mld_query 0000000002fe fe8000000000000000000000000000fe expected
for count in 1 2 3; do
    as hv1 reset_pcap_file hv1-vif1 hv1/vif1
    as hv1 reset_pcap_file hv1-vif2 hv1/vif2
    as hv1 reset_pcap_file hv1-vif3 hv1/vif3
    as hv1 reset_pcap_file hv1-vif4 hv1/vif4
    as hv2 reset_pcap_file hv2-vif1 hv2/vif1
    as hv2 reset_pcap_file hv2-vif2 hv2/vif2
    as hv2 reset_pcap_file hv2-vif3 hv2/vif3
    as hv2 reset_pcap_file hv2-vif4 hv2/vif4
    OVS_WAIT_UNTIL(
      [check_packets --uniq \
                     'hv1/vif3-tx.pcap expected' \
                     'hv2/vif3-tx.pcap expected'],
      [$at_diff -F'^---' exp rcv])
done

# Disable multicast querier on sw2.
check ovn-nbctl set Logical_Switch sw2 \
    other_config:mcast_querier="false"

# Enable multicast snooping on sw3.
check ovn-nbctl --wait=sb set Logical_Switch sw3       \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"

AT_CAPTURE_FILE([sbflows5])
ovn-sbctl dump-flows > sbflows5

# Send traffic from sw3 and make sure rtr doesn't relay it.
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip_multicast_pkt hv2-vif4 hv2 \
    000000000001 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e2b4e61736461640a

# Sleep a bit to make sure no traffic is received and then check.
sleep 1
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_empty' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Enable multicast relay on rtr
check ovn-nbctl --wait=sb set logical_router rtr options:mcast_relay="true"

AT_CAPTURE_FILE([sbflows6])
ovn-sbctl dump-flows > sbflows6

# Inject MLD Join for ff0a:dead:beef::1 on sw1-p11.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Inject MLD Join for ff0a:dead:beef::1 on sw2-p2.
send_mld_v2_report hv2-vif3 hv2 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Check that the IGMP Group is learned by all switches.
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'

# Send traffic from sw3 and make sure it is relayed by rtr.
# to ports that joined.
> expected_routed_sw1
> expected_routed_sw2
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip_multicast_pkt hv2-vif4 hv2 \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e1b5e61736461640a
store_ip_multicast_pkt \
    000000000100 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw1
store_ip_multicast_pkt \
    000000000200 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_routed_sw1' \
                 'hv2/vif3-tx.pcap expected_routed_sw2' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Inject MLD Join for 239.0.1.68 on sw3-p1.
send_mld_v2_report hv1-vif4 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Check that the Multicast Group is learned by all switches.
wait_row_count IGMP_Group 3 address='"ff0a:dead:beef::1"'
check ovn-nbctl --wait=hv sync

# Send traffic from sw3 and make sure it is relayed by rtr
# to ports that joined.
> expected_routed_sw1
> expected_routed_sw2
> expected_switched
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip_multicast_pkt hv2-vif4 hv2 \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e1b5e61736461640a
store_ip_multicast_pkt \
    000000000100 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw1
store_ip_multicast_pkt \
    000000000200 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw2
store_ip_multicast_pkt \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e1b5e61736461640a \
    expected_switched

# TODO: MLD Relay duplicates IP multicast packets in some conditions, for
# more details see TODO.rst, section "IP Multicast Relay". Once that issue is
# fixed the duplicated packets should not appear anymore.
store_ip_multicast_pkt \
    000000000100 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw1
store_ip_multicast_pkt \
    000000000200 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_routed_sw1' \
                 'hv2/vif3-tx.pcap expected_routed_sw2' \
                 'hv1/vif4-tx.pcap expected_switched' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Flush multicast groups.
check ovn-sbctl ip-multicast-flush sw1
check ovn-sbctl ip-multicast-flush sw2
check ovn-sbctl ip-multicast-flush sw3
wait_row_count IGMP_Group 0 address='"ff0a:dead:beef::1"'

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

> expected_empty
> expected_switched
> expected_routed
> expected_reports

# Enable mcast_flood on sw1-p11
check ovn-nbctl set Logical_Switch_Port sw1-p11 options:mcast_flood='true'

# Enable mcast_flood_reports on sw1-p21
check ovn-nbctl set Logical_Switch_Port sw1-p21 options:mcast_flood_reports='true'
# Enable mcast_flood on rtr-sw2
check ovn-nbctl set Logical_Router_Port rtr-sw2 options:mcast_flood='true'
# Enable mcast_flood on sw2-p1
check ovn-nbctl set Logical_Switch_Port sw2-p1 options:mcast_flood='true'

check ovn-nbctl --wait=hv sync

# Inject MLD Join for ff0a:dead:beef::1 on sw1-p12.
send_mld_v2_report hv1-vif2 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    expected_reports

# Check that the IP multicast group is learned.
wait_row_count IGMP_Group 1 address='"ff0a:dead:beef::1"'
check ovn-nbctl --wait=hv sync

# Send traffic from sw1-p21
send_ip_multicast_pkt hv2-vif1 hv2 \
    000000000001 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e2b4e61736461640a
store_ip_multicast_pkt \
    000000000001 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e2b4e61736461640a \
    expected_switched
store_ip_multicast_pkt \
    000000000200 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e2b4e61736461640a \
    expected_routed

# Sleep a bit to make sure no duplicate traffic is received
sleep 1

AT_CAPTURE_FILE([sbflows7])
ovn-sbctl dump-flows > sbflows7

# Check that traffic is switched to sw1-p11 and sw1-p12
# Check that MLD join is flooded on sw1-p21
# Check that traffic is routed by rtr to rtr-sw2 and then switched to sw2-p1
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_switched' \
                 'hv1/vif2-tx.pcap expected_switched' \
                 'hv1/vif3-tx.pcap expected_routed' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_reports' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- unixctl socket])
ovn_start

sockfile="$at_group_dir/my_sock.ctl"

# Specifying -u should fail since we have no daemon running
AT_CHECK([ovn-nbctl -u $sockfile show], [1], [ignore], [ignore])

AT_CHECK_UNQUOTED([ovn-nbctl --detach -u $sockfile --pidfile], [0], [$sockfile
])
AT_CHECK([if test -f "$sockfile" ; then exit 99 ; fi])
on_exit 'kill $(cat ovn-nbctl.pid)'

# We can't confirm that the nbctl client is actually using the sockfile,
# but we can still ensure that the command is successful.
AT_CHECK([ovn-nbctl -u $sockfile show])

AT_CLEANUP
])

m4_define([DVR_N_S_ARP_HANDLING],
  [OVN_FOR_EACH_NORTHD([
   AT_SETUP([ovn -- 2 HVs, 2 lports/HV, localnet ports, DVR N-S ARP handling, encap $1])
   set -x
   encap=$1
   ovn_start

   # In this test cases we create 3 switches, all connected to same
   # physical network (through br-phys on each HV). LS1 and LS2 have
   # 1 VIF each. Each HV has 1 VIF port. The first digit
   # of VIF port name indicates the hypervisor it is bound to, e.g.
   # lp23 means VIF 3 on hv2.
   #
   # All the switches are connected to a logical router "router".
   #
   # Each switch's VLAN tag and their logical switch ports are:
   #   - ls1:
   #       - tagged with VLAN 101
   #       - ports: lp11
   #   - ls2:
   #       - tagged with VLAN 201
   #       - ports: lp22
   #   - ls-underlay:
   #       - tagged with VLAN 1000
   # Note: a localnet port is created for each switch to connect to
   # physical network.

   for i in 1 2; do
       ls_name=ls$i
       ovn-nbctl ls-add $ls_name
       ln_port_name=ln$i
       if test $i -eq 1; then
           ovn-nbctl lsp-add $ls_name $ln_port_name "" 101
       elif test $i -eq 2; then
           ovn-nbctl lsp-add $ls_name $ln_port_name "" 201
       fi
       ovn-nbctl lsp-set-addresses $ln_port_name unknown
       ovn-nbctl lsp-set-type $ln_port_name localnet
       ovn-nbctl lsp-set-options $ln_port_name network_name=phys
   done

   # lsp_to_ls LSP
   #
   # Prints the name of the logical switch that contains LSP.
   lsp_to_ls () {
       case ${1} in dnl (
           lp?[[11]]) echo ls1 ;; dnl (
           lp?[[12]]) echo ls2 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_hv () {
       case $1 in dnl (
           vif[[1]]?) echo hv1 ;; dnl (
           vif[[2]]?) echo hv2 ;; dnl (
           vif?[[north]]?) echo hv4 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   net_add n1
   for i in 1 2; do
       sim_add hv$i
       as hv$i
       ovs-vsctl add-br br-phys
       ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
       ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:$i$i"
       ovn_attach n1 br-phys 192.168.0.$i 24 $encap

       ovs-vsctl add-port br-int vif$i$i -- \
           set Interface vif$i$i external-ids:iface-id=lp$i$i \
                                 options:tx_pcap=hv$i/vif$i$i-tx.pcap \
                                 options:rxq_pcap=hv$i/vif$i$i-rx.pcap \
                                 ofport-request=$i$i

       lsp_name=lp$i$i
       ls_name=$(lsp_to_ls $lsp_name)

       ovn-nbctl lsp-add $ls_name $lsp_name
       ovn-nbctl lsp-set-addresses $lsp_name "f0:00:00:00:00:$i$i 192.168.$i.$i"
       ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:$i$i

       OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])

   done

   ovn-nbctl ls-add ls-underlay
   ovn-nbctl lsp-add ls-underlay ln3 "" 1000
   ovn-nbctl lsp-set-addresses ln3 unknown
   ovn-nbctl lsp-set-type ln3 localnet
   ovn-nbctl lsp-set-options ln3 network_name=phys

   ovn-nbctl ls-add ls-north
   ovn-nbctl lsp-add ls-north ln4 "" 1000
   ovn-nbctl lsp-set-addresses ln4 unknown
   ovn-nbctl lsp-set-type ln4 localnet
   ovn-nbctl lsp-set-options ln4 network_name=phys

   # Add a VM on ls-north
   ovn-nbctl lsp-add ls-north lp-north
   ovn-nbctl lsp-set-addresses lp-north "f0:f0:00:00:00:11 172.31.0.10"
   ovn-nbctl lsp-set-port-security lp-north f0:f0:00:00:00:11

   # Add 3rd hypervisor
   sim_add hv3
   as hv3 ovs-vsctl add-br br-phys
   as hv3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
   as hv3 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:33"
   as hv3 ovn_attach n1 br-phys 192.168.0.3 24 $encap

   # Add 4th hypervisor
   sim_add hv4
   as hv4 ovs-vsctl add-br br-phys
   as hv4 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
   as hv4 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:44"
   as hv4 ovn_attach n1 br-phys 192.168.0.4 24 $encap

   as hv4 ovs-vsctl add-port br-int vif-north -- \
           set Interface vif-north external-ids:iface-id=lp-north \
                                 options:tx_pcap=hv4/vif-north-tx.pcap \
                                 options:rxq_pcap=hv4/vif-north-rx.pcap \
                                 ofport-request=44

   ovn-nbctl lr-add router
   ovn-nbctl lrp-add router router-to-ls1 00:00:01:01:02:03 192.168.1.3/24
   ovn-nbctl lrp-add router router-to-ls2 00:00:01:01:02:05 192.168.2.3/24
   ovn-nbctl lrp-add router router-to-underlay 00:00:01:01:02:07 172.31.0.1/24

   ovn-nbctl lsp-add ls1 ls1-to-router -- set Logical_Switch_Port ls1-to-router type=router \
             options:router-port=router-to-ls1 -- lsp-set-addresses ls1-to-router router
   ovn-nbctl lsp-add ls2 ls2-to-router -- set Logical_Switch_Port ls2-to-router type=router \
             options:router-port=router-to-ls2 -- lsp-set-addresses ls2-to-router router
   ovn-nbctl lsp-add ls-underlay underlay-to-router -- set Logical_Switch_Port \
                                 underlay-to-router type=router \
                                 options:router-port=router-to-underlay \
                                 -- lsp-set-addresses underlay-to-router router


   OVN_POPULATE_ARP

   vif_to_hv () {
       case ${1} in dnl (
           vif[[1]]?) echo hv1 ;; dnl (
           vif[[2]]?) echo hv2 ;; dnl (
           vif-north) echo hv4 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   # test_arp INPORT SHA SPA TPA [REPLY_HA]
   #
   # Causes a packet to be received on INPORT.  The packet is an ARP
   # request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
   # it should be the hardware address of the target to expect to receive in an
   # ARP reply; otherwise no reply is expected.
   #
   # INPORT is an logical switch port number, e.g. 11 for vif11.
   # SHA and REPLY_HA are each 12 hex digits.
   # SPA and TPA are each 8 hex digits.
   test_arp() {
       local inport=${1} sha=${2} spa=${3} tpa=${4} reply_ha=${5}
       local request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
       hv=`vif_to_hv $inport`
       as $hv ovs-appctl netdev-dummy/receive $inport $request

       if test X$reply_ha = X; then
           # Expect to receive the broadcast ARP on the other logical switch ports
           # if no reply is expected.
           local i j
           for i in 1 2 3; do
               for j in 1 2 3; do
                   if test $i$j != $inport; then
                       echo $request >> $i$j.expected
                   fi
               done
           done
       else
           # Expect to receive the reply, if any.
           local reply=${sha}${reply_ha}08060001080006040002${reply_ha}${tpa}${sha}${spa}
           local reply_vid=${sha}${reply_ha}810003e808060001080006040002${reply_ha}${tpa}${sha}${spa}
           echo $reply_vid >> ${inport}_vid.expected
           echo $reply >> $inport.expected
       fi
   }

   sip=`printf "%02x%02x%02x%02x" 172 31 0 10`
   tip=`printf "%02x%02x%02x%02x" 172 31 0 1`

   # Set a hypervisor as gateway chassis, for router port 172.31.0.1
   ovn-nbctl lrp-set-gateway-chassis router-to-underlay hv3
   wait_for_ports_up
   ovn-nbctl --wait=sb sync

   wait_row_count Port_Binding 1 logical_port=cr-router-to-underlay

   # Dump a bunch of info helpful for debugging if there's a failure.

   ovn-sbctl dump-flows > sbflows
   AT_CAPTURE_FILE([sbflows])

   (ovn-nbctl show
    ovn-sbctl show
    ovn-sbctl list port_binding
    ovn-sbctl list mac_binding) > ovndump
   AT_CAPTURE_FILE([ovndump])

   (as hv1 ovs-vsctl show; as hv1 ovs-vsctl list Open_Vswitch) > hv1dump
   AT_CAPTURE_FILE([hv1dump])

   (as hv2 ovs-vsctl show; as hv2 ovs-vsctl list Open_Vswitch) > hv2dump
   AT_CAPTURE_FILE([hv2dump])

   (as hv3 ovs-vsctl show; as hv3 ovs-vsctl list Open_Vswitch) > hv3dump
   AT_CAPTURE_FILE([hv3dump])

   (as hv4 ovs-vsctl show; as hv4 ovs-vsctl list Open_Vswitch) > hv4dump
   AT_CAPTURE_FILE([hv4dump])

   test_arp vif-north f0f000000011 $sip $tip 000001010207

   # Confirm that vif-north gets a single ARP reply
   OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv4/vif-north-tx.pcap], [vif-north.expected])

   # Confirm that only redirect chassis allowed arp resolution.
   OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv3/br-phys_n1-tx.pcap], [vif-north_vid.expected])

   # Confirm that other OVN chassis did not generate ARP reply.
   $PYTHON "$ovs_srcdir//utilities/ovs-pcap.in" hv1/br-phys_n1-tx.pcap > hv1/br-phys_n1-tx.packets
   $PYTHON "$ovs_srcdir//utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap > hv2/br-phys_n1-tx.packets

   AT_CHECK([grep 000001010207 hv1/br-phys_n1-tx.packets | wc -l], [0], [[0
]])
   AT_CHECK([grep 000001010207 hv2/br-phys_n1-tx.packets | wc -l], [0], [[0
]])

   # validate max_tunid reflects the type of encapsulation used
   max_tunid=`ovn-nbctl get NB_Global . options:max_tunid | sed s/":"//g | sed s/\"//g`
   if [[ $encap = vxlan ]]; then
       max_tunid_expected=4095
   else
       max_tunid_expected=16711680
   fi
   echo max_tunid=$max_tunid max_tunid_expected=$max_tunid_expected
   AT_CHECK([test -n "$max_tunid"])
   AT_CHECK([test "$max_tunid" -eq "$max_tunid_expected"])

   echo "----------- Post Traffic hv1 dump -----------"
   as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int
   as hv1 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv2 dump -----------"
   as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int
   as hv2 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv3 dump -----------"
   as hv3 ovs-ofctl -O OpenFlow13 dump-flows br-int
   as hv3 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv4 dump -----------"
   as hv4 ovs-ofctl -O OpenFlow13 dump-flows br-int
   as hv4 ovs-appctl fdb/show br-phys

   OVN_CLEANUP([hv1],[hv2],[hv3],[hv4])

   AT_CLEANUP])])

DVR_N_S_ARP_HANDLING([geneve])
DVR_N_S_ARP_HANDLING([vxlan])

m4_define([DVR_N_S_PING],
  [OVN_FOR_EACH_NORTHD([
   AT_SETUP([ovn -- 2 HVs, 2 lports/HV, localnet ports, DVR N-S Ping, encap $1])
   AT_KEYWORDS([$1])
   encap=$1
   ovn_start

   # In this test cases we create 3 switches, all connected to same
   # physical network (through br-phys on each HV). LS1 and LS2 have
   # 1 VIF each. Each HV has 1 VIF port. The first digit
   # of VIF port name indicates the hypervisor it is bound to, e.g.
   # lp23 means VIF 3 on hv2.
   #
   # All the switches are connected to a logical router "router".
   #
   # Each switch's VLAN tag and their logical switch ports are:
   #   - ls1:
   #       - tagged with VLAN 101
   #       - ports: lp11
   #   - ls2:
   #       - tagged with VLAN 201
   #       - ports: lp22
   #   - ls-underlay:
   #       - tagged with VLAN 1000
   # Note: a localnet port is created for each switch to connect to
   # physical network.

   for i in 1 2; do
       ls_name=ls$i
       ovn-nbctl ls-add $ls_name
       ln_port_name=ln$i
       if test $i -eq 1; then
           ovn-nbctl lsp-add $ls_name $ln_port_name "" 101
       elif test $i -eq 2; then
           ovn-nbctl lsp-add $ls_name $ln_port_name "" 201
       fi
       ovn-nbctl lsp-set-addresses $ln_port_name unknown
       ovn-nbctl lsp-set-type $ln_port_name localnet
       ovn-nbctl lsp-set-options $ln_port_name network_name=phys
   done

   # lsp_to_ls LSP
   #
   # Prints the name of the logical switch that contains LSP.
   lsp_to_ls () {
       case ${1} in dnl (
           lp?[[11]]) echo ls1 ;; dnl (
           lp?[[12]]) echo ls2 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_hv () {
       case ${1} in dnl (
           vif[[1]]?) echo hv1 ;; dnl (
           vif[[2]]?) echo hv2 ;; dnl (
           vif?[[north]]?) echo hv4 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   net_add n1
   for i in 1 2; do
       sim_add hv$i
       as hv$i
       ovs-vsctl add-br br-phys
       ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
       ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:$i$i"
       ovn_attach n1 br-phys 192.168.0.$i 24 $encap

       ovs-vsctl add-port br-int vif$i$i -- \
           set Interface vif$i$i external-ids:iface-id=lp$i$i \
                                 options:tx_pcap=hv$i/vif$i$i-tx.pcap \
                                 options:rxq_pcap=hv$i/vif$i$i-rx.pcap \
                                 ofport-request=$i$i

       lsp_name=lp$i$i
       ls_name=$(lsp_to_ls $lsp_name)

       ovn-nbctl lsp-add $ls_name $lsp_name
       ovn-nbctl lsp-set-addresses $lsp_name "f0:00:00:00:00:$i$i 192.168.$i.$i"
       ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:$i$i

       OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])

   done

   ovn-nbctl ls-add ls-underlay
   ovn-nbctl lsp-add ls-underlay ln3 "" 1000
   ovn-nbctl lsp-set-addresses ln3 unknown
   ovn-nbctl lsp-set-type ln3 localnet
   ovn-nbctl lsp-set-options ln3 network_name=phys

   ovn-nbctl ls-add ls-north
   ovn-nbctl lsp-add ls-north ln4 "" 1000
   ovn-nbctl lsp-set-addresses ln4 unknown
   ovn-nbctl lsp-set-type ln4 localnet
   ovn-nbctl lsp-set-options ln4 network_name=phys

   # Add a VM on ls-north
   ovn-nbctl lsp-add ls-north lp-north
   ovn-nbctl lsp-set-addresses lp-north "f0:f0:00:00:00:11 172.31.0.10"
   ovn-nbctl lsp-set-port-security lp-north f0:f0:00:00:00:11

   # Add 3rd hypervisor
   sim_add hv3
   as hv3 ovs-vsctl add-br br-phys
   as hv3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
   as hv3 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:33"
   as hv3 ovn_attach n1 br-phys 192.168.0.3 24 $encap

   # Add 4th hypervisor
   sim_add hv4
   as hv4 ovs-vsctl add-br br-phys
   as hv4 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
   as hv4 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:44"
   as hv4 ovn_attach n1 br-phys 192.168.0.4 24 $encap

   as hv4 ovs-vsctl add-port br-int vif-north -- \
           set Interface vif-north external-ids:iface-id=lp-north \
                                 options:tx_pcap=hv4/vif-north-tx.pcap \
                                 options:rxq_pcap=hv4/vif-north-rx.pcap \
                                 ofport-request=44

   ovn-nbctl lr-add router
   ovn-nbctl lrp-add router router-to-ls1 00:00:01:01:02:03 192.168.1.3/24
   ovn-nbctl lrp-add router router-to-ls2 00:00:01:01:02:05 192.168.2.3/24
   ovn-nbctl lrp-add router router-to-underlay 00:00:01:01:02:07 172.31.0.1/24

   ovn-nbctl lsp-add ls1 ls1-to-router -- set Logical_Switch_Port ls1-to-router type=router \
             options:router-port=router-to-ls1 -- lsp-set-addresses ls1-to-router router
   ovn-nbctl lsp-add ls2 ls2-to-router -- set Logical_Switch_Port ls2-to-router type=router \
             options:router-port=router-to-ls2 -- lsp-set-addresses ls2-to-router router
   ovn-nbctl lsp-add ls-underlay underlay-to-router -- set Logical_Switch_Port \
                                 underlay-to-router type=router \
                                 options:router-port=router-to-underlay \
                                 -- lsp-set-addresses underlay-to-router router

   ovn-nbctl lrp-set-gateway-chassis router-to-underlay hv3
   ovn-nbctl lrp-set-redirect-type router-to-underlay bridged

   wait_for_ports_up
   ovn-nbctl --wait=sb sync


   OVN_POPULATE_ARP

   # lsp_to_ls LSP
   #
   # Prints the name of the logical switch that contains LSP.
   lsp_to_ls () {
       case ${1} in dnl (
           lp?[[11]]) echo ls1 ;; dnl (
           lp?[[12]]) echo ls2 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_ls () {
       case ${1} in dnl (
           vif?[[11]]) echo ls1 ;; dnl (
           vif?[[12]]) echo ls2 ;; dnl (
           vif-north) echo ls-north ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   hv_to_num () {
       case ${1} in dnl (
           hv1) echo 1 ;; dnl (
           hv2) echo 2 ;; dnl (
           hv3) echo 3 ;; dnl (
           hv4) echo 4 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_num () {
       case ${1} in dnl (
           vif22) echo 22 ;; dnl (
           vif21) echo 21 ;; dnl (
           vif11) echo 11 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_hv () {
       case ${1} in dnl (
           vif[[1]]?) echo hv1 ;; dnl (
           vif[[2]]?) echo hv2 ;; dnl (
           vif-north) echo hv4 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_lrp () {
       echo router-to-`vif_to_ls ${1}`
   }

   test_ip() {
           # This packet has bad checksums but logical L3 routing doesn't check.
           local inport=${1} src_mac=${2} dst_mac=${3} src_ip=${4} dst_ip=${5} outport=${6}
           local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
           shift; shift; shift; shift; shift
           hv=`vif_to_hv $inport`
           as $hv ovs-appctl netdev-dummy/receive $inport $packet
           in_ls=`vif_to_ls $inport`
           for outport; do
               out_ls=`vif_to_ls $outport`
               if test $in_ls = $out_ls; then
                   # Ports on the same logical switch receive exactly the same packet.
                   echo $packet
               else
                   # Routing decrements TTL and updates source and dest MAC
                   # (and checksum).
                   out_lrp=`vif_to_lrp $outport`
                   # For North-South, packet will come via gateway chassis, i.e hv3
                   if test $inport = vif-north; then
                       echo f0000000001100000101020308004500001c000000003f110100${src_ip}${dst_ip}0035111100080000 >> $outport.expected
                   fi
                   if test $outport = vif-north; then
                       echo f0f00000001100000101020708004500001c000000003e110200${src_ip}${dst_ip}0035111100080000 >> $outport.expected
                   fi
               fi >> $outport.expected
           done
   }

   # Dump a bunch of info helpful for debugging if there's a failure.

   echo "------ OVN dump ------"
   ovn-nbctl show
   ovn-sbctl show
   ovn-sbctl list port_binding
   ovn-sbctl list mac_binding

   echo "------ hv1 dump ------"
   as hv1 ovs-vsctl show
   as hv1 ovs-vsctl list Open_Vswitch

   echo "------ hv2 dump ------"
   as hv2 ovs-vsctl show
   as hv2 ovs-vsctl list Open_Vswitch

   echo "------ hv3 dump ------"
   as hv3 ovs-vsctl show
   as hv3 ovs-vsctl list Open_Vswitch

   echo "------ hv4 dump ------"
   as hv4 ovs-vsctl show
   as hv4 ovs-vsctl list Open_Vswitch

   echo "Send traffic North to South"

   sip=`ip_to_hex 172 31 0 10`
   dip=`ip_to_hex 192 168 1 1`
   test_ip vif-north f0f000000011 000001010207 $sip $dip vif11

   # Confirm that North to south traffic works fine.
   OVN_CHECK_PACKETS([hv1/vif11-tx.pcap], [vif11.expected])

   echo "Send traffic South to Nouth"
   sip=`ip_to_hex 192 168 1 1`
   dip=`ip_to_hex 172 31 0 10`
   test_ip vif11 f00000000011 000001010203 $sip $dip vif-north

   # Confirm that South to North traffic works fine.
   OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv4/vif-north-tx.pcap], [vif-north.expected])

   # Confirm that packets did not go out via tunnel port.
   AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep table=38 | grep NXM_NX_TUN_METADATA0 | grep n_packets=0 | wc -l], [0], [[0
]])

   # Confirm that packet went out via localnet port
   AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep table=65 | grep priority=150 | grep src=00:00:01:01:02:07 | grep n_packets=1 | wc -l], [0], [[1
]])

   echo "----------- Post Traffic hv1 dump -----------"
   as hv1 ovs-ofctl dump-flows br-int
   as hv1 ovs-ofctl show br-phys
   as hv1 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv2 dump -----------"
   as hv2 ovs-ofctl dump-flows br-int
   as hv2 ovs-ofctl show br-phys
   as hv2 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv3 dump -----------"
   as hv3 ovs-ofctl dump-flows br-int
   as hv3 ovs-ofctl show br-phys
   as hv3 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv4 dump -----------"
   as hv4 ovs-ofctl dump-flows br-int
   as hv4 ovs-ofctl show br-phys
   as hv4 ovs-appctl fdb/show br-phys

   OVN_CLEANUP([hv1],[hv2],[hv3],[hv4])

   AT_CLEANUP])])

DVR_N_S_PING([geneve])
DVR_N_S_PING([vxlan])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ARP lookup before learning])
AT_KEYWORDS([virtual ports])
ovn_start

send_garp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

send_arp_reply() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040002${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p3 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03"

# Create the second logical switch with one port
ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create a logical router and attach both logical switches
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

OVN_POPULATE_ARP
wait_for_ports_up
ovn-nbctl --wait=hv sync

as hv1 ovs-appctl -t ovn-controller vlog/set dbg

# From sw0-p1 send GARP for 10.0.0.30.
# ovn-controller should learn the
#   mac_binding entry
#     port - lr0-sw0
#     ip - 10.0.0.30
#     mac - 50:54:00:00:00:03

check_row_count MAC_Binding 0
eth_src=505400000003
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 30)
tpa=$(ip_to_hex 10 0 0 30)
send_garp 1 1 $eth_src $eth_dst $spa $tpa

wait_row_count MAC_Binding 1

AT_CHECK([ovn-sbctl --format=csv --bare --columns logical_port,ip,mac \
list mac_binding], [0], [lr0-sw0
10.0.0.30
50:54:00:00:00:03
])

AT_CHECK([test 1 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])
AT_CHECK([test 1 = `as hv1 ovs-ofctl dump-flows br-int table=10 | grep arp | \
grep controller | grep -v n_packets=0 | wc -l`])

# Wait for an entry in table=67
OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep n_packets=0 \
| wc -l`]
)

# Send garp again. This time the packet should not be sent to ovn-controller.
send_garp 1 1 $eth_src $eth_dst $spa $tpa
# Wait for an entry in table=67
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep n_packets=1 | wc -l`])

# The packet should not be sent to ovn-controller. The packet
# count should be 1 only.
AT_CHECK([test 1 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])
AT_CHECK([test 1 = `as hv1 ovs-ofctl dump-flows br-int table=10 | grep arp | \
grep controller | grep -v n_packets=0 | wc -l`])

# Now send garp packet with different mac.
eth_src=505400000013
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 30)
tpa=$(ip_to_hex 10 0 0 30)
send_garp 1 1 $eth_src $eth_dst $spa $tpa

# The garp packet should be sent to ovn-controller and the mac_binding entry
# should be updated.
OVS_WAIT_UNTIL([test 2 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

check_row_count MAC_Binding 1

AT_CHECK([ovn-sbctl --format=csv --bare --columns logical_port,ip,mac \
list mac_binding], [0], [lr0-sw0
10.0.0.30
50:54:00:00:00:13
])

# Send ARP request to lrp - lr0-sw1 (20.0.0.1) using src mac 50:54:00:00:00:33
# and src ip - 10.0.0.50.from sw0-p1.
# ovn-controller should add the mac_binding entry
#   logical_port - lr0
#   IP           - 10.0.0.50
#   MAC          - 50:54:00:00:00:33
eth_src=505400000033
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 50)
tpa=$(ip_to_hex 20 0 0 1)

send_garp 1 1 $eth_src $eth_dst $spa $tpa

# The garp packet should be sent to ovn-controller and the mac_binding entry
# should be updated.
OVS_WAIT_UNTIL([test 3 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=50:54:00:00:00:33 \
| wc -l`]
)

AT_CHECK([ovn-sbctl --format=csv --bare --columns logical_port,ip,mac \
find mac_binding ip=10.0.0.50], [0], [lr0-sw0
10.0.0.50
50:54:00:00:00:33
])

# Send the same packet again.
send_garp 1 1 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=50:54:00:00:00:33 \
| grep n_packets=1 | wc -l`]
)

AT_CHECK([test 3 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

# Now send ARP reply packet with IP - 10.0.0.40 and mac 505400000023
eth_src=505400000023
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 40)
tpa=$(ip_to_hex 10 0 0 50)
send_arp_reply 1 1 $eth_src $eth_dst $spa $tpa

# ovn-controller should add the
#   mac_binding entry
#     port - lr0-sw0
#     ip - 10.0.0.40
#     mac - 50:54:00:00:00:23

# The garp packet should be sent to ovn-controller and the mac_binding entry
# should be updated.
OVS_WAIT_UNTIL([test 4 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

# Wait for an entry in table=67 for the learnt mac_binding entry.

OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=50:54:00:00:00:23 \
| wc -l`]
)

# Send the same garp reply. This time it should not be sent to ovn-controller.
send_arp_reply 1 1 $eth_src $eth_dst $spa $tpa
OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=50:54:00:00:00:23 \
| grep n_packets=1 | wc -l`]
)

AT_CHECK([test 4 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

send_arp_reply 1 1 $eth_src $eth_dst $spa $tpa
OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=50:54:00:00:00:23 \
| grep n_packets=2 | wc -l`]
)

AT_CHECK([test 4 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- 1 HVs, 1 lport/HV, localnet ports, RARP])
ovn_start

# In this test case we create 1 switch and bring up a VIF on it.
# Logical switch will have a localnet port also.
# This VIF will be assigned a MAC address only (i.e. no ip).

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 ln1 "" 101
ovn-nbctl lsp-set-addresses ln1 unknown
ovn-nbctl lsp-set-type ln1 localnet
ovn-nbctl lsp-set-options ln1 network_name=phys

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.1

ovs-vsctl add-port br-int vif11 -- \
    set Interface vif11 external-ids:iface-id=lp11 \
                          options:tx_pcap=hv1/vif11-tx.pcap \
                          options:rxq_pcap=hv1/vif11-rx.pcap \
                          ofport-request=11

lsp_name=lp11

ovn-nbctl lsp-add ls1 lp11
ovn-nbctl lsp-set-addresses lp11 "f0:00:00:00:00:11"
ovn-nbctl lsp-set-port-security lp11 f0:00:00:00:00:11

wait_for_ports_up
ovn-nbctl --wait=sb sync

ovn-nbctl show
ovn-sbctl show

# Dump a bunch of info helpful for debugging if there's a failure.

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-vsctl list Open_Vswitch

echo "----------- Post Traffic hv1 dump -----------"
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int
as hv1 ovs-appctl fdb/show br-phys

OVS_WAIT_UNTIL(
    [test 1 = `ovs-appctl fdb/show br-phys | grep f0:00:00:00:00:11 | \
grep 101 | wc -l`])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Stateless Floating IP])
ovn_start

# In this test cases we create 3 switches, all connected to same
# physical network (through br-phys on each HV). LS1 and LS2 have
# 1 VIF each. Each HV has 1 VIF port. The first digit
# of VIF port name indicates the hypervisor it is bound to, e.g.
# lp23 means VIF 3 on hv2.
#
# All the switches are connected to a logical router "router".
#
# There is an external logical switch, ls-north.
# This test validates the stateless floating ip implementation.
#
# Each switch's VLAN tag and their logical switch ports are:
#   - ls1:
#       - tagged with VLAN 101
#       - ports: lp11
#   - ls2:
#       - tagged with VLAN 201
#       - ports: lp22
#   - ls-north:
#       - tagged with VLAN 1000
# Note: a localnet port is created for each switch to connect to
# physical network.

for i in 1 2; do
    ls_name=ls$i
    ovn-nbctl ls-add $ls_name
    ln_port_name=ln$i
    if test $i -eq 1; then
        ovn-nbctl lsp-add $ls_name $ln_port_name "" 101
    elif test $i -eq 2; then
        ovn-nbctl lsp-add $ls_name $ln_port_name "" 201
    fi
    ovn-nbctl lsp-set-addresses $ln_port_name unknown
    ovn-nbctl lsp-set-type $ln_port_name localnet
    ovn-nbctl lsp-set-options $ln_port_name network_name=phys
done

# lsp_to_ls LSP
#
# Prints the name of the logical switch that contains LSP.
lsp_to_ls () {
    case $1 in dnl (
        lp?[[11]]) echo ls1 ;; dnl (
        lp?[[12]]) echo ls2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_hv () {
    case $1 in dnl (
        vif[[1]]?) echo hv1 ;; dnl (
        vif[[2]]?) echo hv2 ;; dnl (
        vif?[[north]]?) echo hv4 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:$i$i"
    ovn_attach n1 br-phys 192.168.0.$i

    ovs-vsctl add-port br-int vif$i$i -- \
        set Interface vif$i$i external-ids:iface-id=lp$i$i \
                              options:tx_pcap=hv$i/vif$i$i-tx.pcap \
                              options:rxq_pcap=hv$i/vif$i$i-rx.pcap \
                              ofport-request=$i$i

    lsp_name=lp$i$i
    ls_name=$(lsp_to_ls $lsp_name)

    ovn-nbctl lsp-add $ls_name $lsp_name
    ovn-nbctl lsp-set-addresses $lsp_name "f0:00:00:00:00:$i$i 192.168.$i.$i"
    ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:$i$i

    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])

done

ovn-nbctl ls-add ls-underlay
ovn-nbctl lsp-add ls-underlay ln3 "" 1000
ovn-nbctl lsp-set-addresses ln3 unknown
ovn-nbctl lsp-set-type ln3 localnet
ovn-nbctl lsp-set-options ln3 network_name=phys

ovn-nbctl ls-add ls-north
ovn-nbctl lsp-add ls-north ln4 "" 1000
ovn-nbctl lsp-set-addresses ln4 unknown
ovn-nbctl lsp-set-type ln4 localnet
ovn-nbctl lsp-set-options ln4 network_name=phys

# Add a VM on ls-north
ovn-nbctl lsp-add ls-north lp-north
ovn-nbctl lsp-set-addresses lp-north "f0:f0:00:00:00:11 172.31.0.10"
ovn-nbctl lsp-set-port-security lp-north f0:f0:00:00:00:11

# Add 3rd hypervisor
sim_add hv3
as hv3 ovs-vsctl add-br br-phys
as hv3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
as hv3 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:33"
as hv3 ovn_attach n1 br-phys 192.168.0.3

# Add 4th hypervisor
sim_add hv4
as hv4 ovs-vsctl add-br br-phys
as hv4 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
as hv4 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:44"
as hv4 ovn_attach n1 br-phys 192.168.0.4

as hv4 ovs-vsctl add-port br-int vif-north -- \
        set Interface vif-north external-ids:iface-id=lp-north \
                              options:tx_pcap=hv4/vif-north-tx.pcap \
                              options:rxq_pcap=hv4/vif-north-rx.pcap \
                              ofport-request=44

ovn-nbctl lr-add router
ovn-nbctl lrp-add router router-to-ls1 00:00:01:01:02:03 192.168.1.3/24
ovn-nbctl lrp-add router router-to-ls2 00:00:01:01:02:05 192.168.2.3/24
ovn-nbctl lrp-add router router-to-underlay 00:00:01:01:02:07 172.31.0.1/24

ovn-nbctl lsp-add ls1 ls1-to-router -- set Logical_Switch_Port ls1-to-router type=router \
          options:router-port=router-to-ls1 -- lsp-set-addresses ls1-to-router router
ovn-nbctl lsp-add ls2 ls2-to-router -- set Logical_Switch_Port ls2-to-router type=router \
          options:router-port=router-to-ls2 -- lsp-set-addresses ls2-to-router router
ovn-nbctl lsp-add ls-underlay underlay-to-router -- set Logical_Switch_Port \
                              underlay-to-router type=router \
                              options:router-port=router-to-underlay \
                              -- lsp-set-addresses underlay-to-router router

ovn-nbctl lrp-set-gateway-chassis router-to-underlay hv3
ovn-nbctl --stateless lr-nat-add router dnat_and_snat 172.31.0.100 192.168.1.1
ovn-nbctl lrp-set-redirect-type router-to-underlay bridged

wait_for_ports_up
ovn-nbctl --wait=sb sync


OVN_POPULATE_ARP

# lsp_to_ls LSP
#
# Prints the name of the logical switch that contains LSP.
lsp_to_ls () {
    case $1 in dnl (
        lp?[[11]]) echo ls1 ;; dnl (
        lp?[[12]]) echo ls2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_ls () {
    case $1 in dnl (
        vif?[[11]]) echo ls1 ;; dnl (
        vif?[[12]]) echo ls2 ;; dnl (
        vif-north) echo ls-north ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

hv_to_num () {
    case $1 in dnl (
        hv1) echo 1 ;; dnl (
        hv2) echo 2 ;; dnl (
        hv3) echo 3 ;; dnl (
        hv4) echo 4 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_num () {
    case $1 in dnl (
        vif22) echo 22 ;; dnl (
        vif21) echo 21 ;; dnl (
        vif11) echo 11 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_hv () {
    case $1 in dnl (
        vif[[1]]?) echo hv1 ;; dnl (
        vif[[2]]?) echo hv2 ;; dnl (
        vif-north) echo hv4 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_lrp () {
    echo router-to-`vif_to_ls $1`
}

test_ip() {
        # This packet has bad checksums but logical L3 routing doesn't check.
        local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 outport=$6
        local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
        shift; shift; shift; shift; shift
        hv=`vif_to_hv $inport`
        as $hv ovs-appctl netdev-dummy/receive $inport $packet
        in_ls=`vif_to_ls $inport`
        for outport; do
            out_ls=`vif_to_ls $outport`
            if test $in_ls = $out_ls; then
                # Ports on the same logical switch receive exactly the same packet.
                echo $packet
            else
                # Routing decrements TTL and updates source and dest MAC
                # (and checksum).
                out_lrp=`vif_to_lrp $outport`
                # For North-South, packet will come via gateway chassis, i.e hv3
                if test $inport = vif-north; then
                    echo f0000000001100000101020308004500001c000000003f110100${src_ip}${dst_ip}0035111100080000 >> $outport.expected
                fi
                if test $outport = vif-north; then
                    echo f0f00000001100000101020708004500001c000000003e111726ac1f0064${dst_ip}0035111100080000 >> $outport.expected
                fi
            fi >> $outport.expected
        done
}

# Dump a bunch of info helpful for debugging if there's a failure.

echo "------ OVN dump ------"
ovn-nbctl show
ovn-nbctl lr-nat-list router
ovn-sbctl show
ovn-sbctl list port_binding
ovn-sbctl list mac_binding
ovn-sbctl dump-flows

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-vsctl list Open_Vswitch

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-vsctl list Open_Vswitch

echo "------ hv3 dump ------"
as hv3 ovs-vsctl show
as hv3 ovs-vsctl list Open_Vswitch

echo "------ hv4 dump ------"
as hv4 ovs-vsctl show
as hv4 ovs-vsctl list Open_Vswitch

echo "Send traffic South to Nouth"
sip=`ip_to_hex 192 168 1 1`
dip=`ip_to_hex 172 31 0 10`
test_ip vif11 f00000000011 000001010203 $sip $dip vif-north

# Confirm that South to North traffic works fine.
OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv4/vif-north-tx.pcap], [vif-north.expected])

# Confirm that NATing happened without connection tracker
ovn-sbctl dump-flows router > sbflows
AT_CAPTURE_FILE([sbflows])
AT_CHECK([for regex in ct_snat ct_dnat ip4.dst= ip4.src=; do
  grep -c "$regex" sbflows;
done], [0], [0
0
2
2
])

echo "----------- Post Traffic hv1 dump -----------"
as hv1 ovs-ofctl dump-flows br-int
as hv1 ovs-ofctl show br-phys
as hv1 ovs-appctl fdb/show br-phys
as hv1 ovs-dpctl dump-flows

echo "----------- Post Traffic hv2 dump -----------"
as hv2 ovs-ofctl dump-flows br-int
as hv2 ovs-ofctl show br-phys
as hv2 ovs-appctl fdb/show br-phys

echo "----------- Post Traffic hv3 dump -----------"
as hv3 ovs-ofctl dump-flows br-int
as hv3 ovs-ofctl show br-phys
as hv3 ovs-appctl dpctl/dump-conntrack
as hv3 ovs-appctl fdb/show br-phys
as hv3 ovs-dpctl dump-flows
as hv3 ovs-ofctl dump-flows br-int

echo "----------- Post Traffic hv4 dump -----------"
as hv4 ovs-ofctl dump-flows br-int
as hv4 ovs-ofctl show br-phys
as hv4 ovs-appctl fdb/show br-phys

OVN_CLEANUP([hv1],[hv2],[hv3],[hv4])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Load balancer health checks])
AT_KEYWORDS([lb])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

# Create port group and ACLs for sw0 ports.
check ovn-nbctl pg-add pg0_drop sw0-p1
check ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
check ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

# Create the second logical switch with one port
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1
check ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
check ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create port group and ACLs for sw1 ports.
check ovn-nbctl pg-add pg1_drop sw1-p1
check ovn-nbctl acl-add pg1_drop from-lport 1001 "inport == @pg1_drop && ip" drop
check ovn-nbctl acl-add pg1_drop to-lport 1001 "outport == @pg1_drop && ip" drop

check ovn-nbctl pg-add pg1 sw1-p1
check ovn-nbctl acl-add pg1 from-lport 1002 "inport == @pg1 && ip4" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 router
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

check ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80
OVN_LB_ID=$(ovn-nbctl --bare --column _uuid find load_balancer name=lb1)
check ovn-nbctl set load_balancer ${OVN_LB_ID} selection_fields="ip_dst,ip_src,tp_dst,tp_src"

check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2

AT_CHECK([ovn-nbctl --wait=sb \
          -- --id=@hc create Load_Balancer_Health_Check vip="10.0.0.10\:80" \
             options:failure_count=100 \
          -- add Load_Balancer . health_check @hc | uuidfilt], [0], [<0>
])

check ovn-nbctl --wait=sb ls-lb-add sw0 lb1
check ovn-nbctl --wait=sb ls-lb-add sw1 lb1
check ovn-nbctl --wait=sb lr-lb-add lr0 lb1

check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
check ovn-nbctl lsp-add public ln-public
check ovn-nbctl lsp-set-type ln-public localnet
check ovn-nbctl lsp-set-addresses ln-public unknown
check ovn-nbctl lsp-set-options ln-public network_name=public

# schedule the gw router port to a chassis. Change the name of the chassis
check ovn-nbctl --wait=hv lrp-set-gateway-chassis lr0-public hv1 20

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync

wait_row_count Service_Monitor 2

AT_CAPTURE_FILE([sbflows])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows > sbflows
   ovn-sbctl dump-flows sw0 | grep ct_lb | grep priority=120 | sed 's/table=..//'], 0,
  [  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg1 = 10.0.0.10; reg2[[0..15]] = 80; ct_lb(backends=10.0.0.3:80,20.0.0.3:80; hash_fields="ip_dst,ip_src,tcp_dst,tcp_src");)
])

AT_CAPTURE_FILE([sbflows2])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows > sbflows2
   ovn-sbctl dump-flows lr0 | grep ct_lb | grep priority=120 | sed 's/table=..//'], 0,
  [  (lr_in_dnat         ), priority=120  , match=(ct.new && ip && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80 && is_chassis_resident("cr-lr0-public")), action=(ct_lb(backends=10.0.0.3:80,20.0.0.3:80; hash_fields="ip_dst,ip_src,tcp_dst,tcp_src");)
])

# get the svc monitor mac.
svc_mon_src_mac=`ovn-nbctl get NB_Global . options:svc_monitor_mac | \
sed s/":"//g | sed s/\"//g`

OVS_WAIT_UNTIL(
    [test 1 = `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap | \
grep "505400000003${svc_mon_src_mac}" | wc -l`]
)

OVS_WAIT_UNTIL(
    [test 1 = `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/vif1-tx.pcap | \
grep "405400000003${svc_mon_src_mac}" | wc -l`]
)

check ovn-nbctl set load_balancer_health_check 10.0.0.10:80 options:failure_count=1
wait_row_count Service_Monitor 2 status=offline

OVS_WAIT_UNTIL(
    [test 2 = `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap | \
grep "505400000003${svc_mon_src_mac}" | wc -l`]
)

OVS_WAIT_UNTIL(
    [test 2 = `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/vif1-tx.pcap | \
grep "405400000003${svc_mon_src_mac}" | wc -l`]
)

AT_CAPTURE_FILE([sbflows3])
ovn-sbctl dump-flows sw0 > sbflows3
AT_CHECK(
  [grep "ip4.dst == 10.0.0.10 && tcp.dst == 80" sbflows3 | grep priority=120 |\
   sed 's/table=../table=??/'], [0],
  [  table=??(ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(drop;)
])

AT_CAPTURE_FILE([sbflows4])
ovn-sbctl dump-flows lr0 > sbflows4
AT_CHECK([grep lr_in_dnat sbflows4 | grep priority=120 | sed 's/table=..//' | sort], [0], [dnl
  (lr_in_dnat         ), priority=120  , match=(ct.est && ip && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80 && is_chassis_resident("cr-lr0-public")), action=(ct_dnat;)
  (lr_in_dnat         ), priority=120  , match=(ct.new && ip && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80 && is_chassis_resident("cr-lr0-public")), action=(drop;)
])

# Delete sw0-p1
check ovn-nbctl lsp-del sw0-p1

wait_row_count Service_Monitor 1

# Add back sw0-p1 but without any IP address.
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03" -- \
    lsp-set-port-security sw0-p1 "50:54:00:00:00:03"

wait_row_count Service_Monitor 2 status=offline

check ovn-nbctl lsp-del sw0-p1
check ovn-nbctl lsp-del sw1-p1
wait_row_count Service_Monitor 0

# Add back sw0-p1 but without any address set.
check ovn-nbctl lsp-add sw0 sw0-p1

wait_row_count Service_Monitor 1
wait_row_count Service_Monitor 0 status=offline
wait_row_count Service_Monitor 0 status=online

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- SCTP Load balancer health checks])
AT_KEYWORDS([lb sctp])

# Currently this test just ensures that no service monitors get created when
# An SCTP load balancer is configured to use health checks. Once SCTP load
# balancers are modified to allow health checks, this test should be altered
# to ensure the health check succeeds.

ovn_start

# Set up same network as previous health check test. As long as health checks
# aren't allowed for SCTP load balancers, the network will not be used for
# much. However, having the network in place will make it easy to alter when
# health checks are allowed.

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

# Create the second logical switch with one port
ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create a logical router and attach both logical switches
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 router
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80 sctp

ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:10.0.0.2

ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer . \
health_check @hc

ovn-nbctl --wait=sb ls-lb-add sw0 lb1
ovn-nbctl --wait=sb ls-lb-add sw1 lb1
ovn-nbctl --wait=sb lr-lb-add lr0 lb1

ovn-nbctl ls-add public
ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24
ovn-nbctl lsp-add public public-lr0
ovn-nbctl lsp-set-type public-lr0 router
ovn-nbctl lsp-set-addresses public-lr0 router
ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
ovn-nbctl lsp-add public ln-public
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-options ln-public network_name=public

# schedule the gw router port to a chassis. Change the name of the chassis
ovn-nbctl --wait=hv lrp-set-gateway-chassis lr0-public hv1 20

OVN_POPULATE_ARP
wait_for_ports_up
ovn-nbctl --wait=hv sync

# And now for the anticlimax. We need to ensure that there is no
# service monitor in the southbound db.
check_row_count Service_Monitor 0

# Let's also be sure the warning message about SCTP load balancers is
# is in the ovn-northd log

AT_CHECK([test 1 = `grep -c "SCTP load balancers do not currently support health checks" northd/NORTHD_TYPE.log`])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ARP/ND request broadcast limiting])
ovn_start

send_arp_request() {
    local hv=$1 inport=$2 eth_src=$3 spa=$4 tpa=$5
    local eth_dst=ffffffffffff
    local eth_type=0806
    local eth=${eth_dst}${eth_src}${eth_type}

    local arp=0001080006040001${eth_src}${spa}${eth_dst}${tpa}

    local request=${eth}${arp}
    check as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

send_nd_ns() {
    local hv=$1 inport=$2 eth_src=$3 spa=$4 tpa=$5 cksum=$6

    local eth_dst=ffffffffffff
    local eth_type=86dd
    local eth=${eth_dst}${eth_src}${eth_type}

    local ip_vhlen=60000000
    local ip_plen=0020
    local ip_next=3a
    local ip_ttl=ff
    local ip=${ip_vhlen}${ip_plen}${ip_next}${ip_ttl}${spa}${tpa}

    # Neighbor Solicitation
    local icmp6_type=87
    local icmp6_code=00
    local icmp6_rsvd=00000000
    # ICMPv6 source lla option
    local icmp6_opt=01
    local icmp6_optlen=01
    local icmp6=${icmp6_type}${icmp6_code}${cksum}${icmp6_rsvd}${tpa}${icmp6_opt}${icmp6_optlen}${eth_src}

    local request=${eth}${ip}${icmp6}

    check as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

src_mac=000000000001

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.1

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.2

# One Aggregation Switch connected to two Logical networks (routers).
check ovn-nbctl ls-add sw-agg
check ovn-nbctl lsp-add sw-agg sw-agg-ext \
    -- lsp-set-addresses sw-agg-ext 00:00:00:00:00:01

check ovn-nbctl lsp-add sw-agg sw-rtr1             \
    -- lsp-set-type sw-rtr1 router                 \
    -- lsp-set-addresses sw-rtr1 00:00:00:00:01:00 \
    -- lsp-set-options sw-rtr1 router-port=rtr1-sw
check ovn-nbctl lsp-add sw-agg sw-rtr2             \
    -- lsp-set-type sw-rtr2 router                 \
    -- lsp-set-addresses sw-rtr2 00:00:00:00:02:00 \
    -- lsp-set-options sw-rtr2 router-port=rtr2-sw

# Localnet port on the Aggregation Switch.
check ovn-nbctl lsp-add sw-agg sw-agg-ln
check ovn-nbctl lsp-set-addresses sw-agg-ln unknown
check ovn-nbctl lsp-set-type sw-agg-ln localnet
check ovn-nbctl lsp-set-options sw-agg-ln network_name=phys

# Configure L3 interface IPv4 & IPv6 on both routers.
check ovn-nbctl lr-add rtr1
check ovn-nbctl lrp-add rtr1 rtr1-sw 00:00:00:00:01:00 10.0.0.1/24 10::1/64

check ovn-nbctl lrp-add rtr1 rtr1-sw1 00:00:01:00:00:00 20.0.0.1/24 20::1/64

check ovn-nbctl lr-add rtr2
check ovn-nbctl lrp-add rtr2 rtr2-sw 00:00:00:00:02:00 10.0.0.2/24 10::2/64

# Configure router gateway ports.
check ovn-nbctl lrp-set-gateway-chassis rtr1-sw hv1 20
check ovn-nbctl lrp-set-gateway-chassis rtr2-sw hv1 20

# One private network behind rtr1 with two VMs.
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1 \
    -- lsp-set-addresses sw1-p1 00:00:00:01:00:00
check ovn-nbctl lsp-add sw1 sw1-p2 \
    -- lsp-set-addresses sw1-p2 00:00:00:02:00:00
check ovn-nbctl lsp-add sw1 sw1-rtr1                 \
    -- lsp-set-type sw1-rtr1 router                  \
    -- lsp-set-addresses sw1-rtr1 00:00:01:00:00:00  \
    -- lsp-set-options sw1-rtr1 router-port=rtr1-sw1

# Bind a "VM" connected to sw-agg on hv1.
as hv1
check ovs-vsctl -- add-port br-int hv1-vif0 -- \
    set interface hv1-vif0 external-ids:iface-id=sw-agg-ext \
    options:tx_pcap=hv1/vif0-tx.pcap \
    options:rxq_pcap=hv1/vif0-rx.pcap \
    ofport-request=1

# Bind a "VM" connected to sw1 on hv1.
as hv1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=2

# Bind a "VM" connected to sw1 on hv2.
as hv2
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=3

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

sw_dp_uuid=$(ovn-sbctl --bare --columns _uuid list datapath_binding sw-agg)
sw_dp_key=$(ovn-sbctl --bare --columns tunnel_key list datapath_binding sw-agg)
sw1_dp_key=$(ovn-sbctl --bare --columns tunnel_key list datapath_binding sw1)
r1_dp_key=$(ovn-sbctl --bare --columns tunnel_key list datapath_binding rtr1)

r1_tnl_key=$(ovn-sbctl --bare --columns tunnel_key list port_binding sw-rtr1)
r2_tnl_key=$(ovn-sbctl --bare --columns tunnel_key list port_binding sw-rtr2)

match_sw_metadata="metadata=0x${sw_dp_key}"
match_sw1_metadata="metadata=0x${sw1_dp_key}"
match_r1_metadata="metadata=0x${r1_dp_key}"

# Inject ARP request for first router owned IP address.
send_arp_request 1 0 ${src_mac} $(ip_to_hex 10 0 0 254) $(ip_to_hex 10 0 0 1)

# Verify that the ARP request is sent only to rtr1.
match_arp_req="priority=80.*${match_sw_metadata}.*arp_tpa=10.0.0.1,arp_op=1"
match_send_rtr1="load:0x${r1_tnl_key}->NXM_NX_REG15"
match_send_rtr2="load:0x${r2_tnl_key}->NXM_NX_REG15"

for var in sw_dp_uuid sw_dp_key sw1_dp_key r1_dp_key r1_tnl_key r2_tnl_key \
           match_arp_req match_send_rtr1 match_send_rtr2; do
   AS_VAR_COPY([value], [$var])
   echo "$var=$value"
done

as hv1
AT_CAPTURE_FILE([offlows])
OVS_WAIT_FOR_OUTPUT([
    ovs-ofctl dump-flows br-int > offlows
    for match in "$match_send_rtr1" "$match_send_rtr2"; do
        grep -E "$match_arp_req.*$match" offlows | grep -c 'n_packets=[[1-9]]'
    done
    :
], [0], [1
0
])

# Inject ND_NS for ofirst router owned IP address.
src_ipv6=00100000000000000000000000000254
dst_ipv6=00100000000000000000000000000001
send_nd_ns 1 0 ${src_mac} ${src_ipv6} ${dst_ipv6} 751d

# Verify that the ND_NS is sent only to rtr1.
match_nd_ns="priority=80.*${match_sw_metadata}.*icmp_type=135.*nd_target=10::1"

as hv1
OVS_WAIT_FOR_OUTPUT([
    ovs-ofctl dump-flows br-int > offlows
    for match in "$match_send_rtr1" "$match_send_rtr2"; do
        grep -E "$match_nd_ns.*$match" offlows | grep -c 'n_packets=[[1-9]]'
    done
    :
], [0], [1
0
])

# Configure load balancing on both routers.
check ovn-nbctl lb-add lb1-v4 10.0.0.11 42.42.42.1
check ovn-nbctl lb-add lb1-v6 10::11 42::1
check ovn-nbctl lr-lb-add rtr1 lb1-v4
check ovn-nbctl lr-lb-add rtr1 lb1-v6

check ovn-nbctl lb-add lb2-v4 10.0.0.22 42.42.42.2
check ovn-nbctl lb-add lb2-v6 10::22 42::2
check ovn-nbctl lr-lb-add rtr2 lb2-v4
check ovn-nbctl lr-lb-add rtr2 lb2-v6
check ovn-nbctl --wait=hv sync

# Inject ARP request for first router owned VIP address.
send_arp_request 1 0 ${src_mac} $(ip_to_hex 10 0 0 254) $(ip_to_hex 10 0 0 11)

# Verify that the ARP request is sent only to rtr1.
match_arp_req="priority=80.*${match_sw_metadata}.*arp_tpa=10.0.0.11,arp_op=1"
match_send_rtr1="load:0x${r1_tnl_key}->NXM_NX_REG15"
match_send_rtr2="load:0x${r2_tnl_key}->NXM_NX_REG15"

as hv1
OVS_WAIT_UNTIL([
    pkts_to_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep "${match_send_rtr1}" | \
    grep n_packets=1 -c)
    test "1" = "${pkts_to_rtr1}"
])
OVS_WAIT_UNTIL([
    pkts_to_rtr2=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep "${match_send_rtr2}" | \
    grep n_packets=1 -c)
    test "0" = "${pkts_to_rtr2}"
])

# Inject ND_NS for first router owned VIP address.
src_ipv6=00100000000000000000000000000254
dst_ipv6=00100000000000000000000000000011
send_nd_ns 1 0 ${src_mac} ${src_ipv6} ${dst_ipv6} 751d

# Verify that the ND_NS is sent only to rtr1.
match_nd_ns="priority=80.*${match_sw_metadata}.*icmp_type=135.*nd_target=10::11"

as hv1
OVS_WAIT_UNTIL([
    pkts_to_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep "${match_send_rtr1}" | \
    grep n_packets=1 -c)
    test "1" = "${pkts_to_rtr1}"
])
OVS_WAIT_UNTIL([
    pkts_to_rtr2=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep "${match_send_rtr2}" | \
    grep n_packets=1 -c)
    test "0" = "${pkts_to_rtr2}"
])

# Configure NAT on both routers.
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10.0.0.111 42.42.42.1
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10::111 42::1
check ovn-nbctl lr-nat-add rtr2 dnat_and_snat 10.0.0.222 42.42.42.2
check ovn-nbctl lr-nat-add rtr2 dnat_and_snat 10::222 42::2
check ovn-nbctl --wait=hv sync

# Configure FIP1 and FIP2 on rtr1 for sw1-p1 and sw1-p2.
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10.0.0.121 20.0.0.11 sw1-p1 00:00:00:01:00:00
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10::121 20::11 sw1-p1 00:00:00:01:00:00
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10.0.0.122 20.0.0.12 sw1-p2 00:00:00:02:00:00
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10::122 20::12 sw1-p2 00:00:00:02:00:00
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

# Check that broadcast domain limiting flows match only on IPs that are
# directly reachable via the router port.
# For sw-rtr1:
# - 10.0.0.1, 10::1, fe80::200:ff:fe00:100 - interface IPs.
# - 10.0.0.11, 10::11 - LB VIPs.
# - 10.0.0.111, 10.0.0.121, 10.0.0.122, 10::111, 10::121, 10::122 - DNAT IPs.
# For sw-rtr2:
# - 10.0.0.2, 10::2, fe80::200:ff:fe00:200 - interface IPs.
# - 10.0.0.22, 10::22 - LB VIPs.
# - 10.0.0.222, 10::222 - DNAT IPs.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=80,.*${match_sw_metadata}" | grep -oE "arp_tpa=[[0-9.]]+" | sort], [0], [dnl
arp_tpa=10.0.0.1
arp_tpa=10.0.0.11
arp_tpa=10.0.0.111
arp_tpa=10.0.0.121
arp_tpa=10.0.0.122
arp_tpa=10.0.0.2
arp_tpa=10.0.0.22
arp_tpa=10.0.0.222
])
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=80,.*${match_sw_metadata}" | grep -oE "nd_target=[[0-9a-f:]]+" | sort], [0], [dnl
nd_target=10::1
nd_target=10::11
nd_target=10::111
nd_target=10::121
nd_target=10::122
nd_target=10::2
nd_target=10::22
nd_target=10::222
nd_target=fe80::200:ff:fe00:100
nd_target=fe80::200:ff:fe00:200
])

# For sw1-rtr1:
# - 20.0.0.1, 20::1, fe80::200:1ff:fe00:0 - interface IPs.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=80,.*${match_sw1_metadata}" | grep -oE "arp_tpa=[[0-9.]]+" | sort], [0], [dnl
arp_tpa=20.0.0.1
])
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=80,.*${match_sw1_metadata}" | grep -oE "nd_target=[[0-9a-f:]]+" | sort], [0], [dnl
nd_target=20::1
nd_target=fe80::200:1ff:fe00:0
])

# Self originated ARP/NS with SMACs owned by rtr1-sw and rtr2-sw should be
# flooded:
# - 00:00:00:00:01:00 - interface MAC (rtr1-sw).
# - 00:00:00:00:02:00 - interface MAC (rtr2-sw).
# - 00:00:00:01:00:00 - dnat_and_snat external MAC.
# - 00:00:00:02:00:00 - dnat_and_snat external MAC.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=75,.*${match_sw_metadata}.*arp_op=1" | grep -oE "dl_src=[[0-9a-f:]]+" | sort], [0], [dnl
dl_src=00:00:00:00:01:00
dl_src=00:00:00:00:02:00
dl_src=00:00:00:01:00:00
dl_src=00:00:00:02:00:00
])
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=75,.*${match_sw_metadata}.*icmp_type=135" | grep -oE "dl_src=[[0-9a-f:]]+" | sort], [0], [dnl
dl_src=00:00:00:00:01:00
dl_src=00:00:00:00:02:00
dl_src=00:00:00:01:00:00
dl_src=00:00:00:02:00:00
])

# Self originated ARP/NS with SMACs owned by rtr1-sw1 should be flooded:
# - 00:00:01:00:00:00 - interface MAC.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=75,.*${match_sw1_metadata}.*arp_op=1" | grep -oE "dl_src=[[0-9a-f:]]+" | sort], [0], [dnl
dl_src=00:00:01:00:00:00
])

# Inject ARP request for first router owned NAT address.
send_arp_request 1 0 ${src_mac} $(ip_to_hex 10 0 0 254) $(ip_to_hex 10 0 0 111)

# Verify that the ARP request is sent only to rtr1.
match_arp_req="priority=80.*${match_sw_metadata}.*arp_tpa=10.0.0.111,arp_op=1"
match_send_rtr1="load:0x${r1_tnl_key}->NXM_NX_REG15"
match_send_rtr2="load:0x${r2_tnl_key}->NXM_NX_REG15"

as hv1
OVS_WAIT_UNTIL([
    pkts_to_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep "${match_send_rtr1}" | \
    grep n_packets=1 -c)
    test "1" = "${pkts_to_rtr1}"
])
OVS_WAIT_UNTIL([
    pkts_to_rtr2=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep "${match_send_rtr2}" | \
    grep n_packets=1 -c)
    test "0" = "${pkts_to_rtr2}"
])

# Inject ARP request for FIP1.
send_arp_request 1 0 ${src_mac} $(ip_to_hex 10 0 0 254) $(ip_to_hex 10 0 0 121)

# Verify that the ARP request is replied to from hv1 and not hv2.
match_arp_req="priority=92.*${match_r1_metadata}.*arp_tpa=10.0.0.121,arp_op=1"

as hv1
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep n_packets=1 -c)
    test "1" = "${pkts_on_rtr1}"
])

as hv2
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep n_packets=1 -c)
    test "0" = "${pkts_on_rtr1}"
])

# Inject ARP request for FIP2.
send_arp_request 1 0 ${src_mac} $(ip_to_hex 10 0 0 254) $(ip_to_hex 10 0 0 122)

# Verify that the ARP request is replied to from hv2 and not hv1.
match_arp_req="priority=92.*${match_r1_metadata}.*arp_tpa=10.0.0.122,arp_op=1"

as hv2
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep n_packets=1 -c)
    test "1" = "${pkts_on_rtr1}"
])

as hv1
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep n_packets=1 -c)
    test "0" = "${pkts_on_rtr1}"
])

# Inject ND_NS for first router owned IP address.
src_ipv6=00100000000000000000000000000254
dst_ipv6=00100000000000000000000000000111
send_nd_ns 1 0 ${src_mac} ${src_ipv6} ${dst_ipv6} 751d

# Verify that the ND_NS is sent only to rtr1.
match_nd_ns="priority=80.*${match_sw_metadata}.*icmp_type=135.*nd_target=10::111"

as hv1
OVS_WAIT_UNTIL([
    pkts_to_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep "${match_send_rtr1}" | \
    grep n_packets=1 -c)
    test "1" = "${pkts_to_rtr1}"
])
OVS_WAIT_UNTIL([
    pkts_to_rtr2=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep "${match_send_rtr2}" | \
    grep n_packets=1 -c)
    test "0" = "${pkts_to_rtr2}"
])

# Inject ND_NS for FIP1.
src_ipv6=00100000000000000000000000000254
dst_ipv6=00100000000000000000000000000121
send_nd_ns 1 0 ${src_mac} ${src_ipv6} ${dst_ipv6} 72dd

# Verify that the ND_NS is replied to from hv1 and not hv2.
match_nd_ns="priority=92.*${match_r1_metadata}.*icmp_type=135.*nd_target=10::121"

as hv1
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep n_packets=1 -c)
    test "1" = "${pkts_on_rtr1}"
])

as hv2
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep n_packets=1 -c)
    test "0" = "${pkts_on_rtr1}"
])

# Inject ND_NS for FIP2.
src_ipv6=00100000000000000000000000000254
dst_ipv6=00100000000000000000000000000122
send_nd_ns 1 0 ${src_mac} ${src_ipv6} ${dst_ipv6} 72db

# Verify that the ND_NS is replied to from hv2 and not hv1.
match_nd_ns="priority=92.*${match_r1_metadata}.*icmp_type=135.*nd_target=10::122"

as hv2
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep n_packets=1 -c)
    test "1" = "${pkts_on_rtr1}"
])

as hv1
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep n_packets=1 -c)
    test "0" = "${pkts_on_rtr1}"
])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- trace when flow cookie updated])
AT_KEYWORDS([cookie])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=lp1 ofport-request=1

ovn-nbctl ls-add lsw0
ovn-nbctl lsp-add lsw0 lp1
ovn-nbctl lsp-set-addresses lp1 "f0:00:00:00:00:01 10.0.0.1"
ovn-nbctl acl-add lsw0 from-lport 1000 'eth.type == 0x1234' drop

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Trace with --ovs should see ovs flow related to the ACL
AT_CHECK([ovn-trace --ovs lsw0 'inport == "lp1" && eth.type == 0x1234' | grep "dl_type=0x1234" | grep "cookie"], [0], [ignore])

# Replace the ACL with same match but different action.
ovn-nbctl acl-del lsw0 -- \
    acl-add lsw0 from-lport 1000 'eth.type == 0x1234' allow

check ovn-nbctl --wait=hv sync

# Trace with --ovs should still see the ovs flow related to the ACL, which
# means the OVS flow is updated with new cookie corresponding to the new lflow.
AT_CHECK([ovn-trace --ovs lsw0 'inport == "lp1" && eth.type == 0x1234' | grep "dl_type=0x1234 actions="], [0], [ignore])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- interconnection])

dnl This test has problems with ovn-northd-ddlog.
AT_SKIP_IF([test NORTHD_TYPE = ovn-northd-ddlog && test "$RUN_ANYWAY" != yes])

ovn_init_ic_db
n_az=5
n_ts=5
for i in `seq 1 $n_az`; do
    ovn_start az$i
done

net_add n1

# 1 HV and 1 GW per AZ
for az in `seq 1 $n_az`; do
    sim_add hv$az
    as hv$az
    check ovs-vsctl add-br br-phys
    ovn_az_attach az$az n1 br-phys 192.168.$az.1 16
    for p in `seq 1 $n_ts`; do
        check ovs-vsctl -- add-port br-int vif$p -- \
            set interface vif$p external-ids:iface-id=lsp$az-$p \
            options:tx_pcap=hv$az/vif$p-tx.pcap \
            options:rxq_pcap=hv$az/vif$p-rx.pcap \
            ofport-request=$p
    done

    sim_add gw$az
    as gw$az
    check ovs-vsctl add-br br-phys
    ovn_az_attach az$az n1 br-phys 192.168.$az.2 16
    check ovs-vsctl set open . external-ids:ovn-is-interconn=true
done

for ts in `seq 1 $n_ts`; do
    AT_CHECK([ovn-ic-nbctl create Transit_Switch name=ts$ts], [0], [ignore])
    for az in `seq 1 $n_az`; do
        echo "az$az: wait for ts$ts..."
        check ovn_as az$az ovn-nbctl wait-until logical_switch ts$ts
    done
done

for az in `seq 1 $n_az`; do
    ovn_as az$az
    check ovn-nbctl set nb_global . options:ic-route-learn=true
    check ovn-nbctl set nb_global . options:ic-route-adv=true

    # Each AZ has n_ts LSPi->LSi->LRi connecting to each TSi
    echo
    echo "az$az"
    for i in `seq 1 $n_ts`; do
        lsp_mac=00:00:00:0$az:0$i:00
        lrp_ls_mac=00:00:00:0$az:0$i:01
        lrp_ts_mac=00:00:00:0$az:0$i:02
        lsp_ip=10.$az.$i.123
        lrp_ls_ip=10.$az.$i.1
        lrp_ts_ip=169.254.$i.$az

        check ovn-nbctl ls-add ls$az-$i
        check ovn-nbctl lsp-add ls$az-$i lsp$az-$i
        check ovn-nbctl lsp-set-addresses lsp$az-$i "$lsp_mac $lsp_ip"

        check ovn-nbctl lr-add lr$az-$i

        check ovn-nbctl lrp-add lr$az-$i lrp-lr$az-$i-ls$az-$i $lrp_ls_mac $lrp_ls_ip/24
        check ovn-nbctl lsp-add ls$az-$i lsp-ls$az-$i-lr$az-$i
        check ovn-nbctl lsp-set-addresses lsp-ls$az-$i-lr$az-$i router
        check ovn-nbctl lsp-set-type lsp-ls$az-$i-lr$az-$i router
        check ovn-nbctl lsp-set-options lsp-ls$az-$i-lr$az-$i router-port=lrp-lr$az-$i-ls$az-$i

        check ovn-nbctl lrp-add lr$az-$i lrp-lr$az-$i-ts$i $lrp_ts_mac $lrp_ts_ip/24
        check ovn-nbctl lsp-add ts$i lsp-ts$i-lr$az-$i
        check ovn-nbctl lsp-set-addresses lsp-ts$i-lr$az-$i router
        check ovn-nbctl lsp-set-type lsp-ts$i-lr$az-$i router
        check ovn-nbctl lsp-set-options lsp-ts$i-lr$az-$i router-port=lrp-lr$az-$i-ts$i
        check ovn-nbctl lrp-set-gateway-chassis lrp-lr$az-$i-ts$i gw$az
    done
    check ovn-nbctl --wait=hv sync
    ovn-sbctl list Port_Binding > az$az.ports
    wait_for_ports_up
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

for i in `seq 1 $n_az`; do
    check ovn_as az$i ovn-nbctl --wait=hv sync
    ovn_as az$i ovn-sbctl dump-flows > az$i/sbflows
done

# Allow some time for ovn-northd and ovn-controller to catch up.
# XXX This should be more systematic.
sleep 2

ovn-ic-nbctl show > ic-nbctl.dump
AT_CAPTURE_FILE([ic-nbctl.dump])

(echo "---------ISB dump-----"
 ovn-ic-sbctl show
 echo "---------------------"
 ovn-ic-sbctl list gateway
 echo "---------------------"
 ovn-ic-sbctl list datapath_binding
 echo "---------------------"
 ovn-ic-sbctl list port_binding
 echo "---------------------"
 ovn-ic-sbctl list route
 echo "---------------------") > ic-sbctl.dump
AT_CAPTURE_FILE([ic-sbctl.dump])

AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
check_packets() {
    > expected
    > received
    for az in `seq 1 $n_az`; do
        for i in `seq 1 $n_ts`; do
            pcap=hv$az/vif$i-tx.pcap
            echo "--- $pcap" | tee -a expected >> received
            if test -e $az-$i.expected; then
                sort $az-$i.expected >> expected
            fi
            if test -e $pcap; then
                $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | sort >> received
            fi
            echo | tee -a expected >> received
        done
    done

    $at_diff expected received >/dev/null
}

# Send packets between AZs on each TS
for s_az in $(seq 1 $n_az); do
    ovn_as az${s_az}
    as hv${s_az}
    for d_az in $(seq 1 $n_az); do
        if test $s_az = $d_az; then
            continue
        fi

        for i in $(seq 1 $n_ts); do
            echo
            AS_BOX([packet from az$s_az to az$d_az via ts$i])
            lsp_smac=00:00:00:0${s_az}:0$i:00
            lsp_dmac=00:00:00:0${d_az}:0$i:00
            lrp_ls_smac=00:00:00:0${s_az}:0$i:01
            lrp_ls_dmac=00:00:00:0${d_az}:0$i:01
            lsp_sip=10.${s_az}.$i.123
            lsp_dip=10.${d_az}.$i.123

            ovn_inport=lsp${s_az}-$i
            packet="inport==\"$ovn_inport\" && eth.src==$lsp_smac && eth.dst==$lrp_ls_smac &&
                    ip4 && ip.ttl==64 && ip4.src==$lsp_sip && ip4.dst==$lsp_dip &&
                    udp && udp.src==53 && udp.dst==4369"
            echo "sending: $packet"
            AT_CHECK([ovn-trace --ovs "$packet" > ${s_az}-${d_az}-$i.ovn-trace])
            AT_CHECK([ovs-appctl -t ovn-controller inject-pkt "$packet"])
            ovs_inport=$(ovs-vsctl --bare --columns=ofport find Interface external-ids:iface-id="$ovn_inport")

            ovs_packet=$(echo $packet | ovstest test-ovn expr-to-packets)
            echo ovs_inport=$ovs_inport ovs_packet=$ovs_packet
            AT_CHECK([ovs-appctl ofproto/trace br-int in_port="$ovs_inport" "$ovs_packet" > ${s_az}-${d_az}-$i.ovs-trace])

            # Packet to Expect
            # The TTL should be decremented by 2.
            packet="eth.src==$lrp_ls_dmac && eth.dst==$lsp_dmac &&
                    ip4 && ip.ttl==62 && ip4.src==$lsp_sip && ip4.dst==$lsp_dip &&
                    udp && udp.src==53 && udp.dst==4369"
            echo $packet | ovstest test-ovn expr-to-packets >> ${d_az}-$i.expected
        done
    done
done
OVS_WAIT_UNTIL([check_packets], [$at_diff -F'^---' expected received])

for az in `seq 1 $n_az`; do
    OVN_CLEANUP_SBOX([hv$az])
    OVN_CLEANUP_SBOX([gw$az])
    OVN_CLEANUP_AZ([az$az])
done

OVN_CLEANUP_IC

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ECMP static routes])
ovn_start

# Logical network:
# ls1 (192.168.1.0/24) - lr1 - ls2 (192.168.2.0/24)
# lsl has lsp11 (192.168.1.11) and ls2 has lsp21 (192.168.2.21) and lsp22
# (192.168.2.22)
#
# Static routes on lr1:
# 10.0.0.0/24 nexthop 192.168.2.21
# 10.0.0.0/24 nexthop 192.168.2.22
#
# Test:
# lsp11 send packets to 10.0.0.*
#
# Expected result:
# Both lsp21 and lsp22 should received some of the packets.

ovn-nbctl lr-add lr1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

for i in 1 2; do
    ovn-nbctl lrp-add lr1 lrp-lr1-ls${i} 00:00:00:01:0${i}:01 192.168.${i}.1/24
    ovn-nbctl lsp-add ls${i} lsp-ls${i}-lr1 -- lsp-set-type lsp-ls${i}-lr1 router \
        -- lsp-set-options lsp-ls${i}-lr1 router-port=lrp-lr1-ls${i} \
        -- lsp-set-addresses lsp-ls${i}-lr1 router
done

#install static routes
ovn-nbctl lr-route-add lr1 10.0.0.0/24 192.168.2.21
ovn-nbctl --ecmp lr-route-add lr1 10.0.0.0/24 192.168.2.22

# Create logical ports
ovn-nbctl lsp-add ls1 lsp11 -- \
    lsp-set-addresses lsp11 "f0:00:00:00:01:11 192.168.1.11"
ovn-nbctl lsp-add ls2 lsp21 -- \
    lsp-set-addresses lsp21 "f0:00:00:00:02:21 192.168.2.21"
ovn-nbctl lsp-add ls2 lsp22 -- \
    lsp-set-addresses lsp22 "f0:00:00:00:02:22 192.168.2.22"

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp11 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=lsp21 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=lsp22 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

# wait for earlier changes to take effect
check ovn-nbctl --wait=hv sync
wait_for_ports_up

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

for i in $(seq 5001 5010); do
    packet="inport==\"lsp11\" && eth.src==f0:00:00:00:01:11 && eth.dst==00:00:00:01:01:01 &&
            ip4 && ip.ttl==64 && ip4.src==192.168.1.11 && ip4.dst==10.0.0.123 &&
            tcp && tcp.src==$i && tcp.dst==80"
    AT_CHECK([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

    for j in 1 2; do
        # Assume all packets go to lsp2${j}.
        exp_packet="eth.src==00:00:00:01:02:01 && eth.dst==f0:00:00:00:02:2${j} &&
                ip4 && ip.ttl==63 && ip4.src==192.168.1.11 && ip4.dst==10.0.0.123 &&
                tcp && tcp.src==$i && tcp.dst==80"
        echo $exp_packet | ovstest test-ovn expr-to-packets >> expected_lsp2${j}
    done
done

# Each port should receive some packets and the total number should be 10
OVS_WAIT_UNTIL([
    rcv_n1=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > lsp21.packets && cat lsp21.packets | wc -l`
    rcv_n2=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif3-tx.pcap > lsp22.packets && cat lsp22.packets | wc -l`
    echo $rcv_n1 $rcv_n2
    test $rcv_n1 -ge 1 -a $rcv_n2 -ge 1 -a $(($rcv_n1 + $rcv_n2)) -ge 10])

# Each port should receive a subset of expected packets
for i in 1 2; do
    sort expected_lsp2$i > expout
    AT_CHECK([cat lsp2${i}.packets expected_lsp2$i | sort | uniq], [0], [expout])
done

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- forwarding group: 3 HVs, 1 LR, 2 LS])
AT_KEYWORDS([forwarding-group])
ovn_start

# Logical network:
# One LR - R1 has a logical switch ls1 and ls2 connected to it.
# Logical switch ls1 has one port while ls2 has two logical switch ports as
# child ports.
check ovn-nbctl lr-add R1
check ovn-nbctl ls-add ls1
check ovn-nbctl ls-add ls2

# Logical switch ls1 to R1 connectivity
check ovn-nbctl lrp-add R1 R1-ls1 00:00:00:01:02:f1 192.168.1.1/24
check ovn-nbctl lsp-add ls1 ls1-R1 -- set Logical_Switch_Port ls1-R1 \
    type=router options:router-port=R1-ls1 -- lsp-set-addresses ls1-R1 router
check ovn-nbctl lsp-add ls1 lsp11 \
    -- lsp-set-addresses lsp11 "00:00:00:01:02:01 192.168.1.2"

# Logical switch ls2 to R1 connectivity
check ovn-nbctl lrp-add R1 R1-ls2 00:00:00:01:02:f2 172.16.1.1/24
check ovn-nbctl lsp-add ls2 ls2-R1 -- set Logical_Switch_Port ls2-R1 \
    type=router options:router-port=R1-ls2 -- lsp-set-addresses ls2-R1 router
check ovn-nbctl lsp-add ls2 lsp21 \
    -- lsp-set-addresses lsp21 "00:00:00:01:02:01 172.16.1.2"
check ovn-nbctl lsp-add ls2 lsp22 \
    -- lsp-set-addresses lsp22 "00:00:00:01:02:02 172.16.1.3"

# Create a network
net_add n1

# Create hypervisor hv1 connected to n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lsp11 options:tx_pcap=hv1/vif1-tx.pcap options:rxq_pcap=hv1/vif1-rx.pcap ofport-request=1

# Create hypervisor hv2 connected to n1
sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl add-port br-int vif2 -- set Interface vif2 external-ids:iface-id=lsp21 options:tx_pcap=hv2/vif2-tx.pcap options:rxq_pcap=hv2/vif2-rx.pcap ofport-request=1

# Create hypervisor hv3 connected to n1
sim_add hv3
as hv3
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
check ovs-vsctl add-port br-int vif3 -- set Interface vif3 external-ids:iface-id=lsp22 options:tx_pcap=hv3/vif3-tx.pcap options:rxq_pcap=hv3/vif3-rx.pcap ofport-request=1

# Add a forwarding group on ls2 with lsp21 and lsp22 as child ports
# virtual IP - 172.16.1.11, virtual MAC - 00:11:de:ad:be:ef
check ovn-nbctl --wait=hv fwd-group-add fwd_grp1 ls2 172.16.1.11 00:11:de:ad:be:ef lsp21 lsp22

# Check logical flow
AT_CAPTURE_FILE([sbflows])
ovn-sbctl dump-flows > sbflows
AT_CHECK([grep ls_in_l2_lkup sbflows | grep fwd_group | wc -l], [0], [1
])

# Check openflow rule with "group" on hypervisor
AT_CAPTURE_FILE([offlows])
as hv1 ovs-ofctl dump-flows br-int > offlows
AT_CHECK([grep -c "dl_dst=00:11:de:ad:be:ef actions=group" offlows], [0], [1
])

# Verify openflow group members
 # Verify openflow group members
AT_CAPTURE_FILE([ofgroups])
as hv1 ovs-ofctl -O OpenFlow13 dump-groups br-int > ofgroups
for child_port in lsp21 lsp22; do
    tunnel_key=`ovn-sbctl get Port_Binding $child_port tunnel_key`
    AT_CHECK([grep -c "bucket=actions=load:0x"$tunnel_key ofgroups], [0], [1
])
done

# Send a packet to virtual IP
src_mac=00:00:00:01:02:01
dst_mac=00:00:00:01:02:f1
src_ip=192.168.1.2
dst_ip=172.16.1.11
packet="inport==\"lsp11\" && eth.src==$src_mac && eth.dst==$dst_mac &&
        ip4 && ip.ttl==64 && ip4.src==$src_ip && ip4.dst==$dst_ip &&
        udp && udp.src==53 && udp.dst==4369"
check as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"

# Check if the packet hit the forwarding group policy
AT_CAPTURE_FILE([offlows2])
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int > offlows2
    grep "dl_dst=00:11:de:ad:be:ef actions=group" offlows2 | \
    grep "n_packets=1" | wc -l], [0], [1
])

# Delete the forwarding group
check ovn-nbctl fwd-group-del fwd_grp1

# Add a forwarding group with liveness on ls2 with lsp21 and lsp22 as child
# ports virtual IP - 172.16.1.11, virtual MAC - 00:11:de:ad:be:ef
check ovn-nbctl --wait=hv --liveness fwd-group-add fwd_grp1 ls2 172.16.1.11 00:11:de:ad:be:ef lsp21 lsp22

# Verify openflow group members
ofport_lsp21=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-hv2-0)
tunnel_key=`ovn-sbctl --bare --column tunnel_key find port_binding logical_port=lsp21`
AT_CHECK([as hv1 ovs-ofctl -O OpenFlow13 dump-groups br-int | \
    grep "bucket=watch_port:$ofport_lsp21,actions=load:0x"$tunnel_key | wc -l], [0], [dnl
1
])

ofport_lsp22=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-hv3-0)
tunnel_key=`ovn-sbctl --bare --column tunnel_key find port_binding logical_port=lsp22`
AT_CHECK([as hv1 ovs-ofctl -O OpenFlow13 dump-groups br-int | \
    grep "bucket=watch_port:$ofport_lsp22,actions=load:0x"$tunnel_key | wc -l], [0], [dnl
1
])

OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Load Balancer LS hairpin])
ovn_start

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

build_udp() {
    local sport=$1 dport=$2 chksum=$3
    local len=000a
    echo ${sport}${dport}${len}${chksum}0000
}

build_tcp_syn() {
    local sport=$1 dport=$2 chksum=$3
    local seq=00000001
    local ack=00000000
    local hlen_flags=5002
    local win=00ff
    local urg=0000
    echo ${sport}${dport}${seq}${ack}${hlen_flags}${win}${chksum}${urg}
}

send_ipv4_pkt() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4
    local ip_src=$5 ip_dst=$6 ip_proto=$7 ip_len=$8
    local l4_payload=$9
    local hp_ip_src=${10}
    local hp_l4_payload=${11}
    local outfile=${12}

    local ip_ttl=40

    local eth=${eth_dst}${eth_src}0800
    local hp_eth=${eth_src}${eth_dst}0800
    local ip=4500${ip_len}00004000${ip_ttl}${ip_proto}0000${ip_src}${ip_dst}
    ip=$(ip4_csum_inplace $ip)
    local hp_ip=4500${ip_len}00004000${ip_ttl}${ip_proto}0000${hp_ip_src}${ip_src}
    hp_ip=$(ip4_csum_inplace ${hp_ip})
    local packet=${eth}${ip}${l4_payload}
    local hp_packet=${hp_eth}${hp_ip}${hp_l4_payload}

    echo ${hp_packet} >> ${outfile}
    as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

send_ipv6_pkt() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4
    local ip_src=$5 ip_dst=$6 ip_proto=$7 ip_len=$8
    local l4_payload=$9
    local hp_ip_src=${10}
    local hp_l4_payload=${11}
    local outfile=${12}

    local ip_ttl=40

    local eth=${eth_dst}${eth_src}86dd
    local hp_eth=${eth_src}${eth_dst}86dd
    local ip=60000000${ip_len}${ip_proto}${ip_ttl}${ip_src}${ip_dst}
    local hp_ip=60000000${ip_len}${ip_proto}${ip_ttl}${hp_ip_src}${ip_src}
    local packet=${eth}${ip}${l4_payload}
    local hp_packet=${hp_eth}${hp_ip}${hp_l4_payload}

    echo ${hp_packet} >> ${outfile}
    as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

# One logical switch with IPv4 and IPv6 load balancers that hairpin the
# traffic.
# Also create "duplicate" load balancers, i.e., different VIPs using the same
# backends.
ovn-nbctl ls-add sw
ovn-nbctl lsp-add sw lsp -- lsp-set-addresses lsp 00:00:00:00:00:01
ovn-nbctl lb-add lb-ipv4-tcp     88.88.88.88:8080 42.42.42.1:4041 tcp
ovn-nbctl lb-add lb-ipv4-tcp-dup 88.88.88.89:8080 42.42.42.1:4041 tcp
ovn-nbctl lb-add lb-ipv4-udp     88.88.88.88:4040 42.42.42.1:2021 udp
ovn-nbctl lb-add lb-ipv4-udp-dup 88.88.88.89:4040 42.42.42.1:2021 udp
ovn-nbctl lb-add lb-ipv6-tcp     [[8800::0088]]:8080 [[4200::1]]:4041 tcp
ovn-nbctl lb-add lb-ipv6-tcp-dup [[8800::0089]]:8080 [[4200::1]]:4041 tcp
ovn-nbctl lb-add lb-ipv6-udp     [[8800::0088]]:4040 [[4200::1]]:2021 udp
ovn-nbctl lb-add lb-ipv6-udp-dup [[8800::0089]]:4040 [[4200::1]]:2021 udp
ovn-nbctl ls-lb-add sw lb-ipv4-tcp
ovn-nbctl ls-lb-add sw lb-ipv4-tcp-dup
ovn-nbctl ls-lb-add sw lb-ipv4-udp
ovn-nbctl ls-lb-add sw lb-ipv4-udp-dup
ovn-nbctl ls-lb-add sw lb-ipv6-tcp
ovn-nbctl ls-lb-add sw lb-ipv6-tcp-dup
ovn-nbctl ls-lb-add sw lb-ipv6-udp
ovn-nbctl ls-lb-add sw lb-ipv6-udp-dup

ovn-nbctl lr-add rtr
ovn-nbctl lrp-add rtr rtr-sw 00:00:00:00:01:00 42.42.42.254/24 4200::00ff/64
ovn-nbctl lsp-add sw sw-rtr                       \
    -- lsp-set-type sw-rtr router                 \
    -- lsp-set-addresses sw-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw-rtr router-port=rtr-sw

ovn-nbctl --wait=hv sync
wait_for_ports_up

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])
> expected

AS_BOX([IPv4 TCP Hairpin])

# Inject IPv4 TCP packets from lsp.
tcp_payload=$(build_tcp_syn 84d0 1f90 05a7)
hp_tcp_payload=$(build_tcp_syn 84d0 0fc9 156e)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 88) \
    06 0028 \
    ${tcp_payload} \
    $(ip_to_hex 88 88 88 88) ${hp_tcp_payload} \
    expected

tcp_payload=$(build_tcp_syn 84d1 1f90 05a5)
hp_tcp_payload=$(build_tcp_syn 84d1 0fc9 156c)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 89) \
    06 0028 \
    ${tcp_payload} \
    $(ip_to_hex 88 88 88 89) ${hp_tcp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.88,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
])

# Change LB Hairpin SNAT IP.
# Also flush conntrack to avoid reusing an existing entry.
as hv1 ovs-appctl dpctl/flush-conntrack

ovn-nbctl --wait=hv set load_balancer lb-ipv4-tcp options:hairpin_snat_ip="88.88.88.87"
# Inject IPv4 TCP packets from lsp.
tcp_payload=$(build_tcp_syn 84d0 1f90 05a7)
hp_tcp_payload=$(build_tcp_syn 84d0 0fc9 156f)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 88) \
    06 0028 \
    ${tcp_payload} \
    $(ip_to_hex 88 88 88 87) ${hp_tcp_payload} \
    expected

tcp_payload=$(build_tcp_syn 84d1 1f90 05a5)
hp_tcp_payload=$(build_tcp_syn 84d1 0fc9 156c)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 89) \
    06 0028 \
    ${tcp_payload} \
    $(ip_to_hex 88 88 88 89) ${hp_tcp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
])

AS_BOX([IPv4 UDP Hairpin])

# Inject IPv4 UDP packets from lsp.
udp_payload=$(build_udp 84d0 0fc8 6666)
hp_udp_payload=$(build_udp 84d0 07e5 6e49)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 88) \
    11 001e \
    ${udp_payload} \
    $(ip_to_hex 88 88 88 88) ${hp_udp_payload} \
    expected

udp_payload=$(build_udp 84d1 0fc8 6664)
hp_udp_payload=$(build_udp 84d1 07e5 6e47)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 89) \
    11 001e \
    ${udp_payload} \
    $(ip_to_hex 88 88 88 89) ${hp_udp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.88,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

# Change LB Hairpin SNAT IP.
# Also flush conntrack to avoid reusing an existing entry.
as hv1 ovs-appctl dpctl/flush-conntrack
ovn-nbctl --wait=hv set load_balancer lb-ipv4-udp options:hairpin_snat_ip="88.88.88.87"
# Inject IPv4 UDP packets from lsp.
udp_payload=$(build_udp 84d0 0fc8 6666)
hp_udp_payload=$(build_udp 84d0 07e5 6e4a)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 88) \
    11 001e \
    ${udp_payload} \
    $(ip_to_hex 88 88 88 87) ${hp_udp_payload} \
    expected

udp_payload=$(build_udp 84d1 0fc8 6664)
hp_udp_payload=$(build_udp 84d1 07e5 6e47)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 89) \
    11 001e \
    ${udp_payload} \
    $(ip_to_hex 88 88 88 89) ${hp_udp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

AS_BOX([IPv6 TCP Hairpin])

# Inject IPv6 TCP packets from lsp.
tcp_payload=$(build_tcp_syn 84d0 1f90 3ff9)
hp_tcp_payload=$(build_tcp_syn 84d0 0fc9 4fc0)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000088 \
    06 0014 \
    ${tcp_payload} \
    88000000000000000000000000000088 ${hp_tcp_payload} \
    expected

tcp_payload=$(build_tcp_syn 84d1 1f90 3ff7)
hp_tcp_payload=$(build_tcp_syn 84d1 0fc9 4fbe)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000089 \
    06 0014 \
    ${tcp_payload} \
    88000000000000000000000000000089 ${hp_tcp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::88,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

# Change LB Hairpin SNAT IP.
# Also flush conntrack to avoid reusing an existing entry.
as hv1 ovs-appctl dpctl/flush-conntrack
ovn-nbctl --wait=hv set load_balancer lb-ipv6-tcp options:hairpin_snat_ip="8800::0087"

# Inject IPv6 TCP packets from lsp.
tcp_payload=$(build_tcp_syn 84d0 1f90 3ff9)
hp_tcp_payload=$(build_tcp_syn 84d0 0fc9 4fc1)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000088 \
    06 0014 \
    ${tcp_payload} \
    88000000000000000000000000000087 ${hp_tcp_payload} \
    expected

tcp_payload=$(build_tcp_syn 84d1 1f90 3ff7)
hp_tcp_payload=$(build_tcp_syn 84d1 0fc9 4fbe)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000089 \
    06 0014 \
    ${tcp_payload} \
    88000000000000000000000000000089 ${hp_tcp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

AS_BOX([IPv6 UDP Hairpin])

# Inject IPv6 UDP packets from lsp.
udp_payload=$(build_udp 84d0 0fc8 a0b8)
hp_udp_payload=$(build_udp 84d0 07e5 a89b)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000088 \
    11 000a \
    ${udp_payload} \
    88000000000000000000000000000088 ${hp_udp_payload} \
    expected

udp_payload=$(build_udp 84d1 0fc8 a0b6)
hp_udp_payload=$(build_udp 84d1 07e5 a899)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000089 \
    11 000a \
    ${udp_payload} \
    88000000000000000000000000000089 ${hp_udp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::88,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

# Change LB Hairpin SNAT IP.
# Also flush conntrack to avoid reusing an existing entry.
as hv1 ovs-appctl dpctl/flush-conntrack
ovn-nbctl --wait=hv set load_balancer lb-ipv6-udp options:hairpin_snat_ip="8800::0087"

# Inject IPv6 UDP packets from lsp.
udp_payload=$(build_udp 84d0 0fc8 a0b8)
hp_udp_payload=$(build_udp 84d0 07e5 a89b)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000088 \
    11 000a \
    ${udp_payload} \
    88000000000000000000000000000087 ${hp_udp_payload} \
    expected

udp_payload=$(build_udp 84d1 0fc8 a0b6)
hp_udp_payload=$(build_udp 84d1 07e5 a899)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000089 \
    11 000a \
    ${udp_payload} \
    88000000000000000000000000000089 ${hp_udp_payload} \
    expected

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

AS_BOX([Delete VIP])
check ovn-nbctl --wait=hv set Load_Balancer lb-ipv4-tcp vips='"88.88.88.88:8080"=""'
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

AS_BOX([Delete LB])
check ovn-nbctl --wait=hv     \
    -- lb-del lb-ipv4-tcp     \
    -- lb-del lb-ipv4-tcp-dup \
    -- lb-del lb-ipv4-udp     \
    -- lb-del lb-ipv4-udp-dup

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

check ovn-nbctl --wait=hv     \
    -- lb-del lb-ipv6-tcp     \
    -- lb-del lb-ipv6-tcp-dup
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

check ovn-nbctl --wait=hv     \
    -- lb-del lb-ipv6-udp     \
    -- lb-del lb-ipv6-udp-dup
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [1], [dnl
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Big Load Balancer])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 lsp1

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl add-port br-int p1 -- set Interface p1 external-ids:iface-id=lsp1

IPS=192.169.0.1:80
for i in `seq 1 9` ; do
    for j in `seq 1 254` ; do
        IPS=${IPS},192.169.$i.$j:80
    done
done

ovn-nbctl lb-add lb0 172.172.0.1:8080 "${IPS}"
ovn-nbctl --wait=hv ls-lb-add ls1 lb0

AT_CHECK([test 2287 = `ovs-ofctl dump-group-stats br-int | grep -o bucket | wc -l`])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Bind existing VIF])
net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-int
ovs-vsctl add-port br-int p1 \
    -- set Interface p1 external-ids:iface-id=lsp1 \
    -- set Interface p1 ofport-request=1
OVS_WAIT_UNTIL([ovs-vsctl list Interface p1])

ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl --wait=sb lsp-add ls1 lsp1

# Simulate the fact that lsp1 had been previously bound on hv1.
ovn-sbctl --id=@e create encap chassis_name=hv1 ip="192.168.0.1" type="geneve" \
    -- --id=@c create chassis name=hv1 encaps=@e \
    -- set Port_Binding lsp1 chassis=@c

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Chassis hv1 should add flows for the ls1 datapath in table 8 (ls_in_port_sec_l2).
dp_key=$(ovn-sbctl --bare --columns tunnel_key list Datapath_Binding ls1)
OVS_WAIT_UNTIL([as hv1 ovs-ofctl dump-flows br-int | grep -E "table=8.*metadata=0x${dp_key}"], [0], [ignore])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Release stale port binding])
net_add n1
sim_add hv1

ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl --wait=sb lsp-add ls1 lsp1

# Simulate the fact that lsp1 had been previously bound on hv1.
ovn-sbctl --id=@e create encap chassis_name=hv1 ip="192.168.0.1" type="geneve" \
    -- --id=@c create chassis hostname=hv1 name=hv1 encaps=@e \
    -- set Port_Binding lsp1 chassis=@c

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Port_Binding should be released.
OVS_WAIT_UNTIL([test 0 = $(ovn-sbctl show | grep Port_Binding -c)], [0])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Logical router policy packet marking])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-port1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-port2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

as hv1 check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=public:br-phys

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 10.0.0.5"
check ovn-nbctl lsp-set-port-security sw0-port1 "50:54:00:00:00:03 10.0.0.3 10.0.0.5"

check ovn-nbctl lsp-add sw0 sw0-port2
check ovn-nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 aef0::4"

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 aef0::1/64
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24 bef0::1/64
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
check ovn-nbctl lsp-add public ln-public
check ovn-nbctl lsp-set-type ln-public localnet
check ovn-nbctl lsp-set-addresses ln-public unknown
check ovn-nbctl lsp-set-options ln-public network_name=public

check ovn-nbctl lrp-set-gateway-chassis lr0-public hv1 20
check ovn-nbctl lr-nat-add lr0 snat 172.168.0.100 10.0.0.0/24
check ovn-nbctl --wait=hv sync
wait_for_ports_up

wait_row_count datapath_binding 1 external-ids:name=lr0
lr0_dp_uuid=$(ovn-sbctl --bare --columns _uuid list datapath_binding lr0)

AT_CHECK(
  [ovn-sbctl create mac_binding datapath=$lr0_dp_uuid ip=172.168.0.120 \
       logical_port=lr0-public mac="10\:54\:00\:00\:00\:03"
   ovn-sbctl create mac_binding datapath=$lr0_dp_uuid ip=172.168.0.200 \
       logical_port=lr0-public mac="10\:54\:00\:00\:00\:04"
   ovn-sbctl create mac_binding datapath=$lr0_dp_uuid ip="bef0\:\:4" \
       logical_port=lr0-public mac="10\:54\:00\:00\:00\:05"
   ovn-sbctl create mac_binding datapath=$lr0_dp_uuid ip="bef0\:\:5" \
       logical_port=lr0-public mac="10\:54\:00\:00\:00\:06"
   ovn-sbctl create mac_binding datapath=$lr0_dp_uuid ip="bef0\:\:6" \
       logical_port=lr0-public mac="10\:54\:00\:00\:00\:07"
   ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
       ip_prefix="\:\:/64" nexthop="bef0\:\:4" -- add Logical_Router lr0 \
       static_routes @lrt],
  [0], [stdout])
AT_CHECK([uuidfilt stdout], [0],
  [<0>
<1>
<2>
<3>
<4>
<5>
])

check ovn-nbctl --wait=hv sync

# Add logical router policy and set pkt_mark on it.
check ovn-nbctl lr-policy-add lr0 2000 "ip4.src == 10.0.0.3" allow pkt_mark=100
check ovn-nbctl lr-policy-add lr0 1000 "ip4.src == 10.0.0.4" allow
check ovn-nbctl lr-policy-add lr0 900 "ip4.src == 10.0.0.5" reroute 172.168.0.200 pkt_mark=3
check ovn-nbctl lr-policy-add lr0 2001 "ip6.dst == bef0::5" reroute bef0::6
check ovn-nbctl lr-policy-add lr0 1001 "ip6" allow

pol1=$(ovn-nbctl --bare --columns _uuid find logical_router_policy priority=2000)
pol4=$(ovn-nbctl --bare --columns _uuid find logical_router_policy priority=2001)
pol5=$(ovn-nbctl --bare --columns _uuid find logical_router_policy priority=1001)

check ovn-nbctl set logical_router_policy $pol4 options:pkt_mark=4
check ovn-nbctl set logical_router_policy $pol5 options:pkt_mark=4294967295
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])
AT_CAPTURE_FILE([offlows])
OVS_WAIT_UNTIL([
    as hv1 ovs-ofctl dump-flows br-int table=20 > offlows
    test $(grep -c "load:0x64->NXM_NX_PKT_MARK" offlows) = 1 && \
    test $(grep -c "load:0x3->NXM_NX_PKT_MARK" offlows) = 1 && \
    test $(grep -c "load:0x4->NXM_NX_PKT_MARK" offlows) = 1 && \
    test $(grep -c "load:0xffffffff->NXM_NX_PKT_MARK" offlows) = 1
])

as hv1 check ovs-ofctl del-flows br-phys
AT_DATA([flows.txt], [dnl
table=0, priority=0 actions=NORMAL
table=0, priority=200 arp,actions=drop
table=0, priority=100, pkt_mark=0x64 actions=drop
table=0, priority=100, pkt_mark=0x2 actions=drop
table=0, priority=100, pkt_mark=0x3 actions=drop
table=0, priority=100, pkt_mark=0x4 actions=drop
table=0, priority=100, pkt_mark=0xffffffff actions=drop
])

as hv1 check ovs-ofctl --protocols=OpenFlow13 add-flows br-phys flows.txt
sleep 5

send_ipv4_pkt() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4
    local ip_src=$5 ip_dst=$6
    packet=${eth_dst}${eth_src}08004500001c0000000040110000${ip_src}${ip_dst}0035111100080000
    tcpdump_hex $packet
    as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

send_icmp6_packet() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6

    local ip6_hdr=6000000000083aff${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}8000dcb662f00001

    as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

send_ipv4_pkt hv1 hv1-vif1 505400000003 00000000ff01 \
    $(ip_to_hex 10 0 0 3) $(ip_to_hex 172 168 0 120)

AT_CAPTURE_FILE([offlows2])
OVS_WAIT_UNTIL([
    as hv1 ovs-ofctl dump-flows br-phys table=0 > offlows2
    test 1 -eq $(grep "priority=100,pkt_mark=0x64" offlows2 | \
                 grep -c "n_packets=1")
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep priority=0 | \
    grep "n_packets=0" -c)
])

# Send the pkt from sw0-port2. Packet should not be marked.
send_ipv4_pkt hv1 hv1-vif2 505400000004 00000000ff01 \
    $(ip_to_hex 10 0 0 4) $(ip_to_hex 172 168 0 120)

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep priority=0 | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x64" | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x3" | \
    grep "n_packets=0" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x4" | \
    grep "n_packets=0" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0xffffffff" | \
    grep "n_packets=0" -c)
])

ovn-nbctl set logical_router_policy $pol1 options:pkt_mark=2
send_ipv4_pkt hv1 hv1-vif1 505400000003 00000000ff01 \
    $(ip_to_hex 10 0 0 3) $(ip_to_hex 172 168 0 120)

OVS_WAIT_UNTIL([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-int table=20 | \
    grep "load:0x2->NXM_NX_PKT_MARK" -c)
])

AT_CHECK([
    test 0 -eq $(as hv1 ovs-ofctl dump-flows br-int table=20 | \
    grep "load:0x64->NXM_NX_PKT_MARK" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x2" | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep priority=0 | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x3" | \
    grep "n_packets=0" -c)
])

# Send with src ip 10.0.0.5. The reroute policy should be hit
# and the packet should be marked with 5.
send_ipv4_pkt hv1 hv1-vif1 505400000003 00000000ff01 \
    $(ip_to_hex 10 0 0 5) $(ip_to_hex 172 168 0 120)

OVS_WAIT_UNTIL([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x3" | \
    grep "n_packets=1" -c)
])

# Send IPv6 traffic.
src_ip6=aef00000000000000000000000000004
dst_ip6=bef00000000000000000000000000004

send_icmp6_packet hv1 hv1-vif2 505400000004 00000000ff01 ${src_ip6} ${dst_ip6}

OVS_WAIT_UNTIL([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0xffffffff" | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x4" | \
    grep "n_packets=0" -c)
])

# Send IPv6 packet which hits the reroute policy. Packet should be marked
# with 4.

src_ip6=aef00000000000000000000000000004
dst_ip6=bef00000000000000000000000000005

send_icmp6_packet hv1 hv1-vif2 505400000004 00000000ff01 ${src_ip6} ${dst_ip6}

OVS_WAIT_UNTIL([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x4" | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0xffffffff" | \
    grep "n_packets=1" -c)
])

AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_policy.*priority=1001" | sort], [0], [dnl
  table=12(lr_in_policy       ), priority=1001 , dnl
match=(ip6), action=(pkt.mark = 4294967295; reg8[[0..15]] = 0; next;)
])

ovn-nbctl --wait=hv set logical_router_policy $pol5 options:pkt_mark=-1
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_policy.*priority=1001" | sort], [0], [dnl
  table=12(lr_in_policy       ), priority=1001 , dnl
match=(ip6), action=(reg8[[0..15]] = 0; next;)
])

ovn-nbctl --wait=hv set logical_router_policy $pol5 options:pkt_mark=2147483648
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_policy.*priority=1001" | sort], [0], [dnl
  table=12(lr_in_policy       ), priority=1001 , dnl
match=(ip6), action=(pkt.mark = 2147483648; reg8[[0..15]] = 0; next;)
])

ovn-nbctl --wait=hv set logical_router_policy $pol5 options:pkt_mark=foo
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_policy.*priority=1001" | sort], [0], [dnl
  table=12(lr_in_policy       ), priority=1001 , dnl
match=(ip6), action=(reg8[[0..15]] = 0; next;)
])

ovn-nbctl --wait=hv set logical_router_policy $pol5 options:pkt_mark=4294967296
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_policy.*priority=1001" | sort], [0], [dnl
  table=12(lr_in_policy       ), priority=1001 , dnl
match=(ip6), action=(reg8[[0..15]] = 0; next;)
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- normalized lrp-add])
ovn_start

ovn-nbctl lr-add r1
ovn-nbctl lrp-add r1 rp1 CC:DD:EE:EE:DD:CC AEF0::1/64 BEF0::1/64

AT_CHECK([ovn-nbctl --may-exist lrp-add r1 rp1 cc:dd:ee:ee:dd:cc bef0:0000:0000:0000::1/64 aef0::1/64])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- normalized lr-nat-add])
ovn_start

ovn-nbctl lr-add r1
ovn-nbctl lr-nat-add r1 snat AEF0::1 BEEF::/64
ovn-nbctl lr-nat-add r1 dnat AEF0::1 BEEF::1

AT_CHECK([ovn-nbctl --may-exist lr-nat-add r1 snat aef0:0000::1 beef:0000::/ffff:ffff:ffff:ffff::0])
AT_CHECK([ovn-nbctl --may-exist lr-nat-add r1 dnat aef0:0000:00::1 beef::0001])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- normalized lr-nat-del])
ovn_start

ovn-nbctl lr-add r1
ovn-nbctl lr-nat-add r1 snat AEF0::1 BEEF::/64
ovn-nbctl lr-nat-add r1 dnat AEF0::1 BEEF::1

AT_CHECK([ovn-nbctl --if-exists lr-nat-del r1 snat beef:0000::0/ffff:ffff:ffff:ffff::0])
AT_CHECK([ovn-nbctl --if-exists lr-nat-del r1 dnat aef0:0000:00::1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Load balancer selection fields])
AT_KEYWORDS([lb])
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

# Create port group and ACLs for sw0 ports.
ovn-nbctl pg-add pg0_drop sw0-p1 sw0-p2
ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

ovn-nbctl pg-add pg0 sw0-p1 sw0-p2
ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip4" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create the second logical switch with one port
ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create port group and ACLs for sw1 ports.
ovn-nbctl pg-add pg1_drop sw1-p1
ovn-nbctl acl-add pg1_drop from-lport 1001 "inport == @pg1_drop && ip" drop
ovn-nbctl acl-add pg1_drop to-lport 1001 "outport == @pg1_drop && ip" drop

ovn-nbctl pg-add pg1 sw1-p1
ovn-nbctl acl-add pg1 from-lport 1002 "inport == @pg1 && ip4" allow-related
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create a logical router and attach both logical switches
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 router
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80
lb1_uuid=$(ovn-nbctl --bare --columns _uuid list load_balancer)
ovn-nbctl ls-lb-add sw0 lb1
ovn-nbctl ls-lb-add sw1 lb1
ovn-nbctl lr-lb-add lr0 lb1

OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-groups br-int | \
    grep "selection_method=dp_hash" -c) -eq 1
])

OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-groups br-int | \
    grep "selection_method=dp_hash" -c) -eq 1
])

echo "lb1_uuid = $lb1_uuid"

ovn-nbctl set load_balancer $lb1_uuid selection_fields="ip_src,ip_dst,tp_src,tp_dst"

OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)" -c) -eq 1
])

OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)" -c) -eq 1
])

# Change the protocol to udp.
ovn-nbctl set load_balancer $lb1_uuid protocol=udp
OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,udp_src,udp_dst)" -c) -eq 1
])

OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,udp_src,udp_dst)" -c) -eq 1
])

# Change the protocol to udp.
ovn-nbctl set load_balancer $lb1_uuid protocol=sctp
OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,sctp_src,sctp_dst)" -c) -eq 1
])

OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,sctp_src,sctp_dst)" -c) -eq 1
])

ovn-nbctl set load_balancer $lb1_uuid selection_fields="ip_src,ip_dst,tp_dst"
OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,sctp_dst)" -c) -eq 1
])

OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,sctp_dst)" -c) -eq 1
])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- controller I-P handling with monitoring disabled])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1


sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

wait_for_ports_up sw0-p1

# Get the number of OF flows in hv1 and hv2
hv1_offlows=$(as hv1 ovs-ofctl dump-flows br-int | wc -l)
echo "hv1 flows : $hv1_offlows"
AT_CHECK([test $hv1_offlows -gt 0])

as hv2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

wait_for_ports_up sw0-p2

hv2_offlows=$(as hv2 ovs-ofctl dump-flows br-int | wc -l)
echo "hv2 flows : $hv2_offlows"
AT_CHECK([test $hv2_offlows -gt 0])

ovn-nbctl ls-del sw0
as hv1 ovs-vsctl del-port hv1-vif1
as hv2 ovs-vsctl del-port hv2-vif1

as hv1 ovs-vsctl set open . external_ids:ovn-monitor-all=true
as hv2 ovs-vsctl set open . external_ids:ovn-monitor-all=true

# Wait until ovn-monitor-all is processed by ovn-controller.
wait_row_count Chassis 1 name=hv1 other_config:ovn-monitor-all=true
wait_row_count Chassis 1 name=hv2 other_config:ovn-monitor-all=true

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

wait_for_ports_up sw0-p1

# Get the number of OF flows in hv1 and hv2
hv1_offlows_mon=$(as hv1 ovs-ofctl dump-flows br-int | wc -l)
echo "hv1 flows after monitor-all=true : $hv1_offlows"
AT_CHECK([test "$hv1_offlows" = "$hv1_offlows_mon"])

as hv2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

wait_for_ports_up sw0-p2

hv2_offlows_mon=$(as hv2 ovs-ofctl dump-flows br-int | wc -l)
echo "hv2 flows after monitor-all=true : $hv2_offlows"
AT_CHECK([test "$hv2_offlows" = "$hv2_offlows_mon"])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- controller I-P handling when lrp added last])

ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Step 1. Add OVS interface with external_ids:iface-id set.
# Step 2. Create the logical switch and logical port.
# Step 3. Create logical switch port of type router and set the peer.
# Step 4. Create logical router and the logical router port (peer to logical switch)
# Step 5. Check that all the flows are added and logical port gets arp reply for
#         router IP.

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "00:00:00:01:01:02 192.168.1.2"

ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0
ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:00:01

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:00:01 192.168.1.1/24 aef0:0:0:0:0:0:0:1/64

wait_for_ports_up sw0-p1
ovn-nbctl --wait=sb sync

sw0_dpkey=$(ovn-sbctl  --bare --columns tunnel_key list datapath_binding sw0)
lr0_dpkey=$(ovn-sbctl  --bare --columns tunnel_key list datapath_binding lr0)

AT_CHECK([test $(as hv1 ovs-ofctl dump-flows br-int metadata=0x${sw0_dpkey} | wc -l) -gt 80])
AT_CHECK([test $(as hv1 ovs-ofctl dump-flows br-int metadata=0x${lr0_dpkey} | wc -l) -gt 80])

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local hv=$1 inport=$2 sha=$3 spa=$4 tpa=$5 reply_ha=$6
    local request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request

    if test X$reply_ha != X; then
        # Expect to receive the reply, if any.
        local reply=${sha}${reply_ha}08060001080006040002${reply_ha}${tpa}${sha}${spa}
        echo $reply >> hv${hv}-vif$inport.expected
    fi
}

sw0p1_ip=$(ip_to_hex 192 168 1 2)
rtr_ip=$(ip_to_hex 192 168 1 1)
test_arp 1 1 000000010102 $sw0p1_ip $rtr_ip 000000000001

# Now check the packets actually received against the ones expected.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [hv1-vif1.expected])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# When a lport is released on a chassis, ovn-controller was
# not clearing some of the flowss in the table 33.
# Make sure that those flows are cleared properly.
AT_SETUP([ovn -- Test clear flows in physical tables])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

as hv1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1) = xup])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2) = xup])

sw0_dpkey=$(ovn-sbctl  --bare --columns tunnel_key list datapath_binding sw0)
p1_dpkey=$(ovn-sbctl  --bare --columns tunnel_key list port_binding sw0-p1)
p2_dpkey=$(ovn-sbctl  --bare --columns tunnel_key list port_binding sw0-p2)

p1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p1 | sed 's/"//g')
AT_CHECK([test ! -z $p1_zoneid])

p2_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p2 | sed 's/"//g')
AT_CHECK([test ! -z $p2_zoneid])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=38,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep REG13 | wc -l) -eq 1])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=38,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep "load:0x${p1_zoneid}->NXM_NX_REG13" | wc -l) -eq 1])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=38,metadata=${sw1_dpkey},\
reg15=0x${p2_dpkey} | grep REG13 | wc -l) -eq 1])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=38,metadata=${sw1_dpkey},\
reg15=0x${p2_dpkey} | grep "load:0x${p2_zoneid}->NXM_NX_REG13" | wc -l) -eq 1])

ovs-vsctl set interface hv1-vif1 external_ids:iface-id=foo
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1) = xdown])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=38,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep REG13 | wc -l) -eq 0])

p1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p1 | sed 's/"//g')
AT_CHECK([test -z $p1_zoneid])

ovs-vsctl set interface hv1-vif1 external_ids:iface-id=sw0-p1
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1) = xup])

p1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p1 | sed 's/"//g')
AT_CHECK([test ! -z $p1_zoneid])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=38,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep REG13 | wc -l) -eq 1])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=38,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep "load:0x${p1_zoneid}->NXM_NX_REG13" | wc -l) -eq 1])

ovs-vsctl del-port hv1-vif2
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2) = xdown])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=38,metadata=${sw0_dpkey},\
reg15=0x${p2_dpkey} | grep REG13 | wc -l) -eq 0])

p2_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p2 | sed 's/"//g')
AT_CHECK([test -z $p2_zoneid])

ovn-nbctl lsp-del sw0-p1

OVS_WAIT_UNTIL([test $(ovs-ofctl dump-flows br-int table=38,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep REG13 | wc -l) -eq 0])

p1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p1 | sed 's/"//g')
AT_CHECK([test ! -z $p1_zoneid])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Symmetric ECMP reply flows])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

# Logical network
#
#   ls1 \
#        \
#         DR -- join -- GW -- ext
#        /
#   ls2 /
#
#  ls1 and ls2 are internal switches connected to distributed router
#  DR. DR is then connected via a join switch to gateway router GW.
#  GW is then connected to external switch ext. In real life, this
#  would likely have a localnet port, but for the purposes of this test
#  it is unnecessary.

ovn-nbctl create Logical_Router name=DR
gw_uuid=$(ovn-nbctl create Logical_Router name=GW)

check ovn-nbctl ls-add ls1
check ovn-nbctl ls-add ls2
check ovn-nbctl ls-add join
check ovn-nbctl ls-add ext

# Connect ls1 to DR
check ovn-nbctl lrp-add DR dr-ls1 00:00:01:01:02:03 10.0.0.1/24
check ovn-nbctl lsp-add ls1 ls1-dr -- set Logical_Switch_Port ls1-dr \
    type=router options:router-port=dr-ls1 addresses='"00:00:01:01:02:03"'

# Connect ls2 to DR
check ovn-nbctl lrp-add DR dr-ls2 00:00:01:01:02:04 10.0.0.2/24
check ovn-nbctl lsp-add ls2 ls2-dr -- set Logical_Switch_Port ls2-dr \
    type=router options:router-port=dr-ls2 addresses='"00:00:01:01:02:04"'

# Connect join to DR
check ovn-nbctl lrp-add DR dr-join 00:00:02:01:02:03 20.0.0.1/24
check ovn-nbctl lsp-add join join-dr -- set Logical_Switch_Port join-dr \
    type=router options:router-port=dr-join addresses='"00:00:02:01:02:03"'

# Connect join to GW
check ovn-nbctl lrp-add GW gw-join 00:00:02:01:02:04 20.0.0.2/24
check ovn-nbctl lsp-add join join-gw -- set Logical_Switch_Port join-gw \
    type=router options:router-port=gw-join addresses='"00:00:02:01:02:04"'

# Connect ext to GW
check ovn-nbctl lrp-add GW gw-ext 00:00:03:01:02:03 172.16.0.1/16
check ovn-nbctl lsp-add ext ext-gw -- set Logical_Switch_Port ext-gw \
    type=router options:router-port=gw-ext addresses='"00:00:03:01:02:03"'

check ovn-nbctl lr-route-add GW 10.0.0.0/24 20.0.0.1
check ovn-nbctl --policy="src-ip" lr-route-add DR 10.0.0.0/24 20.0.0.2

# Now add some ECMP routes to the GW router.
check ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add GW 10.0.0.0/24 172.16.0.2
check ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add GW 10.0.0.0/24 172.16.0.3

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Ensure ECMP symmetric reply flows are not present on any hypervisor.
AT_CHECK([
    test 0 -eq $(as hv1 ovs-ofctl dump-flows br-int table=15 | \
    grep "priority=100" | \
    grep "ct(commit,zone=NXM_NX_REG11\\[[0..15\\]],exec(move:NXM_OF_ETH_SRC\\[[\\]]->NXM_NX_CT_LABEL\\[[32..79\\]],load:0x[[0-9]]->NXM_NX_CT_LABEL\\[[80..95\\]]))" -c)
])
AT_CHECK([
    test 0 -eq $(as hv1 ovs-ofctl dump-flows br-int table=21 | \
    grep "priority=200" | \
    grep "actions=move:NXM_NX_CT_LABEL\\[[32..79\\]]->NXM_OF_ETH_DST\\[[\\]]" -c)
])

AT_CHECK([
    test 0 -eq $(as hv2 ovs-ofctl dump-flows br-int table=15 | \
    grep "priority=100" | \
    grep "ct(commit,zone=NXM_NX_REG11\\[[0..15\\]],exec(move:NXM_OF_ETH_SRC\\[[\\]]->NXM_NX_CT_LABEL\\[[32..79\\]],load:0x[[0-9]]->NXM_NX_CT_LABEL\\[[80..95\\]]))" -c)
])
AT_CHECK([
    test 0 -eq $(as hv2 ovs-ofctl dump-flows br-int table=21 | \
    grep "priority=200" | \
    grep "actions=move:NXM_NX_CT_LABEL\\[[32..79\\]]->NXM_OF_ETH_DST\\[[\\]]" -c)
])

# Now make GW a gateway router on hv1
ovn-nbctl set Logical_Router $gw_uuid options:chassis=hv1
ovn-nbctl --wait=hv sync

# And ensure that ECMP symmetric reply flows are present only on hv1
as hv1 ovs-ofctl dump-flows br-int > hv1flows
AT_CAPTURE_FILE([hv1flows])
as hv2 ovs-ofctl dump-flows br-int > hv2flows
AT_CAPTURE_FILE([hv2flows])

AT_CHECK([
    for hv in 1 2; do
        grep table=15 hv${hv}flows | \
        grep "priority=100" | \
        grep -c "ct(commit,zone=NXM_NX_REG11\\[[0..15\\]],exec(move:NXM_OF_ETH_SRC\\[[\\]]->NXM_NX_CT_LABEL\\[[32..79\\]],load:0x[[0-9]]->NXM_NX_CT_LABEL\\[[80..95\\]]))"

        grep table=22 hv${hv}flows | \
        grep "priority=200" | \
        grep -c "actions=move:NXM_NX_CT_LABEL\\[[32..79\\]]->NXM_OF_ETH_DST\\[[\\]]"
    done; :], [0], [dnl
1
1
0
0
])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# Test option:dynamic_neigh_routers. No static neighbor flows when enabled, and
# traffic should still work, with the help of dynamic mac_bindings.
AT_SETUP([ovn -- Dynamic neighbor between LRs])
ovn_start

# Logical network:
# 2 LRs - R1 and R2 that are connected to each other via LS "join"
# in 10.0.0.0/24 network.
# R1 is connected to S1 (10.0.1.0/24), R2 is connected to S2 (10.0.2.0/24)

ovn-nbctl lr-add r1 -- set logical_router r1 option:dynamic_neigh_routers=true
ovn-nbctl lr-add r2 -- set logical_router r2 option:dynamic_neigh_routers=true

ovn-nbctl ls-add s1
ovn-nbctl ls-add s2
ovn-nbctl ls-add join

# Connnect r1 to s1.
ovn-nbctl lrp-add r1 lrp-r1-s1 00:00:00:00:01:01 10.0.1.1/24
ovn-nbctl lsp-add s1 lsp-s1-r1 -- set Logical_Switch_Port lsp-s1-r1 type=router \
    options:router-port=lrp-r1-s1 addresses=router

# Connnect r2 to s2.
ovn-nbctl lrp-add r2 lrp-r2-s2 00:00:00:00:02:01 10.0.2.1/24
ovn-nbctl lsp-add s2 lsp-s2-r2 -- set Logical_Switch_Port lsp-s2-r2 type=router \
    options:router-port=lrp-r2-s2 addresses=router

# Connect r1 to join
ovn-nbctl lrp-add r1 lrp-r1-join 00:00:00:00:03:01 10.0.0.1/24
ovn-nbctl lsp-add join lsp-join-r1 -- set Logical_Switch_Port lsp-join-r1 \
    type=router options:router-port=lrp-r1-join addresses=router

# Connect r2 to join
ovn-nbctl lrp-add r2 lrp-r2-join 00:00:00:00:03:02 10.0.0.2/24
ovn-nbctl lsp-add join lsp-join-r2 -- set Logical_Switch_Port lsp-join-r2 \
    type=router options:router-port=lrp-r2-join addresses=router

#install static routes
ovn-nbctl lr-route-add r1 10.0.2.0/24 10.0.0.2
ovn-nbctl lr-route-add r2 10.0.1.0/24 10.0.0.1

# Create logical port p1 in s1
ovn-nbctl lsp-add s1 p1 \
-- lsp-set-addresses p1 "f0:00:00:00:01:02 10.0.1.2"

# Create logical port p2 in s2
ovn-nbctl lsp-add s2 p2 \
-- lsp-set-addresses p2 "f0:00:00:00:02:02 10.0.2.2"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

wait_for_ports_up
ovn-nbctl --wait=hv sync

AT_CHECK([ovn-sbctl lflow-list | grep lr_in_arp_resolve | grep 10.0.0.1], [1], [])
AT_CHECK([ovn-sbctl lflow-list | grep lr_in_arp_resolve | grep 10.0.0.2], [1], [])

# Send ip packets from p1 to p2
src_mac="f00000000102"
dst_mac="000000000101"
src_ip=`ip_to_hex 10 0 1 2`
dst_ip=`ip_to_hex 10 0 2 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
as hv1 ovs-appctl ofproto/trace br-int in_port=1 $packet

# Packet to Expect at p2
src_mac="000000000201"
dst_mac="f00000000202"
src_ip=`ip_to_hex 10 0 1 2`
dst_ip=`ip_to_hex 10 0 2 2`
echo "${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000" > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# MAC binding entry should have generated
AT_CHECK([ovn-sbctl find mac ip=10.0.0.2 mac='"00:00:00:00:03:02"' logical_port=lrp-r1-join | grep 10\.0\.0\.2], [0], [ignore], [])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- lflow cache for conjunctions])
ovn_start
net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "10:14:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p1 "10:14:00:00:00:03 10.0.0.3"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "10:14:00:00:00:04 10.0.0.4"
check ovn-nbctl lsp-set-port-security sw0-p2 "10:14:00:00:00:04 10.0.0.4"

check ovn-nbctl lsp-add sw0 sw0-p3
check ovn-nbctl lsp-set-addresses sw0-p3 "10:14:00:00:00:05 10.0.0.5"
check ovn-nbctl lsp-set-port-security sw0-p3 "10:14:00:00:00:05 10.0.0.5"

check ovn-nbctl lsp-add sw0 sw0-p4
check ovn-nbctl lsp-set-addresses sw0-p4 "10:14:00:00:00:06 10.0.0.6"
check ovn-nbctl lsp-set-port-security sw0-p4 "10:14:00:00:00:06 10.0.0.6"

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2
ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=sw0-p3 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3
ovs-vsctl -- add-port br-int hv1-vif4 -- \
    set interface hv1-vif4 external-ids:iface-id=sw0-p4 \
    options:tx_pcap=hv1/vif4-tx.pcap \
    options:rxq_pcap=hv1/vif4-rx.pcap \
    ofport-request=4

wait_for_ports_up

check ovn-nbctl pg-add pg0 sw0-p1 sw0-p2
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && tcp.dst >= 80 && tcp.dst <= 82" allow
check ovn-nbctl --wait=hv sync

# wait_conj_id_count COUNT ["ID COUNT [MATCH]"]...
#
# Waits until COUNT flows matching against conj_id appear in the
# table 45 on hv1's br-int bridge.  Makes the flows available in
# "hv1flows", which will be logged on error.
#
# In addition, for each quoted "ID COUNT" or "ID COUNT MATCH",
# verifies that there are COUNT flows in table 45 that match
# aginst conj_id=ID and (if MATCH) is nonempty, match MATCH.
wait_conj_id_count() {
  AT_CAPTURE_FILE([hv1flows])
  local retval
  case $1 in
      (0) retval=1 ;;
      (*) retval=0 ;;
  esac

  echo "waiting for $1 conj_id flows..."
  OVS_WAIT_FOR_OUTPUT_UNQUOTED(
    [ovs-ofctl dump-flows br-int > hv1flows
     grep table=45 hv1flows | grep -c conj_id],
    [$retval], [$1
])

  shift
  for arg; do
    set -- $arg; id=$1 count=$2 match=$3
    echo "checking that there are $count ${match:+$match }flows with conj_id=$id..."
    AT_CHECK_UNQUOTED(
      [grep table=45 hv1flows | grep "$match" | grep -c conj_id=$id],
      [0], [$count
])
  done
}

AS_BOX([Add sw0-p3 to the port group pg0. The conj_id should be 2.])
check ovn-nbctl --wait=hv pg-set-ports pg0 sw0-p1 sw0-p2 sw0-p3
wait_conj_id_count 1 "2 1"

AS_BOX([Add sw0p4 to the port group pg0. The conj_id should be 2.])
check ovn-nbctl --wait=hv pg-set-ports pg0 sw0-p1 sw0-p2 sw0-p3 sw0-p4
wait_conj_id_count 1 "2 1"

AS_BOX([Add another ACL with conjunction.])
check ovn-nbctl --wait=hv acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && udp.dst >= 80 && udp.dst <= 82" allow
wait_conj_id_count 2 "2 1 tcp" "3 1 udp"

AS_BOX([Delete tcp ACL.])
check ovn-nbctl --wait=hv acl-del pg0 to-lport 1002 "outport == @pg0 && ip4 && tcp.dst >= 80 && tcp.dst <= 82"
wait_conj_id_count 1 "3 1 udp"

AS_BOX([Add back the tcp ACL.])
check ovn-nbctl --wait=hv acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && tcp.dst >= 80 && tcp.dst <= 82" allow
wait_conj_id_count 2 "3 1 udp" "4 1 tcp"
AT_CHECK([test 1 = $(as hv1 ovs-ofctl dump-flows br-int table=45 | grep udp | grep -c "conj_id=3")])
AT_CHECK([test 1 = $(as hv1 ovs-ofctl dump-flows br-int table=45 | grep tcp | grep -c "conj_id=4")])

AS_BOX([Add another tcp ACL.])
check ovn-nbctl --wait=hv acl-add pg0 to-lport 1002 "outport == @pg0 && inport == @pg0 && ip4 && tcp.dst >= 84 && tcp.dst <= 86" allow
wait_conj_id_count 3 "3 1 udp" "4 1 tcp" "5 1 tcp"

AS_BOX([Clear ACLs.])
check ovn-nbctl --wait=hv clear port_group pg0 acls
wait_conj_id_count 0

AS_BOX([Add TCP ACL.])
check ovn-nbctl --wait=hv acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && tcp.dst >= 80 && tcp.dst <= 82" allow
check ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && udp.dst >= 80 && udp.dst <= 82" allow
wait_conj_id_count 2 "6 1 tcp" "7 1 udp"

AS_BOX([Flush lflow cache.])
as hv1 ovn-appctl -t ovn-controller lflow-cache/flush
wait_conj_id_count 2 "2 1" "3 1"

AS_BOX([Disable lflow caching.])
as hv1 ovs-vsctl set open . external_ids:ovn-enable-lflow-cache=false

AS_BOX([Wait until ovn-enble-lflow-cache is processed by ovn-controller.])
wait_row_count Chassis 1 name=hv1 other_config:ovn-enable-lflow-cache=false
wait_conj_id_count 2 "2 1" "3 1"

AS_BOX([Remove port sw0-p4 from port group.])
check ovn-nbctl --wait=hv pg-set-ports pg0 sw0-p1 sw0-p2 sw0-p3
wait_conj_id_count 2 "4 1" "5 1"

AS_BOX([Recompute.])
as hv1 ovn-appctl -t ovn-controller recompute

wait_conj_id_count 2 "2 1" "3 1"

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- lflow cache operations])
ovn_start
net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 \
    -- set interface hv1-vif1 external-ids:iface-id=lsp1 \
    -- add-port br-int hv1-vif2 \
    -- set interface hv1-vif2 external-ids:iface-id=lsp2

ovn-nbctl ls-add ls1 \
    -- lsp-add ls1 lsp1 \
    -- lsp-add ls1 lsp2 \
    -- pg-add pg1 lsp1 lsp2 \
    -- create Address_Set name=as1 addresses=\"10.0.0.1\",\"10.0.0.2\"
check ovn-nbctl --wait=hv sync
wait_for_ports_up lsp1 lsp2

get_cache_count () {
    local cache_name=$1
    as hv1 ovn-appctl -t ovn-controller lflow-cache/show-stats | grep ${cache_name} | awk '{ print $3 }'
}

AS_BOX([Check matches caching])
conj_id_cnt=$(get_cache_count cache-conj-id)
expr_cnt=$(get_cache_count cache-expr)
matches_cnt=$(get_cache_count cache-matches)

check ovn-nbctl acl-add ls1 from-lport 1 '1' drop
check ovn-nbctl --wait=hv sync

AT_CHECK([test "$conj_id_cnt" = "$(get_cache_count cache-conj-id)"], [0], [])
AT_CHECK([test "$expr_cnt" = "$(get_cache_count cache-expr)"], [0], [])
AT_CHECK([test "$(($matches_cnt + 1))" = "$(get_cache_count cache-matches)"], [0], [])

AS_BOX([Check expr caching for is_chassis_resident() matches])
conj_id_cnt=$(get_cache_count cache-conj-id)
expr_cnt=$(get_cache_count cache-expr)
matches_cnt=$(get_cache_count cache-matches)

check ovn-nbctl acl-add ls1 from-lport 1 'is_chassis_resident("lsp1")' drop
check ovn-nbctl --wait=hv sync

AT_CHECK([test "$conj_id_cnt" = "$(get_cache_count cache-conj-id)"], [0], [])
AT_CHECK([test "$(($expr_cnt + 1))" = "$(get_cache_count cache-expr)"], [0], [])
AT_CHECK([test "$matches_cnt" = "$(get_cache_count cache-matches)"], [0], [])

AS_BOX([Check conj-id caching for conjunctive port group/address set matches])
conj_id_cnt=$(get_cache_count cache-conj-id)
expr_cnt=$(get_cache_count cache-expr)
matches_cnt=$(get_cache_count cache-matches)

check ovn-nbctl acl-add ls1 from-lport 1 'inport == @pg1 && outport == @pg1 && is_chassis_resident("lsp1")' drop
check ovn-nbctl acl-add ls1 from-lport 1 'ip4.src == $as1 && ip4.dst == $as1 && is_chassis_resident("lsp1")' drop
check ovn-nbctl --wait=hv sync

AT_CHECK([test "$(($conj_id_cnt + 2))" = "$(get_cache_count cache-conj-id)"], [0], [])
AT_CHECK([test "$expr_cnt" = "$(get_cache_count cache-expr)"], [0], [])
AT_CHECK([test "$matches_cnt" = "$(get_cache_count cache-matches)"], [0], [])

AS_BOX([Check no caching for non-conjunctive port group/address set matches])
conj_id_cnt=$(get_cache_count cache-conj-id)
expr_cnt=$(get_cache_count cache-expr)
matches_cnt=$(get_cache_count cache-matches)

check ovn-nbctl acl-add ls1 from-lport 1 'inport == @pg2 && outport == @pg2 && is_chassis_resident("lsp1")' drop
check ovn-nbctl --wait=hv sync

AT_CHECK([test "$conj_id_cnt" = "$(get_cache_count cache-conj-id)"], [0], [])
AT_CHECK([test "$expr_cnt" = "$(get_cache_count cache-expr)"], [0], [])
AT_CHECK([test "$matches_cnt" = "$(get_cache_count cache-matches)"], [0], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Delete Port_Binding and OVS port Incremental Processing])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

ovn-nbctl ls-add ls
ovn-nbctl lsp-add ls lsp

as hv1 ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp

# Wait for port to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=lsp chassis=$ch

# Pause ovn-controller.
as hv1 ovn-appctl -t ovn-controller debug/pause

# Delete port binding and OVS port. The updates will be processed in the same
# loop in ovn-controller when it resumes.
ovn-nbctl --wait=sb lsp-del lsp
as hv1 ovs-vsctl del-port vif1

# Resume ovn-controller.
as hv1 ovn-appctl -t ovn-controller debug/resume

# Make sure ovn-controller runs fine.
OVS_WAIT_UNTIL([test x$(as hv1 ovn-appctl -t ovn-controller debug/status) = "xrunning"])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

AT_SETUP([ovn -- Multiple OVS port changes Incremental Processing])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw lsp1
check ovn-nbctl lsp-add sw lsp2

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1 \
    ofport-request=1
ovs-vsctl \
    -- add-port br-int vif2 \
    -- set Interface vif2 external_ids:iface-id=lsp2 \
    ofport-request=2

# Wait for ports to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch
wait_row_count Port_Binding 1 logical_port=lsp2 chassis=$ch

AS_BOX([check output flows for initial interfaces])
as hv1 ovs-ofctl dump-flows br-int table=65 > offlows_table65.txt
AT_CAPTURE_FILE([offlows_table65.txt])
AT_CHECK_UNQUOTED([grep -c "output:1" offlows_table65.txt], [0], [dnl
1
])
AT_CHECK_UNQUOTED([grep -c "output:2" offlows_table65.txt], [0], [dnl
1
])

AS_BOX([delete and add OVS interfaces and force batch of updates])
as hv1 ovn-appctl -t ovn-controller debug/pause

as hv1
ovs-vsctl \
    -- del-port vif1 \
    -- del-port vif2

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1 \
    ofport-request=3 \
    -- add-port br-int vif2 \
    -- set Interface vif2 external_ids:iface-id=lsp2 \
    ofport-request=4

as hv1 ovn-appctl -t ovn-controller debug/resume
check ovn-nbctl --wait=hv sync

AS_BOX([check output flows for new interfaces])
as hv1 ovs-ofctl dump-flows br-int table=65 > offlows_table65_2.txt
AT_CAPTURE_FILE([offlows_table65_2.txt])
AT_CHECK_UNQUOTED([grep -c "output:3" offlows_table65_2.txt], [0], [dnl
1
])
AT_CHECK_UNQUOTED([grep -c "output:4" offlows_table65_2.txt], [0], [dnl
1
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn -- Container port Incremental Processing])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1 \
    ofport-request=1

check ovn-nbctl ls-add ls1 \
    -- ls-add ls2 \
    -- lsp-add ls1 lsp1 \
    -- lsp-add ls2 lsp-cont1 lsp1 1
check ovn-nbctl --wait=hv sync

# Wait for ports to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch
wait_row_count Port_Binding 1 logical_port=lsp-cont1 chassis=$ch

AS_BOX([delete OVS VIF and OVN container port])
as hv1 ovn-appctl -t ovn-controller debug/pause
as hv1 ovs-vsctl del-port vif1

check ovn-nbctl --wait=sb lsp-del lsp-cont1
as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync
check_row_count Port_Binding 1 logical_port=lsp1 chassis="[[]]"

AS_BOX([readd OVS VIF])
as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1 \
    ofport-request=1
wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch

AS_BOX([readd OVN container port])
check ovn-nbctl lsp-add ls2 lsp-cont1 lsp1 1
check ovn-nbctl --wait=hv sync
check_row_count Port_Binding 1 logical_port=lsp-cont1 chassis=$ch

AS_BOX([delete both OVN VIF and OVN container port])
as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-del lsp1 \
    -- lsp-del lsp-cont1
check ovn-nbctl --wait=sb sync
as hv1 ovn-appctl -t ovn-controller debug/resume

AS_BOX([readd both OVN VIF and OVN container port])
as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-add ls1 lsp1 \
    -- lsp-add ls2 lsp-cont1 lsp1 1
check ovn-nbctl --wait=sb sync
as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync
wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch
wait_row_count Port_Binding 1 logical_port=lsp-cont1 chassis=$ch

OVN_CLEANUP([hv1])
AT_CLEANUP

# Test dropping traffic destined to router owned IPs.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- gateway router drop traffic for own IPs])
ovn_start

ovn-nbctl lr-add r1 -- set logical_router r1 options:chassis=hv1
ovn-nbctl ls-add s1

# Connnect r1 to s1.
ovn-nbctl lrp-add r1 lrp-r1-s1 00:00:00:00:01:01 10.0.1.1/24
ovn-nbctl lsp-add s1 lsp-s1-r1 -- set Logical_Switch_Port lsp-s1-r1 type=router \
    options:router-port=lrp-r1-s1 addresses=router

# Create logical port p1 in s1
ovn-nbctl lsp-add s1 p1 \
-- lsp-set-addresses p1 "f0:00:00:00:01:02 10.0.1.2" \
-- lsp-set-port-security p1 "f0:00:00:00:01:02 10.0.1.2"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

wait_for_ports_up
ovn-nbctl --wait=hv sync

sw_key=$(ovn-sbctl --bare --columns tunnel_key list datapath_binding r1)

AT_CHECK([ovn-sbctl lflow-list | grep lr_in_arp_resolve | grep 10.0.1.1], [1], [])

# Send ip packets from p1 to lrp-r1-s1
src_mac="f00000000102"
dst_mac="000000000101"
src_ip=`ip_to_hex 10 0 1 2`
dst_ip=`ip_to_hex 10 0 1 1`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# No packet-ins should reach ovn-controller.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep "actions=controller" | grep -v n_packets=0 -c], [1], [dnl
0
])

# The packet should have been dropped in the lr_in_ip_input stage.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep -E "table=11, n_packets=1,.* priority=60,ip,metadata=0x${sw_key},nw_dst=10.0.1.1 actions=drop" -c], [0], [dnl
1
])

# Use the router IP as SNAT IP.
ovn-nbctl set logical_router r1 options:lb_force_snat_ip=10.0.1.1
ovn-nbctl --wait=hv sync

# Send ip packets from p1 to lrp-r1-s1
src_mac="f00000000102"
dst_mac="000000000101"
src_ip=`ip_to_hex 10 0 1 2`
dst_ip=`ip_to_hex 10 0 1 1`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Even after configuring a router owned IP for SNAT, no packet-ins should
# reach ovn-controller.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep "actions=controller" | grep -v n_packets=0 -c], [1], [dnl
0
])

# The packet should've been dropped in the lr_in_arp_resolve stage.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep -E "table=22, n_packets=1,.* priority=1,ip,metadata=0x${sw_key},nw_dst=10.0.1.1 actions=drop" -c], [0], [dnl
1
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- nb_cfg timestamp])
ovn_start

check ovn-nbctl ls-add s2
check ovn-nbctl ls-add join

net_add n1

n=10
for i in $(seq 1 $n); do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done

# get_cfg IDX
#
# Fetches data fields into shell variables:
# - nb_cfg into nbs$IDX
# - nb_cfg_timestamp into nbt$IDX
# - sb_cfg into sbs$IDX
# - sb_cfg_timestamp into sbt$IDX
# - hv_cfg into hvs$IDX
# - hv_cfg_timestamp into hvt$IDX
get_cfg() {
    local i=$1
    set -- $(ovn-nbctl get nb_global . nb_cfg nb_cfg_timestamp sb_cfg sb_cfg_timestamp hv_cfg hv_cfg_timestamp)
    AS_VAR_SET([nbs$i], [$1])
    AS_VAR_SET([nbt$i], [$2])
    AS_VAR_SET([sbs$i], [$3])
    AS_VAR_SET([sbt$i], [$4])
    AS_VAR_SET([hvs$i], [$5])
    AS_VAR_SET([hvt$i], [$6])
    if test "$i" = 1; then
        printf '\n-- %s\n' "$i. *_cfg(*_cfg_timestamp): nb=$1($2) sb=$3($4) hv=$5($6)"
    else
        AS_VAR_ARITH([p], [$i - 1])
        AS_VAR_COPY([nbtp], [nbt$p])
        AS_VAR_COPY([sbtp], [sbt$p])
        AS_VAR_COPY([hvtp], [hvt$p])
        AS_VAR_ARITH([nbtdelta], [$2 - $nbtp])
        AS_VAR_ARITH([sbtdelta], [$4 - $sbtp])
        AS_VAR_ARITH([hvtdelta], [$6 - $hvtp])
        printf "\n-- $i. *_cfg(*_cfg_timestamp): nb=$1(%+d) sb=$3(%+d) hv=$5(%+d)\n" $nbtdelta $sbtdelta $hvtdelta
    fi
}

# Check initial timestamps
get_cfg 1
check test "$nbs1" = 0
check test "$sbs1" = 0
check test "$hvs1" = 0

# Force a sequence number change and check the new timestamps
ovn-nbctl --wait=hv ls-add s1
get_cfg 2
check test "$nbs2" = 1
check test "$nbt2" -gt 0
check test "$sbt2" -gt 0
check test "$hvt2" -gt 0

# Kill ovn-controller on chassis hv3, so that it won't update nb_cfg.
# Then wait for 9 out of 10
sleep 1
check as hv3 ovn-appctl -t ovn-controller exit --restart
wait_for_ports_up
ovn-nbctl --wait=sb sync
wait_row_count Chassis_Private 9 name!=hv3 nb_cfg=2
check_row_count Chassis_Private 1 name=hv3 nb_cfg=1

get_cfg 3
check test "$nbs3" = 2
check test "$nbt3" -gt "$nbt2"
check test "$sbt3" -gt "$sbt2"
check test "$hvt3" -gt 0

# start ovn-controller on hv3 again, so that it will update nb_cfg with latest
# timestamp (hv3 will be the slowest one).
as hv3 start_daemon ovn-controller
wait_row_count Chassis_Private 1 name=hv3 nb_cfg=2

get_cfg 4
hv3_ts=$(ovn-sbctl --bare --columns=nb_cfg_timestamp find chassis_private name=hv3)
echo hv3_ts=$hv3_ts
hv_cfg_ts=$(ovn-nbctl get nb_global . hv_cfg_timestamp)
check test "$hv3_ts" = "$hvt4"

AT_CHECK([test x$(ovn-nbctl --print-wait-time --wait=sb sync | grep ms | wc -l) = x2])
AT_CHECK([test x$(ovn-nbctl --print-wait-time --wait=hv sync | grep ms | wc -l) = x3])

for i in $(seq 2 $n); do
    OVN_CLEANUP_SBOX([hv$i])
done
OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- ARP replies for SNAT external ips])
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-port1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw3-port1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])
ovs-vsctl set open . external_ids:ovn-enable-lflow-cache=false

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-port2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])
ovs-vsctl set open . external_ids:ovn-enable-lflow-cache=false

sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=sw1-port1 \
    options:tx_pcap=hv3/vif1-tx.pcap \
    options:rxq_pcap=hv3/vif1-rx.pcap \
    ofport-request=1
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])
ovs-vsctl set open . external_ids:ovn-enable-lflow-cache=false

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-port1
ovn-nbctl lsp-set-addresses sw0-port1 "10:54:00:00:00:03 10.0.0.3 1000::3"
ovn-nbctl lsp-add sw0 sw0-port2
ovn-nbctl lsp-set-addresses sw0-port2 "10:54:00:00:00:04 10.0.0.4 1000::4"

ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-port1
ovn-nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 router
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

ovn-nbctl ls-add public
ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.16.0.100/24 3000::a/64
ovn-nbctl lsp-add public public-lr0
ovn-nbctl lsp-set-type public-lr0 router
ovn-nbctl lsp-set-addresses public-lr0 router
ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
ovn-nbctl lsp-add public ln-public
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-options ln-public network_name=physnet1

# schedule the gw router port to a chassis.
ovn-nbctl lrp-set-gateway-chassis lr0-public hv1 20

# Create NAT entries for the ports

# sw0-port1
ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.16.0.110 10.0.0.3 sw0-port1 30:54:00:00:00:03
ovn-nbctl lr-nat-add lr0 dnat_and_snat 3000::c 1000::3 sw0-port1 40:54:00:00:00:03
# sw1-port1
ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.16.0.120 20.0.0.3 sw1-port1 30:54:00:00:00:04
ovn-nbctl lr-nat-add lr0 dnat_and_snat 3000::d 2000::3 sw1-port1 40:54:00:00:00:04

# Add snat entriess
ovn-nbctl lr-nat-add lr0 snat 172.16.0.100 10.0.0.0/24
ovn-nbctl lr-nat-add lr0 snat 172.16.0.101 10.0.0.10
ovn-nbctl lr-nat-add lr0 snat 172.16.0.102 10.0.0.11
ovn-nbctl lr-nat-add lr0 snat 172.16.0.100 20.0.0.0/24

ovn-nbctl ls-add sw3
ovn-nbctl lsp-add sw3 sw3-port1
ovn-nbctl lsp-set-addresses sw3-port1 "20:14:00:00:00:03 30.0.0.3 3000::3"

ovn-nbctl lr-add lr1
ovn-nbctl lrp-add lr1 lr1-sw3 00:00:00:10:ff:03 30.0.0.1/24 3000::a/64
ovn-nbctl lsp-add sw3 sw3-lr1
ovn-nbctl lsp-set-type sw3-lr1 router
ovn-nbctl lsp-set-addresses sw3-lr1 router
ovn-nbctl lsp-set-options sw3-lr1 router-port=lr1-sw3

ovn-nbctl ls-add join

# Connect lr1 to join
ovn-nbctl lrp-add lr1 lr1-join 00:00:04:01:02:03 170.0.0.1/24
ovn-nbctl lsp-add join join-lr1
ovn-nbctl lsp-set-type join-lr1 router
ovn-nbctl lsp-set-addresses join-lr1 router
ovn-nbctl lsp-set-options join-lr1 router-port=lr1-join

# Create GW router
ovn-nbctl lr-add gw_router
# connect gw_router to join
ovn-nbctl lrp-add gw_router gw_router-join 00:00:03:11:12:13 170.0.0.2/24
ovn-nbctl lsp-add join join-gw_router
ovn-nbctl lsp-set-type join-gw_router router
ovn-nbctl lsp-set-addresses join-gw_router router
ovn-nbctl lsp-set-options join-gw_router router-port=gw_router-join

# Connect gw_router to public
ovn-nbctl lrp-add gw_router gw_router-public 00:00:30:30:32:33 172.16.0.200/24 3000::b/64
ovn-nbctl lsp-add public public-gw_router
ovn-nbctl lsp-set-type public-gw_router router
ovn-nbctl lsp-set-addresses public-gw_router router
ovn-nbctl lsp-set-options public-gw_router router-port=gw_router-public

# Pin gw_router to hv3
ovn-nbctl set logical_router gw_router options:chassis=hv3

# Add snat entries on gw_router
ovn-nbctl lr-nat-add gw_router snat 172.16.0.200 30.0.0.0/24
ovn-nbctl lr-nat-add gw_router snat 172.16.0.201 30.0.0.3

wait_for_ports_up
ovn-nbctl --wait=hv sync

# Create an interface in br-phys in hv2 and send ARP request for 172.16.0.100
as hv2
ovs-vsctl -- add-port br-phys hv2-phys1 -- \
    set interface hv2-phys1 options:tx_pcap=hv2/phys1-tx.pcap \
    options:rxq_pcap=hv2/phys1-rx.pcap \
    ofport-request=1

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

send_arp_request() {
    local eth_src=$1 spa=$2 tpa=$3
    local eth_dst=ffffffffffff
    local eth_type=0806
    local eth=${eth_dst}${eth_src}${eth_type}

    local arp=0001080006040001${eth_src}${spa}${eth_dst}${tpa}

    local request=${eth}${arp}
    as hv2 ovs-appctl netdev-dummy/receive hv2-phys1 $request
}

test_arp_response () {
    local router_mac=$1 router_ip=$2 gw=$3 nongw1=$4 nongw2=$5

    echo "Checking arp reply for IP - $router_ip"
    as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
    as hv2 reset_pcap_file br-phys_n1 hv2/br-phys_n1
    as hv3 reset_pcap_file br-phys_n1 hv3/br-phys_n1
    as hv2 reset_pcap_file hv2-phys1 hv2/phys1

    local src_mac=000200100011
    src_ip=$(ip_to_hex 172 16 0 40)
    send_arp_request ${src_mac} ${src_ip} ${router_ip}
    arp_reply=${src_mac}${router_mac}08060001080006040002${router_mac}
    arp_reply=${arp_reply}${router_ip}${src_mac}${src_ip}

    OVS_WAIT_UNTIL([
        test $($PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/phys1-tx.pcap | wc -l) -ge 1
    ])

    AT_CHECK([$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/phys1-tx.pcap | \
    grep -c $arp_reply], [0], [1
])

    # $gw phys1-n1 should see the response because $gw ovn-controller responds
    # to arp request.
    AT_CHECK([$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $gw/br-phys_n1-tx.pcap | \
    grep -c $arp_reply], [0], [1
])

    # $nongw1 and $nongw1 phys1-n1 should not see the response.
    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $nongw1/br-phys_n1-tx.pcap
    AT_CHECK([$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $nongw1/br-phys_n1-tx.pcap | \
    grep -c $arp_reply], [1], [0
])

    AT_CHECK([$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $nongw2/br-phys_n1-tx.pcap | \
    grep -c $arp_reply], [1], [0
])
}

# Send ARP request for the IPs which belongs to lr0 having
# distributed gw router port - lr0-public.
test_arp_response 000020201213 $(ip_to_hex 172 16 0 100) hv1 hv2 hv3
test_arp_response 000020201213 $(ip_to_hex 172 16 0 101) hv1 hv2 hv3
test_arp_response 000020201213 $(ip_to_hex 172 16 0 102) hv1 hv2 hv3

# Send ARP request for the IP which belongs to gw_router
test_arp_response 000030303233 $(ip_to_hex 172 16 0 200) hv3 hv1 hv2
test_arp_response 000030303233 $(ip_to_hex 172 16 0 201) hv3 hv1 hv2

# Make hv3 claim the cr-lr0-public
ovn-nbctl lrp-set-gateway-chassis lr0-public hv1 20
ovn-nbctl lrp-set-gateway-chassis lr0-public hv2 30
ovn-nbctl lrp-set-gateway-chassis lr0-public hv3 40

hv3_uuid=$(ovn-sbctl --bare --columns _uuid list chassis hv3)

OVS_WAIT_UNTIL([
    cr_lr0_public_ch=$(ovn-sbctl --bare --columns chassis list port_binding cr-lr0-public)
    test $cr_lr0_public_ch = $hv3_uuid
])

test_arp_response 000020201213 $(ip_to_hex 172 16 0 100) hv3 hv1 hv2
test_arp_response 000020201213 $(ip_to_hex 172 16 0 101) hv3 hv1 hv2
test_arp_response 000020201213 $(ip_to_hex 172 16 0 102) hv3 hv1 hv2

# Schedule gw_router on hv1.
ovn-nbctl set logical_router gw_router options:chassis=hv1
hv1_uuid=$(ovn-sbctl --bare --columns _uuid list chassis hv1)

OVS_WAIT_UNTIL([
    gw_router_ch=$(ovn-sbctl --bare --columns chassis list port_binding gw_router-public)
    test $gw_router_ch = $hv1_uuid
])

# Send ARP request for the IP which belongs to gw_router
test_arp_response 000030303233 $(ip_to_hex 172 16 0 200) hv1 hv2 hv3
test_arp_response 000030303233 $(ip_to_hex 172 16 0 201) hv1 hv2 hv3

OVN_CLEANUP([hv1],[hv2],[hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# Duplicate ACLs (same match with same action) should work as expected.
# Conflict ACLs (same match with different actions) behavior is unpredictable
# (only one of them would work).
# This test covers both situation and also makes sure adding/deleting in
# different order is handled properly (duplicated flow handling in ofctrl_put()
# of ovn-controller)
AT_SETUP([ovn -- conflict or duplicate ACLs resulting in same OVS match])
ovn_start

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 lsp1 \
    -- lsp-set-addresses lsp1 "f0:00:00:00:00:01 10.0.0.1"

check ovn-nbctl lsp-add ls1 lsp2 \
    -- lsp-set-addresses lsp2 "f0:00:00:00:00:02 10.0.0.2"

net_add n1
sim_add hv1

as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=lsp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

# Default drop
check ovn-nbctl acl-add ls1 to-lport 1000 \
    'outport == "lsp1" && ip4' drop

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes an ip packet to be received on INPORT.
# The packet's content has Ethernet destination DST and source SRC
# (each exactly 12 hex digits) and Ethernet type ETHTYPE (4 hex digits).
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 11 for vif11.
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}\
${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}


# Create overlapping ACLs resulting in duplicated desired OVS flows
check ovn-nbctl acl-add ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == 10.0.0.2' allow
check ovn-nbctl acl-add ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == {10.0.0.2, 10.0.0.3}' allow

wait_for_ports_up
check ovn-nbctl --wait=hv sync

sip=`ip_to_hex 10 0 0 2`
dip=`ip_to_hex 10 0 0 1`
test_ip 2 f00000000002 f00000000001 $sip $dip 1
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# Delete one of the ACLs.
check ovn-nbctl acl-del ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == {10.0.0.2, 10.0.0.3}'
check ovn-nbctl --wait=hv sync

test_ip 2 f00000000002 f00000000001 $sip $dip 1
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# Add a conflict ACL with drop action.
check ovn-nbctl acl-add ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == {10.0.0.2, 10.0.0.3}' drop
# Don't test because it is unpredicatable which rule will take effect.

# Delete the ACL that has "allow" action
check ovn-nbctl acl-del ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == 10.0.0.2'
check ovn-nbctl --wait=hv sync

# Packet should be dropped
test_ip 2 f00000000002 f00000000001 $sip $dip
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# Add the ACL back and delete the "drop" ACL
check ovn-nbctl acl-add ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == 10.0.0.2' allow
check ovn-nbctl acl-del ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == {10.0.0.2, 10.0.0.3}'
check ovn-nbctl --wait=hv sync

# Packet should be received
test_ip 2 f00000000002 f00000000001 $sip $dip 1
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# This test cases tests a scenario of ACL confliction with address set update.
# It is to cover a corner case when flows are re-processed in the I-P
# iteration, combined with the scenario of conflicting ACLs.
AT_SETUP([ovn -- conflict ACLs with address set])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 lsp1 \
-- lsp-set-addresses lsp1 "f0:00:00:00:00:01 10.0.0.1"

ovn-nbctl lsp-add ls1 lsp2 \
-- lsp-set-addresses lsp2 "f0:00:00:00:00:02 10.0.0.2"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=lsp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

# Default drop
ovn-nbctl acl-add ls1 to-lport 1000 \
'outport == "lsp1" && ip4' drop

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes an ip packet to be received on INPORT.
# The packet's content has Ethernet destination DST and source SRC
# (each exactly 12 hex digits) and Ethernet type ETHTYPE (4 hex digits).
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 11 for vif11.
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}\
${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

# Create an address set
ovn-nbctl create Address_Set name=as1 \
addresses=\"10.0.0.2\",\"10.0.0.3\"

# Create overlapping ACLs resulting in conflict desired OVS flows
# Add ACL1 uses the address set
ovn-nbctl --wait=hv acl-add ls1 to-lport 1001 \
'outport == "lsp1" && ip4 && ip4.src == $as1' allow

# Add ACL2 which uses a single IP, which shouldn't take effect because
# when it is added incrementally there is already a conflict one installed.
ovn-nbctl --wait=hv acl-add ls1 to-lport 1001 \
'outport == "lsp1" && ip4 && ip4.src == 10.0.0.2' drop


sip=`ip_to_hex 10 0 0 2`
dip=`ip_to_hex 10 0 0 1`
test_ip 2 f00000000002 f00000000001 $sip $dip 1
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# Update the address set which causes flow reprocessing but the OVS flow
# for allowing 10.0.0.2 should keep unchanged
ovn-nbctl --wait=hv set Address_Set as1 addresses=\"10.0.0.2\"

test_ip 2 f00000000002 f00000000001 $sip $dip 1
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# Delete the ACL1 that has "allow" action
ovn-nbctl acl-del ls1 to-lport 1001 \
'outport == "lsp1" && ip4 && ip4.src == $as1'

# ACL2 should take effect and packet should be dropped
test_ip 2 f00000000002 f00000000001 $sip $dip
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

OVN_CLEANUP([hv1])
AT_CLEANUP

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- port bind/unbind change handling with conj flows - IPv6])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 lsp1 \
    -- lsp-set-addresses lsp1 "f0:00:00:00:00:01 2001::1" \
    -- lsp-set-port-security lsp1 "f0:00:00:00:00:01 2001::1"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

wait_for_ports_up
ovn-nbctl --wait=hv sync

# Expected conjunction flows:
# ... nd_tll=00:00:00:00:00:00 actions=conjunction(2,2/2)
# ... nd_tll=f0:00:00:00:00:01 actions=conjunction(2,2/2)
# ... nd_target=fe80::f200:ff:fe00:1 actions=conjunction(2,1/2)
# ... nd_target=2001::1 actions=conjunction(2,1/2)
OVS_WAIT_UNTIL([test 4 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])

# unbind the port
ovs-vsctl set interface hv1-vif1 external_ids:iface-id=foo
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])

# bind the port again
ovs-vsctl set interface hv1-vif1 external_ids:iface-id=lsp1
OVS_WAIT_UNTIL([test 4 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])

# unbind the port again
ovs-vsctl set interface hv1-vif1 external_ids:iface-id=foo
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- I-P of OVS interface changes which belong to non integration bridge])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-add sw0 sw0-p2

as hv1 ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=sw0-p1

# Wait for port to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=sw0-p1 chassis=$ch

as hv1 ovs-vsctl add-br br-temp
as hv1 ovs-vsctl \
    -- add-port br-temp t1 \
    -- set Interface t1 external_ids:iface-id=sw0-p2

ovn-nbctl --wait=hv sync

# hv1 ovn-controller should not bind sw0-p2.
wait_for_ports_up sw0-p1
check_row_count Port_Binding 0 logical_port=sw0-p2 chassis=$c

# Trigger recompute and sw0-p2 should not be claimed.
as hv1 ovn-appctl -t ovn-controller recompute
ovn-nbctl --wait=hv sync

check_row_count Port_Binding 0 logical_port=sw0-p2 chassis=$ch

ovn-sbctl --columns chassis --bare list port_binding sw0-p2

OVN_CLEANUP([hv1])
AT_CLEANUP
])

#
# When multiple encap-ips are configued, make sure the
# ovn-controller doesn't get into a state of constantly
# updating the SB Chassis's encap information. The test
# configures multiple vteps and waits for a couple
# of seconds to makes sure the SB encap info remains
# unchanged.
#
#
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- multi-vtep SB Chassis encap updates])
ovn_start

net_add n1
sim_add hv1
as hv1

ovs-vsctl add-br br-phys
# Just set the encap type to be geneve for this test.
ovn_attach n1 br-phys 192.168.0.1 24 geneve

# Get the encap rec, should be just one - with geneve/192.168.0.1
encap_rec=$(ovn-sbctl --data=bare --no-heading --column encaps list chassis hv1)

# Set multiple IPs
as hv1
ovs-vsctl \
    -- set Open_vSwitch . external-ids:ovn-encap-ip="192.168.0.1,192.168.1.1"

# Check if the encap_rec changed - should have, no need to
# compare the exact values.
encap_rec_mvtep=$(ovn-sbctl --data=bare --no-heading --column encaps list chassis hv1)

AT_CHECK([test "$encap_rec" != "$encap_rec_mvtep"], [0], [])

# now, wait for a couple of secs -  should be enough time, I suppose.
sleep 2

# Check if the encap_rec changed (it should not have)
encap_rec_mvtep1=$(ovn-sbctl --data=bare --no-heading --column encaps list chassis hv1)

AT_CHECK([test "$encap_rec_mvtep" = "$encap_rec_mvtep1"], [0], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Load Balancer LS hairpin OF flows])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

check ovn-nbctl --wait=hv ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 00:00:00:00:00:01

check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1 -- lsp-set-addresses sw1-p1 00:00:00:00:01:01

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1) = xup])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw1-p1) = xup])

check ovn-nbctl lb-add lb-ipv4-tcp 88.88.88.88:8080 42.42.42.1:4041 tcp
check ovn-nbctl lb-add lb-ipv4-udp 88.88.88.88:4040 42.42.42.1:2021 udp
check ovn-nbctl lb-add lb-ipv6-tcp [[8800::0088]]:8080 [[4200::1]]:4041 tcp
check ovn-nbctl --wait=hv lb-add lb-ipv6-udp [[8800::0088]]:4040 [[4200::1]]:2021 udp

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | grep -v NXST], [1], [dnl
])

check ovn-nbctl --wait=hv ls-lb-add sw0 lb-ipv4-tcp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 1]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69], [0], [dnl
NXST_FLOW reply (xid=0x8):
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | grep -v NXST], [1], [dnl
])

check ovn-nbctl lb-add lb-ipv4-tcp 88.88.88.90:8080 42.42.42.42:4041,52.52.52.52:4042 tcp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 3]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69], [0], [dnl
NXST_FLOW reply (xid=0x8):
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | grep -v NXST], [1], [dnl
])

check ovn-nbctl lsp-add sw0 sw0-p2
# hv2 should bind sw0-p2 and it should install the LB hairpin flows.
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2) = xup])

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 3]
)

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
])

check ovn-nbctl --wait=hv ls-lb-add sw0 lb-ipv4-udp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 4]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 4]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
])

check ovn-nbctl --wait=hv ls-lb-add sw0 lb-ipv6-tcp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 5]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 5]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
])

check ovn-nbctl --wait=hv ls-lb-add sw0 lb-ipv6-udp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 6]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 6]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
])

check ovn-nbctl --wait=hv ls-lb-add sw1 lb-ipv6-udp

# Number of hairpin flows shouldn't change as it doesn't depend on how many
# datapaths the LB is applied.
OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 6]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 6]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x2 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x2 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
])

# Check backwards compatibility with ovn-northd versions that don't store the
# original destination tuple.
#
# ovn-controller should fall back to matching on ct_nw_dst()/ct_tp_dst().
as northd-backup ovn-appctl -t NORTHD_TYPE pause
as northd ovn-appctl -t NORTHD_TYPE pause

check ovn-sbctl \
    -- remove load_balancer lb-ipv4-tcp options hairpin_orig_tuple \
    -- remove load_balancer lb-ipv6-tcp options hairpin_orig_tuple \
    -- remove load_balancer lb-ipv4-udp options hairpin_orig_tuple \
    -- remove load_balancer lb-ipv6-udp options hairpin_orig_tuple

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_ipv6_dst=8800::88,ct_nw_proto=17,ct_tp_dst=4040,udp6,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_ipv6_dst=8800::88,ct_nw_proto=6,ct_tp_dst=8080,tcp6,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_nw_dst=88.88.88.88,ct_nw_proto=17,ct_tp_dst=4040,udp,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_nw_dst=88.88.88.88,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,ct_state=+trk+dnat,ct_ipv6_dst=8800::88,ct_nw_proto=17,ct_tp_dst=4040,udp6,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,ct_state=+trk+dnat,ct_ipv6_dst=8800::88,ct_nw_proto=17,ct_tp_dst=4040,udp6,metadata=0x2 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,ct_state=+trk+dnat,ct_ipv6_dst=8800::88,ct_nw_proto=6,ct_tp_dst=8080,tcp6,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.88,ct_nw_proto=17,ct_tp_dst=4040,udp,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.88,ct_nw_proto=6,ct_tp_dst=8080,tcp,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
])

OVS_WAIT_FOR_OUTPUT([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_ipv6_dst=8800::88,ct_nw_proto=17,ct_tp_dst=4040,udp6,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_ipv6_dst=8800::88,ct_nw_proto=6,ct_tp_dst=8080,tcp6,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_nw_dst=88.88.88.88,ct_nw_proto=17,ct_tp_dst=4040,udp,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_nw_dst=88.88.88.88,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_label=0x2/0x2,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

OVS_WAIT_FOR_OUTPUT([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,ct_state=+trk+dnat,ct_ipv6_dst=8800::88,ct_nw_proto=17,ct_tp_dst=4040,udp6,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,ct_state=+trk+dnat,ct_ipv6_dst=8800::88,ct_nw_proto=17,ct_tp_dst=4040,udp6,metadata=0x2 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,ct_state=+trk+dnat,ct_ipv6_dst=8800::88,ct_nw_proto=6,ct_tp_dst=8080,tcp6,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.88,ct_nw_proto=17,ct_tp_dst=4040,udp,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.88,ct_nw_proto=6,ct_tp_dst=8080,tcp,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
])

# Resume ovn-northd.
as northd ovn-appctl -t NORTHD_TYPE resume
as northd-backup ovn-appctl -t NORTHD_TYPE resume
check ovn-nbctl --wait=hv sync

as hv2 ovs-vsctl del-port hv2-vif1
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2) = xdown])

# Trigger recompute on hv2 as sw0 will not be cleared from local_datapaths.
as hv2 ovn-appctl -t ovn-controller recompute

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=69 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=70 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 6]
)

check ovn-nbctl --wait=hv lb-del lb-ipv4-tcp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 3]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 0]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_label=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_label=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69], [0], [dnl
NXST_FLOW reply (xid=0x8):
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x1 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,metadata=0x2 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
])

check ovn-nbctl --wait=hv ls-del sw0
check ovn-nbctl --wait=hv ls-del sw1

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=69 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=70 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=69 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=70 | grep -c -v NXST) -eq 0]
)

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- check ovn-northd and ovn-controller version pinning])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-add sw0 sw0-p2

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=sw0-p1 \
    ofport-request=1
ovs-vsctl \
    -- add-port br-int vif2 \
    -- set Interface vif2 external_ids:iface-id=sw0-p2 \
    ofport-request=2

# Wait for port to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=sw0-p1 chassis=$ch
wait_row_count Port_Binding 1 logical_port=sw0-p2 chassis=$ch

northd_version=$(ovn-sbctl get SB_Global . options:northd_internal_version | sed s/\"//g)
echo "northd version = $northd_version"
AT_CHECK([grep -c $northd_version hv1/ovn-controller.log], [0], [1
])

# Stop ovn-northd so that we can modify the northd_version.
as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as northd-backup
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

check ovn-sbctl set SB_Global . options:northd_internal_version=foo

as hv1
check ovs-vsctl set interface vif2 external_ids:iface-id=foo

# ovn-controller should release the lport sw0-p2 since ovn-match-northd-version
# is not true.
wait_row_count Port_Binding 1 logical_port=sw0-p2 'chassis=[[]]'

as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [1], [dnl
0
])

echo
echo "__file__:__line__: Pin ovn-controller to ovn-northd version."

as hv1
check ovs-vsctl set open . external_ids:ovn-match-northd-version=true

OVS_WAIT_UNTIL(
    [test 1 = $(grep -c "controller version - $northd_version mismatch with northd version - foo" hv1/ovn-controller.log)
])

as hv1
check ovs-vsctl set interface vif2 external_ids:iface-id=sw0-p2

# ovn-controller should not claim sw0-p2 since there is version mismatch
as hv1 ovn-appctl -t ovn-controller recompute
wait_row_count Port_Binding 1 logical_port=sw0-p2 'chassis=[[]]'

as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [1], [dnl
0
])

check ovn-sbctl set SB_Global . options:northd_internal_version=$northd_version

# It should claim sw0-p2
wait_row_count Port_Binding 1 logical_port=sw0-p2 chassis=$ch

as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [0], [dnl
1
])

as hv1
ovn_remote=$(ovs-vsctl get open . external_ids:ovn-remote | sed s/\"//g)
ovs-vsctl set open . external_ids:ovn-remote=unix:foo
check ovs-vsctl set interface vif2 external_ids:iface-id=foo

# ovn-controller is not connected to the SB DB. Even though it
# releases sw0-p2, it will not delete the OF flows.
as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [0], [dnl
1
])

# Change the version to incorrect one and reconnect to the SB DB.
check ovn-sbctl set SB_Global . options:northd_internal_version=bar

as hv1
check ovs-vsctl set open . external_ids:ovn-remote=$ovn_remote

sleep 1

as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [0], [dnl
1
])

wait_row_count Port_Binding 1 logical_port=sw0-p2 chassis=$ch

# Change the ovn-remote to incorrect and set the correct northd version
# and then change back to the correct ovn-remote
as hv1
check ovs-vsctl set open . external_ids:ovn-remote=unix:foo

check ovn-sbctl set SB_Global . options:northd_internal_version=$northd_version

as hv1
check ovs-vsctl set open . external_ids:ovn-remote=$ovn_remote

wait_row_count Port_Binding 1 logical_port=sw0-p2 'chassis=[[]]'
as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [1], [dnl
0
])

as hv1
OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- propagate Port_Binding.up to NB and OVS])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl ls-add ls

AS_BOX([add OVS port for existing LSP])
check ovn-nbctl lsp-add ls lsp1
check ovn-nbctl --wait=hv sync
check_column "false" Port_Binding up logical_port=lsp1

check ovs-vsctl add-port br-int lsp1 -- set Interface lsp1 external-ids:iface-id=lsp1
wait_column "true" Port_Binding up logical_port=lsp1
wait_column "true" nb:Logical_Switch_Port up name=lsp1
OVS_WAIT_UNTIL([test `ovs-vsctl get Interface lsp1 external_ids:ovn-installed` = '"true"'])

AS_BOX([add LSP for existing OVS port])
check ovs-vsctl add-port br-int lsp2 -- set Interface lsp2 external-ids:iface-id=lsp2
check ovn-nbctl lsp-add ls lsp2
check ovn-nbctl --wait=hv sync
check_column "true" Port_Binding up logical_port=lsp2
wait_column "true" nb:Logical_Switch_Port up name=lsp2
OVS_WAIT_UNTIL([test `ovs-vsctl get Interface lsp2 external_ids:ovn-installed` = '"true"'])

AS_BOX([ovn-controller should not reset Port_Binding.up without northd])
# Pause northd and clear the "up" field to simulate older ovn-northd
# versions writing to the Southbound DB.
as northd ovn-appctl -t NORTHD_TYPE pause
as northd-backup ovn-appctl -t NORTHD_TYPE pause

as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-sbctl clear Port_Binding lsp1 up
as hv1 ovn-appctl -t ovn-controller debug/resume

# Forcefully release the Port_Binding so ovn-controller reclaims it.
# Make sure the Port_Binding.up field is not updated though.
check ovn-sbctl clear Port_Binding lsp1 chassis
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp1
check_column "" Port_Binding up logical_port=lsp1

# Once northd should explicitly set the Port_Binding.up field to 'false' and
# ovn-controller sets it to 'true' as soon as the update is processed.
as northd ovn-appctl -t NORTHD_TYPE resume
as northd-backup ovn-appctl -t NORTHD_TYPE resume
wait_column "true" Port_Binding up logical_port=lsp1
wait_column "true" nb:Logical_Switch_Port up name=lsp1

AS_BOX([ovn-controller should reset Port_Binding.up - from NULL])
# If Port_Binding.up is cleared externally, ovn-northd resets it to 'false'
# and ovn-controller finally sets it to 'true' once the update is processed.
as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-sbctl clear Port_Binding lsp1 up
check ovn-nbctl --wait=sb sync
wait_column "false" nb:Logical_Switch_Port up name=lsp1
as hv1 ovn-appctl -t ovn-controller debug/resume
wait_column "true" Port_Binding up logical_port=lsp1
wait_column "true" nb:Logical_Switch_Port up name=lsp1

AS_BOX([ovn-controller should reset Port_Binding.up - from false])
# If Port_Binding.up is externally set to 'false', ovn-controller should sets
# it to 'true' once the update is processed.
as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-sbctl set Port_Binding lsp1 up=false
check ovn-nbctl --wait=sb sync
wait_column "false" nb:Logical_Switch_Port up name=lsp1
as hv1 ovn-appctl -t ovn-controller debug/resume
wait_column "true" Port_Binding up logical_port=lsp1
wait_column "true" nb:Logical_Switch_Port up name=lsp1

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# Test case to check that ovn-controller doesn't assert when
# handling port group updates.
AT_SETUP([ovn -- No ovn-controller assert for port group updates])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=sw0-port1 \
    ofport-request=1

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "10:14:00:00:00:01 192.168.0.2"

check ovn-nbctl lsp-add sw0 sw0-port2
check ovn-nbctl lsp-add sw0 sw0-port3
check ovn-nbctl lsp-add sw0 sw0-port4
check ovn-nbctl lsp-add sw0 sw0-port5
check ovn-nbctl lsp-add sw0 sw0-port6
check ovn-nbctl lsp-add sw0 sw0-port7

ovn-nbctl create address_set name=as1
ovn-nbctl set address_set . addresses="10.0.0.10,10.0.0.11,10.0.0.12"

ovn-nbctl pg-add pg1 sw0-port1 sw0-port2 sw0-port3
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4.dst == \$as1 && icmp4" drop
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4.dst == \$as1 && tcp && tcp.dst >=10000 && tcp.dst <= 20000" drop
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4.dst == \$as1 && udp && udp.dst >=10000 && udp.dst <= 20000" drop

ovn-nbctl pg-add pg2 sw0-port2 sw0-port3 sw0-port4 sw0-port5
ovn-nbctl acl-add pg2 to-lport 1002 "outport == @pg2 && ip4.dst == \$as1 && icmp4" allow-related
ovn-nbctl acl-add pg2 to-lport 1002 "outport == @pg2 && ip4.dst == \$as1 && tcp && tcp.dst >=30000 && tcp.dst <= 40000" drop
ovn-nbctl acl-add pg2 to-lport 1002 "outport == @pg2 && ip4.dst == \$as1 && udp && udp.dst >=30000 && udp.dst <= 40000" drop

ovn-nbctl pg-add pg3 sw0-port1 sw0-port5
ovn-nbctl acl-add pg3 to-lport 1002 "outport == @pg3 && ip4.dst == \$as1 && icmp4" allow-related
ovn-nbctl acl-add pg3 to-lport 1002 "outport == @pg3 && ip4.dst == \$as1 && tcp && tcp.dst >=20000 && tcp.dst <= 30000" allow-related
ovn-nbctl acl-add pg3 to-lport 1002 "outport == @pg3 && ip4.dst == \$as1 && udp && udp.dst >=20000 && udp.dst <= 30000" allow-related

AS_BOX([Delete and add the port groups multiple times])

for i in $(seq 1 10)
do
    check ovn-nbctl --wait=hv clear port_Group pg1 ports
    check ovn-nbctl --wait=hv clear port_Group pg2 ports
    check ovn-nbctl --wait=hv clear port_Group pg3 ports
    check ovn-nbctl --wait=hv pg-set-ports pg1 sw0-port1
    check ovn-nbctl --wait=hv pg-set-ports pg1 sw0-port1 sw0-port4
    check ovn-nbctl --wait=hv pg-set-ports pg1 sw0-port1 sw0-port4 sw0-port5

    check ovn-nbctl --wait=hv pg-set-ports pg2 sw0-port2
    check ovn-nbctl --wait=hv pg-set-ports pg2 sw0-port2 sw0-port6
    check ovn-nbctl --wait=hv pg-set-ports pg2 sw0-port2 sw0-port6 sw0-port7

    check ovn-nbctl --wait=hv pg-set-ports pg3 sw0-port1
    check ovn-nbctl --wait=hv pg-set-ports pg3 sw0-port1 sw0-port3
    check ovn-nbctl --wait=hv pg-set-ports pg3 sw0-port1 sw0-port3 sw0-port6

    # Make sure that ovn-controller has not asserted.
    AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])
done

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# Test case to check that ovn-controller doesn't assert when
# handling conjunction flows.  When ovn-controller claims
# the first port of a logical switch datapath, it programs the flows
# for this datapath incrementally (without full recompute).  If
# suppose, in the same SB update from ovsdb-server, a logical flow is added
# which results in conjunction action, then this logical flow is also
# handled incrementally.  The newly added logical flow is processed
# twice which results in wrong oflows and it results in an assertion
# in ovn-controller.  Test this ovn-controller handles this scenario
# properly and doesn't assert.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- No ovn-controller assert when generating conjunction flows])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=sw0-p1 \
    ofport-request=1

check as hv1
ovs-vsctl set open . external_ids:ovn-monitor-all=true

check ovn-nbctl ls-add sw0
check ovn-nbctl pg-add pg1
check ovn-nbctl pg-add pg2
check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "00:00:00:00:00:02 192.168.47.2"
check ovn-nbctl lsp-add sw0 sw0-p3
check ovn-nbctl lsp-set-addresses sw0-p3 "00:00:00:00:00:03 192.168.47.3"

# Pause ovn-northd. When it is resumed, all the below NB updates
# will be sent in one transaction.

check as northd ovn-appctl -t NORTHD_TYPE pause
check as northd-backup ovn-appctl -t NORTHD_TYPE pause

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "00:00:00:00:00:01 192.168.47.1"
check ovn-nbctl pg-set-ports pg1 sw0-p1 sw0-p2
check ovn-nbctl pg-set-ports pg2 sw0-p3
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == \$pg2_ip4 && udp && udp.dst >= 1 && udp.dst <= 65535" allow-related

# resume ovn-northd now. This should result in a single update message
# from SB ovsdb-server to ovn-controller for all the above NB updates.
check as northd ovn-appctl -t NORTHD_TYPE resume

AS_BOX([Wait for sw0-p1 to be up])
wait_for_ports_up sw0-p1

# When the port group pg1 is updated, it should not result in
# any assert in ovn-controller.
ovn-nbctl --wait=hv pg-set-ports pg1 sw0-p1 sw0-p2 sw0-p3
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])
check ovn-nbctl --wait=hv sync

# Check OVS flows are installed properly.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=45 | ofctl_strip_all | \
    grep "priority=2002" | grep conjunction | \
    sed 's/conjunction([[^)]]*)/conjunction()/g' | sort], [0], [dnl
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x10/0xfff0 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x100/0xff00 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x1000/0xf000 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x2/0xfffe actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x20/0xffe0 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x200/0xfe00 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x2000/0xe000 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x4/0xfffc actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x40/0xffc0 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x400/0xfc00 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x4000/0xc000 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x8/0xfff8 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x80/0xff80 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x800/0xf800 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x8000/0x8000 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.3,tp_dst=1 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x100/0x100,reg15=0x3,metadata=0x1,nw_src=192.168.47.3 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x10/0xfff0 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x100/0xff00 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x1000/0xf000 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x2/0xfffe actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x20/0xffe0 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x200/0xfe00 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x2000/0xe000 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x4/0xfffc actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x40/0xffc0 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x400/0xfc00 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x4000/0xc000 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x8/0xfff8 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x80/0xff80 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x800/0xf800 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=0x8000/0x8000 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.3,tp_dst=1 actions=conjunction()
 table=45, priority=2002,udp,reg0=0x80/0x80,reg15=0x3,metadata=0x1,nw_src=192.168.47.3 actions=conjunction()
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

AT_SETUP([ovn -- OVN FDB (MAC learning) - 2 HVs, 2 LS, 1 LR ])
ovn_start

# Create the first logical switch with one port
check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3" unknown

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
# Port security is set for sw0-p2
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

# sw0-p1 and sw0-p3 have unknown address and no port security.
# FDB should be enabled for these lports.
check ovn-nbctl lsp-add sw0 sw0-p3
check ovn-nbctl lsp-set-addresses sw0-p3 unknown

# Create the second logical switch with one port
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1
check ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 11.0.0.3" unknown

check ovn-nbctl lsp-add sw1 sw1-p2
check ovn-nbctl lsp-set-addresses sw1-p2 "40:54:00:00:00:04 11.0.0.4"
check ovn-nbctl lsp-set-port-security sw1-p2 "40:54:00:00:00:04 11.0.0.4"

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 11.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 router
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1
ovn-nbctl --wait=hv sync

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2
ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=sw0-p3 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=2

OVN_POPULATE_ARP

ip_to_hex() {
    printf "%02x%02x%02x%02x" "$@"
}

send_icmp_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7 data=$8
    shift 8

    local ip_ttl=ff
    local ip_len=001c
    local packet=${eth_dst}${eth_src}08004500${ip_len}00004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}${data}
    echo $packet > expected
    as hv$hv ovs-appctl netdev-dummy/receive hv$hv-vif$inport $packet
}

reset_pcap_file() {
    local iface=$1
    local pcap_file=$2
    ovs-vsctl -- set Interface $iface options:tx_pcap=dummy-tx.pcap \
options:rxq_pcap=dummy-rx.pcap
    rm -f ${pcap_file}*.pcap
    ovs-vsctl -- set Interface $iface options:tx_pcap=${pcap_file}-tx.pcap \
options:rxq_pcap=${pcap_file}-rx.pcap
}

trim_zeros() {
    sed 's/\(00\)\{1,\}$//'
}

AS_BOX([Wait for all ports to be up])
wait_for_ports_up

# Check that there is put_fdb() flow added by ovn-northd for sw0-p1
ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep "ls_in_lookup_fdb" sw0flows | sort], [0], [dnl
  table=3 (ls_in_lookup_fdb   ), priority=0    , dnl
match=(1), action=(next;)
  table=3 (ls_in_lookup_fdb   ), priority=100  , dnl
match=(inport == "sw0-p1"), action=(reg0[[11]] = lookup_fdb(inport, eth.src); next;)
  table=3 (ls_in_lookup_fdb   ), priority=100  , dnl
match=(inport == "sw0-p3"), action=(reg0[[11]] = lookup_fdb(inport, eth.src); next;)
])

AT_CHECK([grep "ls_in_put_fdb" sw0flows | sort], [0], [dnl
  table=4 (ls_in_put_fdb      ), priority=0    , dnl
match=(1), action=(next;)
  table=4 (ls_in_put_fdb      ), priority=100  , dnl
match=(inport == "sw0-p1" && reg0[[11]] == 0), action=(put_fdb(inport, eth.src); next;)
  table=4 (ls_in_put_fdb      ), priority=100  , dnl
match=(inport == "sw0-p3" && reg0[[11]] == 0), action=(put_fdb(inport, eth.src); next;)
])

# Send a packet from sw0-p1 with a different mac not present
# in it's addresses.
AS_BOX([Send a pkt from sw0-p1 with a different mac address])

# Use the src mac 50:54:00:00:00:13 instead of 50:54:00:00:00:03
src_mac=505400000013
src_ip=$(ip_to_hex 10 0 0 13)

# send the packet to sw0-p2
dst_mac=505400000004
dst_ip=$(ip_to_hex 10 0 0 4)

data=0800bee4391a0001
send_icmp_packet 1 1 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# There should be one row in fdb
AS_BOX([Check that the FDB entry is created])
wait_row_count FDB 1

sw0_dpkey=$(fetch_column datapath_binding tunnel_key external_ids:name=sw0)
sw0p1_dpkey=$(fetch_column port_binding tunnel_key logical_port=sw0-p1)
sw0p3_dpkey=$(fetch_column port_binding tunnel_key logical_port=sw0-p3)

check_column '50:54:00:00:00:13' fdb mac
check_column $sw0_dpkey fdb dp_key
check_column $sw0p1_dpkey fdb port_key

# Make sure that OVS tables 71 and 72 are populated on both hv1 and hv2.
AS_BOX([Check that ovn-controller programs the flows for FDB])
as hv1 ovs-ofctl dump-flows br-int table=71 > hv1_offlows_table71.txt
as hv2 ovs-ofctl dump-flows br-int table=71 > hv2_offlows_table71.txt

AT_CAPTURE_FILE([hv1_offlows_table71.txt])
AT_CAPTURE_FILE([hv2_offlows_table71.txt])
AT_CHECK([cat hv1_offlows_table71.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,metadata=0x1,dl_dst=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG15[[]]
])

AT_CHECK([cat hv2_offlows_table71.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,metadata=0x1,dl_dst=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG15[[]]
])

as hv1 ovs-ofctl dump-flows br-int table=72 > hv1_offlows_table72.txt
as hv2 ovs-ofctl dump-flows br-int table=72 > hv2_offlows_table72.txt

AT_CAPTURE_FILE([hv1_offlows_table72.txt])
AT_CAPTURE_FILE([hv2_offlows_table72.txt])
AT_CHECK([cat hv1_offlows_table72.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,reg14=0x1,metadata=0x1,dl_src=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[8]]
])

AT_CHECK([cat hv2_offlows_table72.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,reg14=0x1,metadata=0x1,dl_src=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[8]]
])

# Use the src mac 50:54:00:00:00:14 instead of 50:54:00:00:00:03
src_mac=505400000014
src_ip=$(ip_to_hex 10 0 0 14)

as hv2 reset_pcap_file hv2-vif1 hv2/vif1

send_icmp_packet 1 1 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# There should be two rows in fdb
wait_row_count FDB 2

check_column "50:54:00:00:00:13 50:54:00:00:00:14" fdb mac
check_column "$sw0_dpkey $sw0_dpkey" fdb dp_key
check_column "$sw0p1_dpkey $sw0p1_dpkey" fdb port_key

# Make sure that OVS tables 71 and 72 are populated on both hv1 and hv2.
as hv1 ovs-ofctl dump-flows br-int table=71 > hv1_offlows_table71.txt
as hv2 ovs-ofctl dump-flows br-int table=71 > hv2_offlows_table71.txt

AT_CAPTURE_FILE([hv1_offlows_table71.txt])
AT_CAPTURE_FILE([hv2_offlows_table71.txt])
AT_CHECK([cat hv1_offlows_table71.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,metadata=0x1,dl_dst=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG15[[]]
priority=100,metadata=0x1,dl_dst=50:54:00:00:00:14 actions=load:0x1->NXM_NX_REG15[[]]
])

AT_CHECK([cat hv2_offlows_table71.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,metadata=0x1,dl_dst=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG15[[]]
priority=100,metadata=0x1,dl_dst=50:54:00:00:00:14 actions=load:0x1->NXM_NX_REG15[[]]
])

as hv1 ovs-ofctl dump-flows br-int table=72 > hv1_offlows_table72.txt
as hv2 ovs-ofctl dump-flows br-int table=72 > hv2_offlows_table72.txt

AT_CAPTURE_FILE([hv1_offlows_table72.txt])
AT_CAPTURE_FILE([hv2_offlows_table72.txt])
AT_CHECK([cat hv1_offlows_table72.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,reg14=0x1,metadata=0x1,dl_src=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[8]]
priority=100,reg14=0x1,metadata=0x1,dl_src=50:54:00:00:00:14 actions=load:0x1->NXM_NX_REG10[[8]]
])

AT_CHECK([cat hv2_offlows_table72.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,reg14=0x1,metadata=0x1,dl_src=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[8]]
priority=100,reg14=0x1,metadata=0x1,dl_src=50:54:00:00:00:14 actions=load:0x1->NXM_NX_REG10[[8]]
])

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file hv2-vif1 hv2/vif1

# Send the packet from sw0-p2 to sw0-p1 with the dst mac 50:54:00:00:00:13
src_mac=505400000004
src_ip=$(ip_to_hex 10 0 0 4)

dst_mac=505400000013
dst_ip=$(ip_to_hex 10 0 0 13)

send_icmp_packet 1 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
dst_mac=505400000014
dst_ip=$(ip_to_hex 10 0 0 14)

send_icmp_packet 1 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif3 hv1/vif3

# Send a packet from sw0-p2 to an unknown mac. Should be received
# by both sw0-p1 and sw0-p3 (as unknown is set).
AS_BOX([Send pkt from sw0-p2 to an unknown mac])

src_mac=505400000004
src_ip=$(ip_to_hex 10 0 0 4)

dst_mac=505400000023
dst_ip=$(ip_to_hex 10 0 0 23)

send_icmp_packet 1 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])
OVN_CHECK_PACKETS([hv1/vif3-tx.pcap], [expected])

AS_BOX([Flip the mac - 50:54:00:00:00:13 from sw0-p1 to sw0-p3])

# Use the src mac 50:54:00:00:00:13
src_mac=505400000013
src_ip=$(ip_to_hex 10 0 0 23)

# send the packet to sw0-p2
dst_mac=505400000004
dst_ip=$(ip_to_hex 10 0 0 4)

data=0800bee4391a0001

as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv1 reset_pcap_file hv1-vif3 hv1/vif3

# Send the pkt from sw0-p3 to sw0-p2.
send_icmp_packet 3 1 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# fdb row count should be still 2. But the mac 50:54:00:00:00:13
# should be learnt on sw0-p3.

wait_row_count FDB 2

check_column "50:54:00:00:00:13 50:54:00:00:00:14" fdb mac
check_column "$sw0_dpkey $sw0_dpkey" fdb dp_key
check_column "$sw0p1_dpkey $sw0p3_dpkey" fdb port_key

check_column "$sw0p3_dpkey" fdb port_key mac="50\:54\:00\:00\:00\:13"

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif3 hv1/vif3

# Send the packet from sw0-p2 to sw0-p3 with the dst mac 50:54:00:00:00:13
src_mac=505400000004
src_ip=$(ip_to_hex 10 0 0 4)

dst_mac=505400000013
dst_ip=$(ip_to_hex 10 0 0 13)

send_icmp_packet 1 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv1/vif3-tx.pcap], [expected])

# sw0-p1 should not receive the packet.
: > expected
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

AS_BOX([Test routing])

# Test the routing.
# Send the packet from sw1-p2 (hv1) to sw0-p1 (hv1) with dst ip 10.0.0.14
# The packet should be delivered to sw0-p1 with dst mac 50:54:00:00:00:14
# Before sending add mac_binding entry for 10.0.0.14

lr0_dp_uuid=$(fetch_column datapath_binding _uuid external_ids:name=lr0)

ovn-sbctl create mac_binding ip=10.0.0.14 logical_port=lr0-sw0 \
mac="50\:54\:00\:00\:00\:14" datapath=$lr0_dp_uuid

# Wait till the mac_binding flows appear in hv1
OVS_WAIT_UNTIL([test 1 = $(as hv1 ovs-ofctl dump-flows br-int table=66 \
| grep -c  reg0=0xa00000e)])

src_mac=405400000004
src_ip=$(ip_to_hex 11 0 0 4)

dst_mac=00000000ff02 # lr0-sw1 mac
dst_ip=$(ip_to_hex 10 0 0 14)

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif3 hv1/vif3

send_icmp_packet 2 1 $src_mac $dst_mac $src_ip $dst_ip 0000 $data

exp_packet=50540000001400000000ff0108004500001c00004000fe010100${src_ip}${dst_ip}${data}
echo $exp_packet > expected
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# sw0-p3 should not receive the packet.
: > expected
OVN_CHECK_PACKETS([hv1/vif3-tx.pcap], [expected])

# Now the send the packet from sw1-p1 (hv2) to sw0-p1 (hv1) with dst ip 10.0.0.14
# The acket should be delivered to sw0-p1 with dst mac 50:54:00:00:00:14

src_mac=405400000003
src_ip=$(ip_to_hex 11 0 0 3)

dst_mac=00000000ff02 # lr0-sw1 mac
dst_ip=$(ip_to_hex 10 0 0 14)

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
send_icmp_packet 2 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data

exp_packet=50540000001400000000ff0108004500001c00004000fe010100${src_ip}${dst_ip}${data}
echo $exp_packet > expected
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

AS_BOX([Clear the FDB rows])

# Clear the fdb rows.
check ovn-sbctl --all destroy fdb
ovn-sbctl list fdb

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif3 hv1/vif3

# Send the packet from sw0-p2 to sw0-p1 with the dst mac 50:54:00:00:00:14
# It should be delivered to both sw0-p1 and sw0-p3 since we have cleared the
# FDB table.
src_mac=505400000004
src_ip=$(ip_to_hex 10 0 0 4)

dst_mac=505400000014
dst_ip=$(ip_to_hex 10 0 0 13)

send_icmp_packet 1 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])
OVN_CHECK_PACKETS([hv1/vif3-tx.pcap], [expected])

# Make sure that OVS tables 71 and 72 are empty.
as hv1 ovs-ofctl dump-flows br-int table=71 > hv1_offlows_table71.txt
as hv2 ovs-ofctl dump-flows br-int table=71 > hv2_offlows_table71.txt

AT_CAPTURE_FILE([hv1_offlows_table71.txt])
AT_CAPTURE_FILE([hv2_offlows_table71.txt])
AT_CHECK([cat hv1_offlows_table71.txt | grep -v NXST], [1], [dnl
])

AT_CHECK([cat hv2_offlows_table71.txt | grep -v NXST], [1], [dnl
])

as hv1 ovs-ofctl dump-flows br-int table=72 > hv1_offlows_table72.txt
as hv2 ovs-ofctl dump-flows br-int table=72 > hv2_offlows_table72.txt

AT_CAPTURE_FILE([hv1_offlows_table72.txt])
AT_CAPTURE_FILE([hv2_offlows_table72.txt])
AT_CHECK([cat hv1_offlows_table72.txt | grep -v NXST], [1], [dnl
])

AT_CHECK([cat hv2_offlows_table72.txt | grep -v NXST], [1], [dnl
])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])
