# OVN_CHECK_PACKETS([PCAP], [EXPECTED])
#
# This compares packets read from PCAP, in pcap format, to those read
# from EXPECTED, which is a text file containing packets as hex
# strings, one per line.  If PCAP contains fewer packets than
# EXPECTED, it waits up to 10 seconds for more packets to appear.
#
# The implementation is an m4 macro that is mostly implemented in
# terms of a shell function.  This reduces the size of the generated
# testsuite file since the shell function is only emitted once even
# when this macro is invoked many times.
m4_divert_text([PREPARE_TESTS],
  [dump_diff__ () {
     local rcv_pcap=$1 exp_text=$2
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     echo "Expected:"
     sort $exp_text
     echo "Received:"
     sort $rcv_text
     sort $exp_text -o $exp_text.sorted
     sort $rcv_text -o $rcv_text.sorted
     echo "Diff:"
     diff -u $exp_text.sorted $rcv_text.sorted
   }
   ovn_check_packets__ () {
     if [[ -n "$4" ]]; then
       echo "$3: checking packets in $1 against $2: using $4"
     else
       echo "$3: checking packets in $1 against $2:"
     fi
     rcv_pcap=$1
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     exp_text=$2
     exp_n=`wc -l < "$exp_text"`
     OVS_WAIT_UNTIL(
       [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $rcv_pcap > $rcv_text
        rcv_n=`wc -l < "$rcv_text"`
        echo "rcv_n=$rcv_n exp_n=$exp_n"
        test $rcv_n -ge $exp_n],
       [dump_diff__ "$rcv_pcap" "$exp_text"])
     if [[ -n "$4" ]]; then
       sort $exp_text | $4 > expout
       cat $rcv_text | $4 > rcv_tmp
       mv rcv_tmp $rcv_text
     else
       sort $exp_text > expout
     fi
   }
   ovn_check_packets_remove_broadcast__ () {
     echo "$3: checking packets in $1 against $2:"
     rcv_pcap=$1
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     exp_text=$2
     exp_n=`wc -l < "$exp_text"`
     OVS_WAIT_UNTIL(
       [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $rcv_pcap > $rcv_text
        sed -i '/ffffffffffff/d' $rcv_text
        rcv_n=`wc -l < "$rcv_text"`
        echo "rcv_n=$rcv_n exp_n=$exp_n"
        test $rcv_n -ge $exp_n],
       [dump_diff__ "$rcv_pcap" "$exp_text"])
     sort $exp_text > expout
   }
   ovn_wait_packets__ () {
     echo "$3: waiting for packets from $2 at $1:"
     if [[ -n "$4" ]]; then
       echo "$3: checking packets from $2 at $1: using $4"
     else
       echo "$3: checking packets from $2 at $1:"
     fi
     rcv_pcap=$1
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     exp_text=$2
     if [[ -n "$4" ]]; then
       cmd=$4
     else
       cmd=:
     fi
     OVS_WAIT_UNTIL(
       [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $rcv_pcap > $rcv_text
        sort $exp_text | $cmd > expout
        test x"$(sort $rcv_text | $cmd | comm -2 -3 expout -)" = "x"],
       [dump_diff__ "$rcv_pcap" "$exp_text"])
     cat $rcv_text | $cmd > rcv_tmp
     mv rcv_tmp $rcv_text
   }
   ovn_wait_packets_uniq__ () {
     echo "$3: waiting for packets from $2 at $1:"
     rcv_pcap=$1
     rcv_text=`echo "$rcv_pcap.packets" | sed 's/\.pcap//'`
     exp_text=$2
     OVS_WAIT_UNTIL(
       [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $rcv_pcap > $rcv_text
        sort $exp_text > expout
        test x"$(sort $rcv_text | uniq | comm -3 expout -)" = "x"],
       [dump_diff__ "$rcv_pcap" "$exp_text"])
   }

   ovn_wait_patch_port_flows () {
     for localnet in $1; do
       patch_port="patch-br-int-to-$localnet"
       for hv in $2; do
         echo "$3: waiting for flows for $patch_port on $hv"
         # Patch port might be created after ports are reported up
         OVS_WAIT_UNTIL([
             test 1 = $(as $hv ovs-vsctl show | grep "Port \b$patch_port\b" | wc -l)
         ])
         # Wait for a flow outputing to patch port
         OVS_WAIT_UNTIL([
             hv_patch_ofport=$(as $hv ovs-vsctl --bare --columns ofport find Interface name=$patch_port)
             echo "$patch_port=$hv_patch_ofport"
             test 1 -le $(as $hv ovs-ofctl dump-flows br-int | grep -c "output:\b$hv_patch_ofport\b")
         ])
       done
     done
   }

   ovn_wait_remote_output_flows () {
     hv1=$1
     hv2=$2
     echo "$3: waiting for flows for remote output on $hv1"
     # Wait for a flow outputing  to remote output
     OVS_WAIT_UNTIL([
         ofport=$(as $hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-${hv2}-0)
         echo "tunnel port=$ofport"
         test 1 -le $(as $hv1 ovs-ofctl dump-flows br-int | grep -c "output:$ofport")
     ])
   }

   ovn_wait_remote_input_flows () {
     hv1=$1
     hv2=$2
     echo "$3: waiting for flows for remote input on $hv1"
     # Wait for a flow outputing  to remote input
     OVS_WAIT_UNTIL([
         ofport=$(as $hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-${hv2}-0)
         echo "tunnel port=$ofport"
         test 1 -le $(as $hv1 ovs-ofctl dump-flows br-int | grep -c "in_port=$ofport")
     ])
   }

   # ovn_wait_for_bfd_up HV
   # BFD might be quite slow. While BFD is not up, all chassis will fight to claim the port
   # Wait for BFD between different chassis to be up
   ovn_wait_for_bfd_up() {
     for hv; do
       as $hv
       for chassis; do
         if test $hv != $chassis; then
             echo "checking bdf_status for $hv -> $chassis"
             OVS_WAIT_UNTIL([
                 bfd_status=$(as $hv ovs-vsctl get interface ovn-$chassis-0 bfd_status:state)
                 echo "bfd status = $bfd_status"
                 test "$bfd_status" = "up"
             ])
         fi
       done
     done
   }
])

m4_define([OVN_CHECK_PACKETS],
  [AT_CHECK([$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $1 ], [0], [ignore])
   ovn_check_packets__ "$1" "$2" "__file__:__line__" $3
   AT_CHECK([sort $rcv_text], [0], [expout], [ignore], [dump_diff__ "$1" "$2"])])

m4_define([OVN_CHECK_PACKETS_REMOVE_BROADCAST],
  [ovn_check_packets_remove_broadcast__ "$1" "$2" "__file__:__line__"
   AT_CHECK([sort $rcv_text], [0], [expout], [ignore], [dump_diff__ "$1" "$2"])])

m4_define([OVN_CHECK_PACKETS_CONTAIN],
  [ovn_wait_packets__ "$1" "$2" "__file__:__line__"])

# OVN_CHECK_PACKETS_UNIQ succeeds if some expected packets are duplicated.
# It fails if unexpected packets are received.
m4_define([OVN_CHECK_PACKETS_UNIQ],
  [ovn_wait_packets_uniq__ "$1" "$2" "__file__:__line__"])

m4_define([OVN_WAIT_PATCH_PORT_FLOWS],
  [ovn_wait_patch_port_flows "$1" "$2" "__file__:__line__"])

m4_define([OVN_WAIT_REMOTE_OUTPUT_FLOWS],
  [ovn_wait_remote_output_flows "$1" "$2" "__file__:__line__"])

m4_define([OVN_WAIT_REMOTE_INPUT_FLOWS],
  [ovn_wait_remote_input_flows "$1" "$2" "__file__:__line__"])

AT_BANNER([OVN components])

AT_SETUP([lexer])
dnl For lines without =>, input and expected output are identical.
dnl For lines with =>, input precedes => and expected output follows =>.
AT_DATA([test-cases.txt], [dnl
foo bar baz quuxquuxquux _abcd_ a.b.c.d a123_.456
"abc\u0020def" => "abc def"
" => error("Input ends inside quoted string.")dnl "

$foo $bar $baz $quuxquuxquux $_abcd_ $a.b.c.d $a123_.456
$1 => error("`$' must be followed by a valid identifier.") 1

a/*b*/c => a c
a//b c => a
a/**/b => a b
a/*/b => a error("`/*' without matching `*/'.")
a/*/**/b => a b
a/b => a error("`/' is only valid as part of `//' or `/*'.") b

0 1 12345 18446744073709551615
18446744073709551616 => error("Decimal constants must be less than 2**64.")
9999999999999999999999 => error("Decimal constants must be less than 2**64.")
01 => error("Decimal constants must not have leading zeros.")

0/0
0/1
1/0 => 0/0
1/1
128/384
1/3
1/ => error("Integer constant expected.")

1/0x123 => error("Value and mask have incompatible formats.")

0x1234
0x01234 => 0x1234
0x0 => 0
0x000 => 0
0xfedcba9876543210
0XFEDCBA9876543210 => 0xfedcba9876543210
0xfedcba9876543210fedcba9876543210
0x0000fedcba9876543210fedcba9876543210 => 0xfedcba9876543210fedcba9876543210
0x => error("Hex digits expected following 0x.")
0X => error("Hex digits expected following 0X.")
0x0/0x0 => 0/0
0x0/0x1 => 0/0x1
0x1/0x0 => 0/0
0xffff/0x1ffff
0x. => error("Invalid syntax in hexadecimal constant.")

192.168.128.1 1.2.3.4 255.255.255.255 0.0.0.0
256.1.2.3 => error("Invalid numeric constant.")
192.168.0.0/16
192.168.0.0/255.255.0.0 => 192.168.0.0/16
192.168.0.0/255.255.255.0 => 192.168.0.0/24
192.168.0.0/255.255.0.255
192.168.0.0/255.0.0.0 => 192.0.0.0/8
192.168.0.0/32
192.168.0.0/255.255.255.255 => 192.168.0.0/32
192.168.0.2/32
192.168.0.2/30 => 192.168.0.0/30
192.168.0.2/24 => 192.168.0.0/24
1.2.3.4:5 => 1.2.3.4 : 5

::
::1
ff00::1234 => ff00::1234
2001:db8:85a3::8a2e:370:7334
2001:db8:85a3:0:0:8a2e:370:7334 => 2001:db8:85a3::8a2e:370:7334
2001:0db8:85a3:0000:0000:8a2e:0370:7334 => 2001:db8:85a3::8a2e:370:7334
::ffff:192.0.2.128
::ffff:c000:0280 => ::ffff:192.0.2.128
::1/::1
::1/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff => ::1/128
::1/128
ff00::/8
ff00::/ff00:: => ff00::/8

01:23:45:67:ab:cd
01:23:45:67:AB:CD => 01:23:45:67:ab:cd
fe:dc:ba:98:76:54
FE:DC:ba:98:76:54 => fe:dc:ba:98:76:54
01:00:00:00:00:00/01:00:00:00:00:00
ff:ff:ff:ff:ff:ff/ff:ff:ff:ff:ff:ff
fe:ff:ff:ff:ff:ff/ff:ff:ff:ff:ff:ff
ff:ff:ff:ff:ff:ff/fe:ff:ff:ff:ff:ff => fe:ff:ff:ff:ff:ff/fe:ff:ff:ff:ff:ff
fe:x => error("Invalid numeric constant.")
00:01:02:03:04:x => error("Invalid numeric constant.")

# Test that operators are tokenized as expected, even without white space.
(){}[[]]==!=<<=>>=!&&||..,;=<->--: => ( ) { } [[ ]] == != < <= > >= ! && || .. , ; = <-> -- :
& => error("`&' is only valid as part of `&&'.")
| => error("`|' is only valid as part of `||'.")

^ => error("`^' must be followed by a valid identifier.")
])
AT_CAPTURE_FILE([input.txt])
sed 's/ =>.*//' test-cases.txt > input.txt
sed 's/.* => //' test-cases.txt > expout
AT_CHECK([ovstest test-ovn lex < input.txt], [0], [expout])
AT_CLEANUP

dnl The OVN expression parser needs to know what fields overlap with one
dnl another.  This test therefore verifies that all the smaller registers
dnl are defined as terms of subfields of the larger ones.
dnl
dnl When we add or remove registers this test needs to be updated, of course.
AT_SETUP([registers])
AT_CHECK([ovstest test-ovn dump-symtab | grep reg | sort], [0],
[[reg0 = xxreg0[96..127]
reg1 = xxreg0[64..95]
reg2 = xxreg0[32..63]
reg3 = xxreg0[0..31]
reg4 = xxreg1[96..127]
reg5 = xxreg1[64..95]
reg6 = xxreg1[32..63]
reg7 = xxreg1[0..31]
reg8 = xreg4[32..63]
reg9 = xreg4[0..31]
xreg0 = xxreg0[64..127]
xreg1 = xxreg0[0..63]
xreg2 = xxreg1[64..127]
xreg3 = xxreg1[0..63]
xreg4 = OXM_OF_PKT_REG4
xxreg0 = NXM_NX_XXREG0
xxreg1 = NXM_NX_XXREG1
]])
AT_CLEANUP

dnl Check that the OVN conntrack field definitions are correct.
AT_SETUP([conntrack fields])
AT_CHECK([ovstest test-ovn dump-symtab | grep ^ct | sort], [0],
[[ct.dnat = ct_state[7]
ct.est = ct_state[1]
ct.inv = ct_state[4]
ct.new = ct_state[0]
ct.rel = ct_state[2]
ct.rpl = ct_state[3]
ct.snat = ct_state[6]
ct.trk = ct_state[5]
ct_label = NXM_NX_CT_LABEL
ct_label.blocked = ct_label[0]
ct_label.ecmp_reply_eth = ct_label[32..79]
ct_label.ecmp_reply_port = ct_label[80..95]
ct_label.force_snat = ct_label[3]
ct_label.label = ct_label[96..127]
ct_label.natted = ct_label[1]
ct_label.skip_snat = ct_label[2]
ct_mark = NXM_NX_CT_MARK
ct_mark.blocked = ct_mark[0]
ct_mark.ecmp_reply_port = ct_mark[16..31]
ct_mark.force_snat = ct_mark[3]
ct_mark.natted = ct_mark[1]
ct_mark.skip_snat = ct_mark[2]
ct_state = NXM_NX_CT_STATE
]])
AT_CLEANUP

AT_SETUP([composition])
AT_CHECK([ovstest test-ovn composition 2], [0], [ignore])
AT_CLEANUP

AT_SETUP([expression parser])
dnl For lines without =>, input and expected output are identical.
dnl For lines with =>, input precedes => and expected output follows =>.
AT_DATA([test-cases.txt], [[
eth.type == 0x800
eth.type==0x800 => eth.type == 0x800
eth.type[0..15] == 0x800 => eth.type == 0x800

vlan.present
vlan.present == 1 => vlan.present
!(vlan.present == 0) => vlan.present
!(vlan.present != 1) => vlan.present
!vlan.present
vlan.present == 0 => !vlan.present
vlan.present != 1 => !vlan.present
!(vlan.present == 1) => !vlan.present
!(vlan.present != 0) => !vlan.present

eth.dst[0]
eth.dst[0] == 1 => eth.dst[0]
eth.dst[0] != 0 => eth.dst[0]
!(eth.dst[0] == 0) => eth.dst[0]
!(eth.dst[0] != 1) => eth.dst[0]

!eth.dst[0]
eth.dst[0] == 0 => !eth.dst[0]
eth.dst[0] != 1 => !eth.dst[0]
!(eth.dst[0] == 1) => !eth.dst[0]
!(eth.dst[0] != 0) => !eth.dst[0]

vlan.tci[12..15] == 0x3
vlan.tci == 0x3000/0xf000 => vlan.tci[12..15] == 0x3
vlan.tci[12..15] != 0x3
vlan.tci != 0x3000/0xf000 => vlan.tci[12..15] != 0x3

!vlan.pcp => vlan.pcp == 0
!(vlan.pcp) => vlan.pcp == 0
vlan.pcp == 0x4
vlan.pcp != 0x4
vlan.pcp > 0x4
vlan.pcp >= 0x4
vlan.pcp < 0x4
vlan.pcp <= 0x4
!(vlan.pcp != 0x4) => vlan.pcp == 0x4
!(vlan.pcp == 0x4) => vlan.pcp != 0x4
!(vlan.pcp <= 0x4) => vlan.pcp > 0x4
!(vlan.pcp < 0x4) => vlan.pcp >= 0x4
!(vlan.pcp >= 0x4) => vlan.pcp < 0x4
!(vlan.pcp > 0x4) => vlan.pcp <= 0x4
0x4 == vlan.pcp => vlan.pcp == 0x4
0x4 != vlan.pcp => vlan.pcp != 0x4
0x4 < vlan.pcp => vlan.pcp > 0x4
0x4 <= vlan.pcp => vlan.pcp >= 0x4
0x4 > vlan.pcp => vlan.pcp < 0x4
0x4 >= vlan.pcp => vlan.pcp <= 0x4
!(0x4 != vlan.pcp) => vlan.pcp == 0x4
!(0x4 == vlan.pcp) => vlan.pcp != 0x4
!(0x4 >= vlan.pcp) => vlan.pcp > 0x4
!(0x4 > vlan.pcp) => vlan.pcp >= 0x4
!(0x4 <= vlan.pcp) => vlan.pcp < 0x4
!(0x4 < vlan.pcp) => vlan.pcp <= 0x4

1 < vlan.pcp < 4 => vlan.pcp > 0x1 && vlan.pcp < 0x4
1 <= vlan.pcp <= 4 => vlan.pcp >= 0x1 && vlan.pcp <= 0x4
1 < vlan.pcp <= 4 => vlan.pcp > 0x1 && vlan.pcp <= 0x4
1 <= vlan.pcp < 4 => vlan.pcp >= 0x1 && vlan.pcp < 0x4
1 <= vlan.pcp <= 4 => vlan.pcp >= 0x1 && vlan.pcp <= 0x4
4 > vlan.pcp > 1 => vlan.pcp < 0x4 && vlan.pcp > 0x1
4 >= vlan.pcp > 1 => vlan.pcp <= 0x4 && vlan.pcp > 0x1
4 > vlan.pcp >= 1 => vlan.pcp < 0x4 && vlan.pcp >= 0x1
4 >= vlan.pcp >= 1 => vlan.pcp <= 0x4 && vlan.pcp >= 0x1
!(1 < vlan.pcp < 4) => vlan.pcp <= 0x1 || vlan.pcp >= 0x4
!(1 <= vlan.pcp <= 4) => vlan.pcp < 0x1 || vlan.pcp > 0x4
!(1 < vlan.pcp <= 4) => vlan.pcp <= 0x1 || vlan.pcp > 0x4
!(1 <= vlan.pcp < 4) => vlan.pcp < 0x1 || vlan.pcp >= 0x4
!(1 <= vlan.pcp <= 4) => vlan.pcp < 0x1 || vlan.pcp > 0x4
!(4 > vlan.pcp > 1) => vlan.pcp >= 0x4 || vlan.pcp <= 0x1
!(4 >= vlan.pcp > 1) => vlan.pcp > 0x4 || vlan.pcp <= 0x1
!(4 > vlan.pcp >= 1) => vlan.pcp >= 0x4 || vlan.pcp < 0x1
!(4 >= vlan.pcp >= 1) => vlan.pcp > 0x4 || vlan.pcp < 0x1

vlan.pcp == {1, 2, 3, 4} => vlan.pcp == 0x1 || vlan.pcp == 0x2 || vlan.pcp == 0x3 || vlan.pcp == 0x4
vlan.pcp == 1 || ((vlan.pcp == 2 || vlan.pcp == 3) || vlan.pcp == 4) => vlan.pcp == 0x1 || vlan.pcp == 0x2 || vlan.pcp == 0x3 || vlan.pcp == 0x4

vlan.pcp != {1, 2, 3, 4} => vlan.pcp != 0x1 && vlan.pcp != 0x2 && vlan.pcp != 0x3 && vlan.pcp != 0x4
vlan.pcp == 1 && ((vlan.pcp == 2 && vlan.pcp == 3) && vlan.pcp == 4) => vlan.pcp == 0x1 && vlan.pcp == 0x2 && vlan.pcp == 0x3 && vlan.pcp == 0x4

vlan.pcp == 1 && !((vlan.pcp == 2 && vlan.pcp == 3) && vlan.pcp == 4) => vlan.pcp == 0x1 && (vlan.pcp != 0x2 || vlan.pcp != 0x3 || vlan.pcp != 0x4)
vlan.pcp == 1 && (!(vlan.pcp == 2 && vlan.pcp == 3) && vlan.pcp == 4) => vlan.pcp == 0x1 && (vlan.pcp != 0x2 || vlan.pcp != 0x3) && vlan.pcp == 0x4
vlan.pcp == 1 && !(!(vlan.pcp == 2 && vlan.pcp == 3) && vlan.pcp == 4) => vlan.pcp == 0x1 && ((vlan.pcp == 0x2 && vlan.pcp == 0x3) || vlan.pcp != 0x4)

ip4.src == {10.0.0.0/8, 192.168.0.0/16, 172.16.20.0/24, 8.8.8.8} => ip4.src[24..31] == 0xa || ip4.src[16..31] == 0xc0a8 || ip4.src[8..31] == 0xac1014 || ip4.src == 0x8080808
ip6.src == ::1 => ip6.src == 0x1

ip4.src == 1.2.3.4 => ip4.src == 0x1020304
ip4.src == ::1.2.3.4/::ffff:ffff => ip4.src == 0x1020304
ip6.src == ::1 => ip6.src == 0x1

1
0
!1 => 0
!0 => 1

inport == "eth0"
!(inport != "eth0") => inport == "eth0"

(((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) => 0

ip4.src == "eth0" => Integer field ip4.src is not compatible with string constant.
inport == 1 => String field inport is not compatible with integer constant.
ip4.src = 1.2.3.4 => Syntax error at `=' expecting relational operator.

ip4.src > {1, 2, 3} => Only == and != operators may be used with value sets.
eth.type > 0x800 => Only == and != operators may be used with nominal field eth.type.
vlan.present > 0 => Only == and != operators may be used with Boolean field vlan.present.

inport != "eth0" => Nominal field inport may only be tested for equality (taking enclosing `!' operators into account).
!(inport == "eth0") => Nominal field inport may only be tested for equality (taking enclosing `!' operators into account).
eth.type != 0x800 => Nominal field eth.type may only be tested for equality (taking enclosing `!' operators into account).
!(eth.type == 0x800) => Nominal field eth.type may only be tested for equality (taking enclosing `!' operators into account).
inport = "eth0" => Syntax error at `=' expecting relational operator.

123 == 123 => Syntax error at `123' expecting field name.

$name => Syntax error at `$name' expecting address set name.
@name => Syntax error at `@name' expecting port group name.

123 == xyzzy => Syntax error at `xyzzy' expecting field name.
xyzzy == 1 => Syntax error at `xyzzy' expecting field name.

inport[1] == 1 => Cannot select subfield of string field inport.

eth.type[] == 1 => Syntax error at `@:>@' expecting small integer.
eth.type[::1] == 1 => Syntax error at `::1' expecting small integer.
eth.type[18446744073709551615] == 1 => Syntax error at `18446744073709551615' expecting small integer.

eth.type[5!] => Syntax error at `!' expecting `@:>@'.

eth.type[5..1] => Invalid bit range 5 to 1.

eth.type[12..16] => Cannot select bits 12 to 16 of 16-bit field eth.type.

eth.type[10] == 1 => Cannot select subfield of nominal field eth.type.

eth.type => Explicit `!= 0' is required for inequality test of multibit field against 0.

!(!(vlan.pcp)) => Explicit `!= 0' is required for inequality test of multibit field against 0.

123 => Syntax error at end of input expecting relational operator.

123 x => Syntax error at `x' expecting relational operator.

{1, "eth0"} => Syntax error at `"eth0"' expecting integer.

eth.type == xyzzy => Syntax error at `xyzzy' expecting constant.

(1 x) => Syntax error at `x' expecting `)'.

!0x800 != eth.type => Missing parentheses around operand of !.

eth.type == 0x800 || eth.type == 0x86dd && ip.proto == 17 => && and || must be parenthesized when used together.

eth.dst == {} => Syntax error at `}' expecting constant.

eth.src > 00:00:00:00:11:11/00:00:00:00:ff:ff => Only == and != operators may be used with masked constants.  Consider using subfields instead (e.g. eth.src[0..15] > 0x1111 in place of eth.src > 00:00:00:00:11:11/00:00:00:00:ff:ff).

ip4.src == ::1 => 128-bit constant is not compatible with 32-bit field ip4.src.

1 == eth.type == 2 => Range expressions must have the form `x < field < y' or `x > field > y', with each `<' optionally replaced by `<=' or `>' by `>=').

eth.dst[40] x => Syntax error at `x' expecting end of input.

ip4.src == {1.2.3.4, $set1, $unknownset} => Syntax error at `$unknownset' expecting address set name.
eth.src == {$set3, badmac, 00:00:00:00:00:01} => Syntax error at `badmac' expecting constant.

((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) => Parentheses nested too deeply.

ct_label > $set4 => Only == and != operators may be used to compare a field against an empty value set.
]])
sed 's/ =>.*//' test-cases.txt > input.txt
sed 's/.* => //' test-cases.txt > expout
AT_CHECK([ovstest test-ovn parse-expr < input.txt], [0], [expout])
AT_CLEANUP

AT_SETUP([expression annotation])
dnl Input precedes =>, expected output follows =>.
dnl Empty lines and lines starting with # are ignored.
AT_DATA([test-cases.txt], [[
ip4.src == 1.2.3.4 => ip4.src == 0x1020304 && eth.type == 0x800
ip4.src != 1.2.3.4 => ip4.src != 0x1020304 && eth.type == 0x800
ip.proto == 123 => ip.proto == 0x7b && (eth.type == 0x800 || eth.type == 0x86dd)
ip.proto == {123, 234} => (ip.proto == 0x7b || ip.proto == 0xea) && (eth.type == 0x800 || eth.type == 0x86dd)
ip4.src == 1.2.3.4 && ip4.dst == 5.6.7.8 => ip4.src == 0x1020304 && eth.type == 0x800 && ip4.dst == 0x5060708 && eth.type == 0x800

# Nested expressions over a single symbol should be annotated with symbol's
# prerequisites only once, at the top level.
tcp.dst == 1 || (tcp.dst >= 2 && tcp.dst <= 3) => (tcp.dst == 0x1 || (tcp.dst >= 0x2 && tcp.dst <= 0x3)) && ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)

ip => eth.type == 0x800 || eth.type == 0x86dd
ip == 1 => eth.type == 0x800 || eth.type == 0x86dd
ip[0] == 1 => eth.type == 0x800 || eth.type == 0x86dd
ip > 0 => Only == and != operators may be used with nominal field ip.
!ip => Nominal predicate ip may only be tested positively, e.g. `ip' or `ip == 1' but not `!ip' or `ip == 0'.
ip == 0 => Nominal predicate ip may only be tested positively, e.g. `ip' or `ip == 1' but not `!ip' or `ip == 0'.

vlan.present => vlan.tci[12]
!vlan.present => !vlan.tci[12]

!vlan.pcp => vlan.tci[13..15] == 0 && vlan.tci[12]
vlan.pcp == 1 && vlan.vid == 2 => vlan.tci[13..15] == 0x1 && vlan.tci[12] && vlan.tci[0..11] == 0x2 && vlan.tci[12]
!reg0 && !reg1 && !reg2 && !reg3 => xxreg0[96..127] == 0 && xxreg0[64..95] == 0 && xxreg0[32..63] == 0 && xxreg0[0..31] == 0

ip.first_frag => ip.frag[0] && (eth.type == 0x800 || eth.type == 0x86dd) && (!ip.frag[1] || (eth.type != 0x800 && eth.type != 0x86dd))
!ip.first_frag => !ip.frag[0] || (eth.type != 0x800 && eth.type != 0x86dd) || (ip.frag[1] && (eth.type == 0x800 || eth.type == 0x86dd))
ip.later_frag => ip.frag[1] && (eth.type == 0x800 || eth.type == 0x86dd)

bad_prereq != 0 => Error parsing expression `xyzzy' encountered as prerequisite or predicate of initial expression: Syntax error at `xyzzy' expecting field name.
self_recurse != 0 => Error parsing expression `self_recurse != 0' encountered as prerequisite or predicate of initial expression: Recursive expansion of symbol `self_recurse'.
mutual_recurse_1 != 0 => Error parsing expression `mutual_recurse_2 != 0' encountered as prerequisite or predicate of initial expression: Error parsing expression `mutual_recurse_1 != 0' encountered as prerequisite or predicate of initial expression: Recursive expansion of symbol `mutual_recurse_1'.
mutual_recurse_2 != 0 => Error parsing expression `mutual_recurse_1 != 0' encountered as prerequisite or predicate of initial expression: Error parsing expression `mutual_recurse_2 != 0' encountered as prerequisite or predicate of initial expression: Recursive expansion of symbol `mutual_recurse_2'.
]])
sed 's/ =>.*//' test-cases.txt > input.txt
sed 's/.* => //' test-cases.txt > expout
AT_CHECK([ovstest test-ovn annotate-expr < input.txt], [0], [expout])
AT_CLEANUP

AT_SETUP([1-term expression conversion])
AT_CHECK([ovstest test-ovn exhaustive --operation=convert 1], [0],
  [Tested converting all 1-terminal expressions with 2 numeric vars (each 3 bits) in terms of operators == != < <= > >= and 2 string vars.
])
AT_CLEANUP

AT_SETUP([2-term expression conversion])
AT_CHECK([ovstest test-ovn exhaustive --operation=convert 2], [0],
  [Tested converting 578 expressions of 2 terminals with 2 numeric vars (each 3 bits) in terms of operators == != < <= > >= and 2 string vars.
])
AT_CLEANUP

AT_SETUP([3-term expression conversion])
AT_CHECK([ovstest test-ovn exhaustive --operation=convert --bits=2 3], [0],
  [Tested converting 67410 expressions of 3 terminals with 2 numeric vars (each 2 bits) in terms of operators == != < <= > >= and 2 string vars.
])
AT_CLEANUP

AT_SETUP([3-term numeric expression simplification])
AT_KEYWORDS([slowtest])
AT_CHECK([ovstest test-ovn exhaustive --operation=simplify --nvars=2 --svars=0 3], [0],
  [Tested simplifying 490770 expressions of 3 terminals with 2 numeric vars (each 3 bits) in terms of operators == != < <= > >=.
])
AT_CLEANUP

AT_SETUP([4-term string expression simplification])
AT_CHECK([ovstest test-ovn exhaustive --operation=simplify --nvars=0 --svars=4 4], [0],
  [Tested simplifying 21978 expressions of 4 terminals with 4 string vars.
])
AT_CLEANUP

AT_SETUP([3-term mixed expression simplification])
AT_CHECK([ovstest test-ovn exhaustive --operation=simplify --nvars=1 --svars=1 3], [0],
  [Tested simplifying 127890 expressions of 3 terminals with 1 numeric vars (each 3 bits) in terms of operators == != < <= > >= and 1 string vars.
])
AT_CLEANUP

AT_SETUP([simplification special cases])
simplify() {
    echo "$1" | ovstest test-ovn simplify-expr
}
AT_CHECK([simplify 'eth.dst == 0/0'], [0], [1
])
AT_CHECK([simplify 'eth.dst != 0/0'], [0], [0
])
AT_CHECK([simplify 'tcp.dst >= 0'], [0],
    [ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)
])
AT_CHECK([simplify 'tcp.dst <= 65535'], [0],
    [ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)
])
AT_CHECK([simplify 'tcp.dst > 0'], [0],
    [[(tcp.dst[0] || tcp.dst[1] || tcp.dst[2] || tcp.dst[3] || tcp.dst[4] || tcp.dst[5] || tcp.dst[6] || tcp.dst[7] || tcp.dst[8] || tcp.dst[9] || tcp.dst[10] || tcp.dst[11] || tcp.dst[12] || tcp.dst[13] || tcp.dst[14] || tcp.dst[15]) && ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)
]])
AT_CHECK([simplify 'tcp.dst < 65535'], [0],
    [[(!tcp.dst[0] || !tcp.dst[1] || !tcp.dst[2] || !tcp.dst[3] || !tcp.dst[4] || !tcp.dst[5] || !tcp.dst[6] || !tcp.dst[7] || !tcp.dst[8] || !tcp.dst[9] || !tcp.dst[10] || !tcp.dst[11] || !tcp.dst[12] || !tcp.dst[13] || !tcp.dst[14] || !tcp.dst[15]) && ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)
]])
AT_CLEANUP

AT_SETUP([is_chassis_resident simplification])
simplify() {
    echo "$1" | ovstest test-ovn simplify-expr
}
AT_CHECK([simplify 'is_chassis_resident("eth1")'], [0], [1
])
AT_CHECK([simplify 'is_chassis_resident("eth2")'], [0], [0
])
AT_CHECK([simplify '!is_chassis_resident("eth1")'], [0], [0
])
AT_CHECK([simplify '!is_chassis_resident("eth2")'], [0], [1
])
AT_CLEANUP

AT_SETUP([4-term numeric expression normalization])
AT_KEYWORDS([slowtest])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=3 --svars=0 --bits=1 4], [0],
  [Tested normalizing 1874026 expressions of 4 terminals with 3 numeric vars (each 1 bits) in terms of operators == != < <= > >=.
])
AT_CLEANUP

AT_SETUP([4-term string expression normalization])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=0 --svars=3 --bits=1 4], [0],
  [Tested normalizing 11242 expressions of 4 terminals with 3 string vars.
])
AT_CLEANUP

AT_SETUP([4-term mixed expression normalization])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=1 --bits=1 --svars=2 4], [0],
  [Tested normalizing 175978 expressions of 4 terminals with 1 numeric vars (each 1 bits) in terms of operators == != < <= > >= and 2 string vars.
])
AT_CLEANUP

AT_SETUP([5-term numeric expression normalization])
AT_KEYWORDS([slowtest])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=3 --svars=0 --bits=1 --relops='==' 5], [0],
  [Tested normalizing 1317600 expressions of 5 terminals with 3 numeric vars (each 1 bits) in terms of operators ==.
])
AT_CLEANUP

AT_SETUP([5-term string expression normalization])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=0 --svars=3 --bits=1 --relops='==' 5], [0],
  [Tested normalizing 368550 expressions of 5 terminals with 3 string vars.
])
AT_CLEANUP

AT_SETUP([5-term mixed expression normalization])
AT_CHECK([ovstest test-ovn exhaustive --operation=normalize --nvars=1 --svars=1 --bits=1 --relops='==' 5], [0],
  [Tested normalizing 216000 expressions of 5 terminals with 1 numeric vars (each 1 bits) in terms of operators == and 1 string vars.
])
AT_CLEANUP

AT_SETUP([4-term numeric expressions to flows])
AT_KEYWORDS([expression])
AT_CHECK([ovstest test-ovn exhaustive --operation=flow --nvars=2 --svars=0 --bits=2 --relops='==' 4], [0],
  [Tested converting to flows 175978 expressions of 4 terminals with 2 numeric vars (each 2 bits) in terms of operators ==.
])
AT_CLEANUP

AT_SETUP([4-term string expressions to flows])
AT_KEYWORDS([expression])
AT_CHECK([ovstest test-ovn exhaustive --operation=flow --nvars=0 --svars=4 4], [0],
  [Tested converting to flows 21978 expressions of 4 terminals with 4 string vars.
])
AT_CLEANUP

AT_SETUP([4-term mixed expressions to flows])
AT_KEYWORDS([slowtest])
AT_KEYWORDS([expression])
AT_CHECK([ovstest test-ovn exhaustive --operation=flow --nvars=1 --bits=2 --svars=1 --relops='==' 4], [0],
  [Tested converting to flows 48312 expressions of 4 terminals with 1 numeric vars (each 2 bits) in terms of operators == and 1 string vars.
])
AT_CLEANUP

AT_SETUP([3-term numeric expressions to flows])
AT_KEYWORDS([expression])
AT_CHECK([ovstest test-ovn exhaustive --operation=flow --nvars=3 --svars=0 --bits=3 --relops='==' 3], [0],
  [Tested converting to flows 41328 expressions of 3 terminals with 3 numeric vars (each 3 bits) in terms of operators ==.
])
AT_CLEANUP

AT_SETUP([converting expressions to flows -- string fields])
AT_KEYWORDS([expression])
expr_to_flow () {
    echo "$1" | ovstest test-ovn expr-to-flows | sort
}
AT_CHECK([expr_to_flow 'inport == "eth0"'], [0], [reg14=0x5
])
AT_CHECK([expr_to_flow 'inport == "eth1"'], [0], [reg14=0x6
])
AT_CHECK([expr_to_flow 'inport == "eth2"'], [0], [(no flows)
])
AT_CHECK([expr_to_flow 'inport == "eth0" && ip'], [0], [dnl
ip,reg14=0x5
ipv6,reg14=0x5
])
AT_CHECK([expr_to_flow 'inport == "eth1" && ip'], [0], [dnl
ip,reg14=0x6
ipv6,reg14=0x6
])
AT_CHECK([expr_to_flow 'inport == "eth2" && ip'], [0], [(no flows)
])
AT_CHECK([expr_to_flow 'inport == {"eth0", "eth1", "eth2", "LOCAL"}'], [0],
[reg14=0x5
reg14=0x6
reg14=0xfffe
])
AT_CHECK([expr_to_flow 'inport == {"eth0", "eth1", "eth2"} && ip'], [0], [dnl
ip,reg14=0x5
ip,reg14=0x6
ipv6,reg14=0x5
ipv6,reg14=0x6
])
AT_CHECK([expr_to_flow 'inport == "eth0" && inport == "eth1"'], [0], [dnl
(no flows)
])
AT_CLEANUP

AT_SETUP([converting expressions to flows -- address sets])
AT_KEYWORDS([expression])
expr_to_flow () {
    echo "$1" | ovstest test-ovn expr-to-flows | sort
}
AT_CHECK([expr_to_flow 'ip4.src == {10.0.0.1, 10.0.0.2, 10.0.0.3}'], [0], [dnl
ip,nw_src=10.0.0.1
ip,nw_src=10.0.0.2
ip,nw_src=10.0.0.3
])
AT_CHECK([expr_to_flow 'ip4.src == $set1'], [0], [dnl
ip,nw_src=10.0.0.1
ip,nw_src=10.0.0.2
ip,nw_src=10.0.0.3
])
AT_CHECK([expr_to_flow 'ip4.src == {1.2.3.4, $set1}'], [0], [dnl
ip,nw_src=1.2.3.4
ip,nw_src=10.0.0.1
ip,nw_src=10.0.0.2
ip,nw_src=10.0.0.3
])
AT_CHECK([expr_to_flow 'ip4.src == {1.2.0.0/20, 5.5.5.0/24, $set1}'], [0], [dnl
ip,nw_src=1.2.0.0/20
ip,nw_src=10.0.0.1
ip,nw_src=10.0.0.2
ip,nw_src=10.0.0.3
ip,nw_src=5.5.5.0/24
])
AT_CHECK([expr_to_flow 'ip6.src == {::1, ::2, ::3}'], [0], [dnl
ipv6,ipv6_src=::1
ipv6,ipv6_src=::2
ipv6,ipv6_src=::3
])
AT_CHECK([expr_to_flow 'ip6.src == {::1, $set2, ::4}'], [0], [dnl
ipv6,ipv6_src=::1
ipv6,ipv6_src=::2
ipv6,ipv6_src=::3
ipv6,ipv6_src=::4
])
AT_CHECK([expr_to_flow 'eth.src == {00:00:00:00:00:01, 00:00:00:00:00:02, 00:00:00:00:00:03}'], [0], [dnl
dl_src=00:00:00:00:00:01
dl_src=00:00:00:00:00:02
dl_src=00:00:00:00:00:03
])
AT_CHECK([expr_to_flow 'eth.src == {$set3}'], [0], [dnl
dl_src=00:00:00:00:00:01
dl_src=00:00:00:00:00:02
dl_src=00:00:00:00:00:03
])
AT_CHECK([expr_to_flow 'eth.src == {00:00:00:00:00:01, $set3, ba:be:be:ef:de:ad, $set3}'], [0], [dnl
dl_src=00:00:00:00:00:01
dl_src=00:00:00:00:00:02
dl_src=00:00:00:00:00:03
dl_src=ba:be:be:ef:de:ad
])
AT_CHECK([expr_to_flow 'ip4.src == {$set4}'], [0], [dnl
(no flows)
])
AT_CHECK([expr_to_flow 'ip4.src == {1.2.3.4, $set4}'], [0], [dnl
ip,nw_src=1.2.3.4
])
AT_CHECK([expr_to_flow 'ip4.src == 1.2.3.4 || ip4.src == {$set4}'], [0], [dnl
ip,nw_src=1.2.3.4
])
AT_CHECK([expr_to_flow 'ip4.src != {$set4}'], [0], [dnl

])
AT_CHECK([expr_to_flow 'ip4.src != {1.0.0.0/8, $set4}'], [0], [dnl
ip,nw_src=0.0.0.0/1.0.0.0
ip,nw_src=128.0.0.0/1
ip,nw_src=16.0.0.0/16.0.0.0
ip,nw_src=2.0.0.0/2.0.0.0
ip,nw_src=32.0.0.0/32.0.0.0
ip,nw_src=4.0.0.0/4.0.0.0
ip,nw_src=64.0.0.0/64.0.0.0
ip,nw_src=8.0.0.0/8.0.0.0
])
AT_CHECK([expr_to_flow 'ip4.src != 1.0.0.0/8 && ip4.src != {$set4}'], [0], [dnl
ip,nw_src=0.0.0.0/1.0.0.0
ip,nw_src=128.0.0.0/1
ip,nw_src=16.0.0.0/16.0.0.0
ip,nw_src=2.0.0.0/2.0.0.0
ip,nw_src=32.0.0.0/32.0.0.0
ip,nw_src=4.0.0.0/4.0.0.0
ip,nw_src=64.0.0.0/64.0.0.0
ip,nw_src=8.0.0.0/8.0.0.0
])
AT_CHECK([expr_to_flow 'ip4.dst == 172.27.0.65 && ip4.src == $set1 && ip4.dst != 10.128.0.0/14'], [0], [dnl
ip,nw_src=10.0.0.1,nw_dst=172.27.0.65
ip,nw_src=10.0.0.2,nw_dst=172.27.0.65
ip,nw_src=10.0.0.3,nw_dst=172.27.0.65
])
AT_CHECK([expr_to_flow 'ip4.src == 172.168.13.0/16 && ip4.src != {172.168.13.0/24, 172.168.14.0/24}'], [0], [dnl
ip,nw_src=172.168.0.0/255.255.3.0
ip,nw_src=172.168.0.0/255.255.4.0
ip,nw_src=172.168.0.0/255.255.8.0
ip,nw_src=172.168.128.0/17
ip,nw_src=172.168.16.0/255.255.16.0
ip,nw_src=172.168.3.0/255.255.3.0
ip,nw_src=172.168.32.0/255.255.32.0
ip,nw_src=172.168.64.0/255.255.64.0
])
dnl Negative match flow explosion.
AT_CHECK([test $(expr_to_flow 'ip4.src != {172.168.13.0/24, 172.168.14.0/24, 172.168.15.0/24}' | wc -l) -le 30])
AT_CLEANUP

AT_SETUP([converting expressions to flows -- port groups])
AT_KEYWORDS([expression])
expr_to_flow () {
    echo "$1" | ovstest test-ovn expr-to-flows | sort
}
AT_CHECK([expr_to_flow 'outport == @pg1'], [0], [dnl
reg15=0x11
reg15=0x12
reg15=0x13
])
AT_CHECK([expr_to_flow 'outport == {@pg_empty}'], [0], [dnl
(no flows)
])
AT_CHECK([expr_to_flow 'outport == {"lsp1", @pg_empty}'], [0], [dnl
reg15=0x11
])
AT_CLEANUP

AT_SETUP([converting expressions to flows -- conjunction])
AT_KEYWORDS([conjunction])
expr_to_flow () {
    echo "$1" | ovstest test-ovn expr-to-flows | sort
}

lflow="ip4.src == {10.0.0.1, 10.0.0.2, 10.0.0.3} && \
ip4.dst == {20.0.0.1, 20.0.0.2, 20.0.0.3}"
AT_CHECK([expr_to_flow "$lflow"], [0], [dnl
conj_id=1,ip
ip,nw_dst=20.0.0.1: conjunction(1, 0/2)
ip,nw_dst=20.0.0.2: conjunction(1, 0/2)
ip,nw_dst=20.0.0.3: conjunction(1, 0/2)
ip,nw_src=10.0.0.1: conjunction(1, 1/2)
ip,nw_src=10.0.0.2: conjunction(1, 1/2)
ip,nw_src=10.0.0.3: conjunction(1, 1/2)
])

lflow="ip && (!ct.est || (ct.est && ct_mark.blocked == 1))"
AT_CHECK([expr_to_flow "$lflow"], [0], [dnl
ct_state=+est+trk,ct_mark=0x1/0x1,ip
ct_state=+est+trk,ct_mark=0x1/0x1,ipv6
ct_state=-est+trk,ip
ct_state=-est+trk,ipv6
])

lflow="ip4.src == {10.0.0.1, 10.0.0.2, 10.0.0.3} && \
ip4.dst == {20.0.0.1, 20.0.0.2}"
AT_CHECK([expr_to_flow "$lflow"], [0], [dnl
conj_id=1,ip
ip,nw_dst=20.0.0.1: conjunction(1, 0/2)
ip,nw_dst=20.0.0.2: conjunction(1, 0/2)
ip,nw_src=10.0.0.1: conjunction(1, 1/2)
ip,nw_src=10.0.0.2: conjunction(1, 1/2)
ip,nw_src=10.0.0.3: conjunction(1, 1/2)
])

lflow="ip4 && ip4.src == {10.0.0.1, 10.0.0.2, 10.0.0.3} && \
ip4.dst == {20.0.0.1, 20.0.0.2, 20.0.0.3} && \
tcp.dst >= 1000 && tcp.dst <= 1010"

AT_CHECK([expr_to_flow "$lflow"], [0], [dnl
conj_id=1,tcp
tcp,nw_dst=20.0.0.1: conjunction(1, 0/3)
tcp,nw_dst=20.0.0.2: conjunction(1, 0/3)
tcp,nw_dst=20.0.0.3: conjunction(1, 0/3)
tcp,nw_src=10.0.0.1: conjunction(1, 1/3)
tcp,nw_src=10.0.0.2: conjunction(1, 1/3)
tcp,nw_src=10.0.0.3: conjunction(1, 1/3)
tcp,tp_dst=0x3ea/0xfffe: conjunction(1, 2/3)
tcp,tp_dst=0x3ec/0xfffc: conjunction(1, 2/3)
tcp,tp_dst=0x3f0/0xfffe: conjunction(1, 2/3)
tcp,tp_dst=1000: conjunction(1, 2/3)
tcp,tp_dst=1001: conjunction(1, 2/3)
tcp,tp_dst=1010: conjunction(1, 2/3)
])

lflow="ip4 && ip4.src == {10.0.0.4, 10.0.0.5, 10.0.0.6} && \
((ip4.dst == {20.0.0.4, 20.0.0.7, 20.0.0.8} && tcp.dst >= 1000 && \
tcp.dst <= 2000 && tcp.src >=1000 && tcp.src <= 2000) \
|| ip4.dst == 20.0.0.5 || ip4.dst == 20.0.0.6)"

AT_CHECK([expr_to_flow "$lflow"], [0], [dnl
conj_id=1,tcp
ip,nw_src=10.0.0.4,nw_dst=20.0.0.5
ip,nw_src=10.0.0.4,nw_dst=20.0.0.6
ip,nw_src=10.0.0.5,nw_dst=20.0.0.5
ip,nw_src=10.0.0.5,nw_dst=20.0.0.6
ip,nw_src=10.0.0.6,nw_dst=20.0.0.5
ip,nw_src=10.0.0.6,nw_dst=20.0.0.6
tcp,nw_dst=20.0.0.4: conjunction(1, 0/4)
tcp,nw_dst=20.0.0.7: conjunction(1, 0/4)
tcp,nw_dst=20.0.0.8: conjunction(1, 0/4)
tcp,nw_src=10.0.0.4: conjunction(1, 1/4)
tcp,nw_src=10.0.0.5: conjunction(1, 1/4)
tcp,nw_src=10.0.0.6: conjunction(1, 1/4)
tcp,tp_dst=0x3ea/0xfffe: conjunction(1, 2/4)
tcp,tp_dst=0x3ec/0xfffc: conjunction(1, 2/4)
tcp,tp_dst=0x3f0/0xfff0: conjunction(1, 2/4)
tcp,tp_dst=0x400/0xfe00: conjunction(1, 2/4)
tcp,tp_dst=0x600/0xff00: conjunction(1, 2/4)
tcp,tp_dst=0x700/0xff80: conjunction(1, 2/4)
tcp,tp_dst=0x780/0xffc0: conjunction(1, 2/4)
tcp,tp_dst=0x7c0/0xfff0: conjunction(1, 2/4)
tcp,tp_dst=1000: conjunction(1, 2/4)
tcp,tp_dst=1001: conjunction(1, 2/4)
tcp,tp_dst=2000: conjunction(1, 2/4)
tcp,tp_src=0x3ea/0xfffe: conjunction(1, 3/4)
tcp,tp_src=0x3ec/0xfffc: conjunction(1, 3/4)
tcp,tp_src=0x3f0/0xfff0: conjunction(1, 3/4)
tcp,tp_src=0x400/0xfe00: conjunction(1, 3/4)
tcp,tp_src=0x600/0xff00: conjunction(1, 3/4)
tcp,tp_src=0x700/0xff80: conjunction(1, 3/4)
tcp,tp_src=0x780/0xffc0: conjunction(1, 3/4)
tcp,tp_src=0x7c0/0xfff0: conjunction(1, 3/4)
tcp,tp_src=1000: conjunction(1, 3/4)
tcp,tp_src=1001: conjunction(1, 3/4)
tcp,tp_src=2000: conjunction(1, 3/4)
])
AT_CLEANUP

AT_SETUP([action parsing])
dnl Unindented text is input (a set of OVN logical actions).
dnl Indented text is expected output.
AT_DATA([test-cases.txt],
[[# drop
drop;
    encodes as drop
drop; next;
    Syntax error at `next' expecting end of input.
next; drop;
    Syntax error at `drop' expecting action.

# output
output;
    encodes as resubmit(,64)

# next
next;
    encodes as resubmit(,19)
next(11);
    formats as next;
    encodes as resubmit(,19)
next(0);
    encodes as resubmit(,8)
next(23);
    encodes as resubmit(,31)

next();
    Syntax error at `)' expecting "pipeline" or "table".
next(10;
    Syntax error at `;' expecting `)'.
next(24);
    "next" action cannot advance beyond table 23.

next(table=11);
    formats as next;
    encodes as resubmit(,19)
next(pipeline=ingress);
    formats as next;
    encodes as resubmit(,19)
next(table=11, pipeline=ingress);
    formats as next;
    encodes as resubmit(,19)
next(pipeline=ingress, table=11);
    formats as next;
    encodes as resubmit(,19)

next(pipeline=egress);
    formats as next(pipeline=egress, table=11);
    encodes as resubmit(,53)

next(pipeline=egress, table=5);
    encodes as resubmit(,47)

next(table=10);
    formats as next(10);
    encodes as resubmit(,18)

# Loading a constant value.
tcp.dst=80;
    formats as tcp.dst = 80;
    encodes as set_field:80->tcp_dst
    has prereqs ip.proto == 0x6 && (eth.type == 0x800 || eth.type == 0x86dd)
eth.dst[40] = 1;
    encodes as set_field:01:00:00:00:00:00/01:00:00:00:00:00->eth_dst
vlan.pcp = 2;
    encodes as set_field:0x4000/0xe000->vlan_tci
    has prereqs vlan.tci[12]
vlan.tci[13..15] = 2;
    encodes as set_field:0x4000/0xe000->vlan_tci
inport = "";
    encodes as set_field:0->reg14
ip.ttl=4;
    formats as ip.ttl = 4;
    encodes as set_field:4->nw_ttl
    has prereqs eth.type == 0x800 || eth.type == 0x86dd
outport="eth0"; next; outport="LOCAL"; next;
    formats as outport = "eth0"; next; outport = "LOCAL"; next;
    encodes as set_field:0x5->reg15,resubmit(,19),set_field:0xfffe->reg15,resubmit(,19)

inport[1] = 1;
    Cannot select subfield of string field inport.
ip.proto[1] = 1;
    Cannot select subfield of nominal field ip.proto.
eth.dst[40] == 1;
    Syntax error at `==' expecting `=' or `<->'.
ip = 1;
    Predicate symbol ip used where lvalue required.
ip.proto = 6;
    Field ip.proto is not modifiable.
inport = {"a", "b"};
    Syntax error at `{' expecting constant.
inport = {};
    Syntax error at `{' expecting constant.
bad_prereq = 123;
    Error parsing expression `xyzzy' encountered as prerequisite or predicate of initial expression: Syntax error at `xyzzy' expecting field name.
self_recurse = 123;
    Error parsing expression `self_recurse != 0' encountered as prerequisite or predicate of initial expression: Error parsing expression `self_recurse != 0' encountered as prerequisite or predicate of initial expression: Recursive expansion of symbol `self_recurse'.
vlan.present = 0;
    Predicate symbol vlan.present used where lvalue required.

# Moving one field into another.
reg0=reg1;
    formats as reg0 = reg1;
    encodes as move:NXM_NX_XXREG0[64..95]->NXM_NX_XXREG0[96..127]
vlan.pcp = reg0[0..2];
    encodes as move:NXM_NX_XXREG0[96..98]->NXM_OF_VLAN_TCI[13..15]
    has prereqs vlan.tci[12]
reg0[10] = vlan.pcp[1];
    encodes as move:NXM_OF_VLAN_TCI[14]->NXM_NX_XXREG0[106]
    has prereqs vlan.tci[12]
outport = inport;
    encodes as move:NXM_NX_REG14[]->NXM_NX_REG15[]

reg0[0] = vlan.present;
    Predicate symbol vlan.present used where lvalue required.
reg0 = reg1[0..10];
    Can't assign 11-bit value to 32-bit destination.
inport = reg0;
    Can't assign integer field (reg0) to string field (inport).
inport = big_string;
    String fields inport and big_string are incompatible for assignment.
ip.proto = reg0[0..7];
    Field ip.proto is not modifiable.

# Exchanging fields.
reg0 <-> reg1;
    encodes as push:NXM_NX_XXREG0[64..95],push:NXM_NX_XXREG0[96..127],pop:NXM_NX_XXREG0[64..95],pop:NXM_NX_XXREG0[96..127]
vlan.pcp <-> reg0[0..2];
    encodes as push:NXM_NX_XXREG0[96..98],push:NXM_OF_VLAN_TCI[13..15],pop:NXM_NX_XXREG0[96..98],pop:NXM_OF_VLAN_TCI[13..15]
    has prereqs vlan.tci[12]
reg0[10] <-> vlan.pcp[1];
    encodes as push:NXM_OF_VLAN_TCI[14],push:NXM_NX_XXREG0[106],pop:NXM_OF_VLAN_TCI[14],pop:NXM_NX_XXREG0[106]
    has prereqs vlan.tci[12]
outport <-> inport;
    encodes as push:NXM_NX_REG14[],push:NXM_NX_REG15[],pop:NXM_NX_REG14[],pop:NXM_NX_REG15[]

reg0[0] <-> vlan.present;
    Predicate symbol vlan.present used where lvalue required.
reg0 <-> reg1[0..10];
    Can't exchange 32-bit field with 11-bit field.
inport <-> reg0;
    Can't exchange string field (inport) with integer field (reg0).
inport <-> big_string;
    String fields inport and big_string are incompatible for exchange.
ip.proto <-> reg0[0..7];
    Field ip.proto is not modifiable.
reg0[0..7] <-> ip.proto;
    Field ip.proto is not modifiable.

# TTL decrement.
ip.ttl--;
    encodes as dec_ttl
    has prereqs ip
ip.ttl
    Syntax error at end of input expecting `--'.

# Packet mark.
pkt.mark=1;
    formats as pkt.mark = 1;
    encodes as set_field:0x1->pkt_mark

pkt.mark = 1000;
    encodes as set_field:0x3e8->pkt_mark

pkt.mark;
    Syntax error at `pkt.mark' expecting action.

pkt.mark = foo;
    Syntax error at `foo' expecting field name.

pkt.mark = "foo";
    Integer field pkt.mark is not compatible with string constant.

# load balancing.
ct_lb;
    encodes as ct(table=19,zone=NXM_NX_REG13[0..15],nat)
    has prereqs ip
ct_lb();
    formats as ct_lb;
    encodes as ct(table=19,zone=NXM_NX_REG13[0..15],nat)
    has prereqs ip
ct_lb(192.168.1.2:80, 192.168.1.3:80);
    Syntax error at `192.168.1.2' expecting backends.
ct_lb(backends=192.168.1.2:80,192.168.1.3:80);
    encodes as group:1
    uses group: id(1), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=192.168.1.2:80,192.168.1.3:80; skip_snat);
    encodes as group:2
    uses group: id(2), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label,set_field:4/4->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label,set_field:4/4->ct_label)))
    has prereqs ip
ct_lb(backends=192.168.1.2:80,192.168.1.3:80; force_snat);
    encodes as group:3
    uses group: id(3), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label,set_field:8/8->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label,set_field:8/8->ct_label)))
    has prereqs ip
ct_lb(backends=192.168.1.2, 192.168.1.3, );
    formats as ct_lb(backends=192.168.1.2,192.168.1.3);
    encodes as group:4
    uses group: id(4), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2, fd0f::3, );
    formats as ct_lb(backends=fd0f::2,fd0f::3);
    encodes as group:5
    uses group: id(5), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip

ct_lb(backends=192.168.1.2:);
    Syntax error at `)' expecting port number.
ct_lb(backends=192.168.1.2:123456);
    Syntax error at `123456' expecting port number.
ct_lb(backends=foo);
    Syntax error at `foo' expecting IP address.
ct_lb(backends=[192.168.1.2]);
    Syntax error at `192.168.1.2' expecting IPv6 address.

ct_lb(backends=192.168.1.2:80,192.168.1.3:80; hash_fields=eth_src,eth_dst,ip_src);
    Syntax error at `eth_src' invalid hash_fields.
ct_lb(backends=192.168.1.2:80,192.168.1.3:80; hash_fields="eth_src,eth_dst,ip_src");
    encodes as group:6
    uses group: id(6), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2,fd0f::3; hash_fields="eth_src,eth_dst,ip_src,ip_dst,tp_src,tp_dst");
    encodes as group:7
    uses group: id(7), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,tp_src,tp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2,fd0f::3; hash_fields="eth_src,eth_dst,ip_src,ip_dst,tcp_src,tcp_dst");
    encodes as group:8
    uses group: id(8), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,tcp_src,tcp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2,fd0f::3; hash_fields="eth_src,eth_dst,ip_src,ip_dst,udp_src,udp_dst");
    encodes as group:9
    uses group: id(9), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,udp_src,udp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2,fd0f::3; hash_fields="eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst");
    encodes as group:10
    uses group: id(10), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2,fd0f::3; hash_fields="eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst"; skip_snat);
    encodes as group:11
    uses group: id(11), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label,set_field:4/4->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label,set_field:4/4->ct_label)))
    has prereqs ip
ct_lb(backends=fd0f::2,fd0f::3; hash_fields="eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst"; force_snat);
    encodes as group:12
    uses group: id(12), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=fd0f::2),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label,set_field:8/8->ct_label)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=fd0f::3),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_label,set_field:8/8->ct_label)))
    has prereqs ip

ct_lb_mark(backends=192.168.1.2:80,192.168.1.3:80);
    encodes as group:13
    uses group: id(13), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark)))
    has prereqs ip
ct_lb_mark(backends=192.168.1.2:80,192.168.1.3:80; skip_snat);
    encodes as group:14
    uses group: id(14), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark,set_field:4/4->ct_mark)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark,set_field:4/4->ct_mark)))
    has prereqs ip
ct_lb_mark(backends=192.168.1.2:80,192.168.1.3:80; force_snat);
    encodes as group:15
    uses group: id(15), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark,set_field:8/8->ct_mark)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark,set_field:8/8->ct_mark)))
    has prereqs ip
ct_lb_mark(backends=192.168.1.2:80,192.168.1.3:80; hash_fields="eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst");
    encodes as group:16
    uses group: id(16), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark)))
    has prereqs ip
ct_lb_mark(backends=192.168.1.2:80,192.168.1.3:80; hash_fields="eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst"; skip_snat);
    encodes as group:17
    uses group: id(17), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark,set_field:4/4->ct_mark)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark,set_field:4/4->ct_mark)))
    has prereqs ip
ct_lb_mark(backends=192.168.1.2:80,192.168.1.3:80; hash_fields="eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst"; force_snat);
    encodes as group:18
    uses group: id(18), name(type=select,selection_method=hash,fields(eth_src,eth_dst,ip_src,ip_dst,sctp_src,sctp_dst),bucket=bucket_id=0,weight:100,actions=ct(nat(dst=192.168.1.2:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark,set_field:8/8->ct_mark)),bucket=bucket_id=1,weight:100,actions=ct(nat(dst=192.168.1.3:80),commit,table=19,zone=NXM_NX_REG13[0..15],exec(set_field:2/2->ct_mark,set_field:8/8->ct_mark)))
    has prereqs ip

# ct_next
ct_next;
    encodes as ct(table=19,zone=NXM_NX_REG13[0..15])
    has prereqs ip

# ct_commit
ct_commit;
    encodes as ct(commit,zone=NXM_NX_REG13[0..15])
    has prereqs ip
ct_commit { };
    formats as ct_commit;
    encodes as ct(commit,zone=NXM_NX_REG13[0..15])
    has prereqs ip
ct_commit { ct_mark=1; };
    formats as ct_commit { ct_mark = 1; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_mark))
    has prereqs ip
ct_commit { ct_mark=1/1; };
    formats as ct_commit { ct_mark = 1/1; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1/0x1->ct_mark))
    has prereqs ip
ct_commit { ct_label=1; };
    formats as ct_commit { ct_label = 1; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_label))
    has prereqs ip
ct_commit { ct_label=1/1; };
    formats as ct_commit { ct_label = 1/1; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1/0x1->ct_label))
    has prereqs ip
ct_commit { ct_mark=1; ct_label=2; };
    formats as ct_commit { ct_mark = 1; ct_label = 2; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_mark,set_field:0x2->ct_label))
    has prereqs ip

ct_commit { ct_label=0x01020304050607080910111213141516; };
    formats as ct_commit { ct_label = 0x1020304050607080910111213141516; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1020304050607080910111213141516->ct_label))
    has prereqs ip
ct_commit { ct_label=0x1000000000000000000000000000000/0x1000000000000000000000000000000; };
    formats as ct_commit { ct_label = 0x1000000000000000000000000000000/0x1000000000000000000000000000000; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1000000000000000000000000000000/0x1000000000000000000000000000000->ct_label))
    has prereqs ip
ct_commit { ct_label=18446744073709551615; };
    formats as ct_commit { ct_label = 18446744073709551615; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0xffffffffffffffff->ct_label))
    has prereqs ip
ct_commit { ct_label[0..47] = 0x00000f040201; ct_label[48..63] = 0x0002; };
    formats as ct_commit { ct_label[0..47] = 0xf040201; ct_label[48..63] = 0x2; };
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0xf040201/0xffffffffffff->ct_label,set_field:0x2000000000000/0xffff000000000000->ct_label))
    has prereqs ip
ct_commit { ct_label=18446744073709551616; };
    Decimal constants must be less than 2**64.
ct_commit { ct_label=0x181716151413121110090807060504030201; };
    141-bit constant is not compatible with 128-bit field ct_label.
ct_commit { ip4.dst = 192.168.0.1; };
    Field ip4.dst is not modifiable.

# Legact ct_commit_v1 action.
ct_commit();
    formats as ct_commit;
    encodes as ct(commit,zone=NXM_NX_REG13[0..15])
    has prereqs ip
ct_commit(ct_mark=1);
    formats as ct_commit(ct_mark=0x1);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_mark))
    has prereqs ip
ct_commit(ct_mark=1/1);
    formats as ct_commit(ct_mark=0x1/0x1);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1/0x1->ct_mark))
    has prereqs ip
ct_commit(ct_label=1);
    formats as ct_commit(ct_label=0x1);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_label))
    has prereqs ip
ct_commit(ct_label=1/1);
    formats as ct_commit(ct_label=0x1/0x1);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1/0x1->ct_label))
    has prereqs ip
ct_commit(ct_mark=1, ct_label=2);
    formats as ct_commit(ct_mark=0x1, ct_label=0x2);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1->ct_mark,set_field:0x2->ct_label))
    has prereqs ip

ct_commit(ct_label=0x01020304050607080910111213141516);
    formats as ct_commit(ct_label=0x1020304050607080910111213141516);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1020304050607080910111213141516->ct_label))
    has prereqs ip
ct_commit(ct_label=0x181716151413121110090807060504030201);
    formats as ct_commit(ct_label=0x16151413121110090807060504030201);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x16151413121110090807060504030201->ct_label))
    has prereqs ip
ct_commit(ct_label=0x1000000000000000000000000000000/0x1000000000000000000000000000000);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0x1000000000000000000000000000000/0x1000000000000000000000000000000->ct_label))
    has prereqs ip
ct_commit(ct_label=18446744073709551615);
    formats as ct_commit(ct_label=0xffffffffffffffff);
    encodes as ct(commit,zone=NXM_NX_REG13[0..15],exec(set_field:0xffffffffffffffff->ct_label))
    has prereqs ip
ct_commit(ct_label=18446744073709551616);
    Decimal constants must be less than 2**64.

ct_mark = 12345
    Field ct_mark is not modifiable.
ct_label = 0xcafe
    Field ct_label is not modifiable.
ct_label.blocked = 1/1
    Field ct_label.blocked is not modifiable.

# ct_dnat
ct_dnat;
    encodes as ct(table=19,zone=NXM_NX_REG11[0..15],nat)
    has prereqs ip
ct_dnat(192.168.1.2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=192.168.1.2))
    has prereqs ip
ct_dnat(fd11::2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=fd11::2))
    has prereqs ip
ct_dnat(192.168.1.2, 1-3000);
    formats as ct_dnat(192.168.1.2,1-3000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=192.168.1.2:1-3000))
    has prereqs ip

ct_dnat(192.168.1.2, 192.168.1.3);
    Syntax error at `192.168.1.3' expecting Integer for port range.
ct_dnat(foo);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_dnat(foo, bar);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_dnat();
    Syntax error at `)' expecting IPv4 or IPv6 address.
ct_dnat(192.168.1.2, foo);
    Syntax error at `foo' expecting Integer for port range.
ct_dnat(192.168.1.2, 1000-foo);
    Syntax error at `foo' expecting Integer for port range.
ct_dnat(192.168.1.2, 1000);
    formats as ct_dnat(192.168.1.2,1000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=192.168.1.2:1000))
    has prereqs ip
ct_dnat(192.168.1.2, 1000-100);
    Syntax error at `100' range high should be greater than range low.

# ct_dnat_in_czone
ct_dnat_in_czone;
    encodes as ct(table=19,zone=NXM_NX_REG11[0..15],nat)
    has prereqs ip
ct_dnat_in_czone(192.168.1.2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=192.168.1.2))
    has prereqs ip
ct_dnat_in_czone(fd11::2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=fd11::2))
    has prereqs ip
ct_dnat_in_czone(192.168.1.2, 1-3000);
    formats as ct_dnat_in_czone(192.168.1.2,1-3000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=192.168.1.2:1-3000))
    has prereqs ip

ct_dnat_in_czone(192.168.1.2, 192.168.1.3);
    Syntax error at `192.168.1.3' expecting Integer for port range.
ct_dnat_in_czone(foo);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_dnat_in_czone(foo, bar);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_dnat_in_czone();
    Syntax error at `)' expecting IPv4 or IPv6 address.
ct_dnat_in_czone(192.168.1.2, foo);
    Syntax error at `foo' expecting Integer for port range.
ct_dnat_in_czone(192.168.1.2, 1000-foo);
    Syntax error at `foo' expecting Integer for port range.
ct_dnat_in_czone(192.168.1.2, 1000);
    formats as ct_dnat_in_czone(192.168.1.2,1000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(dst=192.168.1.2:1000))
    has prereqs ip
ct_dnat_in_czone(192.168.1.2, 1000-100);
    Syntax error at `100' range high should be greater than range low.

# ct_snat
ct_snat;
    encodes as ct(table=19,zone=NXM_NX_REG12[0..15],nat)
    has prereqs ip
ct_snat(192.168.1.2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG12[0..15],nat(src=192.168.1.2))
    has prereqs ip
ct_snat(fd11::2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG12[0..15],nat(src=fd11::2))
    has prereqs ip
ct_snat(192.168.1.2, 1-3000);
    formats as ct_snat(192.168.1.2,1-3000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG12[0..15],nat(src=192.168.1.2:1-3000))
    has prereqs ip

ct_snat(192.168.1.2, 192.168.1.3);
    Syntax error at `192.168.1.3' expecting Integer for port range.
ct_snat(foo);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_snat(foo, bar);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_snat();
    Syntax error at `)' expecting IPv4 or IPv6 address.
ct_snat(192.168.1.2, foo);
    Syntax error at `foo' expecting Integer for port range.
ct_snat(192.168.1.2, 1000-foo);
    Syntax error at `foo' expecting Integer for port range.
ct_snat(192.168.1.2, 1000);
    formats as ct_snat(192.168.1.2,1000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG12[0..15],nat(src=192.168.1.2:1000))
    has prereqs ip
ct_snat(192.168.1.2, 1000-100);
    Syntax error at `100' range high should be greater than range low.

# ct_snat_in_czone
ct_snat_in_czone;
    encodes as ct(table=19,zone=NXM_NX_REG11[0..15],nat)
    has prereqs ip
ct_snat_in_czone(192.168.1.2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(src=192.168.1.2))
    has prereqs ip
ct_snat_in_czone(fd11::2);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(src=fd11::2))
    has prereqs ip
ct_snat_in_czone(192.168.1.2, 1-3000);
    formats as ct_snat_in_czone(192.168.1.2,1-3000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(src=192.168.1.2:1-3000))
    has prereqs ip

ct_snat_in_czone(192.168.1.2, 192.168.1.3);
    Syntax error at `192.168.1.3' expecting Integer for port range.
ct_snat_in_czone(foo);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_snat_in_czone(foo, bar);
    Syntax error at `foo' expecting IPv4 or IPv6 address.
ct_snat_in_czone();
    Syntax error at `)' expecting IPv4 or IPv6 address.
ct_snat_in_czone(192.168.1.2, foo);
    Syntax error at `foo' expecting Integer for port range.
ct_snat_in_czone(192.168.1.2, 1000-foo);
    Syntax error at `foo' expecting Integer for port range.
ct_snat_in_czone(192.168.1.2, 1000);
    formats as ct_snat_in_czone(192.168.1.2,1000);
    encodes as ct(commit,table=19,zone=NXM_NX_REG11[0..15],nat(src=192.168.1.2:1000))
    has prereqs ip
ct_snat_in_czone(192.168.1.2, 1000-100);
    Syntax error at `100' range high should be greater than range low.

# ct_clear
ct_clear;
    encodes as ct_clear

# ct_commit_nat
ct_commit_nat;
    encodes as ct(commit,table=19,zone=NXM_NX_REG13[0..15],nat)
    has prereqs ip

# clone
clone { ip4.dst = 255.255.255.255; output; }; next;
    encodes as clone(set_field:255.255.255.255->ip_dst,resubmit(,64)),resubmit(,19)
    has prereqs eth.type == 0x800

# arp
arp { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.00.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip4
arp { };
    formats as arp { drop; };
    encodes as controller(userdata=00.00.00.00.00.00.00.00)
    has prereqs ip4

# get_arp
get_arp(outport, ip4.dst);
    encodes as push:NXM_NX_REG0[],push:NXM_OF_IP_DST[],pop:NXM_NX_REG0[],set_field:00:00:00:00:00:00->eth_dst,resubmit(,66),pop:NXM_NX_REG0[]
    has prereqs eth.type == 0x800
get_arp(inport, reg0);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_REG0[],push:NXM_NX_XXREG0[96..127],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],pop:NXM_NX_REG0[],set_field:00:00:00:00:00:00->eth_dst,resubmit(,66),pop:NXM_NX_REG0[],pop:NXM_NX_REG15[]

get_arp;
    Syntax error at `;' expecting `('.
get_arp();
    Syntax error at `)' expecting field name.
get_arp(inport);
    Syntax error at `)' expecting `,'.
get_arp(inport ip4.dst);
    Syntax error at `ip4.dst' expecting `,'.
get_arp(inport, ip4.dst;
    Syntax error at `;' expecting `)'.
get_arp(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 32-bit field is required.
get_arp(inport, outport);
    Cannot use string field outport where numeric field is required.
get_arp(reg0, ip4.dst);
    Cannot use numeric field reg0 where string field is required.

# put_arp
put_arp(inport, arp.spa, arp.sha);
    encodes as push:NXM_NX_REG0[],push:NXM_OF_ETH_SRC[],push:NXM_NX_ARP_SHA[],push:NXM_OF_ARP_SPA[],pop:NXM_NX_REG0[],pop:NXM_OF_ETH_SRC[],controller(userdata=00.00.00.01.00.00.00.00),pop:NXM_OF_ETH_SRC[],pop:NXM_NX_REG0[]
    has prereqs eth.type == 0x806 && eth.type == 0x806

# lookup_arp
reg0[0] = lookup_arp(inport, ip4.dst, eth.src);
    encodes as push:NXM_NX_REG0[],push:NXM_OF_IP_DST[],pop:NXM_NX_REG0[],set_field:0/0x40->reg10,resubmit(,67),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[96],pop:NXM_NX_REG0[]
    has prereqs eth.type == 0x800
reg1[1] = lookup_arp(inport, arp.spa, arp.sha);
    encodes as push:NXM_NX_REG0[],push:NXM_OF_ETH_SRC[],push:NXM_NX_ARP_SHA[],push:NXM_OF_ARP_SPA[],pop:NXM_NX_REG0[],pop:NXM_OF_ETH_SRC[],set_field:0/0x40->reg10,resubmit(,67),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[65],pop:NXM_OF_ETH_SRC[],pop:NXM_NX_REG0[]
    has prereqs eth.type == 0x806 && eth.type == 0x806

lookup_arp;
    Syntax error at `lookup_arp' expecting action.
reg0[0] = lookup_arp;
    Syntax error at `lookup_arp' expecting field name.
reg0[0] = lookup_arp();
    Syntax error at `)' expecting field name.
reg0[0] = lookup_arp(inport);
    Syntax error at `)' expecting `,'.
reg0[0] = lookup_arp(inport ip4.dst);
    Syntax error at `ip4.dst' expecting `,'.
reg0[0] = lookup_arp(inport, ip4.dst;
    Syntax error at `;' expecting `,'.
reg0[0] = lookup_arp(inport, ip4.dst, eth.src;
    Syntax error at `;' expecting `)'.
reg0[0] = lookup_arp(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 32-bit field is required.
reg0[0] = lookup_arp(inport, ip4.src, ip4.dst);
    Cannot use 32-bit field ip4.dst[0..31] where 48-bit field is required.

# lookup_arp_ip
reg0[0] = lookup_arp_ip(inport, ip4.dst);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_REG0[],push:NXM_OF_IP_DST[],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],pop:NXM_NX_REG0[],push:NXM_OF_ETH_DST[],set_field:0/0x40->reg10,resubmit(,66),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[96],pop:NXM_OF_ETH_DST[],pop:NXM_NX_REG0[],pop:NXM_NX_REG15[]
    has prereqs eth.type == 0x800
reg1[1] = lookup_arp_ip(inport, arp.spa);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_REG0[],push:NXM_OF_ARP_SPA[],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],pop:NXM_NX_REG0[],push:NXM_OF_ETH_DST[],set_field:0/0x40->reg10,resubmit(,66),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[65],pop:NXM_OF_ETH_DST[],pop:NXM_NX_REG0[],pop:NXM_NX_REG15[]
    has prereqs eth.type == 0x806

lookup_arp_ip;
    Syntax error at `lookup_arp_ip' expecting action.
reg0[0] = lookup_arp_ip;
    Syntax error at `lookup_arp_ip' expecting field name.
reg0[0] = lookup_arp_ip();
    Syntax error at `)' expecting field name.
reg0[0] = lookup_arp_ip(inport);
    Syntax error at `)' expecting `,'.
reg0[0] = lookup_arp_ip(inport ip4.dst);
    Syntax error at `ip4.dst' expecting `,'.
reg0[0] = lookup_arp_ip(inport, ip4.dst;
    Syntax error at `;' expecting `)'.
reg0[0] = lookup_arp_ip(inport, ip4.dst, eth.src;
    Syntax error at `,' expecting `)'.
reg0[0] = lookup_arp_ip(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 32-bit field is required.

# put_dhcp_opts
reg1[0] = put_dhcp_opts(offerip = 1.2.3.4, router = 10.0.0.1);
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.40.01.02.03.04.03.04.0a.00.00.01,pause)
reg2[5] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.254.0,mtu=1400,domain_name="ovn.org",wpad="https://example.org",bootfile_name="https://127.0.0.1/boot.ipxe",path_prefix="/tftpboot", next_server=10.0.0.9);
    formats as reg2[5] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.254.0, mtu = 1400, domain_name = "ovn.org", wpad = "https://example.org", bootfile_name = "https://127.0.0.1/boot.ipxe", path_prefix = "/tftpboot", next_server = 10.0.0.9);
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.25.0a.00.00.04.43.1b.68.74.74.70.73.3a.2f.2f.31.32.37.2e.30.2e.30.2e.31.2f.62.6f.6f.74.2e.69.70.78.65.fd.04.0a.00.00.09.03.04.0a.00.00.01.01.04.ff.ff.fe.00.1a.02.05.78.0f.07.6f.76.6e.2e.6f.72.67.fc.13.68.74.74.70.73.3a.2f.2f.65.78.61.6d.70.6c.65.2e.6f.72.67.d2.09.2f.74.66.74.70.62.6f.6f.74,pause)
reg0[15] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.255.0,mtu=1400,ip_forward_enable=1,default_ttl=121,dns_server={8.8.8.8,7.7.7.7},classless_static_route={30.0.0.0/24,10.0.0.4,40.0.0.0/16,10.0.0.6,0.0.0.0/0,10.0.0.1},ethernet_encap=1,router_discovery=0,tftp_server_address={10.0.0.4,10.0.0.5},arp_cache_timeout=10,tcp_keepalive_interval=10);
    formats as reg0[15] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.255.0, mtu = 1400, ip_forward_enable = 1, default_ttl = 121, dns_server = {8.8.8.8, 7.7.7.7}, classless_static_route = {30.0.0.0/24, 10.0.0.4, 40.0.0.0/16, 10.0.0.6, 0.0.0.0/0, 10.0.0.1}, ethernet_encap = 1, router_discovery = 0, tftp_server_address = {10.0.0.4, 10.0.0.5}, arp_cache_timeout = 10, tcp_keepalive_interval = 10);
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.6f.0a.00.00.04.03.04.0a.00.00.01.01.04.ff.ff.ff.00.1a.02.05.78.13.01.01.17.01.79.06.08.08.08.08.08.07.07.07.07.79.14.18.1e.00.00.0a.00.00.04.10.28.00.0a.00.00.06.00.0a.00.00.01.24.01.01.1f.01.00.96.08.0a.00.00.04.0a.00.00.05.23.04.00.00.00.0a.26.04.00.00.00.0a,pause)
reg0[15] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.255.0,mtu=1400,ip_forward_enable=1,default_ttl=121,dns_server={8.8.8.8,7.7.7.7},classless_static_route={30.0.0.0/24,10.0.0.4,40.0.0.0/16,10.0.0.6,0.0.0.0/0,10.0.0.1},ethernet_encap=1,router_discovery=0,tftp_server=10.0.0.10,broadcast_address=255.255.255.255);
    formats as reg0[15] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.255.0, mtu = 1400, ip_forward_enable = 1, default_ttl = 121, dns_server = {8.8.8.8, 7.7.7.7}, classless_static_route = {30.0.0.0/24, 10.0.0.4, 40.0.0.0/16, 10.0.0.6, 0.0.0.0/0, 10.0.0.1}, ethernet_encap = 1, router_discovery = 0, tftp_server = 10.0.0.10, broadcast_address = 255.255.255.255);
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.6f.0a.00.00.04.03.04.0a.00.00.01.01.04.ff.ff.ff.00.1a.02.05.78.13.01.01.17.01.79.06.08.08.08.08.08.07.07.07.07.79.14.18.1e.00.00.0a.00.00.04.10.28.00.0a.00.00.06.00.0a.00.00.01.24.01.01.1f.01.00.42.04.0a.00.00.0a.1c.04.ff.ff.ff.ff,pause)
reg0[15] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.255.0,mtu=1400,ip_forward_enable=1,default_ttl=121,dns_server={8.8.8.8,7.7.7.7},classless_static_route={30.0.0.0/24,10.0.0.4,40.0.0.0/16,10.0.0.6,0.0.0.0/0,10.0.0.1},ethernet_encap=1,router_discovery=0,tftp_server="tftp_server_test");
    formats as reg0[15] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.255.0, mtu = 1400, ip_forward_enable = 1, default_ttl = 121, dns_server = {8.8.8.8, 7.7.7.7}, classless_static_route = {30.0.0.0/24, 10.0.0.4, 40.0.0.0/16, 10.0.0.6, 0.0.0.0/0, 10.0.0.1}, ethernet_encap = 1, router_discovery = 0, tftp_server = "tftp_server_test");
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.6f.0a.00.00.04.03.04.0a.00.00.01.01.04.ff.ff.ff.00.1a.02.05.78.13.01.01.17.01.79.06.08.08.08.08.08.07.07.07.07.79.14.18.1e.00.00.0a.00.00.04.10.28.00.0a.00.00.06.00.0a.00.00.01.24.01.01.1f.01.00.42.10.74.66.74.70.5f.73.65.72.76.65.72.5f.74.65.73.74,pause)
reg2[5] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.254.0,mtu=1400,domain_name="ovn.org",wpad="https://example.org",bootfile_name="https://127.0.0.1/boot.ipxe",path_prefix="/tftpboot",domain_search_list="ovn.org,abc.ovn.org",netbios_name_server={10.0.0.7,10.0.0.8},netbios_node_type=2);
    formats as reg2[5] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.254.0, mtu = 1400, domain_name = "ovn.org", wpad = "https://example.org", bootfile_name = "https://127.0.0.1/boot.ipxe", path_prefix = "/tftpboot", domain_search_list = "ovn.org,abc.ovn.org", netbios_name_server = {10.0.0.7, 10.0.0.8}, netbios_node_type = 2);
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.25.0a.00.00.04.43.1b.68.74.74.70.73.3a.2f.2f.31.32.37.2e.30.2e.30.2e.31.2f.62.6f.6f.74.2e.69.70.78.65.03.04.0a.00.00.01.01.04.ff.ff.fe.00.1a.02.05.78.0f.07.6f.76.6e.2e.6f.72.67.fc.13.68.74.74.70.73.3a.2f.2f.65.78.61.6d.70.6c.65.2e.6f.72.67.d2.09.2f.74.66.74.70.62.6f.6f.74.77.0f.03.6f.76.6e.03.6f.72.67.00.03.61.62.63.c0.00.2c.08.0a.00.00.07.0a.00.00.08.2e.01.02,pause)
reg2[5] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.254.0,mtu=1400,domain_name="ovn.org",wpad="https://example.org",bootfile_name="https://127.0.0.1/boot.ipxe",path_prefix="/tftpboot",domain_search_list="ovn.org,abc.ovn.org,def.ovn.org,ovn.test,def.ovn.test,test.org,abc.com");
    formats as reg2[5] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.254.0, mtu = 1400, domain_name = "ovn.org", wpad = "https://example.org", bootfile_name = "https://127.0.0.1/boot.ipxe", path_prefix = "/tftpboot", domain_search_list = "ovn.org,abc.ovn.org,def.ovn.org,ovn.test,def.ovn.test,test.org,abc.com");
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.25.0a.00.00.04.43.1b.68.74.74.70.73.3a.2f.2f.31.32.37.2e.30.2e.30.2e.31.2f.62.6f.6f.74.2e.69.70.78.65.03.04.0a.00.00.01.01.04.ff.ff.fe.00.1a.02.05.78.0f.07.6f.76.6e.2e.6f.72.67.fc.13.68.74.74.70.73.3a.2f.2f.65.78.61.6d.70.6c.65.2e.6f.72.67.d2.09.2f.74.66.74.70.62.6f.6f.74.77.35.03.6f.76.6e.03.6f.72.67.00.03.61.62.63.c0.00.03.64.65.66.c0.00.03.6f.76.6e.04.74.65.73.74.00.03.64.65.66.c0.15.04.74.65.73.74.c0.04.03.61.62.63.03.63.6f.6d.00,pause)
reg2[5] = put_dhcp_opts(offerip=10.0.0.4,router=10.0.0.1,netmask=255.255.254.0,mtu=1400,domain_name="ovn.org",hostname="ip-10-0-0-4");
    formats as reg2[5] = put_dhcp_opts(offerip = 10.0.0.4, router = 10.0.0.1, netmask = 255.255.254.0, mtu = 1400, domain_name = "ovn.org", hostname = "ip-10-0-0-4");
    encodes as controller(userdata=00.00.00.02.00.00.00.00.00.01.de.10.00.00.00.25.0a.00.00.04.03.04.0a.00.00.01.01.04.ff.ff.fe.00.1a.02.05.78.0f.07.6f.76.6e.2e.6f.72.67.0c.0b.69.70.2d.31.30.2d.30.2d.30.2d.34,pause)

reg1[0..1] = put_dhcp_opts(offerip = 1.2.3.4, router = 10.0.0.1);
    Cannot use 2-bit field reg1[0..1] where 1-bit field is required.
reg1[0] = put_dhcp_opts();
    put_dhcp_opts requires offerip to be specified.
reg1[0] = put_dhcp_opts(x = 1.2.3.4, router = 10.0.0.1);
    Syntax error at `x' expecting DHCPv4 option name.
reg1[0] = put_dhcp_opts(router = 10.0.0.1);
    put_dhcp_opts requires offerip to be specified.
reg1[0] = put_dhcp_opts(offerip=1.2.3.4, "hi");
    Syntax error at `"hi"'.
reg1[0] = put_dhcp_opts(offerip=1.2.3.4, xyzzy);
    Syntax error at `xyzzy' expecting DHCPv4 option name.
reg1[0] = put_dhcp_opts(offerip="xyzzy");
    DHCPv4 option offerip requires numeric value.
reg1[0] = put_dhcp_opts(offerip=1.2.3.4, domain_name=1.2.3.4);
    DHCPv4 option domain_name requires string value.
reg1[0] = put_dhcp_opts(offerip=1.2.3.4, domain_search_list=1.2.3.4);
    DHCPv4 option domain_search_list requires string value.

# nd_ns
nd_ns { nd.target = xxreg0; output; };
    encodes as controller(userdata=00.00.00.09.00.00.00.00.00.1c.00.18.00.80.00.00.00.00.00.00.00.01.de.10.80.00.3e.10.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00)
    has prereqs ip6

nd_ns { };
    formats as nd_ns { drop; };
    encodes as controller(userdata=00.00.00.09.00.00.00.00)
    has prereqs ip6

# nd_na
nd_na { eth.src = 12:34:56:78:9a:bc; nd.tll = 12:34:56:78:9a:bc; outport = inport; inport = ""; /* Allow sending out inport. */ output; };
    formats as nd_na { eth.src = 12:34:56:78:9a:bc; nd.tll = 12:34:56:78:9a:bc; outport = inport; inport = ""; output; };
    encodes as controller(userdata=00.00.00.03.00.00.00.00.00.19.00.10.80.00.08.06.12.34.56.78.9a.bc.00.00.00.19.00.10.80.00.42.06.12.34.56.78.9a.bc.00.00.00.1c.00.18.00.20.00.00.00.00.00.00.00.01.1c.04.00.01.1e.04.00.00.00.00.00.19.00.10.00.01.1c.04.00.00.00.00.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00)
    has prereqs nd_ns
# nd_na_router
nd_na_router { eth.src = 12:34:56:78:9a:bc; nd.tll = 12:34:56:78:9a:bc; outport = inport; inport = ""; /* Allow sending out inport. */ output; };
    formats as nd_na_router { eth.src = 12:34:56:78:9a:bc; nd.tll = 12:34:56:78:9a:bc; outport = inport; inport = ""; output; };
    encodes as controller(userdata=00.00.00.0c.00.00.00.00.00.19.00.10.80.00.08.06.12.34.56.78.9a.bc.00.00.00.19.00.10.80.00.42.06.12.34.56.78.9a.bc.00.00.00.1c.00.18.00.20.00.00.00.00.00.00.00.01.1c.04.00.01.1e.04.00.00.00.00.00.19.00.10.00.01.1c.04.00.00.00.00.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00)
    has prereqs nd_ns

# get_nd
get_nd(outport, ip6.dst);
    encodes as push:NXM_NX_XXREG0[],push:NXM_NX_IPV6_DST[],pop:NXM_NX_XXREG0[],set_field:00:00:00:00:00:00->eth_dst,resubmit(,66),pop:NXM_NX_XXREG0[]
    has prereqs eth.type == 0x86dd
get_nd(inport, xxreg0);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],set_field:00:00:00:00:00:00->eth_dst,resubmit(,66),pop:NXM_NX_REG15[]
get_nd;
    Syntax error at `;' expecting `('.
get_nd();
    Syntax error at `)' expecting field name.
get_nd(inport);
    Syntax error at `)' expecting `,'.
get_nd(inport ip6.dst);
    Syntax error at `ip6.dst' expecting `,'.
get_nd(inport, ip6.dst;
    Syntax error at `;' expecting `)'.
get_nd(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 128-bit field is required.
get_nd(inport, outport);
    Cannot use string field outport where numeric field is required.
get_nd(xxreg0, ip6.dst);
    Cannot use numeric field xxreg0 where string field is required.

# put_nd
put_nd(inport, nd.target, nd.sll);
    encodes as push:NXM_NX_XXREG0[],push:NXM_OF_ETH_SRC[],push:NXM_NX_ND_SLL[],push:NXM_NX_ND_TARGET[],pop:NXM_NX_XXREG0[],pop:NXM_OF_ETH_SRC[],controller(userdata=00.00.00.04.00.00.00.00),pop:NXM_OF_ETH_SRC[],pop:NXM_NX_XXREG0[]
    has prereqs (icmp6.type == 0x87 || icmp6.type == 0x88) && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.code == 0 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && ip.ttl == 0xff && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.type == 0x87 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.code == 0 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && ip.ttl == 0xff && (eth.type == 0x800 || eth.type == 0x86dd)

# put_dhcpv6_opts
reg1[0] = put_dhcpv6_opts(ia_addr = ae70::4, server_id = 00:00:00:00:10:02);
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.05.00.10.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.04.00.02.00.06.00.00.00.00.10.02,pause)
reg1[0] = put_dhcpv6_opts();
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40,pause)
reg1[0] = put_dhcpv6_opts(dns_server={ae70::1,ae70::2});
    formats as reg1[0] = put_dhcpv6_opts(dns_server = {ae70::1, ae70::2});
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.17.00.20.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.01.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.02,pause)
reg1[0] = put_dhcpv6_opts(server_id=12:34:56:78:9a:bc, dns_server={ae70::1,ae89::2});
    formats as reg1[0] = put_dhcpv6_opts(server_id = 12:34:56:78:9a:bc, dns_server = {ae70::1, ae89::2});
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.02.00.06.12.34.56.78.9a.bc.00.17.00.20.ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.01.ae.89.00.00.00.00.00.00.00.00.00.00.00.00.00.02,pause)
reg1[0] = put_dhcpv6_opts(domain_search = "ovn.org");
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.18.00.07.6f.76.6e.2e.6f.72.67,pause)
reg1[0] = put_dhcpv6_opts(x = 1.2.3.4);
    Syntax error at `x' expecting DHCPv6 option name.
reg1[0] = put_dhcpv6_opts(ia_addr=ae70::4, "hi");
    Syntax error at `"hi"'.
reg1[0] = put_dhcpv6_opts(ia_addr=ae70::4, xyzzy);
    Syntax error at `xyzzy' expecting DHCPv6 option name.
reg1[0] = put_dhcpv6_opts(ia_addr="ae70::4");
    DHCPv6 option ia_addr requires numeric value.
reg1[0] = put_dhcpv6_opts(ia_addr=ae70::4, domain_search=ae70::1);
    DHCPv6 option domain_search requires string value.
reg1[0] = put_dhcpv6_opts(bootfile_name="https://127.0.0.1/boot.ipxe");
    formats as reg1[0] = put_dhcpv6_opts(bootfile_name = "https://127.0.0.1/boot.ipxe");
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.3b.00.1b.68.74.74.70.73.3a.2f.2f.31.32.37.2e.30.2e.30.2e.31.2f.62.6f.6f.74.2e.69.70.78.65,pause)
reg1[0] = put_dhcpv6_opts(bootfile_name_alt="https://127.0.0.1/boot.ipxe");
    formats as reg1[0] = put_dhcpv6_opts(bootfile_name_alt = "https://127.0.0.1/boot.ipxe");
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.fe.00.1b.68.74.74.70.73.3a.2f.2f.31.32.37.2e.30.2e.30.2e.31.2f.62.6f.6f.74.2e.69.70.78.65,pause)
reg1[0] = put_dhcpv6_opts(fqdn="ovn.org");
    formats as reg1[0] = put_dhcpv6_opts(fqdn = "ovn.org");
    encodes as controller(userdata=00.00.00.05.00.00.00.00.00.01.de.10.00.00.00.40.00.27.00.09.03.6f.76.6e.03.6f.72.67.00,pause)

# lookup_nd
reg2[0] = lookup_nd(inport, ip6.dst, eth.src);
    encodes as push:NXM_NX_XXREG0[],push:NXM_NX_IPV6_DST[],pop:NXM_NX_XXREG0[],set_field:0/0x40->reg10,resubmit(,67),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[32],pop:NXM_NX_XXREG0[]
    has prereqs eth.type == 0x86dd
reg3[0] = lookup_nd(inport, nd.target, nd.tll);
    encodes as push:NXM_NX_XXREG0[],push:NXM_OF_ETH_SRC[],push:NXM_NX_ND_TLL[],push:NXM_NX_ND_TARGET[],pop:NXM_NX_XXREG0[],pop:NXM_OF_ETH_SRC[],set_field:0/0x40->reg10,resubmit(,67),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[0],pop:NXM_OF_ETH_SRC[],pop:NXM_NX_XXREG0[]
    has prereqs (icmp6.type == 0x87 || icmp6.type == 0x88) && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.code == 0 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && ip.ttl == 0xff && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.type == 0x88 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.code == 0 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && ip.ttl == 0xff && (eth.type == 0x800 || eth.type == 0x86dd)

lookup_nd;
    Syntax error at `lookup_nd' expecting action.
reg0[0] = lookup_nd;
    Syntax error at `lookup_nd' expecting field name.
reg0[0] = lookup_nd();
    Syntax error at `)' expecting field name.
reg0[0] = lookup_nd(inport);
    Syntax error at `)' expecting `,'.
reg0[0] = lookup_nd(inport ip6.dst);
    Syntax error at `ip6.dst' expecting `,'.
reg0[0] = lookup_nd(inport, ip6.dst;
    Syntax error at `;' expecting `,'.
reg0[0] = lookup_nd(inport, ip6.dst, eth.src;
    Syntax error at `;' expecting `)'.
reg0[0] = lookup_nd(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 128-bit field is required.
reg0[0] = lookup_nd(inport, ip4.src, ip4.dst);
    Cannot use 32-bit field ip4.src[0..31] where 128-bit field is required.
reg0[0] = lookup_nd(inport, ip6.src, ip6.dst);
    Cannot use 128-bit field ip6.dst[0..127] where 48-bit field is required.

# lookup_nd_ip
reg2[0] = lookup_nd_ip(inport, ip6.dst);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_XXREG0[],push:NXM_NX_IPV6_DST[],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],pop:NXM_NX_XXREG0[],push:NXM_OF_ETH_DST[],set_field:0/0x40->reg10,resubmit(,66),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[32],pop:NXM_OF_ETH_DST[],pop:NXM_NX_XXREG0[],pop:NXM_NX_REG15[]
    has prereqs eth.type == 0x86dd
reg3[0] = lookup_nd_ip(inport, nd.target);
    encodes as push:NXM_NX_REG15[],push:NXM_NX_XXREG0[],push:NXM_NX_ND_TARGET[],push:NXM_NX_REG14[],pop:NXM_NX_REG15[],pop:NXM_NX_XXREG0[],push:NXM_OF_ETH_DST[],set_field:0/0x40->reg10,resubmit(,66),move:NXM_NX_REG10[6]->NXM_NX_XXREG0[0],pop:NXM_OF_ETH_DST[],pop:NXM_NX_XXREG0[],pop:NXM_NX_REG15[]
    has prereqs (icmp6.type == 0x87 || icmp6.type == 0x88) && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && icmp6.code == 0 && eth.type == 0x86dd && ip.proto == 0x3a && (eth.type == 0x800 || eth.type == 0x86dd) && ip.ttl == 0xff && (eth.type == 0x800 || eth.type == 0x86dd)

lookup_nd_ip;
    Syntax error at `lookup_nd_ip' expecting action.
reg0[0] = lookup_nd_ip;
    Syntax error at `lookup_nd_ip' expecting field name.
reg0[0] = lookup_nd_ip();
    Syntax error at `)' expecting field name.
reg0[0] = lookup_nd_ip(inport);
    Syntax error at `)' expecting `,'.
reg0[0] = lookup_nd_ip(inport ip6.dst);
    Syntax error at `ip6.dst' expecting `,'.
reg0[0] = lookup_nd_ip(inport, ip6.dst;
    Syntax error at `;' expecting `)'.
reg0[0] = lookup_nd_ip(inport, eth.dst);
    Cannot use 48-bit field eth.dst[0..47] where 128-bit field is required.
reg0[0] = lookup_nd_ip(inport, ip4.src);
    Cannot use 32-bit field ip4.src[0..31] where 128-bit field is required.

# set_queue
set_queue(0);
    encodes as set_queue:0
set_queue(61440);
    encodes as set_queue:61440
set_queue(65535);
    Queue ID 65535 for set_queue is not in valid range 0 to 61440.

# dns_lookup
reg1[0] = dns_lookup();
    encodes as controller(userdata=00.00.00.06.00.00.00.00.00.01.de.10.00.00.00.40,pause)
    has prereqs udp
reg1[0] = dns_lookup("foo");
    dns_lookup doesn't take any parameters

# set_meter
set_meter(0);
    Rate 0 for set_meter is not in valid.
set_meter(1);
    encodes as meter:1
set_meter(100, 1000);
    encodes as meter:2
set_meter(100, 1000, );
    Syntax error at `,' expecting `)'.
set_meter(4294967295, 4294967295);
    encodes as meter:3

# log
log(verdict=allow, severity=warning);
    encodes as controller(userdata=00.00.00.07.00.00.00.00.00.04)
log(name="test1", verdict=drop, severity=info);
    encodes as controller(userdata=00.00.00.07.00.00.00.00.01.06.74.65.73.74.31)
log(verdict=drop, severity=info, meter="meter1");
    encodes as controller(userdata=00.00.00.07.00.00.00.00.01.06)
log(name="test1", verdict=drop, severity=info, meter="meter1");
    encodes as controller(userdata=00.00.00.07.00.00.00.00.01.06.74.65.73.74.31)
log(verdict=drop);
    formats as log(verdict=drop, severity=info);
    encodes as controller(userdata=00.00.00.07.00.00.00.00.01.06)
log(verdict=bad_verdict, severity=info);
    Syntax error at `bad_verdict' unknown verdict.
log(verdict=drop, severity=bad_severity);
    Syntax error at `bad_severity' unknown severity.
log(severity=notice);
    Syntax error at `;' expecting verdict.

# put_nd_ra_opts
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", mtu = 1500, router_preference = "HIGH", prefix = aef0::/64, slla = ae:01:02:03:04:05);
    encodes as controller(userdata=00.00.00.08.00.00.00.00.00.01.de.10.00.00.00.40.86.00.00.00.ff.08.ff.ff.00.00.00.00.00.00.00.00.05.01.00.00.00.00.05.dc.03.04.40.c0.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.ae.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.ae.01.02.03.04.05,pause)
    has prereqs ip6
reg1[0] = put_nd_ra_opts(addr_mode = "dhcpv6_stateful", router_preference = "MEDIUM", slla = ae:01:02:03:04:10, mtu = 1450);
    encodes as controller(userdata=00.00.00.08.00.00.00.00.00.01.de.10.00.00.00.40.86.00.00.00.ff.80.ff.ff.00.00.00.00.00.00.00.00.01.01.ae.01.02.03.04.10.05.01.00.00.00.00.05.aa,pause)
    has prereqs ip6
reg1[0] = put_nd_ra_opts(addr_mode = "dhcpv6_stateless", router_preference = "LOW", slla = ae:01:02:03:04:06, prefix = aef0::/64);
    encodes as controller(userdata=00.00.00.08.00.00.00.00.00.01.de.10.00.00.00.40.86.00.00.00.ff.58.ff.ff.00.00.00.00.00.00.00.00.01.01.ae.01.02.03.04.06.03.04.40.c0.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.ae.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00,pause)
    has prereqs ip6
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", mtu = 1500, prefix = aef0::/64);
    slla option not present
reg1[0] = put_nd_ra_opts(addr_mode = "dhcpv6_stateful", mtu = 1450, prefix = aef0::/64, prefix = bef0::/64, slla = ae:01:02:03:04:10);
    encodes as controller(userdata=00.00.00.08.00.00.00.00.00.01.de.10.00.00.00.40.86.00.00.00.ff.80.ff.ff.00.00.00.00.00.00.00.00.05.01.00.00.00.00.05.aa.03.04.40.80.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.ae.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.04.40.80.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.be.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.ae.01.02.03.04.10,pause)
    has prereqs ip6
reg1[0] = put_nd_ra_opts(addr_mode = "dhcpv6_stateful", mtu = 1450, prefix = aef0::/64, prefix = bef0::/64, slla = ae:01:02:03:04:10);
    encodes as controller(userdata=00.00.00.08.00.00.00.00.00.01.de.10.00.00.00.40.86.00.00.00.ff.80.ff.ff.00.00.00.00.00.00.00.00.05.01.00.00.00.00.05.aa.03.04.40.80.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.ae.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00.03.04.40.80.ff.ff.ff.ff.ff.ff.ff.ff.00.00.00.00.be.f0.00.00.00.00.00.00.00.00.00.00.00.00.00.00.01.01.ae.01.02.03.04.10,pause)
    has prereqs ip6
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", slla = ae:01:02:03:04:10);
    prefix option needs to be set when address mode is slaac/dhcpv6_stateless.
reg1[0] = put_nd_ra_opts(addr_mode = "dhcpv6_stateless", slla = ae:01:02:03:04:10);
    prefix option needs to be set when address mode is slaac/dhcpv6_stateless.
reg1[0] = put_nd_ra_opts(addr_mode = dhcpv6_stateless, prefix = aef0::/64, slla = ae:01:02:03:04:10);
    Syntax error at `dhcpv6_stateless' expecting constant.
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", mtu = 1500, prefix = aef0::, slla = ae:01:02:03:04:10);
    Invalid value for "prefix" option
reg1[0] = put_nd_ra_opts(addr_mode = "foo", mtu = 1500, slla = ae:01:02:03:04:10);
    Invalid value for "addr_mode" option
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", mtu = "1500", slla = ae:01:02:03:04:10);
    IPv6 ND RA option mtu requires numeric value.
reg1[0] = put_nd_ra_opts(addr_mode = "slaac", mtu = 10.0.0.4, slla = ae:01:02:03:04:10);
    Invalid value for "mtu" option

# icmp4
icmp4 { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.0a.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip4

icmp4 { };
    formats as icmp4 { drop; };
    encodes as controller(userdata=00.00.00.0a.00.00.00.00)
    has prereqs ip4

# icmp4 with icmp4.frag_mtu
icmp4 { eth.dst = ff:ff:ff:ff:ff:ff; icmp4.frag_mtu = 1500; output; }; output;
    encodes as controller(userdata=00.00.00.0a.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.28.00.00.23.20.00.25.00.00.00.00.00.00.00.03.00.0e.00.00.00.0d.00.00.00.00.05.dc.00.00.00.04.00.04.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip4

# icmp4_error
icmp4_error { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.0e.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip4

icmp4_error { };
    formats as icmp4_error { drop; };
    encodes as controller(userdata=00.00.00.0e.00.00.00.00)
    has prereqs ip4

# icmp4_error with icmp4.frag_mtu
icmp4_error { eth.dst = ff:ff:ff:ff:ff:ff; icmp4.frag_mtu = 1500; output; }; output;
    encodes as controller(userdata=00.00.00.0e.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.28.00.00.23.20.00.25.00.00.00.00.00.00.00.03.00.0e.00.00.00.0d.00.00.00.00.05.dc.00.00.00.04.00.04.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip4

icmp4.frag_mtu = 1500;
    encodes as controller(userdata=00.00.00.0d.00.00.00.00.05.dc,pause)

# icmp6
icmp6 { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.0a.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip6

icmp6 { };
    formats as icmp6 { drop; };
    encodes as controller(userdata=00.00.00.0a.00.00.00.00)
    has prereqs ip6

# icmp6_error
icmp6_error { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.14.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip6

icmp6_error { };
    formats as icmp6_error { drop; };
    encodes as controller(userdata=00.00.00.14.00.00.00.00)
    has prereqs ip6

# icmp6_error with icmp6.frag_mtu
icmp6_error { eth.dst = ff:ff:ff:ff:ff:ff; icmp6.frag_mtu = 1500; output; }; output;
    encodes as controller(userdata=00.00.00.14.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.28.00.00.23.20.00.25.00.00.00.00.00.00.00.03.00.10.00.00.00.15.00.00.00.00.00.00.05.dc.00.04.00.04.00.00.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs ip6

icmp6.frag_mtu = 1500;
    encodes as controller(userdata=00.00.00.15.00.00.00.00.00.00.05.dc,pause)

# tcp_reset
tcp_reset { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.0b.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs tcp

tcp_reset { };
    formats as tcp_reset { drop; };
    encodes as controller(userdata=00.00.00.0b.00.00.00.00)
    has prereqs tcp

# sctp_abort
sctp_abort {eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    formats as sctp_abort { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.18.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)
    has prereqs sctp

sctp_abort { };
    formats as sctp_abort { drop; };
    encodes as controller(userdata=00.00.00.18.00.00.00.00)
    has prereqs sctp

# reject
reject { eth.dst = ff:ff:ff:ff:ff:ff; output; }; output;
    encodes as controller(userdata=00.00.00.16.00.00.00.00.00.19.00.10.80.00.06.06.ff.ff.ff.ff.ff.ff.00.00.ff.ff.00.10.00.00.23.20.00.0e.ff.f8.40.00.00.00),resubmit(,64)

reject { };
    formats as reject { drop; };
    encodes as controller(userdata=00.00.00.16.00.00.00.00)

# trigger_event
trigger_event(event = "empty_lb_backends", vip = "10.0.0.1:80", protocol = "tcp", load_balancer = "12345678-abcd-9876-fedc-11119f8e7d6c");
    encodes as controller(userdata=00.00.00.0f.00.00.00.00.00.00.00.00.00.01.00.0b.31.30.2e.30.2e.30.2e.31.3a.38.30.00.02.00.03.74.63.70.00.03.00.24.31.32.33.34.35.36.37.38.2d.61.62.63.64.2d.39.38.37.36.2d.66.65.64.63.2d.31.31.31.31.39.66.38.65.37.64.36.63)

# Testing invalid vip results in extra error messages from socket-util.c
trigger_event(event = "empty_lb_backends", vip = "10.0.0.1:80", protocol = "aarp", load_balancer = "12345678-abcd-9876-fedc-11119f8e7d6c");
    Load balancer protocol 'aarp' is not 'tcp', 'udp', or 'sctp'
trigger_event(event = "empty_lb_backends", vip = "10.0.0.1:80", protocol = "tcp", load_balancer = "bacon");
    Load balancer 'bacon' is not a UUID

# IGMP
igmp;
    encodes as controller(userdata=00.00.00.10.00.00.00.00)

# Contradictionary prerequisites (allowed but not useful):
ip4.src = ip6.src[0..31];
    encodes as move:NXM_NX_IPV6_SRC[0..31]->NXM_OF_IP_SRC[]
    has prereqs eth.type == 0x800 && eth.type == 0x86dd
ip4.src <-> ip6.src[0..31];
    encodes as push:NXM_NX_IPV6_SRC[0..31],push:NXM_OF_IP_SRC[],pop:NXM_NX_IPV6_SRC[0..31],pop:NXM_OF_IP_SRC[]
    has prereqs eth.type == 0x800 && eth.type == 0x86dd

# check_pkt_larger
reg0[0] = check_pkt_larger(1500);
    encodes as check_pkt_larger(1500)->NXM_NX_XXREG0[96]

reg0 = check_pkt_larger(1500);
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

reg0 = check_pkt_larger(foo);
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

reg0[0] = check_pkt_larger(foo);
    Syntax error at `foo' expecting `;'.

# bind_vport
# lsp1's port key is 0x11.
bind_vport("lsp1", inport);
    encodes as controller(userdata=00.00.00.11.00.00.00.00.00.00.00.11)
# lsp2 doesn't exist. So it should be encoded as drop.
bind_vport("lsp2", inport);
    encodes as drop
bind_vport;
    Syntax error at `;' expecting `('.
bind_vport(;
    Syntax error at `;' expecting port name string.
bind_vport("xyzzy";
    Syntax error at `;' expecting `,'.
bind_vport("xyzzy",;
    Syntax error at `;' expecting field name.
bind_vport("xyzzy", inport;
    Syntax error at `;' expecting `)'.

# handle_svc_check
handle_svc_check(inport);
    encodes as controller(userdata=00.00.00.12.00.00.00.00)

handle_svc_check(outport);
    encodes as push:NXM_NX_REG14[],push:NXM_NX_REG15[],pop:NXM_NX_REG14[],controller(userdata=00.00.00.12.00.00.00.00),pop:NXM_NX_REG14[]

handle_svc_check();
    Syntax error at `)' expecting field name.

handle_svc_check(reg0);
    Cannot use numeric field reg0 where string field is required.

# select
reg9[16..31] = select(1=50, 2=100, 3, );
    formats as reg9[16..31] = select(1=50, 2=100, 3=100);
    encodes as group:19
    uses group: id(19), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:50,actions=load:1->xreg4[16..31],resubmit(,19),bucket=bucket_id=1,weight:100,actions=load:2->xreg4[16..31],resubmit(,19),bucket=bucket_id=2,weight:100,actions=load:3->xreg4[16..31],resubmit(,19))

reg0 = select(1, 2);
    formats as reg0 = select(1=100, 2=100);
    encodes as group:20
    uses group: id(20), name(type=select,selection_method=dp_hash,bucket=bucket_id=0,weight:100,actions=load:1->xxreg0[96..127],resubmit(,19),bucket=bucket_id=1,weight:100,actions=load:2->xxreg0[96..127],resubmit(,19))

reg0 = select(1=, 2);
    Syntax error at `,' expecting weight.
reg0 = select(1=0, 2);
    Syntax error at `,' weight can't be 0.
reg0 = select(1=123456, 2);
    Syntax error at `123456' expecting weight.
reg0 = select(123);
    Syntax error at `;' expecting at least 2 group members.
ip.proto = select(1, 2, 3);
    Field ip.proto is not modifiable.
reg0[0..14] = select(1, 2, 3);
    cannot use 15-bit field reg0[0..14] for "select", which requires at least 16 bits.

fwd_group(liveness=true, childports="eth0", "lsp1");
    formats as fwd_group(liveness="true", childports="eth0", "lsp1");
    encodes as group:21
    uses group: id(21), name(type=select,selection_method=dp_hash,bucket=watch_port:5,load=0x5->NXM_NX_REG15[0..15],resubmit(,64),bucket=watch_port:17,load=0x17->NXM_NX_REG15[0..15],resubmit(,64))

fwd_group(childports="eth0", "lsp1");
    encodes as group:22
    uses group: id(22), name(type=select,selection_method=dp_hash,bucket=load=0x5->NXM_NX_REG15[0..15],resubmit(,64),bucket=load=0x17->NXM_NX_REG15[0..15],resubmit(,64))

fwd_group(childports=eth0);
    Syntax error at `eth0' expecting logical switch port.

fwd_group();
    Syntax error at `)' expecting `;'.

fwd_group(childports="eth0", "lsp1");
    encodes as group:22
    uses group: id(22), name(type=select,selection_method=dp_hash,bucket=load=0x5->NXM_NX_REG15[0..15],resubmit(,64),bucket=load=0x17->NXM_NX_REG15[0..15],resubmit(,64))

fwd_group(liveness=xyzzy, childports="eth0", "lsp1");
    Syntax error at `xyzzy' expecting true or false.

fwd_group(liveness=false childports="eth0", "lsp1");
    Syntax error at `childports' expecting `,'.

# prefix delegation
handle_dhcpv6_reply;
    encodes as controller(userdata=00.00.00.13.00.00.00.00)

# chk_lb_hairpin
reg0[0] = chk_lb_hairpin();
    encodes as set_field:0/0x80->reg10,resubmit(,68),move:NXM_NX_REG10[7]->NXM_NX_XXREG0[96]

reg2[2] = chk_lb_hairpin();
    encodes as set_field:0/0x80->reg10,resubmit(,68),move:NXM_NX_REG10[7]->NXM_NX_XXREG0[34]

reg0 = chk_lb_hairpin();
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

reg0[0] = chk_lb_hairpin(foo);
    chk_lb_hairpin doesn't take any parameters

chk_lb_hairpin;
    Syntax error at `chk_lb_hairpin' expecting action.

# chk_lb_hairpin_reply
reg0[0] = chk_lb_hairpin_reply();
    encodes as set_field:0/0x80->reg10,resubmit(,69),move:NXM_NX_REG10[7]->NXM_NX_XXREG0[96]

reg2[2..3] = chk_lb_hairpin_reply();
    Cannot use 2-bit field reg2[2..3] where 1-bit field is required.

reg0 = chk_lb_hairpin_reply();
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

reg0[0] = chk_lb_hairpin_reply(foo);
    chk_lb_hairpin_reply doesn't take any parameters

chk_lb_hairpin_reply;
    Syntax error at `chk_lb_hairpin_reply' expecting action.

# ct_snat_to_vip
ct_snat_to_vip;
    encodes as resubmit(,70)

ct_snat_to_vip(foo);
    Syntax error at `(' expecting `;'.

# bfd packets
handle_bfd_msg();
    encodes as controller(userdata=00.00.00.17.00.00.00.00)

# put_fdb
put_fdb(inport, arp.sha);
    encodes as push:NXM_OF_ETH_SRC[],push:NXM_NX_ARP_SHA[],pop:NXM_OF_ETH_SRC[],controller(userdata=00.00.00.19.00.00.00.00),pop:NXM_OF_ETH_SRC[]
    has prereqs eth.type == 0x806

put_fdb(inport, eth.src);
    encodes as controller(userdata=00.00.00.19.00.00.00.00)

put_fdb(inport, ip4.src);
    Cannot use 32-bit field ip4.src[0..31] where 48-bit field is required.

# get_fdb
outport = get_fdb(eth.dst);
    encodes as set_field:0->reg15,resubmit(,71)

outport = get_fdb(eth.src);
    encodes as push:NXM_OF_ETH_DST[],push:NXM_OF_ETH_SRC[],pop:NXM_OF_ETH_DST[],set_field:0->reg15,resubmit(,71),pop:NXM_OF_ETH_DST[]

inport = get_fdb(arp.sha);
    encodes as push:NXM_OF_ETH_DST[],push:NXM_NX_ARP_SHA[],pop:NXM_OF_ETH_DST[],set_field:0->reg15,resubmit(,71),pop:NXM_OF_ETH_DST[],move:NXM_NX_REG15[]->NXM_NX_REG14[]
    has prereqs eth.type == 0x806

reg0 = get_fdb(arp.tha);
    encodes as push:NXM_OF_ETH_DST[],push:NXM_NX_ARP_THA[],pop:NXM_OF_ETH_DST[],set_field:0->reg15,resubmit(,71),pop:NXM_OF_ETH_DST[],move:NXM_NX_REG15[]->NXM_NX_XXREG0[96..127]
    has prereqs eth.type == 0x806

reg0[1..3] = get_fdb(eth.src);
    Cannot use 3-bit field reg0[1..3] where 32-bit field is required.

reg15 = get_fdb(eth.dst);
    Syntax error at `reg15' expecting field name.

outport = get_fdb(ip4.dst);
    Cannot use 32-bit field ip4.dst[0..31] where 48-bit field is required.

# lookup_fdb
reg0[0] = lookup_fdb(inport, eth.src);
    encodes as set_field:0/0x100->reg10,resubmit(,72),move:NXM_NX_REG10[8]->NXM_NX_XXREG0[96]

reg1[4] = lookup_fdb(outport, eth.dst);
    encodes as push:NXM_NX_REG14[],push:NXM_OF_ETH_SRC[],push:NXM_OF_ETH_DST[],push:NXM_NX_REG15[],pop:NXM_NX_REG14[],pop:NXM_OF_ETH_SRC[],set_field:0/0x100->reg10,resubmit(,72),pop:NXM_OF_ETH_SRC[],pop:NXM_NX_REG14[],move:NXM_NX_REG10[8]->NXM_NX_XXREG0[68]

reg0[0] = lookup_fdb(outport, arp.sha);
    encodes as push:NXM_NX_REG14[],push:NXM_OF_ETH_SRC[],push:NXM_NX_ARP_SHA[],push:NXM_NX_REG15[],pop:NXM_NX_REG14[],pop:NXM_OF_ETH_SRC[],set_field:0/0x100->reg10,resubmit(,72),pop:NXM_OF_ETH_SRC[],pop:NXM_NX_REG14[],move:NXM_NX_REG10[8]->NXM_NX_XXREG0[96]
    has prereqs eth.type == 0x806

reg0 = lookup_fdb(outport, arp.sha);
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

outport = lookup_fdb(outport, arp.sha);
    Cannot use string field outport where numeric field is required.

reg1[1] = lookup_fdb(outport, ip4.src);
    Cannot use 32-bit field ip4.src[0..31] where 48-bit field is required.

reg1[1] = lookup_fdb(ip4.src, eth.src);
    Cannot use numeric field ip4.src where string field is required.

# check_in_port_sec
reg0[0] = check_in_port_sec();
    encodes as set_field:0/0x1000->reg10,resubmit(,73),move:NXM_NX_REG10[12]->NXM_NX_XXREG0[96]

reg2[2] = check_in_port_sec();
    encodes as set_field:0/0x1000->reg10,resubmit(,73),move:NXM_NX_REG10[12]->NXM_NX_XXREG0[34]

reg0 = check_in_port_sec();
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

reg0[0] = check_in_port_sec(foo);
    check_in_port_sec doesn't take any parameters

check_in_port_sec;
    Syntax error at `check_in_port_sec' expecting action.

# check_out_port_sec
reg0[0] = check_out_port_sec();
    encodes as set_field:0/0x1000->reg10,resubmit(,75),move:NXM_NX_REG10[12]->NXM_NX_XXREG0[96]

reg2[2..3] = check_out_port_sec();
    Cannot use 2-bit field reg2[2..3] where 1-bit field is required.

reg0 = check_out_port_sec();
    Cannot use 32-bit field reg0[0..31] where 1-bit field is required.

reg0[0] = check_out_port_sec(foo);
    check_out_port_sec doesn't take any parameters

check_out_port_sec;
    Syntax error at `check_out_port_sec' expecting action.

# commit_ecmp_nh
commit_ecmp_nh(ipv6 = "false", proto = tcp);
    formats as commit_ecmp_nh(ipv6 = false, proto = tcp);
    encodes as learn(table=76,idle_timeout=20,hard_timeout=30,delete_learned,OXM_OF_METADATA[],NXM_OF_ETH_SRC[],eth_type=0x800,NXM_OF_IP_SRC[],NXM_OF_IP_DST[],nw_proto=6,NXM_OF_TCP_SRC[],NXM_OF_TCP_DST[],load:0x1->NXM_NX_REG10[13]),learn(table=77,idle_timeout=20,hard_timeout=30,delete_learned,OXM_OF_METADATA[],eth_type=0x800,NXM_OF_IP_SRC[]=NXM_OF_IP_DST[0..-1],NXM_OF_IP_DST[]=NXM_OF_IP_SRC[0..-1],nw_proto=6,NXM_OF_TCP_SRC[]=NXM_OF_TCP_DST[0..-1],NXM_OF_TCP_DST[]=NXM_OF_TCP_SRC[0..-1],load:0x1->NXM_NX_REG10[13])

commit_ecmp_nh(ipv6 = "true", proto = udp);
    formats as commit_ecmp_nh(ipv6 = true, proto = udp);
    encodes as learn(table=76,idle_timeout=20,hard_timeout=30,delete_learned,OXM_OF_METADATA[],NXM_OF_ETH_SRC[],eth_type=0x86dd,NXM_NX_IPV6_SRC[],NXM_NX_IPV6_DST[],nw_proto=17,NXM_OF_UDP_SRC[],NXM_OF_UDP_DST[],load:0x1->NXM_NX_REG10[13]),learn(table=77,idle_timeout=20,hard_timeout=30,delete_learned,OXM_OF_METADATA[],eth_type=0x86dd,NXM_NX_IPV6_SRC[]=NXM_NX_IPV6_DST[0..-1],NXM_NX_IPV6_DST[]=NXM_NX_IPV6_SRC[0..-1],nw_proto=17,NXM_OF_UDP_SRC[]=NXM_OF_UDP_DST[0..-1],NXM_OF_UDP_DST[]=NXM_OF_UDP_SRC[0..-1],load:0x1->NXM_NX_REG10[13])

commit_ecmp_nh(proto = sctp);
    Syntax error at `proto' invalid parameter.

# chk_ecmp_nh_mac
reg9[5] = chk_ecmp_nh_mac();
    encodes as set_field:0/0x2000->reg10,resubmit(,76),move:NXM_NX_REG10[13]->OXM_OF_PKT_REG4[5]

# chk_ecmp_nh
reg9[5] = chk_ecmp_nh();
    encodes as set_field:0/0x2000->reg10,resubmit(,77),move:NXM_NX_REG10[13]->OXM_OF_PKT_REG4[5]

# commit_lb_aff
commit_lb_aff(vip = "172.16.0.123:8080", backend = "10.0.0.3:8080", proto = tcp, timeout = 30);
    encodes as learn(table=78,idle_timeout=30,delete_learned,OXM_OF_METADATA[],eth_type=0x800,NXM_OF_IP_SRC[],ip_dst=172.16.0.123,nw_proto=6,tcp_dst=8080,load:0x1->NXM_NX_REG10[14],load:0xa000003->NXM_NX_REG4[],load:0x1f90->NXM_NX_REG8[0..15])

commit_lb_aff(vip = "172.16.0.123", backend = "10.0.0.3", timeout = 30);
    encodes as learn(table=78,idle_timeout=30,delete_learned,OXM_OF_METADATA[],eth_type=0x800,NXM_OF_IP_SRC[],ip_dst=172.16.0.123,load:0x1->NXM_NX_REG10[14],load:0xa000003->NXM_NX_REG4[])

commit_lb_aff(vip = "[::1]:8080", backend = "[::2]:8080", proto = tcp, timeout = 30);
    encodes as learn(table=78,idle_timeout=30,delete_learned,OXM_OF_METADATA[],eth_type=0x86dd,NXM_NX_IPV6_SRC[],ipv6_dst=::1,nw_proto=6,tcp_dst=8080,load:0x1->NXM_NX_REG10[14],load:0x2->NXM_NX_XXREG0[],load:0x1f90->NXM_NX_REG8[0..15])

# chk_lb_aff()
reg9[6] = chk_lb_aff();
    encodes as set_field:0/0x4000->reg10,resubmit(,78),move:NXM_NX_REG10[14]->OXM_OF_PKT_REG4[6]

# push/pop
push(xxreg0);push(xxreg1[10..20]);push(eth.src);pop(xxreg0[0..47]);pop(xxreg0[48..57]);pop(xxreg1);
    formats as push(xxreg0); push(xxreg1[10..20]); push(eth.src); pop(xxreg0[0..47]); pop(xxreg0[48..57]); pop(xxreg1);
    encodes as push:NXM_NX_XXREG0[],push:NXM_NX_XXREG1[10..20],push:NXM_OF_ETH_SRC[],pop:NXM_NX_XXREG0[0..47],pop:NXM_NX_XXREG0[48..57],pop:NXM_NX_XXREG1[]

pop(eth.type);
    Field eth.type is not modifiable.

push(abc);
    Syntax error at `abc' expecting field name.

# sample
sample(probability=100,collector_set=200,obs_domain=0,obs_point=1000);
    encodes as sample(probability=100,collector_set_id=200,obs_domain_id=11259375,obs_point_id=1000)

# sample with obs_domain = 10. Final obs_domain is 0xA << 24 | 0xABCDEF.
sample(probability=100,collector_set=200,obs_domain=10,obs_point=$cookie);
    encodes as sample(probability=100,collector_set_id=200,obs_domain_id=179031535,obs_point_id=2863311530)

sample(probability=10);
    formats as sample(probability=10,collector_set=0,obs_domain=0,obs_point=0);
    encodes as sample(probability=10,collector_set_id=0,obs_domain_id=11259375,obs_point_id=0)

sample(probability=10);
    formats as sample(probability=10,collector_set=0,obs_domain=0,obs_point=0);
    encodes as sample(probability=10,collector_set_id=0,obs_domain_id=11259375,obs_point_id=0)

# sample with a collector_set_id that is not configured in the chassis.
sample(probability=100,collector_set=999,obs_domain=0,obs_point=1000);
    encodes as drop

sample(probability=0,collector_set=200,obs_domain=0,obs_point=1000);
    probability must be greater than zero

sample(probability=0,collector_set=200,obs_domain=0,obs_point=foo);
    Syntax error at `foo' malformed sample observation_point_id.

sample(probability=0,collector_set=200,obs_domain=300,obs_point=foo);
    Syntax error at `300' obs_domain must be 8-bit long.

sample(probability=10,foo=bar,obs_domain=0,obs_point=1000);
    Syntax error at `foo' unknown argument.

# mac_cache_use
mac_cache_use;
    encodes as resubmit(,79)

# Miscellaneous negative tests.
;
    Syntax error at `;'.
xyzzy;
    Syntax error at `xyzzy' expecting action.
next; 123;
    Syntax error at `123'.
next; xyzzy;
    Syntax error at `xyzzy' expecting action.
next
    Syntax error at end of input expecting `;'.
]])
sed '/^[[ 	]]/d' test-cases.txt > input.txt
cp test-cases.txt expout
AT_CHECK([ovstest test-ovn parse-actions < input.txt], [0], [expout])
AT_CLEANUP

AT_BANNER([OVN end-to-end tests])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- enables vlan-limit=0])
ovn_start

net_add n
check ovs-vsctl add-br br-phys
ovn_attach n br-phys 192.168.0.1

OVS_WAIT_UNTIL([test x`ovs-vsctl get Open_vSwitch . other_config:vlan-limit | tr -d '""'` = x0])

check ovs-vsctl set Open_vSwitch . other_config:vlan-limit=100
OVS_WAIT_UNTIL([test x`ovs-vsctl get Open_vSwitch . other_config:vlan-limit | tr -d '""'` = x0])

check ovs-vsctl set Open_vSwitch . other_config:vlan-limit=foo
OVS_WAIT_UNTIL([test x`ovs-vsctl get Open_vSwitch . other_config:vlan-limit | tr -d '""'` = x0])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- allows ACLs to match against vlan-transparent double tagged traffic L3 fields])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

for i in 1 2; do
    check ovn-nbctl ls-add lsw$i
    check ovn-nbctl --wait=sb add Logical-Switch lsw$i other_config vlan-passthru=true

    ln_port_name=ln-$i
    check ovn-nbctl lsp-add lsw$i $ln_port_name
    check ovn-nbctl lsp-set-addresses $ln_port_name unknown
    check ovn-nbctl lsp-set-type $ln_port_name localnet
    check ovn-nbctl lsp-set-options $ln_port_name network_name=phys
    net_add n
done

# two hypervisors, each connected to the same network
for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovn_attach n br-phys 192.168.0.$i
done

check ovs-vsctl add-port br-phys tap
for i in 1 2; do
    as hv-$i
    check ovs-vsctl add-port br-int vif$i -- set Interface vif$i \
        external-ids:iface-id=lp$i options:tx_pcap=vif$i-tx.pcap options:rxq_pcap=vif$i-rx.pcap
    check ovn-nbctl lsp-add lsw$i lp$i
    check ovn-nbctl lsp-set-addresses lp$i "f0:00:00:00:00:0$i 10.0.0.$i"
done
for i in 1 2; do
    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp$i` = xup])
    > $i.expected
done

test_tcp_packet() {
    local inport=$1 eth_dst=$2 eth_src=$3 ip_dst=$4 ip_src=$5 eout=$6 lout=$7 fail=$8
    local packet=$(fmt_pkt "Ether(dst='${eth_dst}', src='${eth_src}')/ \
                            Dot1Q()/ \
                            Dot1Q()/ \
                            IP(dst='${ip_dst}', src='${ip_src}')/ \
                            TCP()")
    as hv-$inport ovs-appctl netdev-dummy/receive vif$inport $packet
    if [[ $fail -eq 0 ]]; then
        echo $packet >> ${eout#lp}.expected
    fi
}

# first check that acl drop rule works for tagged traffic
for i in 1 2; do
    check ovn-nbctl acl-add lsw$i to-lport 1000 'tcp' drop
done
check ovn-nbctl --wait=hv sync

test_tcp_packet 1 f0:00:00:00:00:02 f0:00:00:00:00:01 10.0.0.2 10.0.0.1 lp2 lp2 1
test_tcp_packet 2 f0:00:00:00:00:01 f0:00:00:00:00:02 10.0.0.1 10.0.0.2 lp1 lp1 1

for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([vif$i-tx.pcap], [$i.expected])
done

# now check that with no rule traffic passes through
for i in 1 2; do
    check ovn-nbctl acl-del lsw$i to-lport 1000 'tcp'
    check ovn-nbctl acl-add lsw$i to-lport 1000 'tcp' allow-stateless
done
check ovn-nbctl --wait=hv sync

test_tcp_packet 2 f0:00:00:00:00:01 f0:00:00:00:00:02 10.0.0.1 10.0.0.2 lp1 lp1 0
test_tcp_packet 1 f0:00:00:00:00:02 f0:00:00:00:00:01 10.0.0.2 10.0.0.1 lp2 lp2 0

for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([vif$i-tx.pcap], [$i.expected])
done

AT_CLEANUP
])

# 3 hypervisors, one logical switch, 3 logical ports per hypervisor
OVN_FOR_EACH_NORTHD([
AT_SETUP([3 HVs, 1 LS, 3 lports/HV])
AT_KEYWORDS([ovnarp])
AT_KEYWORDS([slowtest])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Create hypervisors hv[123].
# Add vif1[123] to hv1, vif2[123] to hv2, vif3[123] to hv3.
# Add all of the vifs to a single logical switch lsw0.
# Turn on port security on all the vifs except vif[123]1.
# Make vif13, vif2[23], vif3[123] destinations for unknown MACs.
# Add some ACLs for Ethertypes 1234, 1235, 1236.
check ovn-nbctl ls-add lsw0
net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2 3; do
        check ovs-vsctl add-port br-int vif$i$j -- set Interface vif$i$j external-ids:iface-id=lp$i$j options:tx_pcap=hv$i/vif$i$j-tx.pcap options:rxq_pcap=hv$i/vif$i$j-rx.pcap ofport-request=$i$j
        check ovn-nbctl lsp-add lsw0 lp$i$j
        if test $j = 1; then
            check ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j 192.168.0.$i$j" unknown
        else
            if test $j = 3; then
                ip_addrs="192.168.0.$i$j fe80::ea2a:eaff:fe28:$i$j/64 192.169.0.$i$j"
            else
                ip_addrs="192.168.0.$i$j"
            fi
            check ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j $ip_addrs"
            check ovn-nbctl lsp-set-port-security lp$i$j f0:00:00:00:00:$i$j
        fi
    done
done
check ovn-nbctl acl-add lsw0 from-lport 1000 'eth.type == 0x1234' drop
check ovn-nbctl acl-add lsw0 from-lport 1000 'eth.type == 0x1235 && inport == "lp11"' drop
check ovn-nbctl acl-add lsw0 to-lport 1000 'eth.type == 0x1236 && outport == "lp33"' drop
ovn-nbctl create Address_Set name=set1 addresses=\"f0:00:00:00:00:11\",\"f0:00:00:00:00:21\",\"f0:00:00:00:00:31\"
check ovn-nbctl acl-add lsw0 to-lport 1000 'eth.type == 0x1237 && eth.src == $set1 && outport == "lp33"' drop

check ovn-nbctl pg-add pg1 lp22 lp33
check ovn-nbctl acl-add lsw0 to-lport 1000 'eth.type == 0x1238 && outport == @pg1' drop
check ovn-nbctl --wait=hv sync
wait_for_ports_up

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Make sure there is no attempt to adding duplicated flows by ovn-controller
AT_FAIL_IF([test -n "`grep duplicate hv1/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv2/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv3/ovn-controller.log`"])

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}

# test_packet INPORT DST SRC ETHTYPE OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 11 for vif11.
for i in 1 2 3; do
    for j in 1 2 3; do
        : > $i$j.expected
    done
done
test_packet() {
    local inport=$1 packet=$2$3$4; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local inport=$1 sha=$2 spa=$3 tpa=$4 reply_ha=$5
    local request=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                             ARP(hwsrc='${sha}', hwdst='ff:ff:ff:ff:ff:ff', psrc='${spa}', pdst='${tpa}')")
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $request

    if test X$reply_ha = X; then
        # Expect to receive the broadcast ARP on the other logical switch ports
        # if no reply is expected.
        local i j
        for i in 1 2 3; do
            for j in 1 2 3; do
                if test $i$j != $inport; then
                    echo $request >> $i$j.expected
                fi
            done
        done
    else
        # Expect to receive the reply, if any.
        local reply=$(fmt_pkt "Ether(dst='${sha}', src='${reply_ha}') /
                               ARP(op=2, hwsrc='${reply_ha}', hwdst='${sha}', psrc='${tpa}', pdst='${spa}')")
        echo $reply >> $inport.expected
    fi
}

# Send packets between all pairs of source and destination ports:
#
# 1. Unicast packets are delivered to exactly one logical switch port
#    (except that packets destined to their input ports are dropped).
#
# 2. Broadcast and multicast are delivered to all logical switch ports
#    except the input port.
#
# 3. When port security is turned on, the switch drops packets from the wrong
#    MAC address.
#
# 4. The switch drops all packets with a VLAN tag.
#
# 5. The switch drops all packets with a multicast source address.  (This only
#    affects behavior when port security is turned off, since otherwise port
#    security would drop the packet anyway.)
#
# 6. The switch delivers packets with an unknown destination to logical
#    switch ports with "unknown" among their MAC addresses (and port
#    security disabled).
#
# 7. The switch drops unicast packets that violate an ACL.
#
# 8. The switch drops multicast and broadcast packets that violate an ACL.
#
# 9. OVN generates responses to ARP requests for known IPs, except for
#    requests from a port for the port's own IP.
#
# 10. No response to ARP requests for unknown IPs.

for is in 1 2 3; do
    for js in 1 2 3; do
        s=$is$js
        bcast=
        unknown=
        bacl2=
        bacl3=
        for id in 1 2 3; do
            for jd in 1 2 3; do
                d=$id$jd

                if test $d != $s; then unicast=$d; else unicast=; fi
                test_packet $s f000000000$d f000000000$s $s$d $unicast     #1

                if test $d != $s && test $js = 1; then
                    impersonate=$d
                else
                    impersonate=
                fi
                test_packet $s f000000000$d f00000000055 55$d $impersonate #3

                if test $d != $s && test $s != 11; then acl2=$d; else acl2=; fi
                if test $d != $s && test $d != 33; then acl3=$d; else acl3=; fi
                if test $d = $s || (test $js = 1 && test $d = 33); then
                    # Source of 11, 21, or 31 and dest of 33 should be dropped
                    # due to the 4th ACL that uses address_set(set1).
                    acl4=
                else
                    acl4=$d
                fi
                if test $d = $s || test $d = 22 || test $d = 33; then
                    # dest of 22 and 33 should be dropped
                    # due to the 5th ACL that uses port_group(pg1).
                    acl5=
                else
                    acl5=$d
                fi
                test_packet $s f000000000$d f000000000$s 1234        #7, acl1
                test_packet $s f000000000$d f000000000$s 1235 $acl2  #7, acl2
                test_packet $s f000000000$d f000000000$s 1236 $acl3  #7, acl3
                test_packet $s f000000000$d f000000000$s 1237 $acl4  #7, acl4
                test_packet $s f000000000$d f000000000$s 1238 $acl5  #7, acl5

                test_packet $s f000000000$d f00000000055 810000091234      #4
                test_packet $s f000000000$d 0100000000$s $s$d              #5

                if test $d != $s && test $jd = 1; then
                    unknown="$unknown $d"
                fi
                bcast="$bcast $unicast"
                bacl2="$bacl2 $acl2"
                bacl3="$bacl3 $acl3"

                sip="192.168.0.$is$js"
                tip="192.168.0.$id$jd"
                tip_unknown="11.11.11.11"
                reply_ha=;
                if test $d != $s; then
                    if test $jd != 1; then
                        reply_ha="f0:00:00:00:00:$d"
                    fi
                fi

                test_arp $s f0:00:00:00:00:$s $sip $tip $reply_ha               #9
                test_arp $s f0:00:00:00:00:$s $sip $tip_unknown                 #10

                if test $jd = 3; then
                    # lsp[123]3 has an additional ip 192.169.0.[123]3.
                    tip="192.169.0.$id$jd"
                    test_arp $s f0:00:00:00:00:$s $sip $tip $reply_ha           #9
                fi
            done
        done

        # Broadcast and multicast.
        test_packet $s ffffffffffff f000000000$s ${s}ff $bcast             #2
        test_packet $s 010000000000 f000000000$s ${s}ff $bcast             #2
        if test $js = 1; then
            bcast_impersonate=$bcast
        else
            bcast_impersonate=
        fi
        test_packet $s 010000000000 f00000000044 44ff $bcast_impersonate   #3

        test_packet $s f0000000ffff f000000000$s ${s}66 $unknown           #6

        test_packet $s ffffffffffff f000000000$s 1234                #8, acl1
        test_packet $s ffffffffffff f000000000$s 1235 $bacl2         #8, acl2
        test_packet $s ffffffffffff f000000000$s 1236 $bacl3         #8, acl3
        test_packet $s 010000000000 f000000000$s 1234                #8, acl1
        test_packet $s 010000000000 f000000000$s 1235 $bacl2         #8, acl2
        test_packet $s 010000000000 f000000000$s 1236 $bacl3         #8, acl3
    done
done

# set address for lp13 with invalid characters.
# lp13 should be configured with only 192.168.0.13.
check ovn-nbctl --wait=hv lsp-set-addresses lp13 "f0:00:00:00:00:13 192.168.0.13 invalid 192.169.0.13"

sip="192.168.0.11"
tip="192.168.0.13"
test_arp 11 f0:00:00:00:00:11  $sip $tip f0:00:00:00:00:13

tip="192.169.0.13"
#arp request for 192.169.0.13 should be flooded
test_arp 11 f0:00:00:00:00:11  $sip $tip

# dump information and flows with counters
ovn-sbctl dump-flows -- list multicast_group > sbflows
AT_CAPTURE_FILE([sbflows])

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    for j in 1 2 3; do
        OVN_CHECK_PACKETS([hv$i/vif$i$j-tx.pcap], [$i$j.expected])
    done
done

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

# 2 hypervisors, one logical switch, 2 logical ports per hypervisor
# logical ports bound to chassis encap-ip.
OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 1 LS, 2 lports/HV])
AT_KEYWORDS([ovnarp])
ovn_start

# Create hypervisors hv[12].
# Add vif1[12] to hv1, vif2[12] to hv2
ovn-nbctl ls-add lsw0
net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2; do
        ovs-vsctl add-port br-int vif$i$j -- set Interface vif$i$j external-ids:iface-id=lp$i$j options:tx_pcap=hv$i/vif$i$j-tx.pcap options:rxq_pcap=hv$i/vif$i$j-rx.pcap ofport-request=$i$j
        ovn-nbctl lsp-add lsw0 lp$i$j
        ip_addrs="192.168.0.$i$j"
        ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j $ip_addrs"
        ovn-nbctl --wait=hv lsp-set-port-security lp$i$j f0:00:00:00:00:$i$j
    done
done

get_lsp_uuid () {
    ovn-nbctl lsp-list lsw0 | grep $1 | awk '{ print $1 }'
}

# XXX-Check how to pass lp$i1 in AT_CHECK_UNQUOTED, for now just do it
# explictly

# For Chassis hv1
check_row_count Port_Binding 1 logical_port=lp11 'encap=[[]]'
check_row_count Port_Binding 1 logical_port=lp12 'encap=[[]]'

# For Chassis hv2
check_row_count Port_Binding 1 logical_port=lp21 'encap=[[]]'
check_row_count Port_Binding 1 logical_port=lp22 'encap=[[]]'

# Bind the ports to the encap-ip
for i in 1 2; do
    for j in 1 2; do
        as hv$i
        ovs-vsctl set Interface vif$i$j external-ids:encap-ip=192.168.0.$i
    done
done

# Wait for bindings to take effect.
wait_row_count Port_Binding 1 logical_port=lp11 'encap!=[[]]'
wait_row_count Port_Binding 1 logical_port=lp12 'encap!=[[]]'
wait_row_count Port_Binding 1 logical_port=lp21 'encap!=[[]]'
wait_row_count Port_Binding 1 logical_port=lp22 'encap!=[[]]'

# dump port bindings; since we have vxlan and geneve tunnels, we expect the
# ports to be bound to geneve tunnels.

# For Chassis 1
encap_rec=$(fetch_column Encap _uuid chassis_name=hv1 type=geneve ip=192.168.0.1)
check_row_count Port_Binding 1 logical_port=lp11 encap=$encap_rec
check_row_count Port_Binding 1 logical_port=lp12 encap=$encap_rec

# For Chassis 2
encap_rec=$(fetch_column Encap _uuid chassis_name=hv2 type=geneve ip=192.168.0.2)
check_row_count Port_Binding 1 logical_port=lp21 encap=$encap_rec
check_row_count Port_Binding 1 logical_port=lp22 encap=$encap_rec

# Remove the encap-ip setting in vif, which should trigger encap removal from
# Port_Binding.
as hv1 ovs-vsctl remove Interface vif11 external-ids encap-ip
wait_row_count Port_Binding 1 logical_port=lp11 'encap=[[]]'

# Change it back and continue the test
as hv1 ovs-vsctl set Interface vif11 external-ids:encap-ip=192.168.0.1
wait_row_count Port_Binding 1 logical_port=lp11 'encap!=[[]]'

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Make sure there is no attempt to adding duplicated flows by ovn-controller
AT_FAIL_IF([test -n "`grep duplicate hv1/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv2/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv3/ovn-controller.log`"])

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}

# test_packet INPORT DST SRC ETHTYPE OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 11 for vif11.
for i in 1 2; do
    for j in 1 2; do
        : > $i$j.expected
    done
done
test_packet() {
    local inport=$1 packet=$2$3$4; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Send packets between all pairs of source and destination ports:
#
# 1. Unicast packets are delivered to exactly one logical switch port
#    (except that packets destined to their input ports are dropped).

for is in 1 2; do
    for js in 1 2; do
        s=$is$js
        bcast=
        unknown=
        bacl2=
        bacl3=
        for id in 1 2 3; do
            for jd in 1 2 3; do
                d=$id$jd

                if test $d != $s; then unicast=$d; else unicast=; fi
                test_packet $s f000000000$d f000000000$s $s$d $unicast     #1
            done
        done

    done
done

# dump information and flows with counters
ovn-sbctl dump-flows -- list multicast_group

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv3 dump ------"
as hv3 ovs-vsctl show
as hv3 ovs-ofctl -O OpenFlow13 dump-flows br-int

# Now check the packets actually received against the ones expected.
for i in 1 2; do
    for j in 1 2; do
        OVN_CHECK_PACKETS([hv$i/vif$i$j-tx.pcap], [$i$j.expected])
    done
done

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([trace 1 LS, 3 LSPs])
ovn_start

# Create a logical switch and some logical ports.
# Turn on port security on all lports except ls1.
# Make ls1 a destination for unknown MACs.
# Add some ACLs for Ethertypes 1234, 1235, 1236.
ovn-nbctl ls-add lsw0
ovn-sbctl chassis-add hv0 geneve 127.0.0.1
for i in 1 2 3; do
    ovn-nbctl lsp-add lsw0 lp$i
done
ovn-nbctl --wait=sb sync
for i in 1 2 3; do
    ovn-sbctl lsp-bind lp$i hv0
    if test $i = 1; then
        ovn-nbctl lsp-set-addresses lp$i "f0:00:00:00:00:0$i 192.168.0.$i" unknown
    else
        if test $i = 3; then
           ip_addrs="192.168.0.$i fe80::ea2a:eaff:fe28:$i/64 192.169.0.$i"
        else
           ip_addrs="192.168.0.$i"
        fi
        ovn-nbctl lsp-set-addresses lp$i "f0:00:00:00:00:0$i $ip_addrs"
        ovn-nbctl lsp-set-port-security lp$i f0:00:00:00:00:0$i
    fi
done
ovn-nbctl acl-add lsw0 from-lport 1000 'eth.type == 0x1234' drop
ovn-nbctl acl-add lsw0 from-lport 1000 'eth.type == 0x1235 && inport == "lp1"' drop
ovn-nbctl acl-add lsw0 to-lport 1000 'eth.type == 0x1236 && outport == "lp3"' drop
ovn-nbctl create Address_Set name=set1 addresses=\"f0:00:00:00:00:01\",\"f0:00:00:00:00:02\"
ovn-nbctl acl-add lsw0 to-lport 1000 'eth.type == 0x1237 && eth.src == $set1 && outport == "lp3"' drop

ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])
on_exit 'kill `cat ovn-trace.pid`'
ovn-trace --detach --pidfile --no-chdir

# test_packet INPORT DST SRC [-vlan] [-eth TYPE] OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 11 for vif11.
test_packet() {
    local inport=$1 eth_dst=$2 eth_src=$3; shift; shift; shift
    uflow="inport==\"lp$inport\" && eth.dst==$eth_dst && eth.src==$eth_src"
    while :; do
        case $1 in # (
            -vlan) uflow="$uflow && vlan.vid == 1234"; shift ;; # (
            -eth) uflow="$uflow && eth.type == 0x$2"; shift; shift ;; # (
            *) break ;;
        esac
    done
    for outport; do
        echo "output(\"lp$outport\");"
    done > expout

    AT_CHECK([ovn_trace_client ovn-trace --minimal lsw0 "$uflow"], [0], [expout])
}

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local inport=$1 sha=$2 spa=$3 tpa=$4 reply_ha=$5

    local request="inport == \"lp$inport\"
                   && eth.dst == ff:ff:ff:ff:ff:ff && eth.src == $sha
                   && arp.op == 1 && arp.sha == $sha && arp.spa == $spa
                   && arp.tha == ff:ff:ff:ff:ff:ff && arp.tpa == $tpa"

    if test -z "$reply_ha"; then
        reply=
        local i
        for i in 1 2 3; do
            if test $i != $inport; then
                reply="${reply}output(\"lp$i\");
"
            fi
        done
    else
        reply="\
eth.dst = $sha;
eth.src = $reply_ha;
arp.op = 2;
arp.tha = $sha;
arp.sha = $reply_ha;
arp.tpa = $spa;
arp.spa = $tpa;
output(\"lp$inport\");
"
    fi

    AT_CHECK_UNQUOTED([ovn_trace_client ovn-trace --minimal lsw0 "$request"], [0], [$reply])
}

# Send packets between all pairs of source and destination ports:
#
# 1. Unicast packets are delivered to exactly one logical switch port
#    (except that packets destined to their input ports are dropped).
#
# 2. Broadcast and multicast are delivered to all logical switch ports
#    except the input port.
#
# 3. When port security is turned on, the switch drops packets from the wrong
#    MAC address.
#
# 4. The switch drops all packets with a VLAN tag.
#
# 5. The switch drops all packets with a multicast source address.  (This only
#    affects behavior when port security is turned off, since otherwise port
#    security would drop the packet anyway.)
#
# 6. The switch delivers packets with an unknown destination to logical
#    switch ports with "unknown" among their MAC addresses (and port
#    security disabled).
#
# 7. The switch drops unicast packets that violate an ACL.
#
# 8. The switch drops multicast and broadcast packets that violate an ACL.
#
# 9. OVN generates responses to ARP requests for known IPs, except for
#    requests from a port for the port's own IP.
#
# 10. No response to ARP requests for unknown IPs.

for s in 1 2 3; do
    bcast=
    unknown=
    bacl2=
    bacl3=
    for d in 1 2 3; do
        echo
        echo "lp$s -> lp$d"
        if test $d != $s; then unicast=$d; else unicast=; fi
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:0$s $unicast      #1

        if test $d != $s && test $s = 1; then
            impersonate=$d
        else
            impersonate=
        fi
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:55 $impersonate   #3

        if test $d != $s && test $s != 1; then acl2=$d; else acl2=; fi
        if test $d != $s && test $d != 3; then acl3=$d; else acl3=; fi
        if test $d = $s || ( (test $s = 1 || test $s = 2) && test $d = 3); then
            # Source of 1 or 2 and dest of 3 should be dropped
            # due to the 4th ACL that uses address_set(set1).
            acl4=
        else
            acl4=$d
        fi

        #7, acl1 to acl4:
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:0$s -eth 1234
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:0$s -eth 1235 $acl2
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:0$s -eth 1236 $acl3
        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:0$s -eth 1237 $acl4

        test_packet $s f0:00:00:00:00:0$d f0:00:00:00:00:55 -vlan          #4
        test_packet $s f0:00:00:00:00:0$d 01:00:00:00:00:0$s               #5

        if test $d != $s && test $d = 1; then
            unknown="$unknown $d"
        fi
        bcast="$bcast $unicast"
        bacl2="$bacl2 $acl2"
        bacl3="$bacl3 $acl3"

        sip=192.168.0.$s
        tip=192.168.0.$d
        tip_unknown=11.11.11.11
        reply_ha=;
        if test $d != $s; then
            if test $d != 1; then
                reply_ha=f0:00:00:00:00:0$d;
            fi
        fi

        test_arp $s f0:00:00:00:00:0$s $sip $tip $reply_ha                 #9
        test_arp $s f0:00:00:00:00:0$s $sip $tip_unknown                   #10

        if test $d = 3; then
            # lp3 has an additional ip 192.169.0.[123]3.
            tip=192.169.0.$d
            test_arp $s f0:00:00:00:00:0$s $sip $tip $reply_ha             #9
        fi
    done

    # Broadcast and multicast.
    test_packet $s ff:ff:ff:ff:ff:ff f0:00:00:00:00:0$s $bcast             #2
    test_packet $s 01:00:00:00:00:00 f0:00:00:00:00:0$s $bcast             #2
    if test $s = 1; then
       bcast_impersonate=$bcast
    else
       bcast_impersonate=
    fi
    test_packet $s 01:00:00:00:00:00 f0:00:00:00:00:44 $bcast_impersonate  #3

    test_packet $s f0:00:00:00:ff:ff f0:00:00:00:00:0$s $unknown           #6

    #8, acl1 to acl3:
    test_packet $s ff:ff:ff:ff:ff:ff f0:00:00:00:00:0$s -eth 1234
    test_packet $s ff:ff:ff:ff:ff:ff f0:00:00:00:00:0$s -eth 1235 $bacl2
    test_packet $s ff:ff:ff:ff:ff:ff f0:00:00:00:00:0$s -eth 1236 $bacl3

    #8, acl1 to acl3:
    test_packet $s 01:00:00:00:00:00 f0:00:00:00:00:0$s -eth 1234
    test_packet $s 01:00:00:00:00:00 f0:00:00:00:00:0$s -eth 1235 $bacl2
    test_packet $s 01:00:00:00:00:00 f0:00:00:00:00:0$s -eth 1236 $bacl3
done

# send packets for unknown datapath
AT_CAPTURE_FILE([trace])
AT_CHECK_UNQUOTED([ovs-appctl -t ovn-trace trace --all lsw100 "inport == p100 && ip4.dst == 10.96.57.175"], [0], [dnl
unknown datapath "lsw100"
])

AT_CLEANUP
])

# 2 hypervisors, 4 logical ports per HV
# 2 locally attached networks (one flat, one vlan tagged over same device)
# 2 ports per HV on each network
OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 4 lports/HV, localnet ports])
ovn_start

# In this test cases we create 3 switches, all connected to same
# physical network (through br-phys on each HV). Each switch has
# VIF ports across 2 HVs. Each HV has 5 VIF ports. The first digit
# of VIF port name indicates the hypervisor it is bound to, e.g.
# lp23 means VIF 3 on hv2.
#
# Each switch's VLAN tag and their logical switch ports are:
#   - ls1:
#       - untagged
#       - ports: lp11, lp12, lp21, lp22
#
#   - ls2:
#       - tagged with VLAN 101
#       - ports: lp13, lp14, lp23, lp24
#   - ls3:
#       - untagged
#       - ports: lp15, lp25
#
# Note: a localnet port is created for each switch to connect to
# physical network.

for i in 1 2 3; do
    ls_name=ls$i
    ovn-nbctl ls-add $ls_name
    ln_port_name=ln$i
    if test $i -eq 2; then
        ovn-nbctl lsp-add $ls_name $ln_port_name "" 101
    else
        ovn-nbctl lsp-add $ls_name $ln_port_name
    fi
    ovn-nbctl lsp-set-addresses $ln_port_name unknown
    ovn-nbctl lsp-set-type $ln_port_name localnet
    ovn-nbctl lsp-set-options $ln_port_name network_name=phys
done

# lsp_to_ls LSP
#
# Prints the name of the logical switch that contains LSP.
lsp_to_ls () {
    case $1 in dnl (
        lp?[[12]]) echo ls1 ;; dnl (
        lp?[[34]]) echo ls2 ;; dnl (
        lp?5) echo ls3 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2 3 4 5; do
        ovs-vsctl add-port br-int vif$i$j -- \
            set Interface vif$i$j external-ids:iface-id=lp$i$j \
                                  options:tx_pcap=hv$i/vif$i$j-tx.pcap \
                                  options:rxq_pcap=hv$i/vif$i$j-rx.pcap \
                                  ofport-request=$i$j

        lsp_name=lp$i$j
        ls_name=$(lsp_to_ls $lsp_name)

        ovn-nbctl lsp-add $ls_name $lsp_name
        ovn-nbctl lsp-set-addresses $lsp_name f0:00:00:00:00:$i$j
        ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:$i$j

        OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])
    done
done
wait_for_ports_up
OVN_WAIT_PATCH_PORT_FLOWS(["ln1" "ln2" "ln3"], ["hv1"] ["hv2"])

ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

OVN_POPULATE_ARP

# XXX This is now the 3rd copy of these functions in this file ...

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}
#
# test_packet INPORT DST SRC ETHTYPE EOUT LOUT
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  INPORT is specified as
# logical switch port numbers, e.g. 11 for vif11.
#
# EOUT is the end-to-end output port, that is, where the packet will end up
# after possibly bouncing through one or more localnet ports.  LOUT is the
# logical output port, which might be a localnet port, as seen by ovn-trace
# (which doesn't know what localnet ports are connected to and therefore can't
# figure out the end-to-end answer).
for i in 1 2; do
    for j in 1 2 3 4 5; do
        : > $i$j.expected
    done
done
test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6
    echo "$@"

    # First try tracing the packet.
    uflow="inport==\"lp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    if test $lout != drop; then
        echo "output(\"$lout\");"
    fi > expout
    AT_CHECK([ovn_trace --minimal $(lsp_to_ls lp$inport) "$uflow"], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    hv=`vif_to_hv $inport`
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    if test $eout != drop; then
        echo $packet >> ${eout#lp}.expected
    fi
}

# lp11 and lp21 are on the same network (phys, untagged)
# and on different hypervisors
test_packet 11 f0:00:00:00:00:21 f0:00:00:00:00:11 1121 lp21 lp21
test_packet 21 f0:00:00:00:00:11 f0:00:00:00:00:21 2111 lp11 lp11

# lp11 and lp12 are on the same network (phys, untagged)
# and on the same hypervisor
test_packet 11 f0:00:00:00:00:12 f0:00:00:00:00:11 1112 lp12 lp12
test_packet 12 f0:00:00:00:00:11 f0:00:00:00:00:12 1211 lp11 lp11

# lp13 and lp23 are on the same network (phys, VLAN 101)
# and on different hypervisors
test_packet 13 f0:00:00:00:00:23 f0:00:00:00:00:13 1323 lp23 lp23
test_packet 23 f0:00:00:00:00:13 f0:00:00:00:00:23 2313 lp13 lp13

# lp13 and lp14 are on the same network (phys, VLAN 101)
# and on the same hypervisor
test_packet 13 f0:00:00:00:00:14 f0:00:00:00:00:13 1314 lp14 lp14
test_packet 14 f0:00:00:00:00:13 f0:00:00:00:00:14 1413 lp13 lp13

# lp11 and lp15 are on the same network (phys, untagged),
# same hypervisor, and on different switches
test_packet 11 f0:00:00:00:00:15 f0:00:00:00:00:11 1115 lp15 ln1
test_packet 15 f0:00:00:00:00:11 f0:00:00:00:00:15 1511 lp11 ln3

# lp11 and lp25 are on the same network (phys, untagged),
# different hypervisors, and on different switches
test_packet 11 f0:00:00:00:00:25 f0:00:00:00:00:11 1125 lp25 ln1
test_packet 25 f0:00:00:00:00:11 f0:00:00:00:00:25 2511 lp11 ln3

# Ports that should not be able to communicate
test_packet 11 f0:00:00:00:00:13 f0:00:00:00:00:11 1113 drop ln1
test_packet 11 f0:00:00:00:00:23 f0:00:00:00:00:11 1123 drop ln1
test_packet 21 f0:00:00:00:00:13 f0:00:00:00:00:21 2113 drop ln1
test_packet 21 f0:00:00:00:00:23 f0:00:00:00:00:21 2123 drop ln1
test_packet 13 f0:00:00:00:00:11 f0:00:00:00:00:13 1311 drop ln2
test_packet 13 f0:00:00:00:00:21 f0:00:00:00:00:13 1321 drop ln2
test_packet 23 f0:00:00:00:00:11 f0:00:00:00:00:23 2311 drop ln2
test_packet 23 f0:00:00:00:00:21 f0:00:00:00:00:23 2321 drop ln2

# Dump a bunch of info helpful for debugging if there's a failure.

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int

# Now check the packets actually received against the ones expected.
for i in 1 2; do
    for j in 1 2 3 4 5; do
        OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv$i/vif$i$j-tx.pcap], [$i$j.expected])
    done
done

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 2 LS, routing works for multiple collocated segments attached to different switches])
ovn_start

for tag in `seq 10 30`; do
    net_add n-$tag
done

for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys11
    ovs-vsctl add-br br-phys21
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-11:br-phys11,phys-21:br-phys21
    ovn_attach n-11 br-phys11 192.168.0.${i}1
    ovn_attach n-21 br-phys21 192.168.0.${i}2
done

for i in 1 2; do
    lsname=ls-${i}0
    ovn-nbctl ls-add $lsname
    for tag in `seq ${i}1 ${i}9`; do
        ln_port_name=ln-$tag
        ovn-nbctl lsp-add $lsname $ln_port_name "" $tag
        ovn-nbctl lsp-set-addresses $ln_port_name unknown
        ovn-nbctl lsp-set-type $ln_port_name localnet
        ovn-nbctl lsp-set-options $ln_port_name network_name=phys-$tag
    done
done

for hv in 1 2; do
    as hv-$hv
    for ls in 1 2; do
        lsp_name=lp-$hv-$ls
        ovs-vsctl add-port br-int vif-$hv-$ls -- \
            set Interface vif-$hv-$ls external-ids:iface-id=$lsp_name \
                                  options:tx_pcap=hv-$hv/vif-$hv-$ls-tx.pcap \
                                  options:rxq_pcap=hv-$hv/vif-$hv-$ls-rx.pcap \
                                  ofport-request=$hv$ls

        ovn-nbctl lsp-add ls-${ls}0 $lsp_name
        ovn-nbctl lsp-set-addresses $lsp_name f0:00:00:00:00:${hv}${ls}
        ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:${hv}${ls}

        OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])
    done
done


wait_for_ports_up
ovn-nbctl --wait=sb sync
OVN_WAIT_PATCH_PORT_FLOWS(["ln-11" "ln-21"], ["hv-1" "hv-2"])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

ovn-nbctl show > nbctl-show
AT_CAPTURE_FILE([nbctl-show])
ovn-sbctl show > sbctl-show
AT_CAPTURE_FILE([sbctl-show])

for i in 1 2; do
    hv=hv-$i
    echo "------ $hv dump ------"
    as $hv ovs-vsctl show
    as $hv ovs-ofctl -O OpenFlow13 dump-flows br-int
done

# vif ports
for i in 1-1 1-2 2-1 2-2; do
    : > vif-$i.expected
done

# localnet ports
for hv in 1 2; do
    : > out-$hv.expected
done

test_packet() {
    local hv=$1 inport=$2 outport=$3 dst=$4 src=$5 eth=$6 lout=$7

    : > expout
    if test $lout = unknown; then
        # Expect the packet cloned to all localnet ports
        for tag in `seq ${hv}1 ${hv}9`; do
            echo "output(\"ln-$tag\");" >> expout
        done
    else
        echo "output(\"$lout\");" >> expout
    fi

    # First try tracing the packet.
    uflow="inport==\"lp-$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    AT_CHECK([ovn_trace --minimal ls-${hv}0 "$uflow"], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    as hv-$hv ovs-appctl netdev-dummy/receive vif-$inport $packet

    if test $lout != unknown; then
        # Expect the packet received by the peer VIF port
        echo $packet >> vif-$outport.expected
    fi

    # regardless, the packet is sent through the bridge
    local packet=$(echo $dst$src | sed 's/://g')810000$(printf "%.2x\n" ${hv}1)${eth}
    echo $packet >> out-$hv.expected
}

test_packet 1 1-1 2-1 f0:00:00:00:00:21 f0:00:00:00:00:11 1001 lp-2-1
test_packet 2 2-2 1-2 f0:00:00:00:00:12 f0:00:00:00:00:22 1001 lp-1-2

# unknown mac goes through localnet port
test_packet 1 1-1 2-1 f0:00:00:00:00:e0 f0:00:00:00:00:11 1001 unknown
test_packet 2 2-2 1-2 f0:00:00:00:00:e0 f0:00:00:00:00:22 1001 unknown

# Now check the packets actually received against the ones expected.
for hv in 1 2; do
    for ls in 1 2; do
        port=$hv-$ls
        # check that packets targeted to actual vifs arrived on the other end
        OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv-$hv/vif-$port-tx.pcap], [vif-$port.expected])
    done
    # check that all packets, whether to known or unknown mac addresses, were sent to fabric
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv-$hv/br-phys${hv}1_n-${hv}1-tx.pcap], [out-$hv.expected])
done

OVN_CLEANUP([hv-1],[hv-2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 2 LS, broadcast traffic with multiple localnet ports per switch])
ovn_start

for tag in `seq 10 30`; do
    net_add n-$tag
done

for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys11
    ovs-vsctl add-br br-phys21
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-11:br-phys11,phys-21:br-phys21
    ovn_attach n-11 br-phys11 192.168.0.${i}1
    ovn_attach n-21 br-phys21 192.168.0.${i}2
done

for i in 1 2; do
    lsname=ls-${i}0
    ovn-nbctl ls-add $lsname
    for tag in `seq ${i}1 ${i}9`; do
        ln_port_name=ln-$tag
        ovn-nbctl lsp-add $lsname $ln_port_name "" $tag
        ovn-nbctl lsp-set-addresses $ln_port_name unknown
        ovn-nbctl lsp-set-type $ln_port_name localnet
        ovn-nbctl lsp-set-options $ln_port_name network_name=phys-$tag
    done
done

for hv in 1 2; do
    as hv-$hv
    for ls in 1 2; do
        for peer in 8 9; do
            lsp_name=lp-$hv-$ls-$peer
            ovs-vsctl add-port br-int vif-$hv-$ls-$peer -- \
                set Interface vif-$hv-$ls-$peer external-ids:iface-id=$lsp_name \
                                      options:tx_pcap=hv-$hv/vif-$hv-$ls-$peer-tx.pcap \
                                      options:rxq_pcap=hv-$hv/vif-$hv-$ls-$peer-rx.pcap \
                                      ofport-request=$hv$ls$peer

            ovn-nbctl lsp-add ls-${ls}0 $lsp_name
            ovn-nbctl lsp-set-addresses $lsp_name f0:00:00:00:0${peer}:${hv}${ls}
            ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:0${peer}:${hv}${ls}

            OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])

            : > vif-$hv-$ls-$peer.expected
        done
    done
done


wait_for_ports_up
ovn-nbctl --wait=sb sync
ovn-nbctl show
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

for i in 1 2; do
    hv=hv-$i
    echo "------ $hv dump ------"
    as $hv ovs-vsctl show
    as $hv ovs-ofctl -O OpenFlow13 dump-flows br-int
done

# localnet ports
for hv in 1 2; do
    : > out-$hv.expected
done

test_packet() {
    local hv=$1 inport=$2 dst=$3 src=$4 eth=$5
    shift; shift; shift; shift; shift

    : > expout
    for lout in "$@"; do
        if test $lout = unknown; then
            # Expect the packet cloned to all localnet ports
            for tag in `seq ${hv}1 ${hv}9`; do
                echo "output(\"ln-$tag\");" >> expout
            done
        else
            echo "output(\"$lout\");" >> expout
        fi
    done

    # First try tracing the packet.
    uflow="inport==\"lp-$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    AT_CHECK([ovn_trace --minimal ls-${hv}0 "$uflow" | sort], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    as hv-$hv ovs-appctl netdev-dummy/receive vif-$inport $packet

    for lout in "$@"; do
        if test $lout != unknown; then
            # Expect the packet received by the peer VIF port
            echo $packet >> vif-${lout#lp-}.expected
        fi
    done

    # regardless, the packet is sent through the bridge
    local packet=$(echo $dst$src | sed 's/://g')810000$(printf "%.2x\n" ${hv}1)${eth}
    echo $packet >> out-$hv.expected
}

test_packet 1 1-1-8 f0:00:00:00:08:21 f0:00:00:00:08:11 1001 lp-2-1-8
test_packet 2 2-2-8 f0:00:00:00:08:12 f0:00:00:00:08:22 1001 lp-1-2-8

# unknown mac goes through localnet port
test_packet 1 1-1-8 f0:00:00:00:08:e0 f0:00:00:00:08:11 1001 unknown
test_packet 2 2-2-8 f0:00:00:00:08:e0 f0:00:00:00:08:22 1001 unknown

# broadcast traffic goes to all peers, foreign and local
test_packet 1 1-1-8 ff:ff:ff:ff:ff:ff f0:00:00:00:08:11 1001 $(for n in `seq 11 19`; do echo ln-$n; done) lp-1-1-9 lp-2-1-8 lp-2-1-9

# Now check the packets actually received against the ones expected.
for hv in 1 2; do
    for ls in 1 2; do
        for peer in 8 9; do
            port=$hv-$ls-$peer
            # check that packets targeted to actual vifs arrived on the other end
            OVN_CHECK_PACKETS_CONTAIN([hv-$hv/vif-$port-tx.pcap], [vif-$port.expected])
        done
    done
    # check that all packets, whether to known or unknown mac addresses, were sent to fabric
    OVN_CHECK_PACKETS_CONTAIN([hv-$hv/br-phys${hv}1_n-${hv}1-tx.pcap], [out-$hv.expected])
done

OVN_CLEANUP([hv-1],[hv-2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 2 LS, switching between multiple localnet ports with same tags])
ovn_start

# In this test case we create two switches with multiple localnet ports. Only a
# single localnet of the same tag is connected to fabric for each switch. Two
# hypervisors have VIFs that belong to these switches. The test validates that
# routing between these switches and hypervisors still works regardless of the
# number of (unplugged) localnet ports.

# two switches, each connected to lots of networks
for i in 1 2; do
    ovn-nbctl ls-add ls-$i
    for tag in `seq 10 20`; do
        ln_port_name=ln-$i-$tag
        ovn-nbctl lsp-add ls-$i $ln_port_name "" $tag
        ovn-nbctl lsp-set-addresses $ln_port_name unknown
        ovn-nbctl lsp-set-type $ln_port_name localnet
        ovn-nbctl lsp-set-options $ln_port_name network_name=phys-$tag
    done
done

# multiple networks
for tag in `seq 10 20`; do
    net_add n-$tag
done

# two hypervisors, each connected to the same network
for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-20:br-phys
    ovn_attach n-10 br-phys 192.168.0.$i
done

# two vif ports, one per switch
for i in 1 2; do
    as hv-$i
    ovs-vsctl add-port br-int vif-$i -- \
        set Interface vif-$i external-ids:iface-id=lp-$i \
                              options:tx_pcap=hv-$i/vif-$i-tx.pcap \
                              options:rxq_pcap=hv-$i/vif-$i-rx.pcap \
                              ofport-request=$i

    lsp_name=lp-$i
    ovn-nbctl lsp-add ls-$i $lsp_name
    ovn-nbctl lsp-set-addresses $lsp_name f0:00:00:00:00:0$i
    ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:0$i

    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])
    OVN_WAIT_PATCH_PORT_FLOWS(["ln-$i-20"], ["hv-$i"])
done

wait_for_ports_up
ovn-nbctl --wait=sb sync
ovn-nbctl show
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# vif ports
for i in 1 2; do
    : > vif-$i.expected
done

# localnet ports
for i in 1 2; do
    for tag in `seq 10 20`; do
        : > $i-$tag.expected
    done
done

test_packet() {
    local inport=$1 outport=$2 dst=$3 src=$4 eth=$5 eout=$6 lout=$7

    # Expect the packet cloned to all localnet ports
    : > expout
    for tag in `seq 10 20`; do
        echo "output(\"ln-$inport-$tag\");" >> expout
    done

    # First try tracing the packet.
    uflow="inport==\"lp-$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    AT_CHECK([ovn_trace --minimal ls-$inport "$uflow"], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    as hv-$1 ovs-appctl netdev-dummy/receive vif-$inport $packet

    # Expect the packet received by the peer VIF port
    echo $packet >> vif-$outport.expected

    # Expect the packet to transfer through the common fabric network
    local packet=$(echo $dst$src | sed 's/://g')810000$(printf "%.2x" 20)${eth}
    echo $packet >> $1-10.expected
}

test_packet 1 2 f0:00:00:00:00:02 f0:00:00:00:00:01 1001 ln-1-10 ln-1-10
test_packet 1 2 f0:00:00:00:00:02 f0:00:00:00:00:01 1002 ln-1-10 ln-1-10

test_packet 2 1 f0:00:00:00:00:01 f0:00:00:00:00:02 1003 ln-2-10 ln-2-10
test_packet 2 1 f0:00:00:00:00:01 f0:00:00:00:00:02 1004 ln-2-10 ln-2-10

# Dump a bunch of info helpful for debugging if there's a failure.

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

for i in 1 2; do
    hv=hv-$i
    echo "------ $hv dump ------"
    as $hv ovs-vsctl show
    as $hv ovs-ofctl -O OpenFlow13 dump-flows br-int
done

# Now check the packets actually received against the ones expected.
for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv-$i/vif-$i-tx.pcap], [vif-$i.expected])
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv-$i/br-phys_n-10-tx.pcap], [$i-10.expected])
done

OVN_CLEANUP([hv-1],[hv-2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([VLAN transparency, passthru=true, ARP responder disabled])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

net_add net
for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    check ovs-vsctl add-br br-phys
    check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovn_attach net br-phys 192.168.0.$i 24 vxlan
done

check ovn-nbctl ls-add ls
check ovn-nbctl --wait=sb add Logical-Switch ls other_config vlan-passthru=true

for i in 1 2; do
    check ovn-nbctl lsp-add ls lsp$i
    check ovn-nbctl lsp-set-addresses lsp$i "f0:00:00:00:00:0$i 10.0.0.$i"
done

for i in 1 2; do
    as hv-$i
    check ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i \
                                  options:tx_pcap=vif$i-tx.pcap \
                                  options:rxq_pcap=vif$i-rx.pcap \
                                  ofport-request=$i
done

wait_for_ports_up

# Remote output flows are setup when pb of remote is received
# Hence they can be setup after both ports have been reported up.
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv-1"],["hv-2"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv-2"],["hv-1"])


ovn-sbctl dump-flows ls > lsflows
AT_CAPTURE_FILE([lsflows])

AT_CHECK([grep -w "ls_in_arp_rsp" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=0    , match=(1), action=(next;)
])

for i in 1 2; do
    : > $i.expected
done

test_arp() {
    local inport=$1 outport=$2 sha=$3 spa=$4 tpa=$5 reply_ha=$6
    local request=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                             Dot1Q(vlan=0xefe)/ \
                             ARP(hwsrc='${sha}', hwdst='ff:ff:ff:ff:ff:ff', psrc='${spa}', pdst='${tpa}')")
    as hv-$inport ovs-appctl netdev-dummy/receive vif$inport $request
    echo $request >> $outport.expected

    local reply=$(fmt_pkt "Ether(dst='${sha}', src='${reply_ha}')/ \
                           Dot1Q(vlan=0xefe)/ \
                           ARP(op=2, hwsrc='${reply_ha}', hwdst='${sha}', psrc='${tpa}', pdst='${spa}')")
    as hv-$outport ovs-appctl netdev-dummy/receive vif$outport $reply
    echo $reply >> $inport.expected
}

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

test_arp 1 2 f0:00:00:00:00:01 10.0.0.1 10.0.0.2 f0:00:00:00:00:02
test_arp 2 1 f0:00:00:00:00:02 10.0.0.2 10.0.0.1 f0:00:00:00:00:01

for i in 1 2; do
    OVN_CHECK_PACKETS([vif$i-tx.pcap], [$i.expected])
done

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([VLAN transparency, passthru=true, ND/NA responder disabled])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

net_add net
check ovs-vsctl add-br br-phys
ovn_attach net br-phys 192.168.0.1

check ovn-nbctl ls-add ls
check ovn-nbctl --wait=sb add Logical-Switch ls other_config vlan-passthru=true

for i in 1 2; do
    check ovn-nbctl lsp-add ls lsp$i
    check ovn-nbctl lsp-set-addresses lsp$i "f0:00:00:00:00:0$i fe00::$i"
done

for i in 1 2; do
    check ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i \
                                  options:tx_pcap=vif$i-tx.pcap \
                                  options:rxq_pcap=vif$i-rx.pcap \
                                  ofport-request=$i
done

wait_for_ports_up

ovn-sbctl dump-flows ls > lsflows
AT_CAPTURE_FILE([lsflows])

AT_CHECK([grep -w "ls_in_arp_rsp" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=0    , match=(1), action=(next;)
])

test_nd_na() {
    local inport=$1 outport=$2 sha=$3 spa=$4 tpa=$5 reply_ha=$6
    local request=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                             Dot1Q(vlan=0xefe)/ \
                             IPv6(src='${spa}', dst=inet_ntop(AF_INET6, in6_getnsma(inet_pton(AF_INET6, '${tpa}'))))/ \
                             ICMPv6ND_NS(tgt='${tpa}')")
    ovs-appctl netdev-dummy/receive vif$inport $request
    echo $request >> $outport.expected
    echo $request

    local reply=$(fmt_pkt "Ether(dst='${sha}', src='${reply_ha}')/ \
                           Dot1Q(vlan=0xefe)/ \
                           IPv6(src='${tpa}', dst='${spa}')/ \
                           ICMPv6ND_NA(tgt='${tpa}')")
    ovs-appctl netdev-dummy/receive vif$outport $reply
    echo $reply >> $inport.expected
    echo $reply
}

test_nd_na 1 2 f0:00:00:00:00:01 fe00::1 fe00::2 f0:00:00:00:00:02
test_nd_na 2 1 f0:00:00:00:00:02 fe00::2 fe00::1 f0:00:00:00:00:01

for i in 1 2; do
    OVN_CHECK_PACKETS([vif$i-tx.pcap], [$i.expected])
done

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([VLAN transparency, passthru=true, multiple hosts])
ovn_start

check ovn-nbctl ls-add ls
check ovn-nbctl --wait=sb add Logical-Switch ls other_config vlan-passthru=true

ln_port_name=ln-100
ovn-nbctl lsp-add ls $ln_port_name "" 100
ovn-nbctl lsp-set-addresses $ln_port_name unknown
ovn-nbctl lsp-set-type $ln_port_name localnet
ovn-nbctl lsp-set-options $ln_port_name network_name=phys-100
net_add n-100

# two hypervisors, each connected to the same network
for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-100:br-phys
    ovn_attach n-100 br-phys 192.168.0.$i
done

for i in 1 2; do
    check ovn-nbctl lsp-add ls lsp$i
    check ovn-nbctl lsp-set-addresses lsp$i f0:00:00:00:00:0$i
done

for i in 1 2; do
    as hv-$i
    ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i \
                                  options:tx_pcap=vif$i-tx.pcap \
                                  options:rxq_pcap=vif$i-rx.pcap \
                                  ofport-request=$i
    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp$i` = xup])

    # Patch port might be created after ports are reported up
    # Wait for a flow outputing to patch port
    OVN_WAIT_PATCH_PORT_FLOWS(["ln-100"], ["hv-$i"])
done

test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6

    # First try tracing the packet.
    uflow="inport==\"lsp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth && vlan.present==1"
    echo "output(\"$lout\");" > expout
    AT_CHECK([ovn_trace --minimal ls "$uflow"], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}fefefefe
    vif=vif$inport
    as hv-$1
    ovs-appctl netdev-dummy/receive $vif $packet
    echo $packet >> ${eout#lsp}.expected
}

test_packet 1 f0:00:00:00:00:02 f0:00:00:00:00:01 8100 lsp2 lsp2
test_packet 2 f0:00:00:00:00:01 f0:00:00:00:00:02 8100 lsp1 lsp1
for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([vif$i-tx.pcap], [$i.expected])
done

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([VLAN transparency, passthru=true, multiple hosts, custom ethtype])
ovn_start

ethtype=802.11ad

check ovn-nbctl ls-add ls
check ovn-nbctl --wait=sb add Logical-Switch ls other_config vlan-passthru=true

ln_port_name=ln-100
ovn-nbctl lsp-add ls $ln_port_name "" 100
ovn-nbctl lsp-set-addresses $ln_port_name unknown
ovn-nbctl lsp-set-type $ln_port_name localnet
ovn-nbctl lsp-set-options $ln_port_name network_name=phys-100 ethtype=$ethtype
net_add n-100

# two hypervisors, each connected to the same network
for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-100:br-phys
    ovn_attach n-100 br-phys 192.168.0.$i
done

for i in 1 2; do
    check ovn-nbctl lsp-add ls lsp$i
    check ovn-nbctl lsp-set-addresses lsp$i f0:00:00:00:00:0$i
done

for i in 1 2; do
    as hv-$i
    check ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i \
                                  options:tx_pcap=vif$i-tx.pcap \
                                  options:rxq_pcap=vif$i-rx.pcap \
                                  ofport-request=$i
    wait_for_ports_up lsp$i

    # Patch port might be created after ports are reported up
    # Wait for a flow outputing to patch port
    OVN_WAIT_PATCH_PORT_FLOWS(["ln-100"], ["hv-$i"])
done
# create taps on fabric to check vlan encapsulation there
for i in 1 2; do
    as hv-$i
    ovs-vsctl add-port br-phys tap$i -- set Interface tap$i \
                                  options:tx_pcap=tap$i-tx.pcap \
                                  options:rxq_pcap=tap$i-rx.pcap
done

for i in 1 2; do
    : > $i.expected
done
: > tap.expected

test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 lout=$5 ethtype=$6

    # First try tracing the packet.
    uflow="inport==\"lsp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth && vlan.present==1"
    echo "output(\"$lout\");" > expout
    AT_CHECK([ovn_trace --minimal ls "$uflow"], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    payload=fefefefe
    local packet=$(echo $dst$src | sed 's/://g')${eth}${payload}
    vif=vif$inport
    as hv-$1
    ovs-appctl netdev-dummy/receive $vif $packet
    echo $packet >> ${inport}.expected

    phys_packet=$(echo $dst$src | sed 's/://g')${ethtype}0064${eth}${payload}
    echo $phys_packet >> tap.expected
}

test_packet 1 f0:00:00:00:00:03 f0:00:00:00:00:01 8100 ln-100 88a8
test_packet 2 f0:00:00:00:00:03 f0:00:00:00:00:02 8100 ln-100 88a8
for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([vif$i-rx.pcap], [$i.expected])
done
for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([tap$i-tx.pcap], [tap.expected])
done

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([VLAN transparency, passthru=true, multiple hosts, flat/untagged])
ovn_start

check ovn-nbctl ls-add ls
check ovn-nbctl --wait=sb add Logical-Switch ls other_config vlan-passthru=true

ln_port_name=ln
ovn-nbctl lsp-add ls $ln_port_name
ovn-nbctl lsp-set-addresses $ln_port_name unknown
ovn-nbctl lsp-set-type $ln_port_name localnet
ovn-nbctl lsp-set-options $ln_port_name network_name=phys
net_add n

# two hypervisors, each connected to the same network
for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovn_attach n br-phys 192.168.0.$i
done

for i in 1 2; do
    check ovn-nbctl lsp-add ls lsp$i
    check ovn-nbctl lsp-set-addresses lsp$i f0:00:00:00:00:0$i
done

for i in 1 2; do
    as hv-$i
    ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i \
                                  options:tx_pcap=vif$i-tx.pcap \
                                  options:rxq_pcap=vif$i-rx.pcap \
                                  ofport-request=$i
    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp$i` = xup])

    # Patch port might be created after ports are reported up
    # Wait for a flow outputing to patch port
    OVN_WAIT_PATCH_PORT_FLOWS(["ln"], ["hv-$i"])
done

for i in 1 2; do
    : > $i.expected
done

test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6

    # First try tracing the packet.
    uflow="inport==\"lsp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth && vlan.present==1"
    echo "output(\"$lout\");" > expout
    AT_CHECK([ovn_trace --minimal ls "$uflow"], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}fefefefe
    vif=vif$inport
    as hv-$1
    ovs-appctl netdev-dummy/receive $vif $packet
    echo $packet >> ${eout#lsp}.expected
}

test_packet 1 f0:00:00:00:00:02 f0:00:00:00:00:01 8100 lsp2 lsp2
test_packet 2 f0:00:00:00:00:01 f0:00:00:00:00:02 8100 lsp1 lsp1

for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([vif$i-tx.pcap], [$i.expected])
done

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([VLAN transparency, passthru=true])
ovn_start

check ovn-nbctl ls-add ls
check ovn-nbctl --wait=sb add Logical-Switch ls other_config vlan-passthru=true
for i in 1 2; do
    check ovn-nbctl lsp-add ls lsp$i
    check ovn-nbctl lsp-set-addresses lsp$i f0:00:00:00:00:0$i
done

net_add physnet
ovs-vsctl add-br br-phys
ovs-vsctl set open . external-ids:ovn-bridge-mappings=physnet:br-phys
ovn_attach physnet br-phys 192.168.0.1

for i in 1 2; do
    ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i \
                                  options:tx_pcap=vif$i-tx.pcap \
                                  options:rxq_pcap=vif$i-rx.pcap \
                                  ofport-request=$i
    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp$i` = xup])
done

test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6

    # First try tracing the packet.
    uflow="inport==\"lsp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth && vlan.present==1"
    echo "output(\"$lout\");" > expout
    AT_CHECK([ovn_trace --minimal ls "$uflow"], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}fefefefe
    vif=vif$inport
    ovs-appctl netdev-dummy/receive $vif $packet
    echo $packet >> ${eout#lsp}.expected
}

test_packet 1 f0:00:00:00:00:02 f0:00:00:00:00:01 8100 lsp2 lsp2
test_packet 2 f0:00:00:00:00:01 f0:00:00:00:00:02 8100 lsp1 lsp1
for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([vif$i-tx.pcap], [$i.expected])
done

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([VLAN transparency, passthru=false])
ovn_start

check ovn-nbctl ls-add ls
check ovn-nbctl --wait=sb add Logical-Switch ls other_config vlan-passthru=false
for i in 1 2; do
    check ovn-nbctl lsp-add ls lsp$i
    check ovn-nbctl lsp-set-addresses lsp$i f0:00:00:00:00:0$i
done

net_add physnet
ovs-vsctl add-br br-phys
ovs-vsctl set open . external-ids:ovn-bridge-mappings=physnet:br-phys
ovn_attach physnet br-phys 192.168.0.1

for i in 1 2; do
    ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i \
                                  options:tx_pcap=vif$i-tx.pcap \
                                  options:rxq_pcap=vif$i-rx.pcap \
                                  ofport-request=$i
    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp$i` = xup])

    : > $i.expected
done

test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6

    # First try tracing the packet.
    uflow="inport==\"lsp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth && vlan.present==1"
    AT_CHECK([ovn_trace ls "$uflow" | grep -q drop], [0])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}fefefefe
    ovs-appctl netdev-dummy/receive vif$inport $packet
}

test_packet 1 f0:00:00:00:00:02 f0:00:00:00:00:01 8100 lsp2 lsp2
test_packet 2 f0:00:00:00:00:01 f0:00:00:00:00:02 8100 lsp1 lsp1
for i in 1 2; do
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([vif$i-tx.pcap], [$i.expected])
done

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([VXLAN check port/datapath key space limits])

ovn_start
net_add net
check ovs-vsctl add-br br-phys
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach net br-phys 192.168.0.1 24 vxlan
check ovn-nbctl --wait=sb sync
OVS_WAIT_UNTIL([ovn-sbctl get chassis main _uuid])

check ovn-nbctl ls-add ls-bad -- \
    set Logical_Switch ls-bad other_config:requested-tnl-key=5000
check ovn-nbctl lsp-add ls-bad lsp-bad -- \
    set logical_switch_port lsp-bad options:requested-tnl-key=5000
check ovn-nbctl --wait=sb sync

check ovs-vsctl add-port br-int vif-bad -- \
    set Interface vif-bad external-ids:iface-id=lsp-bad
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp-bad` = xup])

# 5000 is higher than 1 << 12, so OVN should ignore the key requests
AT_CHECK([ovn-sbctl get Datapath_Binding ls-bad tunnel_key], [0], [dnl
1
])
AT_CHECK([ovn-sbctl get Port_Binding lsp-bad tunnel_key], [0], [dnl
1
])

check ovn-nbctl ls-add ls-good -- \
    set Logical_Switch ls-good other_config:requested-tnl-key=1000
check ovn-nbctl lsp-add ls-good lsp-good -- \
    set logical_switch_port lsp-good options:requested-tnl-key=1000
check ovn-nbctl --wait=sb sync

check ovs-vsctl add-port br-int vif-good -- \
    set Interface vif-good external-ids:iface-id=lsp-good
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp-good` = xup])

# 1000 is lower than 1 << 12, so OVN should honor the key requests
AT_CHECK([ovn-sbctl get Datapath_Binding ls-good tunnel_key], [0], [dnl
1000
])
AT_CHECK([ovn-sbctl get Port_Binding lsp-good tunnel_key], [0], [dnl
1000
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 1 LS, no switching between multiple localnet ports with different tags])
ovn_start

# In this test case we create a single switch connected to two physical
# networks via two localnet ports. Then we create two hypervisors, with 2
# ports on each. The test validates no interconnectivity between VIF ports
# located on chassis plugged to different physical networks.

# create the single switch with two locanet ports
ovn-nbctl ls-add ls1
for tag in 10 20; do
    ln_port_name=ln-$tag
    ovn-nbctl lsp-add ls1 $ln_port_name "" $tag
    ovn-nbctl lsp-set-addresses $ln_port_name unknown
    ovn-nbctl lsp-set-type $ln_port_name localnet
    ovn-nbctl lsp-set-options $ln_port_name network_name=phys-$tag
done

# create fabric networks
for tag in 10 20; do
    net_add n-$tag
done

# create four chassis, each connected to one network, each with a single VIF port
for tag in 10 20; do
    for i in 1 2; do
        sim_add hv-$tag-$i
        as hv-$tag-$i
        ovs-vsctl add-br br-phys
        ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-$tag:br-phys
        ovn_attach n-$tag br-phys 192.168.$i.$tag

        ovs-vsctl add-port br-int vif-$tag-$i -- \
            set Interface vif-$tag-$i external-ids:iface-id=lp-$tag-$i \
                                  options:tx_pcap=hv-$tag-$i/vif-$tag-$i-tx.pcap \
                                  options:rxq_pcap=hv-$tag-$i/vif-$tag-$i-rx.pcap \
                                  ofport-request=$tag$i

        lsp_name=lp-$tag-$i
        ovn-nbctl lsp-add ls1 $lsp_name
        ovn-nbctl lsp-set-addresses $lsp_name f0:00:00:00:0$i:$tag
        ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:0$i:$tag

        OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])
        OVN_WAIT_PATCH_PORT_FLOWS(["ln-$tag"], ["hv-$tag-$i"])
    done
done
wait_for_ports_up
ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows

for tag in 10 20; do
    for i in 1 2; do
        : > $tag-$i.expected
    done
done

vif_to_hv() {
    echo hv-$1
}

test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6

    # First try tracing the packet.
    uflow="inport==\"lp-$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    echo "output(\"$lout\");" > expout
    AT_CHECK([ovn_trace --minimal ls1 "$uflow"], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    hv=`vif_to_hv $inport`
    vif=vif-$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    if test $eth = 1002 -o $eth = 2002; then
        echo $packet >> ${eout#lp-}.expected
    fi
}

# different fabric networks -> should fail
test_packet 10-1 f0:00:00:00:01:20 f0:00:00:00:01:10 1001 lp-20-1 lp-20-1
test_packet 20-1 f0:00:00:00:01:10 f0:00:00:00:01:20 2001 lp-10-1 lp-10-1

# same fabric networks -> should pass
test_packet 10-1 f0:00:00:00:02:10 f0:00:00:00:01:10 1002 lp-10-2 lp-10-2
test_packet 20-1 f0:00:00:00:02:20 f0:00:00:00:01:20 2002 lp-20-2 lp-20-2
test_packet 10-2 f0:00:00:00:01:10 f0:00:00:00:02:10 1002 lp-10-1 lp-10-1
test_packet 20-2 f0:00:00:00:01:20 f0:00:00:00:02:20 2002 lp-20-1 lp-20-1

# Dump a bunch of info helpful for debugging if there's a failure.
echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

for tag in 10 20; do
    for i in 1 2; do
        hv=hv-$tag-$i
        echo "------ $hv dump ------"
        as $hv ovs-vsctl show
        as $hv ovs-ofctl -O OpenFlow13 dump-flows br-int
    done
done

# Now check the packets actually received against the ones expected.
for tag in 10 20; do
    for i in 1 2; do
        echo "hv = $tag-$i"
        OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv-$tag-$i/vif-$tag-$i-tx.pcap], [$tag-$i.expected])
    done
done

OVN_CLEANUP([hv-10-1],[hv-10-2],[hv-20-1],[hv-20-2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([vtep: 3 HVs, 1 VIFs/HV, 1 GW, 1 LS])
AT_KEYWORDS([vtep])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Configure the Northbound database
ovn-nbctl ls-add lsw0

ovn-nbctl lsp-add lsw0 lp1
ovn-nbctl lsp-set-addresses lp1 'f0:00:00:00:00:01 192.168.1.24'

ovn-nbctl lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp2 f0:00:00:00:00:02

ovn-nbctl lsp-add lsw0 lp-vtep
ovn-nbctl lsp-set-type lp-vtep vtep
ovn-nbctl lsp-set-options lp-vtep vtep-physical-switch=br-vtep vtep-logical-switch=lsw0
ovn-nbctl lsp-set-addresses lp-vtep unknown

# lpr, lr and lrp1 are used for the ARP request handling test only.
ovn-nbctl lsp-add lsw0 lpr
ovn-nbctl lr-add lr
ovn-nbctl lrp-add lr lrp1 f0:00:00:00:00:f1 192.168.1.1/24
ovn-nbctl set Logical_Switch_Port lpr \
    type=router \
    options:router-port=lrp1 \
    addresses=router
ovn-nbctl lrp-set-gateway-chassis lrp1 hv1

ovn-nbctl lsp-add lsw0 lpr2
ovn-nbctl lrp-add lr lrp2 f0:00:00:00:00:f2 192.168.1.254/24
ovn-nbctl set Logical_Switch_Port lpr2 \
    type=router \
    options:router-port=lrp2 \
    addresses=router
ovn-nbctl lrp-set-gateway-chassis lrp2 hv1

net_add n1               # Network to connect hv1, hv2, and vtep
net_add n2               # Network to connect vtep and hv3

# Create hypervisor hv1 connected to n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1 options:tx_pcap=hv1/vif1-tx.pcap options:rxq_pcap=hv1/vif1-rx.pcap ofport-request=1

# Create hypervisor hv2 connected to n1
sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl add-port br-int vif2 -- set Interface vif2 external-ids:iface-id=lp2 options:tx_pcap=hv2/vif2-tx.pcap options:rxq_pcap=hv2/vif2-rx.pcap ofport-request=1


# Start the vtep emulator with a leg in both networks
sim_add vtep
as vtep

ovsdb-tool create "$ovs_base"/vtep/vtep.db "$ovs_srcdir"/vtep/vtep.ovsschema
ovs-appctl -t ovsdb-server ovsdb-server/add-db "$ovs_base"/vtep/vtep.db

ovs-vsctl add-br br-phys
net_attach n1 br-phys

mac=`ovs-vsctl get Interface br-phys mac_in_use | sed s/\"//g`
arp_table="$arp_table $sandbox,br-phys,192.168.0.3,$mac"
ovs-appctl netdev-dummy/ip4addr br-phys 192.168.0.3/24 >/dev/null
ovs-appctl ovs/route/add 192.168.0.3/24 br-phys >/dev/null

ovs-vsctl add-br br-vtep
net_attach n2 br-vtep

vtep-ctl add-ps br-vtep
vtep-ctl set Physical_Switch br-vtep tunnel_ips=192.168.0.3
vtep-ctl add-ls lsw0

start_daemon ovs-vtep br-vtep
start_daemon ovn-controller-vtep --vtep-db=unix:"$ovs_base"/vtep/db.sock --ovnsb-db=unix:"$ovs_base"/ovn-sb/ovn-sb.sock
OVS_WAIT_UNTIL([vtep-ctl bind-ls br-vtep br-vtep_n2 0 lsw0])

OVS_WAIT_UNTIL([test -n "`as vtep vtep-ctl get-replication-mode lsw0 |
               grep -- source`"])

# Add hv3 on the other side of the vtep
sim_add hv3
as hv3
ovs-vsctl add-br br-phys
net_attach n2 br-phys
ovs-vsctl add-port br-phys vif3 -- set Interface vif3 options:tx_pcap=hv3/vif3-tx.pcap options:rxq_pcap=hv3/vif3-rx.pcap ofport-request=1

# vtep is quite slow setting up all flows
# We need to wait for flow flooding to br-vtep_n2, vx1 and vx2
OVS_WAIT_UNTIL([test `as vtep ovs-ofctl dump-flows br-vtep_vtep_ls1 | grep "priority=0" | grep -o "output" | wc -l` -eq 3])

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# test_packet INPORT DST SRC ETHTYPE OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 1 for vif1.
for i in 1 2 3; do
    : > $i.expected
done
test_packet() {
    local inport=$1 packet=$2$3$4; shift; shift; shift; shift
    #hv=hv`echo $inport | sed 's/^\(.\).*/\1/'`
    hv=hv$inport
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Send packets between all pairs of source and destination ports:
#
# 1. Unicast packets are delivered to exactly one logical switch port
#    (except that packets destined to their input ports are dropped).
#
# 2. Broadcast and multicast are delivered to all logical switch ports
#    except the input port.
#
# 3. The switch delivers packets with an unknown destination to logical
#    switch ports with "unknown" among their MAC addresses (and port
#    security disabled).
for s in 1 2 3; do
    bcast=
    unknown=
    for d in 1 2 3; do
        if test $d != $s; then unicast=$d; else unicast=; fi
        test_packet $s f0000000000$d f0000000000$s 00$s$d $unicast       #1

        # The vtep (vif3) is the only one configured for "unknown"
        if test $d != $s && test $d = 3; then
            unknown="$unknown $d"
        fi
        bcast="$bcast $unicast"
    done

    # Broadcast and multicast.
    test_packet $s ffffffffffff f0000000000$s 0${s}ff $bcast             #2
    test_packet $s 010000000000 f0000000000$s 0${s}ff $bcast             #2

    test_packet $s f0000000ffff f0000000000$s 0${s}66 $unknown           #3
done

# ARP request from VTEP to LRP should be responded by ARP responder.
sha=f0:00:00:00:00:03
spa=192.168.1.2
tpa=192.168.1.1
request=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                   ARP(hwsrc='${sha}', hwdst='ff:ff:ff:ff:ff:ff', psrc='${spa}', pdst='${tpa}')")
as hv3 ovs-appctl netdev-dummy/receive vif3 $request
echo $request >> 1.expected
echo $request >> 2.expected

lrpmac=f0:00:00:00:00:f1
response=$(fmt_pkt "Ether(dst='${sha}', src='${lrpmac}')/ \
                    ARP(op=2, hwsrc='${lrpmac}', hwdst='${sha}', psrc='${tpa}', pdst='${spa}')")
# since lrp1 has gateway chassis set on hv1, hv1 will suppress arp request and
# answer with arp reply by OVS directly to vtep lport. all other lports,
# except lport from which this request was initiated, will receive arp request.
# we expect arp reply packet on hv3
echo $response >> 3.expected

# Ensure there is no MAC_Binding, send GARP from vtep side,
# check that GARP was received by vif1, vif2 and MAC_Binding was created.
wait_row_count MAC_Binding 0 ip="192.168.1.200" mac='"f0:00:00:00:00:12"'

sha=02:00:00:00:00:ff
tha=ff:ff:ff:ff:ff:ff
spa=192.168.1.200
tpa=$spa
garp=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                ARP(op=2, hwsrc='${sha}', hwdst='${tha}', psrc='${spa}', pdst='${tpa}')")
as hv3 ovs-appctl netdev-dummy/receive vif3 $garp
echo $garp >> 1.expected
echo $garp >> 2.expected

wait_row_count MAC_Binding 2 ip="192.168.1.200" mac='"02:00:00:00:00:ff"'

# Send same GARP with changed SHA and ensure MAC_Binding was updated.
sha=02:00:00:00:00:ee
garp=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                ARP(op=2, hwsrc='${sha}', hwdst='${tha}', psrc='${spa}', pdst='${tpa}')")
as hv3 ovs-appctl netdev-dummy/receive vif3 $garp
echo $garp >> 1.expected
echo $garp >> 2.expected

wait_row_count MAC_Binding 2 ip="192.168.1.200" mac='"02:00:00:00:00:ee"'

# Remove local ports on hv1 and check that ARP logic is stil working. -->
check as hv1 ovs-vsctl remove interface vif1 external_ids iface-id
hv_uuid=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 0 chassis="$hv_uuid" type="''"

# Cleanup MAC_Bindings after previous checks.
check ovn-sbctl --all destroy MAC_Binding

# ARP request from VTEP to LRP should be responded by ARP responder.
sha=f0:00:00:00:00:03
spa=192.168.1.2
tpa=192.168.1.1
request=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                   ARP(hwsrc='${sha}', hwdst='ff:ff:ff:ff:ff:ff', psrc='${spa}', pdst='${tpa}')")
as hv3 ovs-appctl netdev-dummy/receive vif3 $request
echo $request >> 2.expected

lrpmac=f0:00:00:00:00:f1
response=$(fmt_pkt "Ether(dst='${sha}', src='${lrpmac}')/ \
                    ARP(op=2, hwsrc='${lrpmac}', hwdst='${sha}', psrc='${tpa}', pdst='${spa}')")
# since lrp1 has gateway chassis set on hv1, hv1 will suppress arp request and
# answer with arp reply by OVS directly to vtep lport. all other lports,
# except lport from which this request was initiated, will receive arp request.
# we expect arp reply packet on hv3
echo $response >> 3.expected

# Ensure there is no MAC_Binding, send GARP from vtep side,
# check that GARP was received by vif1, vif2 and MAC_Binding was created.
wait_row_count MAC_Binding 0 ip="192.168.1.200" mac='"f0:00:00:00:00:12"'

sha=02:00:00:00:00:ff
tha=ff:ff:ff:ff:ff:ff
spa=192.168.1.200
tpa=$spa
garp=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                ARP(op=2, hwsrc='${sha}', hwdst='${tha}', psrc='${spa}', pdst='${tpa}')")
as hv3 ovs-appctl netdev-dummy/receive vif3 $garp
echo $garp >> 2.expected

wait_row_count MAC_Binding 2 ip="192.168.1.200" mac='"02:00:00:00:00:ff"'

# Send same GARP with changed SHA and ensure MAC_Binding was updated.
sha=02:00:00:00:00:ee
garp=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                ARP(op=2, hwsrc='${sha}', hwdst='${tha}', psrc='${spa}', pdst='${tpa}')")
as hv3 ovs-appctl netdev-dummy/receive vif3 $garp
echo $garp >> 2.expected

wait_row_count MAC_Binding 2 ip="192.168.1.200" mac='"02:00:00:00:00:ee"'

# Restore.
check as hv1 ovs-vsctl set interface vif1 external_ids:iface-id=lp1
wait_row_count Port_Binding 1 chassis="$hv_uuid" type='""'
# Make sure flows added by port claim are installed
check ovn-nbctl --wait=hv sync
# <--

# Check ARP response to request for IP on VIF port sent from vtep.
# ARP request from VTEP to LSP's IP must be answered only by LSP vif1 (lp1).
sha=f0:00:00:00:00:03
spa=192.168.1.2
tpa=192.168.1.24
request=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                   ARP(hwsrc='${sha}', hwdst='ff:ff:ff:ff:ff:ff', psrc='${spa}', pdst='${tpa}')")
as hv3 ovs-appctl netdev-dummy/receive vif3 $request
echo $request >> 1.expected
echo $request >> 2.expected

# Simulate response from vif.
sha=f0:00:00:00:00:01
tha=f0:00:00:00:00:03
spa=192.168.1.200
tpa=192.168.1.2
response=$(fmt_pkt "Ether(dst='${tha}', src='${sha}')/ \
                    ARP(op=2, hwsrc='${sha}', hwdst='${tha}', psrc='${spa}', pdst='${tpa}')")
as hv1 ovs-appctl netdev-dummy/receive vif1 $response
echo $response >> 3.expected

# First ensure basic flow contents are as we expect.
AT_CHECK([ovn-sbctl lflow-list lsw0 | grep 'reg0[\[14\]]' | sort | sed 's/table=../table=??/g'], [0], [dnl
  table=??(ls_in_check_port_sec), priority=70   , match=(inport == "lp-vtep"), action=(reg0[[14]] = 1; next(pipeline=ingress, table=??);)
  table=??(ls_in_hairpin      ), priority=1000 , match=(reg0[[14]] == 1), action=(next(pipeline=ingress, table=??);)
  table=??(ls_in_hairpin      ), priority=2000 , match=(reg0[[14]] == 1 && is_chassis_resident("cr-lrp1")), action=(next;)
  table=??(ls_in_hairpin      ), priority=2000 , match=(reg0[[14]] == 1 && is_chassis_resident("cr-lrp2")), action=(next;)
  table=??(ls_in_arp_rsp      ), priority=65535, match=(reg0[[14]] == 1 && (arp || nd_ns)), action=(flags.loopback = 1; next;)
])

# dump information with counters
echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"
ovn-sbctl dump-flows

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-ofctl -O OpenFlow13 show br-int
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-ofctl -O OpenFlow13 show br-int
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv3 dump ------"
as hv3 ovs-vsctl show
# note: hv3 has no logical port bind, thus it should not have br-int
AT_CHECK([as hv3 ovs-ofctl -O OpenFlow13 show br-int], [1], [],
[ovs-ofctl: br-int is not a bridge or a socket
])

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    OVN_CHECK_PACKETS([hv$i/vif$i-tx.pcap], [$i.expected])
done

# Gracefully terminate daemons

OVN_CLEANUP_SBOX([hv1])
OVN_CLEANUP_SBOX([hv2])
OVS_WAIT_UNTIL([test `as vtep ovs-vsctl list-ports vtep_bfd | wc -l` -eq 0])
OVN_CLEANUP([vtep])

OVN_CLEANUP_VSWITCH([hv3])

AT_CLEANUP
])

# Similar test to "hardware GW"
OVN_FOR_EACH_NORTHD([
AT_SETUP([3 HVs, 1 VIFs/HV, 1 software GW, 1 LS])
ovn_start

# Configure the Northbound database
ovn-nbctl ls-add lsw0

ovn-nbctl lsp-add lsw0 lp1
ovn-nbctl lsp-set-addresses lp1 f0:00:00:00:00:01

ovn-nbctl lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp2 f0:00:00:00:00:02

ovn-nbctl lsp-add lsw0 lp-gw
ovn-nbctl lsp-set-type lp-gw l2gateway
ovn-nbctl lsp-set-options lp-gw network_name=physnet1 l2gateway-chassis=hv_gw
ovn-nbctl lsp-set-addresses lp-gw unknown

net_add n1               # Network to connect hv1, hv2, and gw
net_add n2               # Network to connect gw and hv3

# Create hypervisor hv1 connected to n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1 options:tx_pcap=hv1/vif1-tx.pcap options:rxq_pcap=hv1/vif1-rx.pcap ofport-request=1

# Create hypervisor hv2 connected to n1
sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl add-port br-int vif2 -- set Interface vif2 external-ids:iface-id=lp2 options:tx_pcap=hv2/vif2-tx.pcap options:rxq_pcap=hv2/vif2-rx.pcap ofport-request=1

# Create hypervisor hv_gw connected to n1 and n2
# connect br-phys bridge to n1; connect hv-gw bridge to n2
sim_add hv_gw
as hv_gw
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl add-br br-phys2
net_attach n2 br-phys2
ovs-vsctl set open . external_ids:ovn-bridge-mappings="physnet1:br-phys2"

# Add hv3 on the other side of the GW
sim_add hv3
as hv3
ovs-vsctl add-br br-phys
net_attach n2 br-phys
ovs-vsctl add-port br-phys vif3 -- set Interface vif3 options:tx_pcap=hv3/vif3-tx.pcap options:rxq_pcap=hv3/vif3-rx.pcap ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv1"],["hv2"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv2"],["hv1"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv1"],["hv_gw"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv_gw"],["hv1"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv2"],["hv_gw"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv_gw"],["hv2"])

# test_packet INPORT DST SRC ETHTYPE OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as lport numbers, e.g. 1 for vif1.
for i in 1 2 3; do
    : > $i.expected
done
test_packet() {
    local inport=$1 packet=$2$3$4; shift; shift; shift; shift
    #hv=hv`echo $inport | sed 's/^\(.\).*/\1/'`
    hv=hv$inport
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Send packets between all pairs of source and destination ports:
#
# 1. Unicast packets are delivered to exactly one lport (except that packets
#    destined to their input ports are dropped).
#
# 2. Broadcast and multicast are delivered to all lports except the input port.
#
# 3. The lswitch delivers packets with an unknown destination to lports with
#    "unknown" among their MAC addresses (and port security disabled).
for s in 1 2 3 ; do
    bcast=
    unknown=
    for d in 1 2 3 ; do
        if test $d != $s; then unicast=$d; else unicast=; fi
        test_packet $s f0000000000$d f0000000000$s 00$s$d $unicast       #1

        # The vtep (vif3) is the only one configured for "unknown"
        if test $d != $s && test $d = 3; then
            unknown="$unknown $d"
        fi
        bcast="$bcast $unicast"
    done

    test_packet $s ffffffffffff f0000000000$s 0${s}ff $bcast             #2
    test_packet $s 010000000000 f0000000000$s 0${s}ff $bcast             #3
    test_packet $s f0000000ffff f0000000000$s 0${s}66 $unknown           #4
done

echo "------ ovn-nbctl show ------"
ovn-nbctl show
echo "------ ovn-sbctl show ------"
ovn-sbctl show

echo "------ hv1 ------"
as hv1 ovs-vsctl show
echo "------ hv1 br-int ------"
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int
echo "------ hv1 br-phys ------"
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-phys

echo "------ hv2 ------"
as hv2 ovs-vsctl show
echo "------ hv2 br-int ------"
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int
echo "------ hv2 br-phys ------"
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-phys

echo "------ hv_gw ------"
as hv_gw ovs-vsctl show
echo "------ hv_gw br-phys ------"
as hv_gw ovs-ofctl -O OpenFlow13 dump-flows br-phys
echo "------ hv_gw br-phys2 ------"
as hv_gw ovs-ofctl -O OpenFlow13 dump-flows br-phys2

echo "------ hv3 ------"
as hv3 ovs-vsctl show
echo "------ hv3 br-phys ------"
as hv3 ovs-ofctl -O OpenFlow13 dump-flows br-phys

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    OVN_CHECK_PACKETS([hv$i/vif$i-tx.pcap], [$i.expected])
done
AT_CLEANUP
])

# 3 hypervisors, 3 logical switches with 3 logical ports each, 1 logical router
OVN_FOR_EACH_NORTHD([
AT_SETUP([3 HVs, 3 LS, 3 lports/LS, 1 LR])
AT_KEYWORDS([slowtest])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Logical network:
#
# Three logical switches ls1, ls2, ls3.
# One logical router lr0 connected to ls[123],
# with nine subnets, three per logical switch:
#
#    lrp11 on ls1 for subnet 192.168.11.0/24
#    lrp12 on ls1 for subnet 192.168.12.0/24
#    lrp13 on ls1 for subnet 192.168.13.0/24
#    ...
#    lrp33 on ls3 for subnet 192.168.33.0/24
#
# 27 VIFs, 9 per LS, 3 per subnet: lp[123][123][123], where the first two
# digits are the subnet and the last digit distinguishes the VIF.
for i in 1 2 3; do
    ovn-nbctl ls-add ls$i
    for j in 1 2 3; do
        for k in 1 2 3; do
            # Add "unknown" to MAC addresses for lp?11, so packets for
            # MAC-IP bindings discovered via ARP later have somewhere to go.
            if test $j$k = 11; then unknown=unknown; else unknown=; fi

            ovn-nbctl \
                -- lsp-add ls$i lp$i$j$k \
                -- lsp-set-addresses lp$i$j$k \
                   "f0:00:00:00:0$i:$j$k 192.168.$i$j.$k" $unknown
        done
    done
done

ovn-nbctl lr-add lr0
for i in 1 2 3; do
    for j in 1 2 3; do
        ovn-nbctl lrp-add lr0 lrp$i$j 00:00:00:00:ff:$i$j 192.168.$i$j.254/24
        ovn-nbctl \
            -- lsp-add ls$i lrp$i$j-attachment \
            -- set Logical_Switch_Port lrp$i$j-attachment type=router \
                             options:router-port=lrp$i$j \
                             addresses='"00:00:00:00:ff:'$i$j'"'
    done
done

ovn-nbctl set Logical_Switch_Port lrp33-attachment \
    addresses='"00:00:00:00:ff:33 192.168.33.254"'

# Physical network:
#
# Three hypervisors hv[123].
# lp?1[123] spread across hv[123]: lp?11 on hv1, lp?12 on hv2, lp?13 on hv3.
# lp?2[123] spread across hv[23]: lp?21 and lp?22 on hv2, lp?23 on hv3.
# lp?3[123] all on hv3.


# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    case $1 in dnl (
        ?11) echo 1 ;; dnl (
        ?12 | ?21 | ?22) echo 2 ;; dnl (
        ?13 | ?23 | ?3?) echo 3 ;;
    esac
}

# Given the name of a logical port, prints the name of its logical router
# port, e.g. "vif_to_lrp 123" yields 12.
vif_to_lrp() {
    echo ${1%?}
}

# Given the name of a logical port, prints the name of its logical
# switch, e.g. "vif_to_ls 123" yields 1.
vif_to_ls() {
    echo ${1%??}
}

net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            hv=`vif_to_hv $i$j$k`
                as hv$hv ovs-vsctl \
                -- add-port br-int vif$i$j$k \
                -- set Interface vif$i$j$k \
                    external-ids:iface-id=lp$i$j$k \
                    options:tx_pcap=hv$hv/vif$i$j$k-tx.pcap \
                    options:rxq_pcap=hv$hv/vif$i$j$k-rx.pcap \
                    ofport-request=$i$j$k
        done
    done
done

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv1"],["hv2"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv2"],["hv1"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv2"],["hv3"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv3"],["hv2"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv1"],["hv3"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv3"],["hv1"])

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 123 for vif123.
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            : > $i$j$k.expected
        done
    done
done
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                            IP(src='${src_ip}', dst='${dst_ip}', ttl=0x40)/ \
                            UDP(sport=53, dport=4369)")
    shift; shift; shift; shift; shift
    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    in_ls=`vif_to_ls $inport`
    in_lrp=`vif_to_lrp $inport`
    for outport; do
        out_ls=`vif_to_ls $outport`
        if test $in_ls = $out_ls; then
            # Ports on the same logical switch receive exactly the same packet.
            echo $packet
        else
            # Routing decrements TTL and updates source and dest MAC
            # (and checksum).
            out_lrp=`vif_to_lrp $outport`
            echo $(fmt_pkt "Ether(dst='f0:00:00:00:0$out_ls:${outport#?}', src='00:00:00:00:ff:${out_lrp}')/ \
                            IP(src='${src_ip}', dst='${dst_ip}', ttl=0x3f)/ \
                            UDP(sport=53, dport=4369)")
        fi >> $outport.expected
    done
}

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    echo "$@"
    local inport=$1 sha=$2 spa=$3 tpa=$4 reply_ha=$5
    local request=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                             ARP(hwsrc='${sha}', hwdst='ff:ff:ff:ff:ff:ff', psrc='${spa}', pdst='${tpa}')")
    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $request

    # Expect to receive the broadcast ARP on the other logical switch ports if
    # IP address is not configured to the switch patch port.
    local i=`vif_to_ls $inport`
    local j k
    for j in 1 2 3; do
        for k in 1 2 3; do
            # 192.168.33.254 is configured to the switch patch port for lrp33,
            # so no ARP flooding expected for it.
            if test $i$j$k != $inport && test $tpa != 192.168.33.254; then
                echo $request >> $i$j$k.expected
            fi
        done
    done

    # Expect to receive the reply, if any.
    if test X$reply_ha != X; then
        lrp=`vif_to_lrp $inport`
        local reply=$(fmt_pkt "Ether(dst='${sha}', src='00:00:00:00:ff:${lrp}')/ \
                               ARP(op=2, hwsrc='${reply_ha}', hwdst='${sha}', psrc='${tpa}', pdst='${spa}')")
        echo $reply >> $inport.expected
    fi
}

as hv1 ovs-vsctl --columns=name,ofport list interface > interfaces
(as hv1 ovn-sbctl list port_binding
 as hv1 ovn-sbctl list datapath_binding) > bindings
as hv1 ovn-sbctl dump-flows > sbflows
as hv1 ovs-ofctl dump-flows br-int > offlows
AT_CAPTURE_FILE([interfaces])
AT_CAPTURE_FILE([bindings])
AT_CAPTURE_FILE([sbflows])
AT_CAPTURE_FILE([offlows])

# Send IP packets between all pairs of source and destination ports:
#
# 1. Unicast IP packets are delivered to exactly one logical switch port
#    (except that packets destined to their input ports are dropped).
#
# 2. Broadcast IP packets are delivered to all logical switch ports
#    except the input port.
for is in 1 2 3; do
  for js in 1 2 3; do
    for ks in 1 2 3; do
      bcast=
      s=$is$js$ks
      smac=f0:00:00:00:0$is:$js$ks
      sip=192.168.$is$js.$ks
      for id in 1 2 3; do
          for jd in 1 2 3; do
              for kd in 1 2 3; do
                d=$id$jd$kd
                dip=192.168.$id$jd.$kd
                if test $is = $id; then dmac=f0:00:00:00:0$id:$jd$kd; else dmac=00:00:00:00:ff:$is$js; fi
                if test $d != $s; then unicast=$d; else unicast=; fi

                test_ip $s $smac $dmac $sip $dip $unicast #1

                if test $id = $is && test $d != $s; then bcast="$bcast $d"; fi
              done
          done
        done
      test_ip $s $smac ff:ff:ff:ff:ff:ff $sip 255.255.255.255 $bcast #2
      done
  done
  wait
done

: > mac_bindings.expected

# 3. Send an IP packet from every logical port to every other subnet,
#    to an IP address that does not have a static IP-MAC binding.
#    This should generate a broadcast ARP request for the destination
#    IP address in the destination subnet.
#    Moreover generate an ARP reply for each of the IP addresses ARPed
for is in 1 2 3; do
  for js in 1 2 3; do
    for ks in 1 2 3; do
      s=$is$js$ks
      smac=f0:00:00:00:0$is:$js$ks
      sip=192.168.$is$js.$ks
      for id in 1 2 3; do
        for jd in 1 2 3; do
          if test $is$js = $id$jd; then
            continue
          fi

          # Send the packet.
          dmac=00:00:00:00:ff:$is$js
          # Calculate a 4th octet for the destination that is
          # unique per $s, avoids the .1 .2 .3 and .254 IP addresses
          # that have static MAC bindings, and fits in the range
          # 0-255.
          o4=`expr $is '*' 9 + $js '*' 3 + $ks + 10`
          dip=192.168.$id$jd.$o4
          test_ip $s $smac $dmac $sip $dip

          # Every LP on the destination subnet's lswitch should
          # receive the ARP request.
          lrmac=00:00:00:00:ff:$id$jd
          lrip=192.168.$id$jd.254
          arp=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${lrmac}')/ \
                         ARP(hwsrc='${lrmac}', hwdst='00:00:00:00:00:00', psrc='${lrip}', pdst='${dip}')")
          for jd2 in 1 2 3; do
            for kd in 1 2 3; do
              echo $arp >> $id$jd2$kd.expected
            done
          done

          hmac=80:00:00:00:00:$o4
          rmac=00:00:00:00:ff:$id$jd
          echo $(fmt_pkt "Ether(dst='${hmac}', src='${rmac}')/ \
                          IP(src='${sip}', dst='${dip}', ttl=0x3f)/ \
                          UDP(sport=53, dport=4369)") >> ${id}11.expected

          host_mac=80:00:00:00:00:$o4
          lrmac=00:00:00:00:ff:$id$jd

          arp_reply=$(fmt_pkt "Ether(dst='${lrmac}', src='${host_mac}')/ \
                               ARP(op=2, hwsrc='${host_mac}', hwdst='${lrmac}', psrc='${dip}', pdst='${lrip}')")

          hv=hv`vif_to_hv ${id}${jd}1`
          as $hv ovs-appctl netdev-dummy/receive vif${id}${jd}1 $arp_reply

          echo lrp$id$jd,$dip,$hmac >> mac_bindings.expected
        done
      done
    done
  done
done

# Test router replies to ARP requests from all source ports:
#
# 4. Router replies to query for its MAC address from port's own IP address.
#
# 5. Router replies to query for its MAC address from any random IP address
#    in its subnet.
#
# 6. No reply to query for IP address other than router IP.
#
# 7. No reply to query from another subnet.
for i in 1 2 3; do
  for j in 1 2 3; do
    for k in 1 2 3; do
      smac=f0:00:00:00:0$i:$j$k               # Source MAC
      sip=192.168.$i$j.$k    # Source IP
      rip=192.168.$i$j.254   # Router IP
      rmac=00:00:00:00:ff:$i$j                # Router MAC
      otherip=192.168.$i$j.55 # Some other IP in subnet
      externalip=1.2.3.4      # Some other IP not in subnet

      test_arp $i$j$k $smac $sip        $rip        $rmac      #4
      test_arp $i$j$k $smac $otherip    $rip        $rmac      #5
      test_arp $i$j$k $smac $sip        $otherip               #6

      # When rip is 192.168.33.254, ARP request from externalip won't be
      # filtered, because 192.168.33.254 is configured to switch peer port
      # for lrp33.
      lrp33_rsp=
      if test $i = 3 && test $j = 3; then
        lrp33_rsp=$rmac
      fi
      test_arp $i$j$k $smac $externalip $rip        $lrp33_rsp #7

      # MAC binding should be learned from ARP request.
      echo lrp$i$j,$sip,$smac >> mac_bindings.expected

      # mac_binding is learned and overwritten so only the last one remains.
      if test $k = 3; then
          # lrp33 will not learn from ARP request, because 192.168.33.254 is
          # configured to switch peer port for lrp33.
          if test $i != 3 || test $j != 3; then
              echo lrp$i$j,$otherip,$smac >> mac_bindings.expected
          fi
      fi

    done
  done
done


# Allow some time for packet forwarding.
# XXX This can be improved.
sleep 1

# 8. Send an IP packet from every logical port to every other subnet.  These
#    are the same packets already sent as #3, but now the destinations' IP-MAC
#    bindings have been discovered via ARP, so instead of provoking an ARP
#    request, these packets now get routed to their destinations (which don't
#    have static MAC bindings, so they go to the port we've designated as
#    accepting "unknown" MACs.)
for is in 1 2 3; do
  for js in 1 2 3; do
    for ks in 1 2 3; do
      s=$is$js$ks
      smac=f0:00:00:00:0$is:$js$ks
      sip=192.168.$is$js.$ks
      for id in 1 2 3; do
        for jd in 1 2 3; do
          if test $is$js = $id$jd; then
            continue
          fi

          # Send the packet.
          dmac=00:00:00:00:ff:$is$js
          # Calculate a 4th octet for the destination that is
          # unique per $s, avoids the .1 .2 .3 and .254 IP addresses
          # that have static MAC bindings, and fits in the range
          # 0-255.
          o4=`expr $is '*' 9 + $js '*' 3 + $ks + 10`
          dip=192.168.$id$jd.$o4
          test_ip $s $smac $dmac $sip $dip

          # Expect the packet egress.
          host_mac=80:00:00:00:00:$o4
          outport=${id}11
          out_lrp=$id$jd
          echo $(fmt_pkt "Ether(dst='${host_mac}', src='00:00:00:00:ff:$id$jd')/ \
                          IP(src='${sip}', dst='${dip}', ttl=0x3f)/ \
                          UDP(sport=53, dport=4369)") >> $outport.expected
        done
      done
    done
  done
done

ovn-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
check_packets() {
    > expected
    > received
    for i in 1 2 3; do
        for j in 1 2 3; do
            for k in 1 2 3; do
                pcap=hv`vif_to_hv $i$j$k`/vif$i$j$k-tx.pcap
                echo "--- $pcap" | tee -a expected >> received
                sort $i$j$k.expected >> expected
                $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | sort >> received
                echo | tee -a expected >> received
            done
        done
    done

    echo '--- MAC bindings' | tee -a expected >> received
    ovn-sbctl -f csv -d bare --no-heading \
        -- --columns=logical_port,ip,mac list mac_binding | sort >> received
    sort < mac_bindings.expected >> expected

    $at_diff expected received >/dev/null
}
OVS_WAIT_UNTIL([check_packets], [$at_diff -F'^---' expected received])

# Gracefully terminate daemons
OVN_CLEANUP([hv1], [hv2], [hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IP relocation using GARP request])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Logical network:
#
# Two logical switches ls1, ls2.
# One logical router lr0 connected to ls[12],
# with 2 subnets, 1 per logical switch:
#
#    lrp1 on ls1 for subnet 192.168.1.1/24
#    lrp2 on ls2 for subnet 192.168.2.1/24
#
# 4 VIFs, 2 per LS lp[12][12], first digit being LS.
# VIFs' fixed IP addresses are 192.168.[12].1[12].
#
# There is a secondary IP 192.168.1.100 that is unknown in NB and learned
# through ARP only, and it can move between lp11 and lp12.
#
ovn-nbctl lr-add lr0
for i in 1 2 ; do
    ovn-nbctl ls-add ls$i
    ovn-nbctl lrp-add lr0 lrp$i 00:00:00:00:ff:0$i 192.168.$i.1/24
    ovn-nbctl \
        -- lsp-add ls$i lrp$i-attachment \
        -- set Logical_Switch_Port lrp$i-attachment type=router \
                         options:router-port=lrp$i \
                         addresses=router
    for j in 1 2; do
        ovn-nbctl \
            -- lsp-add ls$i lp$i$j \
            -- lsp-set-addresses lp$i$j \
               "f0:00:00:00:00:$i$j 192.168.$i.1$j"
    done
done

# Physical network:
# 2 hypervisors hv[12], lp?1 on hv1, lp?2 on hv2.

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located, e.g. "vif_to_hv 12" yields 2.
vif_to_hv() {
    echo ${1#?}
}

# Given the name of a logical port, prints the name of its logical router
# port, e.g. "vif_to_lrp 12" yields 1.
vif_to_lrp() {
    echo ${1%?}
}

# Given the name of a logical port, prints the name of its logical
# switch, e.g. "vif_to_ls 12" yields 1.
vif_to_ls() {
    echo ${1%?}
}

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done
for i in 1 2; do
    for j in 1 2; do
        hv=`vif_to_hv $i$j`
            as hv$hv ovs-vsctl \
                -- add-port br-int vif$i$j \
                -- set Interface vif$i$j \
                    external-ids:iface-id=lp$i$j \
                    options:tx_pcap=hv$hv/vif$i$j-tx.pcap \
                    options:rxq_pcap=hv$hv/vif$i$j-rx.pcap \
                    ofport-request=$i$j
    done
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 12 for vif12.
for i in 1 2; do
    for j in 1 2; do
        : > $i$j.expected
    done
done
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                            IP(dst='${dst_ip}', src='${src_ip}')/ \
                            UDP(sport=53, dport=4369)")
    shift; shift; shift; shift; shift
    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    in_ls=`vif_to_ls $inport`
    in_lrp=`vif_to_lrp $inport`
    for outport; do
        out_ls=`vif_to_ls $outport`
        if test $in_ls = $out_ls; then
            # Ports on the same logical switch receive exactly the same packet.
            echo $packet
        else
            # Routing decrements TTL and updates source and dest MAC
            # (and checksum).
            out_lrp=`vif_to_lrp $outport`
            echo $(fmt_pkt "Ether(dst='f0:00:00:00:00:${outport}', src='00:00:00:00:ff:${out_lrp}')/ \
                            IP(src='${src_ip}', dst='${dst_ip}', ttl=63)/ \
                            UDP(sport=53, dport=4369)")
        fi >> $outport.expected
    done
}

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local inport=$1 sha=$2 spa=$3 tpa=$3
    local request=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                             ARP(hwsrc='${sha}', hwdst='ff:ff:ff:ff:ff:ff', psrc='${spa}', pdst='${tpa}')")

    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $request

    # Expect to receive the broadcast ARP on the other logical switch ports if
    # IP address is not configured to the switch patch port.
    local i=`vif_to_ls $inport`
    local j
    for j in 1 2; do
        if test $i$j != $inport; then
            echo $request >> $i$j$k.expected
        fi
    done
}

test_na() {
    local inport=$1 sha=$2 spa=$3
    local request=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${sha}')/ \
                             IPv6(dst='ff01::1', src='${spa}')/ \
                             ICMPv6ND_NA(tgt='${spa}')")

    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $request

    # Expect to receive the broadcast ARP on the other logical switch ports if
    # IP address is not configured to the switch patch port.
    local i=`vif_to_ls $inport`
    local j
    for j in 1 2; do
        if test $i$j != $inport; then
            echo $request >> $i$j$k.expected
        fi
    done
}

# lp11 send GARP request to announce ownership of 192.168.1.100 and fe80::abcd:1.

sha="f0:00:00:00:00:11"
spa="192.168.1.100"
spa6="fe80::abcd:1"

# When always_learn_from_arp_request=false, the new mac-binding will not be learned
# through GARP request.
ovn-nbctl --wait=hv set logical_router lr0 options:always_learn_from_arp_request=false

test_arp 11 $sha $spa
test_na 11 $sha $spa6
sleep 1
check_row_count MAC_Binding 0 ip="$spa"
check_row_count MAC_Binding 0 ip=\"$spa6\"

# When always_learn_from_arp_request=true, the new mac-binding will be learned.
ovn-nbctl --wait=hv set logical_router lr0 options:always_learn_from_arp_request=true

test_arp 11 $sha $spa
test_na 11 $sha $spa6
wait_row_count MAC_Binding 1 ip="$spa" mac=\"$sha\"
wait_row_count MAC_Binding 1 ip=\"$spa6\" mac=\"$sha\"
ovn-nbctl --wait=hv sync

# Send an IP packet from lp21 to 192.168.1.100, which should go to lp11.

smac="f0:00:00:00:00:21"
dmac="00:00:00:00:ff:02"
sip="192.168.2.11"
dip="192.168.1.100"
test_ip 21 $smac $dmac $sip $dip 11

# lp12 send GARP request to announce ownership of 192.168.1.100 and fe80::abcd:1.

# Even when always_learn_from_arp_request=false, the existing mac-binding should be
# updated through GARP request.
ovn-nbctl --wait=hv set logical_router lr0 options:always_learn_from_arp_request=false

sha="f0:00:00:00:00:12"
test_arp 12 $sha $spa
test_na 11 $sha $spa6
wait_row_count MAC_Binding 1 ip="$spa" mac=\"$sha\"
wait_row_count MAC_Binding 1 ip=\"$spa6\" mac=\"$sha\"
ovn-nbctl --wait=hv sync
# give to the hv the time to send queued ip packets
sleep 1

# Send an IP packet from lp21 to 192.168.1.100, which should go to lp12.

test_ip 21 $smac $dmac $sip $dip 12

# Now check the packets actually received against the ones expected.
for i in 1 2; do
    for j in 1 2; do
        OVN_CHECK_PACKETS([hv`vif_to_hv $i$j`/vif$i$j-tx.pcap],
                          [$i$j.expected])
    done
done

# Gracefully terminate daemons
OVN_CLEANUP([hv1], [hv2])

AT_CLEANUP
])

# 3 hypervisors, one logical switch, 3 logical ports per hypervisor
OVN_FOR_EACH_NORTHD([
AT_SETUP([portsecurity : 3 HVs, 1 LS, 3 lports/HV])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Create hypervisors hv[123].
# Add vif1[123] to hv1, vif2[123] to hv2, vif3[123] to hv3.
# Add all of the vifs to a single logical switch lsw0.
# Turn off port security on vifs vif[123]1
# Turn on l2 port security on vifs vif[123]2
# Turn of l2 and l3 port security on vifs vif[123]3
# Make vif13, vif2[23], vif3[123] destinations for unknown MACs.
ovn-nbctl ls-add lsw0
net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    for j in 1 2 3; do
        ovs-vsctl add-port br-int vif$i$j -- set Interface vif$i$j external-ids:iface-id=lp$i$j options:tx_pcap=hv$i/vif$i$j-tx.pcap options:rxq_pcap=hv$i/vif$i$j-rx.pcap ofport-request=$i$j
        ovn-nbctl lsp-add lsw0 lp$i$j
        if test $j = 1; then
            ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j 192.168.0.$i$j" unknown
        elif test $j = 2; then
            ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j 192.168.0.$i$j 4343::00$i$j"
            ovn-nbctl lsp-set-port-security lp$i$j f0:00:00:00:00:$i$j
        else
            extra_addr="f0:00:00:00:0$i:$i$j fe80::ea2a:eaff:fe28:$i$j 4242::00$i$j"
            ovn-nbctl lsp-set-addresses lp$i$j "f0:00:00:00:00:$i$j 192.168.0.$i$j" "$extra_addr"
            ovn-nbctl lsp-set-port-security lp$i$j "f0:00:00:00:00:$i$j 192.168.0.$i$j" "$extra_addr"
        fi
        OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp$i$j` = xup])
    done
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}

for i in 1 2 3; do
    for j in 1 2 3; do
        : > $i$j.expected
    done
done

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes an ip packet to be received on INPORT.
# The packet's content has Ethernet destination DST and source SRC
# (each exactly 12 hex digits) and Ethernet type ETHTYPE (4 hex digits).
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 11 for vif11.
test_ip() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                            IP(src='${src_ip}', dst='${dst_ip}')/ \
                            UDP(sport=53, dport=4369)")
    shift; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# test_arp INPORT SHA SPA TPA DROP [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local inport=$1 smac=$2 sha=$3 spa=$4 tpa=$5 drop=$6 reply_ha=$7
    local request=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${smac}')/ \
                             ARP(hwsrc='${sha}', hwdst='ff:ff:ff:ff:ff:ff', psrc='${spa}', pdst='${tpa}')")
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $request
    if test $drop != 1; then
        if test X$reply_ha = X; then
            # Expect to receive the broadcast ARP on the other logical switch ports
            # if no reply is expected.
            local i j
            for i in 1 2 3; do
                for j in 1 2 3; do
                    if test $i$j != $inport; then
                        echo $request >> $i$j.expected
                    fi
                done
            done
        else
            # Expect to receive the reply, if any.
            local reply=$(fmt_pkt "Ether(dst='${smac}', src='${reply_ha}')/ \
                                   ARP(op=2, hwsrc='${reply_ha}', hwdst='${sha}', psrc='${tpa}', pdst='${spa}')")
            echo $reply >> $inport.expected
        fi
    fi
}

# test_ipv6 INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
# This function is similar to test_ip() except that it sends
# ipv6 packet
test_ipv6() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                            IPv6(src='${src_ip}', dst='${dst_ip}')")
    shift; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# test_icmpv6 INPORT  SRC_MAC DST_MAC SRC_IP DST_IP ICMPV6 OUTPORT...
# This function is similar to test_ipv6() except it specifies the ICMPv6 sub-packet
# of the test packet
test_icmpv6() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 icmpv6=$6
    local packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                            IPv6(src='${src_ip}', dst='${dst_ip}')/ \
                            ${icmpv6}")
    shift; shift; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# no port security
sip=192.168.0.12
tip=192.168.0.13
# the arp packet should be allowed even if lp[123]1 is
# not configured with mac f0:00:00:00:00:23 and ip 192.168.0.12
for i in 1 2 3; do
    test_arp ${i}1 f0:00:00:00:00:23 f0:00:00:00:00:23 $sip $tip 0 f0:00:00:00:00:13
    for j in 1 2 3; do
        if test $i != $j; then
            test_ip ${i}1 f0:00:00:00:00:${i}1 f0:00:00:00:00:${j}1 $sip $tip ${j}1
        fi
    done
done

# l2 port security
sip=192.168.0.12
tip=192.168.0.13

# arp packet should be allowed since lp22 is configured with
# mac f0:00:00:00:00:22
test_arp 22 f0:00:00:00:00:22 f0:00:00:00:00:22 $sip $tip 0 f0:00:00:00:00:13

# arp packet should not be allowed since lp32 is not configured with
# mac f0:00:00:00:00:21
test_arp 32 f0:00:00:00:00:21 f0:00:00:00:00:21 $sip $tip 1

# arp packet with sha set to f0:00:00:00:00:21 should not be allowed
# for lp12
test_arp 12 f0:00:00:00:00:12 f0:00:00:00:00:21 $sip $tip 1

# ip packets should be allowed and received since lp[123]2 do not
# have l3 port security
sip=192.168.0.55
tip=192.168.0.66
for i in 1 2 3; do
    for j in 1 2 3; do
        if test $i != $j; then
            test_ip ${i}2 f0:00:00:00:00:${i}2 f0:00:00:00:00:${j}2 $sip $tip ${j}2
        fi
    done
done

# ipv6 packets should be received by lp[123]2
# lp[123]1 can send ipv6 traffic as there is no port security
sip=fe80::
tip=ff02::

for i in 1 2 3; do
    test_ipv6 ${i}1 f0:00:00:00:00:${i}1 f0:00:00:00:00:${i}2 $sip $tip ${i}2
done


# l2 and l3 port security
sip=192.168.0.13
tip=192.168.0.22
# arp packet should be allowed since lp13 is configured with
# f0:00:00:00:00:13 and 192.168.0.13
test_arp 13 f0:00:00:00:00:13 f0:00:00:00:00:13 $sip $tip 0 f0:00:00:00:00:22

# the arp packet should be dropped because lp23 is not configured
# with mac f0:00:00:00:00:22
sip=192.168.0.13
tip=192.168.0.22
test_arp 23 f0:00:00:00:00:22 f0:00:00:00:00:22 $sip $tip 1

# the arp packet should be dropped because lp33 is not configured
# with ip 192.168.0.55
spa=192.168.0.55
tpa=192.168.0.22
test_arp 33 f0:00:00:00:00:31 f0:00:00:00:00:31 $spa $tpa 1

# ip packets should not be received by lp[123]3 since
# l3 port security is enabled
sip=192.168.0.55
tip=192.168.0.66
for i in 1 2 3; do
    for j in 1 2 3; do
        test_ip ${i}2 f0:00:00:00:00:${i}2 f0:00:00:00:00:${j}3 $sip $tip
    done
done

# ipv6 packets should be dropped for lp[123]3 since
# it is configured with only ipv4 address
sip=fe80::
tip=ff02::

for i in 1 2 3; do
    test_ipv6 ${i}3 f0:00:00:00:00:${i}3 f0:00:00:00:00:22 $sip $tip
done

# ipv6 packets should not be received by lp[123]3 with mac f0:00:00:00:00:$[123]3
# lp[123]1 can send ipv6 traffic as there is no port security
for i in 1 2 3; do
    test_ipv6 ${i}1 f0:00:00:00:00:${i}1 f0:00:00:00:00:${i}3 $sip $tip
done

# lp13 has extra port security with mac f0000000113 and ipv6 addr
# fe80::ea2a:eaff:fe28:0012 and 4242::0013

# ipv4 packet should be dropped for lp13 with mac f0000000113
sip=192.168.0.13
tip=192.168.0.23
test_ip 13 f0:00:00:00:01:13 f0:00:00:00:00:23 $sip $tip

# ipv6 packet should be received by lp[123]3 with mac f0:00:00:00:0${i}:${i}3
# and ip6.dst as fe80::ea2a:eaff:fe28:0${i}${i}3.
# lp11 can send ipv6 traffic as there is no port security
sip=ee80::
for i in 1 2 3; do
    tip=fe80::ea2a:eaff:fe28:00${i}3
    test_ipv6 11 f0:00:00:00:00:11 f0:00:00:00:0${i}:${i}3 $sip $tip ${i}3
    tip=4242::${i}3
    test_ipv6 11 f0:00:00:00:00:11 f0:00:00:00:0${i}:${i}3 $sip $tip ${i}3
done


# ipv6 packet should not be received by lp33 with mac f0:00:00:00:03:33
# and ip6.dst as fe80::ea2a:eaff:fe28:0023 or 4242::0023 as it is
# configured with fe80::ea2a:eaff:fe28:0033 and 4242::0033
# lp11 can send ipv6 traffic as there is no port security

sip=ee80::
tip=fe80::ea2a:eaff:fe28:0023
test_ipv6 11 f0:00:00:00:00:11 f0:00:00:00:03:33 $sip $tip
tip=4242::23
test_ipv6 11 f0:00:00:00:00:11 f0:00:00:00:03:33 $sip $tip

# ipv6 packet should be allowed for lp[123]3 with mac f0:00:00:00:0${i}:${i}3
# and ip6.src fe80::ea2a:eaff:fe28:0${i}${i}3, 4242::00${i}3 and ip6.src ::.
# and should be dropped for any other ip6.src
# lp21 can receive ipv6 traffic as there is no port security

tip=ee80::
for i in 1 2 3; do
    sip=fe80::ea2a:eaff:fe28:00${i}3
    test_ipv6 ${i}3 f0:00:00:00:0${i}:${i}3 f0:00:00:00:00:21 $sip $tip 21
    sip=4242::${i}3
    test_ipv6 ${i}3 f0:00:00:00:0${i}:${i}3 f0:00:00:00:00:21 $sip $tip 21

    # Test ICMPv6 MLD reports (v1 and v2) and NS for DAD
    sip=::
    test_icmpv6 ${i}3 f0:00:00:00:0${i}:${i}3 f0:00:00:00:00:21 $sip ff02::16:0 "ICMPv6MLReport()" 21
    test_icmpv6 ${i}3 f0:00:00:00:0${i}:${i}3 f0:00:00:00:00:21 $sip ff02::16:0 "ICMPv6MLReport2()" 21
    test_icmpv6 ${i}3 f0:00:00:00:0${i}:${i}3 f0:00:00:00:00:21 $sip ff02::ea:2aea:fffe:2800 "ICMPv6ND_NS()" 21
    # Traffic to non-multicast traffic should be dropped
    test_icmpv6 ${i}3 f0:00:00:00:0${i}:${i}3 f0:00:00:00:00:21 $sip $tip "ICMPv6MLReport()"
    # Traffic of other ICMPv6 types should be dropped
    test_icmpv6 ${i}3 f0:00:00:00:0${i}:${i}3 f0:00:00:00:00:21 $sip ff02::16:0 "ICMPv6EchoRequest()"

    # should be dropped
    sip=ae80::ea2aeafffe2800aa
    test_ipv6 ${i}3 f0:00:00:00:0${i}:${i}3 f0:00:00:00:00:21 $sip $tip
done

# configure lsp13 to send and received IPv4 packets with an address range
ovn-nbctl --wait=hv lsp-set-port-security lp13 "f0:00:00:00:00:13 192.168.0.13 20.0.0.4/24 10.0.0.0/24 4242::/64"

sip=10.0.0.13
tip=192.168.0.22
# arp packet with inner ip 10.0.0.13 should be allowed for lsp13
test_arp 13 f0:00:00:00:00:13 f0:00:00:00:00:13 $sip $tip 0 f0:00:00:00:00:22

sip=10.0.0.14
tip=192.168.0.23
# IPv4 packet from lsp13 with src ip 10.0.0.14 destined to lsp23
# with dst ip 192.168.0.23 should be allowed
test_ip 13 f0:00:00:00:00:13 f0:00:00:00:00:23 $sip $tip 23

sip=4242::14
tip=4242::23
# IPv6 packet from lsp13 with src ip 4242::14 destined to lsp23
# with dst ip 4242::23 should be received by lsp23
test_ipv6 13 f0:00:00:00:00:13 f0:00:00:00:02:23 $sip $tip 23

sip=192.168.0.33
tip=10.0.0.15
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 10.0.0.15 should be received by lsp13
test_ip 33 f0:00:00:00:00:33 f0:00:00:00:00:13 $sip $tip 13

sip=4242::33
tip=4242::13
# IPv6 packet from lsp33 with src ip 4242::33 destined to lsp13
# with dst ip 4242::13 should be received by lsp13
test_ipv6 33 f0:00:00:00:03:33 f0:00:00:00:00:13 $sip $tip 13

sip=192.168.0.33
tip=20.0.0.4
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 20.0.0.4 should be received by lsp13
test_ip 33 f0:00:00:00:00:33 f0:00:00:00:00:13 $sip $tip 13

sip=192.168.0.33
tip=20.0.0.5
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 20.0.0.5 should not be received by lsp13
test_ip 33 f0:00:00:00:00:33 f0:00:00:00:00:13 $sip $tip

sip=4242::33
tip=4242::5
# IPv6 packet from lsp33 with src ip 4242::33 destined to lsp13
# with dst ip 4242::5 should not be received by lsp13
test_ipv6 33 f0:00:00:00:03:33 f0:00:00:00:00:13 $sip $tip 13

sip=192.168.0.33
tip=20.0.0.255
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 20.0.0.255 should be received by lsp13
test_ip 33 f0:00:00:00:00:33 f0:00:00:00:00:13 $sip $tip 13

sip=192.168.0.33
tip=192.168.0.255
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 192.168.0.255 should not be received by lsp13
test_ip 33 f0:00:00:00:00:33 f0:00:00:00:00:13 $sip $tip

sip=192.168.0.33
tip=224.0.0.4
# IPv4 packet from lsp33 with src ip 192.168.0.33 destined to lsp13
# with dst ip 224.0.0.4  should be received by lsp13
test_ip 33 f0:00:00:00:00:33 f0:00:00:00:00:13 $sip $tip 13

#dump information including flow counters
ovn-nbctl show
ovn-sbctl dump-flows -- list multicast_group > sbflows
AT_CAPTURE_FILE([sbflows])

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-ofctl -O OpenFlow13 show br-int
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-ofctl -O OpenFlow13 show br-int
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int

echo "------ hv3 dump ------"
as hv3 ovs-vsctl show
as hv3 ovs-ofctl -O OpenFlow13 show br-int
as hv3 ovs-ofctl -O OpenFlow13 dump-flows br-int

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    for j in 1 2 3; do
        OVN_CHECK_PACKETS([hv$i/vif$i$j-tx.pcap], [$i$j.expected])
    done
done

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 2 LS, 1 lport/LS, 2 peer LRs])
ovn_start

# Logical network:
# Two LRs - R1 and R2 that are connected to each other as peers in 20.0.0.0/24
# network. R1 has a switchs ls1 (191.168.1.0/24) connected to it.
# R2 has ls2 (172.16.1.0/24) connected to it.

ls1_lp1_mac="f0:00:00:01:02:03"
rp_ls1_mac="00:00:00:01:02:03"
rp_ls2_mac="00:00:00:01:02:04"
ls2_lp1_mac="f0:00:00:01:02:04"

ls1_lp1_ip="192.168.1.2"
ls2_lp1_ip="172.16.1.2"

ovn-nbctl lr-add R1
ovn-nbctl lr-add R2

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 $rp_ls1_mac 192.168.1.1/24

ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 type=router \
  options:router-port=ls1 addresses=\"$rp_ls1_mac\"

# Connect ls2 to R2
ovn-nbctl lrp-add R2 ls2 $rp_ls2_mac 172.16.1.1/24

ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 type=router \
  options:router-port=ls2 addresses=\"$rp_ls2_mac\"

# Connect R1 to R2
ovn-nbctl lrp-add R1 R1_R2 00:00:00:02:03:04 20.0.0.1/24 peer=R2_R1
ovn-nbctl lrp-add R2 R2_R1 00:00:00:02:03:05 20.0.0.2/24 peer=R1_R2

ovn-nbctl lr-route-add R1 "0.0.0.0/0" 20.0.0.2
ovn-nbctl lr-route-add R2 "0.0.0.0/0" 20.0.0.1

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "$ls1_lp1_mac $ls1_lp1_ip"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "$ls2_lp1_mac $ls2_lp1_ip"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Packet to send.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_lp1_mac && eth.dst==$rp_ls1_mac &&
        ip4 && ip.ttl==64 && ip4.src==$ls1_lp1_ip && ip4.dst==$ls2_lp1_ip &&
        udp && udp.src==53 && udp.dst==4369"
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])


echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl show br-int
as hv1 ovs-ofctl dump-flows br-int
echo "------ hv2 dump ----------"
as hv2 ovs-ofctl show br-int
as hv2 ovs-ofctl dump-flows br-int

# Packet to Expect
# The TTL should be decremented by 2.
packet="eth.src==$rp_ls2_mac && eth.dst==$ls2_lp1_mac &&
        ip4 && ip.ttl==62 && ip4.src==$ls1_lp1_ip && ip4.dst==$ls2_lp1_ip &&
        udp && udp.src==53 && udp.dst==4369"
echo $packet | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

AT_CHECK([ovn-sbctl dump-flows | grep lr_in_arp_resolve | \
grep "reg0 == 172.16.1.2" | wc -l], [0], [1
])

# Disable the ls2-lp1 port.
ovn-nbctl --wait=hv set logical_switch_port ls2-lp1 enabled=false

AT_CHECK([ovn-sbctl dump-flows | grep lr_in_arp_resolve | \
grep "reg0 == 172.16.1.2" | wc -l], [0], [0
])

# Generate the packet destined for ls2-lp1 and it should not be delivered.
# Packet to send.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_lp1_mac && eth.dst==$rp_ls1_mac &&
        ip4 && ip.ttl==64 && ip4.src==$ls1_lp1_ip && ip4.dst==$ls2_lp1_ip &&
        udp && udp.src==53 && udp.dst==4369"

OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])
# The 2nd packet sent shound not be received.
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([1 HV, 1 LS, 2 lport/LS, 1 LR])
AT_KEYWORDS([router-admin-state])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Logical network:
# One LR - R1 has switch ls1 with two subnets attached to it (191.168.1.0/24
# and 172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:03 192.168.1.1/24 172.16.1.1/24
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 type=router \
          options:router-port=ls1 addresses=\"00:00:00:01:02:03\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
          -- lsp-set-addresses ls1-lp1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port ls1-lp2 in ls1
ovn-nbctl lsp-add ls1 ls1-lp2 \
          -- lsp-set-addresses ls1-lp2 "f0:00:00:01:02:04 172.16.1.2"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1


wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Send ip packets between the two ports.

# Packet to send.
src_mac="f0:00:00:01:02:03"
dst_mac="00:00:00:01:02:03"
src_ip=192.168.1.2
dst_ip=172.16.1.2
packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}')/ \
                  UDP(sport=53, dport=4369)")
as hv1 ovs-appctl netdev-dummy/receive vif1 $packet


echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list logical_flow
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int


#Disable router R1
ovn-nbctl --wait=hv set Logical_Router R1 enabled=false

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list logical_flow
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int

as hv1 ovs-appctl netdev-dummy/receive vif1 $packet

# Packet to Expect
expect_src_mac="00:00:00:01:02:03"
expect_dst_mac="f0:00:00:01:02:04"
echo $(fmt_pkt "Ether(dst='${expect_dst_mac}', src='${expect_src_mac}')/ \
                IP(src='${src_ip}', dst='${dst_ip}', ttl=0x3f)/ \
                UDP(sport=53, dport=4369)") > expected

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([1 HV, 2 LSs, 1 lport/LS, 1 LR])
AT_KEYWORDS([router-admin-state])
TAG_UNSTABLE
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Logical network:
# One LR - R1 has switch ls1 (191.168.1.0/24) connected to it,
# and has switch ls2 (172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 type=router \
          options:router-port=ls1 addresses=\"00:00:00:01:02:03\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 00:00:00:01:02:04 172.16.1.1/24
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 type=router \
          options:router-port=ls2 addresses=\"00:00:00:01:02:04\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "f0:00:00:01:02:04 172.16.1.2"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1

wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovs-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Send ip packets between the two ports.

# Packet to send.
src_mac="f0:00:00:01:02:03"
dst_mac="00:00:00:01:02:03"
src_ip=192.168.1.2
dst_ip=172.16.1.2
packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}')/ \
                  UDP(sport=53, dport=4369)")
as hv1 ovs-appctl netdev-dummy/receive vif1 $packet

#Disable router R1
ovn-nbctl --wait=hv set Logical_Router R1 enabled=false

ovs-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

as hv1 ovs-appctl netdev-dummy/receive vif1 $packet

# Packet to Expect
expect_src_mac="00:00:00:01:02:04"
expect_dst_mac="f0:00:00:01:02:04"
echo $(fmt_pkt "Ether(dst='${expect_dst_mac}', src='${expect_src_mac}')/ \
                IP(src='${src_ip}', dst='${dst_ip}', ttl=0x3f)/ \
                UDP(sport=53, dport=4369)") > expected

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 3 LS, 1 lport/LS, 2 peer LRs, static routes])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Logical network:
# Two LRs - R1 and R2 that are connected to each other as peers in 20.0.0.0/24
# network. R1 has switchess foo (192.168.1.0/24)
# connected to it.
# R2 has alice (172.16.1.0/24) and bob (172.16.2.0/24) connected to it.

ovn-nbctl lr-add R1
ovn-nbctl lr-add R2

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:00:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
          options:router-port=foo addresses=\"00:00:00:01:02:03\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:00:01:02:04 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
          type=router options:router-port=alice addresses=\"00:00:00:01:02:04\"

# Connect bob to R2
ovn-nbctl lrp-add R2 bob 00:00:00:01:02:05 172.16.2.1/24
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob type=router \
          options:router-port=bob addresses=\"00:00:00:01:02:05\"

# Connect R1 to R2
ovn-nbctl lrp-add R1 R1_R2 00:00:00:02:03:04 20.0.0.1/24 peer=R2_R1
ovn-nbctl lrp-add R2 R2_R1 00:00:00:02:03:05 20.0.0.2/24 peer=R1_R2

#install static routes
ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
ovn-nbctl lr-route-add R2 172.16.2.0/24 20.0.0.2 R1_R2
ovn-nbctl lr-route-add R2 192.168.1.0/24 20.0.0.1

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port alice1 in alice
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Create logical port bob1 in bob
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:05 172.16.2.2"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=alice1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=bob1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Send ip packets between foo1 and alice1
src_mac="f0:00:00:01:02:03"
dst_mac="00:00:00:01:02:03"
src_ip=192.168.1.2
dst_ip=172.16.1.2
packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}')/ \
                  UDP(sport=53, dport=4369)")
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Send ip packets between foo1 and bob1
src_mac="f0:00:00:01:02:03"
dst_mac="00:00:00:01:02:03"
src_ip=192.168.1.2
dst_ip=172.16.2.2
packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}')/ \
                  UDP(sport=53, dport=4369)")
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Packet to Expect at bob1
src_mac="00:00:00:01:02:05"
dst_mac="f0:00:00:01:02:05"
src_ip=192.168.1.2
dst_ip=172.16.2.2
echo $(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}', ttl=0x3e)/ \
                  UDP(sport=53, dport=4369)") > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Packet to Expect at alice1
src_mac="00:00:00:01:02:04"
dst_mac="f0:00:00:01:02:04"
src_ip=192.168.1.2
dst_ip=172.16.1.2
echo $(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}', ttl=0x3e)/ \
                  UDP(sport=53, dport=4369)") > expected

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([send gratuitous arp on localnet])
ovn_start
ovn-nbctl ls-add lsw0
net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0

ovn_attach n1 br-phys 192.168.0.1

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
AT_CHECK([ovs-vsctl add-port br-eth0 snoopvif -- set Interface snoopvif options:tx_pcap=hv/snoopvif-tx.pcap options:rxq_pcap=hv/snoopvif-rx.pcap])

# Create a vif.
AT_CHECK([ovn-nbctl lsp-add lsw0 localvif1])
AT_CHECK([ovn-nbctl lsp-set-addresses localvif1 "f0:00:00:00:00:01 192.168.1.2"])
AT_CHECK([ovn-nbctl lsp-set-port-security localvif1 "f0:00:00:00:00:01"])

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add lsw0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])

AT_CHECK([ovs-vsctl add-port br-int localvif1 -- set Interface localvif1 external_ids:iface-id=localvif1])

# Wait for packet to be received.
echo "fffffffffffff0000000000108060001080006040001f00000000001c0a80102000000000000c0a80102" > expected
OVN_CHECK_PACKETS_UNIQ([hv/snoopvif-tx.pcap], [expected])

# Check GARP packet when restart openflow connection.
as hv
OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])

OVS_WAIT_UNTIL([grep -c "waiting 4 seconds before reconnect" hv/ovn-controller.log])

as hv
start_daemon ovs-vswitchd --enable-dummy=system -vvconn -vofproto_dpif -vunixctl

# Wait for packet to be received.
echo "fffffffffffff0000000000108060001080006040001f00000000001c0a80102000000000000c0a80102" > expected
OVN_CHECK_PACKETS_UNIQ([hv/snoopvif-tx.pcap], [expected])

# Delete the localnet ports.
AT_CHECK([ovs-vsctl del-port localvif1])
AT_CHECK([ovn-nbctl lsp-del ln_port])

OVN_CLEANUP([hv])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 3 LRs connected via LS, static routes])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24)
# connected to it. R2 has alice (172.16.1.0/24) and R3 has bob (10.32.1.0/24)
# connected to it.

ovn-nbctl lr-add R1
ovn-nbctl lr-add R2
ovn-nbctl lr-add R3

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
    options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 10.32.1.1/24
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24
ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

#install static routes
ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
ovn-nbctl lr-route-add R1 10.32.1.0/24 20.0.0.3

ovn-nbctl lr-route-add R2 192.168.1.0/24 20.0.0.1
ovn-nbctl lr-route-add R2 10.32.1.0/24 20.0.0.3

ovn-nbctl lr-route-add R3 192.168.1.0/24 20.0.0.1
ovn-nbctl lr-route-add R3 172.16.1.0/24 20.0.0.2

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port alice1 in alice
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Create logical port bob1 in bob
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:05 10.32.1.2"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=alice1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=bob1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Send ip packets between foo1 and alice1
src_mac="f0:00:00:01:02:03"
dst_mac="00:00:01:01:02:03"
src_ip=192.168.1.2
dst_ip=172.16.1.2
packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}')/ \
                  UDP(sport=53, dport=4369)")
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
as hv1 ovs-appctl ofproto/trace br-int in_port=1 $packet

# Send ip packets between foo1 and bob1
src_mac="f0:00:00:01:02:03"
dst_mac="00:00:01:01:02:03"
src_ip=192.168.1.2
dst_ip=10.32.1.2
packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}')/ \
                  UDP(sport=53, dport=4369)")
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"
ovn-sbctl dump-flows
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl show br-int
as hv1 ovs-ofctl dump-flows br-int
echo "------ hv2 dump ----------"
as hv2 ovs-ofctl show br-int
as hv2 ovs-ofctl dump-flows br-int
echo "----------------------------"

# Packet to Expect at bob1
src_mac="00:00:03:01:02:03"
dst_mac="f0:00:00:01:02:05"
src_ip=192.168.1.2
dst_ip=10.32.1.2
echo $(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}', ttl=0x3e)/ \
                  UDP(sport=53, dport=4369)") > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Packet to Expect at alice1
src_mac="00:00:02:01:02:03"
dst_mac="f0:00:00:01:02:04"
src_ip=192.168.1.2
dst_ip=172.16.1.2
echo $(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}', ttl=0x3e)/ \
                  UDP(sport=53, dport=4369)") > expected

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([dhcpv4 : 1 HV, 2 LS, 2 LSPs/LS])
AT_KEYWORDS([slowtest])
ovn_start

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

check ovn-nbctl lsp-set-port-security ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

check ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02 10.0.0.6 20.0.0.4"

check ovn-nbctl lsp-set-port-security ls1-lp2 "f0:00:00:00:00:02 10.0.0.6 20.0.0.4"

check ovn-nbctl ls-add ls2
check ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "f0:00:00:00:00:03 30.0.0.6 40.0.0.4"
check ovn-nbctl lsp-set-port-security ls2-lp1 "f0:00:00:00:00:03 30.0.0.6 40.0.0.4"
check ovn-nbctl lsp-add ls2 ls2-lp2 \
-- lsp-set-addresses ls2-lp2 "f0:00:00:00:00:04 30.0.0.7"
check ovn-nbctl lsp-set-port-security ls2-lp2 "f0:00:00:00:00:04 30.0.0.7"

d1="$(ovn-nbctl create DHCP_Options cidr=10.0.0.0/24 \
options="\"server_id\"=\"10.0.0.1\" \"server_mac\"=\"ff:10:00:00:00:01\" \
\"lease_time\"=\"3600\" \"router\"=\"10.0.0.1\"")"

check ovn-nbctl lsp-set-dhcpv4-options ls1-lp1 ${d1}
check ovn-nbctl lsp-set-dhcpv4-options ls1-lp2 ${d1}

d2="$(ovn-nbctl create DHCP_Options cidr=30.0.0.0/24 \
options="\"server_id\"=\"30.0.0.1\" \"server_mac\"=\"ff:10:00:00:00:02\" \
\"lease_time\"=\"3600\"")"

check ovn-nbctl lsp-set-dhcpv4-options ls2-lp2 ${d2}

net_add n1
sim_add hv1

as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

check ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

check ovs-vsctl -- add-port br-int hv1-vif4 -- \
    set interface hv1-vif4 external-ids:iface-id=ls2-lp2 \
    options:tx_pcap=hv1/vif4-tx.pcap \
    options:rxq_pcap=hv1/vif4-rx.pcap \
    ofport-request=4

as hv1 ovs-appctl vlog/set dbg

OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

as hv1 ovs-vsctl show

# This shell function sends a DHCP request packet
#
# The first argument is just the number of calls to this function so
# far (1, 2, ...).  This is redundant, but it makes it easier to find
# the failures by searching for the number.
#
# test_dhcp PACKET_NUM INPORT SRC_MAC DHCP_TYPE BROADCAST CIADDR OFFER_IP REQUEST_IP ETH_BOOT USE_IP ...
packet_num=0
test_dhcp() {
    local expect_resume=:
    local trace=false
    while :; do
        case $1 in
            (--no-resume) expect_resume=false; shift ;;
            # --trace isn't used but it can be useful for debugging:
            (--trace) trace=:; shift ;;
            (*) break ;;
        esac
    done

    packet_num=$(expr $packet_num + 1)
    AT_FAIL_IF([test $packet_num != $1])
    shift

    local inport=$1 src_mac=$2 dhcp_type=$3 broadcast=$4 ciaddr=$5 offer_ip=$6 request_ip=$7 eth_boot=$8 use_ip=$9
    shift; shift; shift; shift; shift; shift; shift; shift; shift;

    if test $use_ip != 0; then
        src_ip=$1
        dst_ip=$2
        shift; shift;
    else
        src_ip=`ip_to_hex 0 0 0 0`
        dst_ip=`ip_to_hex 255 255 255 255`
    fi

    AS_BOX([dhcp test packet $packet_num])

    as hv1
    if test -f hv1/ovs-ofctl.pid; then
        OVS_APP_EXIT_AND_WAIT([ovs-ofctl])
        AT_FAIL_IF([test -f ovs-ofctl.pid])
    fi
    AT_CAPTURE_FILE([ofctl_monitor$packet_num.log])
    ovs-ofctl monitor br-int resume --detach --no-chdir \
        --pidfile=ovs-ofctl.pid 2> ofctl_monitor$packet_num.log

    echo "inport=$inport src_mac=$src_mac dhcp_type=$dhcp_type broadcast=$broadcast ciaddr=$ciaddr offer_ip=$offer_ip request_ip=$request_ip use_ip=$use_ip src_ip=$src_ip dst_ip=$dst_ip"

    if test $request_ip != 0; then
        if test $eth_boot != 0; then
            ip_len=0124
            udp_len=010f
        else
            ip_len=0120
            udp_len=010b
        fi
    else
        if test $eth_boot != 0; then
            ip_len=011e
            udp_len=010a
        else
            ip_len=011a
            udp_len=0106
        fi
    fi

    if test $broadcast != 0; then
        flags=8000
        reply_dst_ip=`ip_to_hex 255 255 255 255`
    else
        flags=0000
        reply_dst_ip=${offer_ip}
    fi

    if test "$dhcp_type" = "04"; then
        ciaddr=$offer_ip
    fi

    local request=ffffffffffff${src_mac}08004510${ip_len}0000000080110000${src_ip}${dst_ip}
    # udp header and dhcp header
    request=${request}00440043${udp_len}0000
    request=${request}010106006359aa760000${flags}${ciaddr}000000000000000000000000${src_mac}
    # client hardware padding
    request=${request}00000000000000000000
    # server hostname
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    # boot file name
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    # dhcp magic cookie
    request=${request}63825363
    # dhcp message type
    request=${request}3501${dhcp_type}
    # dhcp unknown option
    request=${request}d70701020304050607
    # dhcp pad option
    request=${request}00
    if test $request_ip != 0; then
        # dhcp requested ip
        request=${request}3204${request_ip}
    fi
    if test $eth_boot != 0; then
        request=${request}af020000
    fi
    # dhcp end option
    request=${request}ff
    tcpdump_hex "-- sending DHCP request on hv1-vif$inport" $request

    for port in $inport "$@"; do
        : >> $port.expected
    done
    if test $offer_ip != 0; then
        local srv_mac=$1 srv_ip=$2 dhcp_reply_type=$3 expected_dhcp_opts=$4
        local offered_ip=$offer_ip
        if [[ "$dhcp_type" == "08" ]]; then
            # DHCP ACK for DHCP INFORM should not have any offer ip.
            offered_ip=00000000
        fi

        # total IP length will be the IP length of the request packet
        # (which is 272 in our case) + 8 (padding bytes) + (expected_dhcp_opts / 2)
        ip_len=`expr 280 + ${#expected_dhcp_opts} / 2`
        udp_len=`expr $ip_len - 20`
        ip_len=$(printf "%x" $ip_len)
        udp_len=$(printf "%x" $udp_len)
        # $ip_len var will be in 3 digits i.e 134. So adding a '0' before $ip_len
        local reply=${src_mac}${srv_mac}0800
        local ip_header=45100${ip_len}0000000080110000${srv_ip}${reply_dst_ip}
        reply=${reply}$(ip4_csum_inplace $ip_header)
        # udp header and dhcp header.
        # $udp_len var will be in 3 digits. So adding a '0' before $udp_len
        reply=${reply}004300440${udp_len}0000020106006359aa760000${flags}${ciaddr}
        # your ip address; 0 for NAK
        if test $dhcp_reply_type = 06; then
            reply=${reply}00000000
        else
            reply=${reply}${offered_ip}
        fi
        # next server ip address, relay agent ip address, client mac address
        reply=${reply}0000000000000000${src_mac}
        # client hardware padding
        reply=${reply}00000000000000000000
        # server hostname
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        # boot file name
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
        # dhcp magic cookie
        reply=${reply}63825363
        reply=${reply}3501${dhcp_reply_type}${expected_dhcp_opts}00000000ff00000000
        echo $reply >> $inport.expected
        tcpdump_hex "-- expecting DHCP reply on $inport" $request
    else
        for outport; do
            echo $request >> $outport.expected
        done
    fi
    if $trace; then
        as hv1 ovs-appctl ofproto/trace br-int in_port=hv1-vif$inport $request > trace$packet_num
        AT_CAPTURE_FILE([trace$packet_num])
    else
        check as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $request
    fi

    # NXT_RESUMEs should be 1.
    if $expect_resume; then
        OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor$packet_num.log | grep -c NXT_RESUME`])
    fi
}

compare_dhcp_packets() {
    OVN_CHECK_PACKETS([hv1/vif$1-tx.pcap], [$1.expected])
}

AT_CAPTURE_FILE([sbflows])
ovn-sbctl dump-flows > sbflows

# ----------------------------------------------------------------------

# Send DHCPDISCOVER.
offer_ip=`ip_to_hex 10 0 0 4`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 1 1 f00000000001 01 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 02 $expected_dhcp_opts
compare_dhcp_packets 1

# ----------------------------------------------------------------------

# ovs-ofctl also resumes the packets and this causes other ports to receive
# the DHCP request packet. So reset the pcap files so that its easier to test.
reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST in the SELECTING/INIT-REBOOT state with the offered IP
# address in the Requested IP Address option.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=$offer_ip
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 2 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST in the SELECTING/INIT-REBOOT state with a mismatched IP in
# the Requested IP Address option, expect a DHCPNAK.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=`ip_to_hex 10 0 0 7`
expected_dhcp_opts=""
test_dhcp 3 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 06 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------
reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send Invalid DHCPv4 packet on ls1-lp2. It should be received by ovn-controller
# but should be resumed without the reply.
# ls1-lp1 (vif1-tx.pcap) should receive the DHCPv4 request packet twice,
# one from ovn-controller and the other from "ovs-ofctl resume."
ciaddr=`ip_to_hex 0 0 0 0`
offer_ip=0
request_ip=0
test_dhcp 4 2 f00000000002 09 0 $ciaddr $offer_ip $request_ip 0 0 1 1

# NXT_RESUMEs should be 4.
# vif1-tx.pcap should have received the DHCPv4 (invalid) request packet
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# NXT_RESUMEs should be 4.
# Send DHCPREQUEST in the RENEWING/REBINDING state with ip4.src set to 10.0.0.6
# and ip4.dst set to 10.0.0.1.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=$offer_ip
request_ip=0
src_ip=$offer_ip
dst_ip=$server_ip
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 5 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST in the RENEWING/REBINDING state with ip4.src set to 10.0.0.6
# and ip4.dst set to 255.255.255.255.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=$offer_ip
request_ip=0
src_ip=$offer_ip
dst_ip=`ip_to_hex 255 255 255 255`
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 6 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST in the RENEWING/REBINDING state with a mismatched IP in the
# ciaddr, expect a DHCPNAK.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 10 0 0 7`
request_ip=0
src_ip=$offer_ip
dst_ip=`ip_to_hex 255 255 255 255`
expected_dhcp_opts=""
test_dhcp 7 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 06 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST in the RENEWING/REBINDING state without a specifyied ciaddr,
# expect a DHCPNAK.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
src_ip=$offer_ip
dst_ip=`ip_to_hex 255 255 255 255`
expected_dhcp_opts=""
test_dhcp 8 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 06 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST with ip4.src set to 10.0.0.6 and ip4.dst set to 10.0.0.4.
# The packet should not be received by ovn-controller.
ciaddr=`ip_to_hex 0 0 0 0`
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 4`
test_dhcp --no-resume 9 2 f00000000002 03 0 $ciaddr 0 0 0 1 $src_ip $dst_ip 1

# vif1-tx.pcap should have received the DHCPv4 request packet
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPDISCOVER with BROADCAST flag on.
offer_ip=`ip_to_hex 10 0 0 4`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 10 1 f00000000001 01 1 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 02 $expected_dhcp_opts
compare_dhcp_packets 1

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPRELEASE.
offer_ip=0
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 10 0 0 6`
request_ip=0
expected_dhcp_opts=0
test_dhcp 11 2 f00000000002 07 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001

# There is no reply for this. Check for the INFO log in ovn-controller.log
OVS_WAIT_UNTIL(
    [test 1 = $(cat hv1/ovn-controller.log | grep "DHCPRELEASE f0:00:00:00:00:02 10.0.0.6" -c)
])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [])

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPINFORM
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=$offer_ip
request_ip=0
src_ip=$offer_ip
dst_ip=$server_ip
# In the expected_dhcp_opts we should not see 330400000e10 which is
# dhcp lease time option and 0104ffffff00 which is subnet mask option.
expected_dhcp_opts=03040a00000136040a000001
test_dhcp 12 2 f00000000002 08 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# Now add the dhcp option T1 to the dhcp options.
check ovn-nbctl --wait=hv set dhcp_options ${d1} options:T1=4000
AT_CAPTURE_FILE([sbflows2])
ovn-sbctl dump-flows > sbflows2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Send DHCPREQUEST to make sure that T1 is in the reply dhcp options.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=$offer_ip
request_ip=0
src_ip=$offer_ip
dst_ip=$server_ip
# In the expected_dhcp_opts we should not see 330400000e10 which is
# dhcp lease time option.
expected_dhcp_opts=3a0400000fa0330400000e100104ffffff0003040a00000136040a000001
test_dhcp 13 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Now send DHCPINFORM again.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=00000000
request_ip=0
src_ip=$offer_ip
dst_ip=$server_ip
# In the expected_dhcp_opts we should not see 330400000e10 which is
# dhcp lease time option and 0104ffffff00 which is subnet mask option.
expected_dhcp_opts=03040a00000136040a000001
test_dhcp 14 2 f00000000002 08 0 $ciaddr $offer_ip $request_ip 0 1 $src_ip $dst_ip ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Set tftp server option (IPv4 address) for ls1
echo "------ Set tftp server (IPv4 address) --------"
ovn-nbctl --wait=hv dhcp-options-set-options $d1 server_id=10.0.0.1 \
server_mac=ff:10:00:00:00:01 lease_time=3600 router=10.0.0.1 \
tftp_server=10.10.10.10
AT_CAPTURE_FILE([sbflows3])
ovn-sbctl dump-flows > sbflows3
echo "----------------------------------------------"

# Send DHCPREQUEST in the SELECTING/INIT-REBOOT state with the offered IP
# address in the Requested IP Address option.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=$offer_ip
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a00000142040a0a0a0a
test_dhcp 15 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Set tftp server option (Hostname) for ls1
echo "------ Set tftp server (hostname) --------"
ovn-nbctl --wait=hv dhcp-options-set-options $d1 server_id=10.0.0.1 \
server_mac=ff:10:00:00:00:01 lease_time=3600 router=10.0.0.1 \
tftp_server=\"test_tftp_server\"
AT_CAPTURE_FILE([sbflows4])
ovn-sbctl dump-flows > sbflows4
echo "------------------------------------------"

# Send DHCPREQUEST in the SELECTING/INIT-REBOOT state with the offered IP
# address in the Requested IP Address option.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=$offer_ip
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a0000014210746573745f746674705f736572766572
test_dhcp 16 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# Set domain search list option for ls1
echo "------ Set domain search list --------"
ovn-nbctl --wait=hv dhcp-options-set-options $d1 server_id=10.0.0.1 \
server_mac=ff:10:00:00:00:01 lease_time=3600 router=10.0.0.1 \
domain_search_list=\"test1.com,test2.com\"
AT_CAPTURE_FILE([sbflows5])
ovn-sbctl dump-flows > sbflows5
echo "------------------------------------------"

# Send DHCPREQUEST in the SELECTING/INIT-REBOOT state with the offered IP
# address in the Requested IP Address option.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=$offer_ip
expected_dhcp_opts=771305746573743103636f6d00057465737432c006330400000e100104ffffff0003040a00000136040a000001
test_dhcp 17 2 f00000000002 03 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 05 $expected_dhcp_opts
compare_dhcp_packets 2

# ----------------------------------------------------------------------

# test DHCPDECLINE
offer_ip=`ip_to_hex 10 0 0 4`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
expected_dhcp_opts=""
test_dhcp 18 1 f00000000001 04 0 $ciaddr $offer_ip $request_ip 0 0 ff1000000001 $server_ip 02 $expected_dhcp_opts
OVS_WAIT_UNTIL(
    [test 1 -le $(grep -F -i -c 'DHCPDECLINE from f0:00:00:00:00:01, 10.0.0.4 duplicated' hv1/ovn-controller.log)
])

# Send Etherboot.

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

ovn-nbctl --all destroy dhcp-option

ovn-nbctl dhcp-options-create 10.0.0.0/24
d3=$(ovn-nbctl --bare --columns=_uuid find dhcp_options cidr="10.0.0.0/24")
ovn-nbctl dhcp-options-set-options $d3 \
   server_id=10.0.0.1 server_mac=ff:10:00:00:00:01 \
   lease_time=3600 router=10.0.0.1 bootfile_name_alt=\"bootfile_name_alt\" \
   bootfile_name=\"bootfile\"

ovn-nbctl --wait=hv lsp-set-dhcpv4-options ls1-lp1 $d3

offer_ip=`ip_to_hex 10 0 0 4`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
boofile=4308626f6f7466696c65
expected_dhcp_opts=${boofile}330400000e100104ffffff0003040a00000136040a000001
test_dhcp 19 1 f00000000001 01 0 $ciaddr $offer_ip $request_ip 1 0 ff1000000001 $server_ip 02 $expected_dhcp_opts
compare_dhcp_packets 1

# Test that ovn-controller pinctrl thread handles dhcp requests when it
# connects to a wrong version of ovn-northd at startup.

# Stop ovn-northd so that we can modify the northd_version.
as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

northd_version=$(ovn-sbctl get SB_Global . options:northd_internal_version | sed s/\"//g)
echo "northd version = $northd_version"

check ovn-sbctl set SB_Global . options:northd_internal_version=foo

echo
echo "__file__:__line__: Stop ovn-controller."
as hv1
OVS_APP_EXIT_AND_WAIT([ovn-controller])

echo
echo "__file__:__line__: Pin ovn-controller to ovn-northd version."

as hv1
check ovs-vsctl set open . external_ids:ovn-match-northd-version=true

# Start ovn-controller
as hv1
start_daemon ovn-controller

OVS_WAIT_UNTIL(
    [test 1 = $(grep -c "controller version - $northd_version mismatch with northd version - foo" hv1/ovn-controller.log)
])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# ----------------------------------------------------------------------

offer_ip=`ip_to_hex 10 0 0 4`
server_ip=`ip_to_hex 10 0 0 1`
ciaddr=`ip_to_hex 0 0 0 0`
request_ip=0
boofile=4308626f6f7466696c65
expected_dhcp_opts=${boofile}330400000e100104ffffff0003040a00000136040a000001
test_dhcp 20 1 f00000000001 01 0 $ciaddr $offer_ip $request_ip 1 0 ff1000000001 $server_ip 02 $expected_dhcp_opts
compare_dhcp_packets 1

as hv1
OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([dhcpv6 : 1 HV, 2 LS, 5 LSPs])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4 ae70::4"

ovn-nbctl lsp-set-port-security ls1-lp1 "f0:00:00:00:00:01 10.0.0.4 ae70::4"

ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02 ae70::5"

ovn-nbctl lsp-set-port-security ls1-lp2 "f0:00:00:00:00:02 ae70::5"

ovn-nbctl lsp-add ls1 ls1-lp3 \
-- lsp-set-addresses ls1-lp3 "f0:00:00:00:00:22 ae70::22"

ovn-nbctl lsp-set-port-security ls1-lp3 "f0:00:00:00:00:22 ae70::22"

d1="$(ovn-nbctl create DHCP_Options cidr="ae70\:\:/64" \
options="\"server_id\"=\"00:00:00:10:00:01\"")"

ovn-nbctl lsp-set-dhcpv6-options ls1-lp1 ${d1}
ovn-nbctl lsp-set-dhcpv6-options ls1-lp2 ${d1}

d2="$(ovn-nbctl create DHCP_Options cidr="ae70\:\:/64" \
options="\"dhcpv6_stateless\"=\"true\" \"server_id\"=\"00:00:00:10:00:01\"")"

ovn-nbctl lsp-set-dhcpv6-options ls1-lp3 ${d2}

ovn-nbctl ls-add ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "f0:00:00:00:00:03 be70::3"
ovn-nbctl lsp-set-port-security ls2-lp1 "f0:00:00:00:00:03 be70::3"
ovn-nbctl lsp-add ls2 ls2-lp2 \
-- lsp-set-addresses ls2-lp2 "f0:00:00:00:00:04 be70::4"
ovn-nbctl lsp-set-port-security ls2-lp2 "f0:00:00:00:00:04 be70::4"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

ovs-vsctl -- add-port br-int hv1-vif4 -- \
    set interface hv1-vif4 external-ids:iface-id=ls2-lp2 \
    options:tx_pcap=hv1/vif4-tx.pcap \
    options:rxq_pcap=hv1/vif4-rx.pcap \
    ofport-request=4

ovs-vsctl -- add-port br-int hv1-vif5 -- \
    set interface hv1-vif5 external-ids:iface-id=ls1-lp3 \
    options:tx_pcap=hv1/vif5-tx.pcap \
    options:rxq_pcap=hv1/vif5-rx.pcap \
    ofport-request=5

OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Start with 0 because the first request will not have NXT_RESUME
n_resume=0

# This shell function sends a DHCPv6 request packet
# test_dhcpv6 INPORT SRC_MAC SRC_LLA DHCPv6_MSG_TYPE OFFER_IP OUTPORT...
# The OUTPORTs (zero or more) list the VIFs on which the original DHCPv6
# packet should be received twice (one from ovn-controller and the other
# from the "ovs-ofctl monitor br-int resume"
test_dhcpv6() {
    local inport=$1 src_mac=$2 src_lla=$3 msg_code=$4 offer_ip=$5 boot_file=$6
    local fqdn=$7

    local req_scapy="Ether(dst='ff:ff:ff:ff:ff:ff', src='${src_mac}')/ \
                     IPv6(dst='ff02::1:2', src='${src_lla}')/ \
                     UDP(sport=546, dport=547)/ \
                     DHCP6(msgtype=${msg_code}, trid=0x010203)/ \
                     DHCP6OptClientId(duid=DUID_LL(lladdr='${src_mac}'))"

    # Add IA-NA (Identity Association for Non Temporary Address) if msg_code
    # is not 11 (information request packet)
    if test $msg_code != 11; then
        req_scapy="${req_scapy}/DHCP6OptIA_NA(iaid=0x01020304, T1=3600, T2=5400)"
    fi
    if test "$boot_file" = "bootfile_name"; then
        local uc_data="USER_CLASS_DATA(data=b'iPXE')"
        req_scapy="${req_scapy}/DHCP6OptUserClass(userclassdata=[[${uc_data}]])"
    fi
    if test -n "$fqdn"; then
        req_scapy="${req_scapy}/DHCP6OptClientFQDN(flags=0x01, fqdn=b'test')"
    fi
    request=$(fmt_pkt "${req_scapy}")
    shift; shift; shift; shift; shift; shift; shift;
    if test $offer_ip != 0; then
        local reply_code=7
        if test $msg_code = 1; then
            reply_code=2
        fi

        local rep_scapy="Ether(dst='${src_mac}', src='00:00:00:10:00:01')/ \
                         IPv6(dst='${src_lla}', src='fe80::0200:00ff:fe10:0001')/ \
                         UDP(sport=547, dport=546)/ \
                         DHCP6(msgtype=${reply_code}, trid=0x010203)/ \
                         DHCP6OptClientId(duid=DUID_LL(lladdr='${src_mac}'))"

        if test $offer_ip != 1; then
            local ip_scapy="DHCP6OptIAAddress(addr='${offer_ip}', \
                            preflft=0xffffffff, validlft=0xffffffff)"
            rep_scapy="${rep_scapy}/ \
                       DHCP6OptIA_NA(iaid=0x01020304, T1=0xffffffff, \
                       T2=0xffffffff, ianaopts=[[${ip_scapy}]])"
        fi
        if test -n "$boot_file"; then
            rep_scapy="${rep_scapy}/DHCP6OptBootFileUrl(optdata=b'${boot_file}')"
        fi
        if test -n "$fqdn"; then
            rep_scapy="${rep_scapy}/DHCP6OptClientFQDN(flags=0x06, fqdn=b'${fqdn}')"
        fi
        rep_scapy="${rep_scapy}/DHCP6OptServerId(duid=DUID_LL(lladdr='00:00:00:10:00:01'))"
        reply=$(fmt_pkt "${rep_scapy}")
        echo $reply | trim_zeros >> $inport.expected
    else
        for outport; do
            echo $request | trim_zeros >> $outport.expected
        done
    fi

    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $request
    OVS_WAIT_UNTIL([test $n_resume = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
    n_resume=$((n_resume + 1))
}

test_dhcpv6_release() {
    local inport=$1 src_mac=$2 src_lla=$3 offer_ip=$4

    local ip_scapy="DHCP6OptIAAddress(addr='${offer_ip}', preflft=0xffffffff, validlft=0xffffffff)"
    local req_scapy="Ether(dst='00:00:00:10:00:01', src='${src_mac}')/ \
                     IPv6(dst='ff02::1:2', src='${src_lla}')/ \
                     UDP(sport=546, dport=547)/ \
                     DHCP6(msgtype=8, trid=0x010203)/ \
                     DHCP6OptClientId(duid=DUID_LL(lladdr='${src_mac}'))/ \
                     DHCP6OptServerId(duid=DUID_LL(lladdr='00:00:00:10:00:01'))/ \
                     DHCP6OptIA_NA(iaid=0x01020304, T1=0xffffffff, T2=0xffffffff, ianaopts=[[${ip_scapy}]])"

    request=$(fmt_pkt "${req_scapy}")

    local rep_scapy="Ether(dst='${src_mac}', src='00:00:00:10:00:01')/ \
                     IPv6(dst='${src_lla}', src='fe80::0200:00ff:fe10:0001')/ \
                     UDP(sport=547, dport=546)/ \
                     DHCP6(msgtype=7, trid=0x010203)/ \
                     DHCP6OptClientId(duid=DUID_LL(lladdr='${src_mac}'))/ \
                     DHCP6OptServerId(duid=DUID_LL(lladdr='00:00:00:10:00:01'))/ \
                     DHCP6OptStatusCode(statuscode=0)"

    reply=$(fmt_pkt "${rep_scapy}")
    echo $reply | trim_zeros >> $inport.expected

    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $request
    OVS_WAIT_UNTIL([test $n_resume = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
    n_resume=$((n_resume + 1))
}

check_packets() {
    local port=$1

    # Skipping UDP checksum
    OVN_CHECK_PACKETS([hv1/vif$port-tx.pcap], [$port.expected], ["trim_zeros | cut -c 1-120,125-"])
    rm $port.expected
}

check_empty_packets() {
    local port=$1

    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif$port-tx.pcap | trim_zeros > $port.packets
    AT_CHECK([cat $port.packets], [0], [])

    rm $port.packets
}

AT_CAPTURE_FILE([ofctl_monitor0.log])
as hv1 ovs-ofctl monitor br-int resume --timeout=120 --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0.log

echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list logical_flow
echo "---------------------"

#ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int

# Send DHCPv6 packet on ls2-lp1. native DHCPv6 is disabled on this port.
# There should be no DHCPv6 reply from ovn-controller and the request packet
# should be received by ls2-lp2.

src_mac="f0:00:00:00:00:03"
src_lla="fe80::f200:00ff:fe00:0003"
test_dhcpv6 3 $src_mac $src_lla 1 0 "" "" 4

# vif3-tx.pcap should not have received the DHCPv6 reply packet
check_empty 3

# vif4-tx.pcap should have received the DHCPv6 request packet
check_packets 4

src_mac="f0:00:00:00:00:01"
src_lla="fe80::f200:00ff:fe00:0001"
offer_ip="ae70::4"

test_dhcpv6 1 $src_mac $src_lla 1 $offer_ip "" ""
check_packets 1

reset_pcap_file hv1-vif1 hv1/vif1

test_dhcpv6_release 1 $src_mac $src_lla $offer_ip
check_packets 1

# Send invalid packet on ls1-lp2. ovn-controller should resume the packet
# without any modifications and the packet should be received by ls1-lp1.
# ls1-lp1 will receive the packet twice, one from the ovn-controller after the
# resume and the other from ovs-ofctl monitor resume.

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2

src_mac="f0:00:00:00:00:02"
src_lla="fe80::f200:00ff:fe00:0002"
offer_ip="ae70::5"
# Set invalid msg_type

test_dhcpv6 2 $src_mac $src_lla 16 0 "" "" 1 1

# vif2-tx.pcap should not have received the DHCPv6 reply packet
check_empty 2

# vif1-tx.pcap should have received the DHCPv6 (invalid) request packet
check_packets 1

# Send DHCPv6 packet on ls1-lp3. native DHCPv6 works as stateless mode for this port.
# The DHCPv6 reply shouldn't contain offer_ip.
src_mac="f0:00:00:00:00:22"
src_lla="fe80::f200:00ff:fe00:0022"
reset_pcap_file hv1-vif5 hv1/vif5

test_dhcpv6 5 $src_mac $src_lla 1 1 "" "" 5
check_packets 5

# Send DHCPv6 information request (code 11) on ls1-lp3. The DHCPv6 reply
# shouldn't contain offer_ip
src_mac="f0:00:00:00:00:22"
src_lla="fe80::f200:00ff:fe00:0022"
reset_pcap_file hv1-vif5 hv1/vif5

test_dhcpv6 5 $src_mac $src_lla 11 1 "" "" 5
check_packets 5

ovn-nbctl --all destroy dhcp-option
d1="$(ovn-nbctl create DHCP_Options cidr="ae70\:\:/64")"
ovn-nbctl dhcp-options-set-options $d1 \
    server_id=00:00:00:10:00:01 \
    bootfile_name_alt=\"bootfile_name_alt\" \
    bootfile_name=\"bootfile_name\"
ovn-nbctl --wait=hv lsp-set-dhcpv6-options ls1-lp2 ${d1}

reset_pcap_file hv1-vif2 hv1/vif2

src_mac="f0:00:00:00:00:02"
src_lla="fe80::f200:00ff:fe00:0002"
offer_ip="ae70::5"

test_dhcpv6 2 $src_mac $src_lla 1 $offer_ip "bootfile_name_alt" ""
check_packets 2

reset_pcap_file hv1-vif2 hv1/vif2

test_dhcpv6_release 2 $src_mac $src_lla $offer_ip
check_packets 2

reset_pcap_file hv1-vif2 hv1/vif2

test_dhcpv6 2 $src_mac $src_lla 1 $offer_ip "bootfile_name" ""
check_packets 2

reset_pcap_file hv1-vif2 hv1/vif2

test_dhcpv6_release 2 $src_mac $src_lla $offer_ip
check_packets 2

ovn-nbctl --all destroy dhcp-option
d1="$(ovn-nbctl create DHCP_Options cidr="ae70\:\:/64")"
ovn-nbctl dhcp-options-set-options $d1 \
    server_id=00:00:00:10:00:01 \
    fqdn=\"ovn.org\"
ovn-nbctl --wait=hv lsp-set-dhcpv6-options ls1-lp2 ${d1}

reset_pcap_file hv1-vif2 hv1/vif2

test_dhcpv6 2 $src_mac $src_lla 1 $offer_ip "" "ovn.org"
check_packets 2

reset_pcap_file hv1-vif2 hv1/vif2

test_dhcpv6_release 2 $src_mac $src_lla $offer_ip
check_packets 2

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 2 LRs connected via LS, gateway router])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24)
# connected to it. R2 has alice (172.16.1.0/24) connected to it.
# R2 is a gateway router.



# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1


sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=alice1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis="hv2"

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'


#install static routes
ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
ip_prefix=172.16.1.0/24 nexthop=20.0.0.2 -- add Logical_Router \
R1 static_routes @lrt

ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
ip_prefix=192.168.1.0/24 nexthop=20.0.0.1 -- add Logical_Router \
R2 static_routes @lrt

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port alice1 in alice
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

wait_for_ports_up
check ovn-nbctl --wait=hv sync

OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv1"],["hv2"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv2"],["hv1"])

# Send ip packets between foo1 and alice1
src_mac="f0:00:00:01:02:03"
dst_mac="00:00:01:01:02:03"
src_ip=192.168.1.2
dst_ip=172.16.1.2
packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}')/ \
                  UDP(sport=53, dport=4369)")

echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"
ovn-sbctl dump-flows
echo "---------------------"
ovn-sbctl list chassis
ovn-sbctl list encap
echo "---------------------"

# Packet to Expect at alice1
src_mac="00:00:02:01:02:03"
dst_mac="f0:00:00:01:02:04"
src_ip=192.168.1.2
dst_ip=172.16.1.2
expected=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/ \
                  IP(src='${src_ip}', dst='${dst_ip}', ttl=0x3e)/ \
                  UDP(sport=53, dport=4369)")


as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
as hv1 ovs-appctl ofproto/trace br-int in_port=1 $packet

echo "------ hv1 dump after packet 1 ----------"
as hv1 ovs-ofctl show br-int
as hv1 ovs-ofctl dump-flows br-int
echo "------ hv2 dump after packet 1 ----------"
as hv2 ovs-ofctl show br-int
as hv2 ovs-ofctl dump-flows br-int
echo "----------------------------"

echo $expected > expected
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Delete the router and re-create it. Things should work as before.
ovn-nbctl  lr-del R2
ovn-nbctl create Logical_Router name=R2 options:chassis="hv2"
# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24

ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
ip_prefix=192.168.1.0/24 nexthop=20.0.0.1 -- add Logical_Router \
R2 static_routes @lrt

# Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Send the packet again.
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

echo "------ hv1 dump after packet 2 ----------"
as hv1 ovs-ofctl show br-int
as hv1 ovs-ofctl dump-flows br-int
echo "------ hv2 dump after packet 2 ----------"
as hv2 ovs-ofctl show br-int
as hv2 ovs-ofctl dump-flows br-int
echo "----------------------------"

echo $expected >> expected
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([icmp_reply: 1 HVs, 2 LSs, 1 lport/LS, 1 LR])
AT_KEYWORDS([router-icmp-reply])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

# Logical network:
# One LR - R1 has switch ls1 (191.168.1.0/24) connected to it,
# and has switch ls2 (172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:f1 192.168.1.1/24
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 \
    type=router options:router-port=ls1 addresses=\"00:00:00:01:02:f1\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 00:00:00:01:02:f2 172.16.1.1/24
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 \
    type=router options:router-port=ls2 addresses=\"00:00:00:01:02:f2\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "00:00:00:01:02:03 192.168.1.2"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "00:00:00:01:02:04 172.16.1.2"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

for i in 1 2; do
    : > vif$i.expected
done
# test_ipv4_icmp_request INPORT ETH_SRC ETH_DST IPV4_SRC IPV4_DST
#
# Causes a packet to be received on INPORT.  The packet is an ICMPv4
# request with ETH_SRC, ETH_DST, IPV4_SRC, and IPV4_DST as specified.
#
# INPORT is an lport number, e.g. 11 for vif11.
# ETH_SRC and ETH_DST are each MAC address strings.
# IPV4_SRC and IPV4_DST are each dotted decimal IPv4 address strings.
test_ipv4_icmp_request() {
    local inport=$1 eth_src=$2 eth_dst=$3 ipv4_src=$4 ipv4_dst=$5
    shift; shift; shift; shift; shift
    # Use ttl to exercise section 4.2.2.9 of RFC1812
    local icmp_data=$(seq 1 56 | xargs printf "%02x")
    local packet=$(fmt_pkt "Ether(dst='${eth_dst}', src='${eth_src}')/ \
                            IP(src='${ipv4_src}', dst='${ipv4_dst}', ttl=0x02)/ \
                            ICMP(type=8, id=0x5fbf, seq=1)/ \
                            b'${icmp_data}'")

    as hv1 ovs-appctl netdev-dummy/receive vif$inport $packet
    # Expect to receive the reply, if any. In same port where packet was sent.
    # Note: src and dst fields are expected to be reversed.
    local reply=$(fmt_pkt "Ether(dst='${eth_src}', src='${eth_dst}')/ \
                           IP(src='${ipv4_dst}', dst='${ipv4_src}', ttl=0xfe)/ \
                           ICMP(type=0, id=0x5fbf, seq=1)/ \
                           b'${icmp_data}'")
    echo $reply >> vif$inport.expected
}

# Send ping packet to router's ip addresses, from each of the 2 logical ports.
rtr_l1_ip=192.168.1.1
rtr_l2_ip=172.16.1.1
l1_ip=192.168.1.2
l2_ip=172.16.1.2

# Ping router ip address that is on same subnet as the logical port
test_ipv4_icmp_request 1 00:00:00:01:02:03 00:00:00:01:02:f1 $l1_ip $rtr_l1_ip
test_ipv4_icmp_request 2 00:00:00:01:02:04 00:00:00:01:02:f2 $l2_ip $rtr_l2_ip

# Ping router ip address that is on the other side of the logical ports
test_ipv4_icmp_request 1 00:00:00:01:02:03 00:00:00:01:02:f1 $l1_ip $rtr_l2_ip
test_ipv4_icmp_request 2 00:00:00:01:02:04 00:00:00:01:02:f2 $l2_ip $rtr_l1_ip


echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list logical_flow
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int

# Now check the packets actually received against the ones expected.
for inport in 1 2; do
    OVN_CHECK_PACKETS([hv1/vif${inport}-tx.pcap], [vif$inport.expected])
done

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([policy-based routing: 1 HVs, 2 LSs, 1 lport/LS, 1 LR])
AT_KEYWORDS([policy-based-routing])
TAG_UNSTABLE
ovn_start

# Logical network:
# One LR - R1 has switch ls1 (191.168.1.0/24) connected to it,
# and has switch ls2 (172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl ls-add ls3

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:f1 192.168.1.1/24
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 \
    type=router options:router-port=ls1 addresses=\"00:00:00:01:02:f1\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 00:00:00:01:02:f2 172.16.1.1/24
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 \
    type=router options:router-port=ls2 addresses=\"00:00:00:01:02:f2\"

# Connect ls3 to R1
ovn-nbctl lrp-add R1 ls3 00:00:00:01:02:f3 20.20.1.1/24
ovn-nbctl lsp-add ls3 rp-ls3 -- set Logical_Switch_Port rp-ls3 \
    type=router options:router-port=ls3 addresses=\"00:00:00:01:02:f3\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "00:00:00:01:02:03 192.168.1.2"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "00:00:00:01:02:04 172.16.1.2"

# Create logical port ls3-lp1 in ls3
ovn-nbctl lsp-add ls3 ls3-lp1 \
-- lsp-set-addresses ls3-lp1 "00:00:00:01:02:05 20.20.1.2"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add pbr-hv
as pbr-hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=pbr-hv/vif1-tx.pcap \
    options:rxq_pcap=pbr-hv/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=pbr-hv/vif2-tx.pcap \
    options:rxq_pcap=pbr-hv/vif2-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif3 -- \
    set interface vif3 external-ids:iface-id=ls3-lp1 \
    options:tx_pcap=pbr-hv/vif3-tx.pcap \
    options:rxq_pcap=pbr-hv/vif3-rx.pcap \
    ofport-request=1

ls1_ro_mac=00:00:00:01:02:f1
ls1_ro_ip=192.168.1.1

ls2_ro_mac=00:00:00:01:02:f2
ls2_ro_ip=172.16.1.1

ls3_ro_mac=00:00:00:01:02:f3

ls1_p1_mac=00:00:00:01:02:03
ls1_p1_ip=192.168.1.2

ls2_p1_mac=00:00:00:01:02:04
ls2_p1_ip=172.16.1.2

ls3_p1_mac=00:00:00:01:02:05

wait_for_ports_up

# Create a drop policy
check ovn-nbctl --wait=hv lr-policy-add R1 10 "ip4.src==192.168.1.0/24 && ip4.dst==172.16.1.0/24" drop

# Check logical flow
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_policy | grep "192.168.1.0" | wc -l], [0], [dnl
1
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip4 && ip.ttl==64 && ip4.src==$ls1_p1_ip && ip4.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"

OVS_WAIT_UNTIL([as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Check if packet hit the drop policy
OVS_WAIT_UNTIL([test "1" = "$(ovs-ofctl dump-flows br-int | \
    grep "nw_src=192.168.1.0/24,nw_dst=172.16.1.0/24 actions=drop" | \
    grep "priority=10" | grep "n_packets=1" -c)"])

# Expected to drop the packet.
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" pbr-hv/vif2-tx.pcap > vif2.packets
rcvd_packet=`cat vif2.packets`
AT_FAIL_IF([test "$rcvd_packet" != ""])

# Override drop policy with allow
check ovn-nbctl --wait=hv lr-policy-add R1 20 "ip4.src==192.168.1.0/24 && ip4.dst==172.16.1.0/24" allow

# Check logical flow
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_policy | grep "192.168.1.0" -c], [0], [dnl
2
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip4 && ip.ttl==64 && ip4.src==$ls1_p1_ip && ip4.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
OVS_WAIT_UNTIL([as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Check if packet hit the allow policy
OVS_WAIT_UNTIL([test "1" = "$(ovs-ofctl dump-flows br-int | \
    grep "nw_src=192.168.1.0/24,nw_dst=172.16.1.0/24" | \
    grep "priority=20" | grep "n_packets=1" -c)"])

# Expected packet has TTL decreased by 1
expected="eth.src==$ls2_ro_mac && eth.dst==$ls2_p1_mac &&
       ip4 && ip.ttl==63 && ip4.src==$ls1_p1_ip && ip4.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([pbr-hv/vif2-tx.pcap], [expected])

# Override allow policy with reroute
check ovn-nbctl --wait=hv lr-policy-add R1 30 "ip4.src==192.168.1.0/24 && ip4.dst==172.16.1.0/24" reroute 20.20.1.2

# Check logical flow
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_policy | \
    grep "192.168.1.0" | \
    grep "priority=30" -c], [0], [dnl
1
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip4 && ip.ttl==64 && ip4.src==$ls1_p1_ip && ip4.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
OVS_WAIT_UNTIL([as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Check if packet hit the allow policy
OVS_WAIT_UNTIL([test "1" = "$(ovs-ofctl dump-flows br-int | \
    grep "nw_src=192.168.1.0/24,nw_dst=172.16.1.0/24" | \
    grep "priority=30" | grep "n_packets=1" -c)"])
echo "packet hit reroute policy"

# Expected packet has TTL decreased by 1
expected="eth.src==$ls3_ro_mac && eth.dst==$ls3_p1_mac &&
       ip4 && ip.ttl==63 && ip4.src==$ls1_p1_ip && ip4.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > 3.expected

OVN_CHECK_PACKETS([pbr-hv/vif3-tx.pcap], [3.expected])

OVN_CLEANUP([pbr-hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([policy-based routing IPv6: 1 HVs, 3 LSs, 1 lport/LS, 1 LR])
AT_KEYWORDS([policy-based-routing])
TAG_UNSTABLE
ovn_start

# Logical network:
# One LR - R1 has switch ls1 (191.168.1.0/24) connected to it,
# and has switch ls2 (172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl ls-add ls3

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:f1 2001::1/64
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 \
    type=router options:router-port=ls1 addresses=\"00:00:00:01:02:f1\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 00:00:00:01:02:f2 2002::1/64
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 \
    type=router options:router-port=ls2 addresses=\"00:00:00:01:02:f2\"

# Connect ls3 to R1
ovn-nbctl lrp-add R1 ls3 00:00:00:01:02:f3 2003::1/64
ovn-nbctl lsp-add ls3 rp-ls3 -- set Logical_Switch_Port rp-ls3 \
    type=router options:router-port=ls3 addresses=\"00:00:00:01:02:f3\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "00:00:00:01:02:03 2001::2"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "00:00:00:01:02:04 2002::2"

# Create logical port ls3-lp1 in ls3
ovn-nbctl lsp-add ls3 ls3-lp1 \
-- lsp-set-addresses ls3-lp1 "00:00:00:01:02:05 2003::2"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add pbr-hv
as pbr-hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=pbr-hv/vif1-tx.pcap \
    options:rxq_pcap=pbr-hv/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=pbr-hv/vif2-tx.pcap \
    options:rxq_pcap=pbr-hv/vif2-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif3 -- \
    set interface vif3 external-ids:iface-id=ls3-lp1 \
    options:tx_pcap=pbr-hv/vif3-tx.pcap \
    options:rxq_pcap=pbr-hv/vif3-rx.pcap \
    ofport-request=1

ls1_ro_mac=00:00:00:01:02:f1
ls1_ro_ip=2001::1

ls2_ro_mac=00:00:00:01:02:f2
ls2_ro_ip=2002::1

ls3_ro_mac=00:00:00:01:02:f3

ls1_p1_mac=00:00:00:01:02:03
ls1_p1_ip=2001::2

ls2_p1_mac=00:00:00:01:02:04
ls2_p1_ip=2002::2

ls3_p1_mac=00:00:00:01:02:05

wait_for_ports_up

# Create a drop policy
check ovn-nbctl --wait=sb lr-policy-add R1 10 "ip6.src==2001::/64 && ip6.dst==2002::/64" drop

# Check logical flow
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_policy | grep "2001" -c], [0], [dnl
1
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip6 && ip.ttl==64 && ip6.src==$ls1_p1_ip && ip6.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"

OVS_WAIT_UNTIL([as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Check if packet hit the drop policy
OVS_WAIT_UNTIL([test "1" = "$(ovs-ofctl dump-flows br-int | \
    grep "ipv6_src=2001::/64,ipv6_dst=2002::/64 actions=drop" | \
    grep "priority=10" | grep "n_packets=1" -c)"])

# Expected to drop the packet.
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" pbr-hv/vif2-tx.pcap > vif2.packets
AT_FAIL_IF([test -s vif2.packets])

# Override drop policy with allow
check ovn-nbctl --wait=sb lr-policy-add R1 20 "ip6.src==2001::/64 && ip6.dst==2002::/64" allow

# Check logical flow
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_policy | grep "2001" -c], [0], [dnl
2
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip6 && ip.ttl==64 && ip6.src==$ls1_p1_ip && ip6.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
OVS_WAIT_UNTIL([as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Check if packet hit the allow policy
OVS_WAIT_UNTIL([test "1" = "$(ovs-ofctl dump-flows br-int | \
    grep "ipv6_src=2001::/64,ipv6_dst=2002::/64"  | \
    grep "priority=20" | grep "n_packets=1" -c)"])

# Expected packet has TTL decreased by 1
expected="eth.src==$ls2_ro_mac && eth.dst==$ls2_p1_mac &&
       ip6 && ip.ttl==63 && ip6.src==$ls1_p1_ip && ip6.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([pbr-hv/vif2-tx.pcap], [expected])

# Override allow policy with reroute
check ovn-nbctl --wait=sb lr-policy-add R1 30 "ip6.src==2001::/64 && ip6.dst==2002::/64" reroute 2003::2

# Check logical flow
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_policy | \
    grep "2001" | \
    grep "priority=30" -c], [0], [dnl
1
])

# Send packet.
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$ls1_ro_mac &&
       ip6 && ip.ttl==64 && ip6.src==$ls1_p1_ip && ip6.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
OVS_WAIT_UNTIL([as pbr-hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Check if packet hit the allow policy
OVS_WAIT_UNTIL([test "1" = "$(ovs-ofctl dump-flows br-int | \
    grep "ipv6_src=2001::/64,ipv6_dst=2002::/64"  | \
    grep "priority=30" | grep "n_packets=1" -c)"])

# Expected packet has TTL decreased by 1
expected="eth.src==$ls3_ro_mac && eth.dst==$ls3_p1_mac &&
       ip6 && ip.ttl==63 && ip6.src==$ls1_p1_ip && ip6.dst==$ls2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > 3.expected

OVN_CHECK_PACKETS([pbr-hv/vif3-tx.pcap], [3.expected])

OVN_CLEANUP([pbr-hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# 1 hypervisor, 1 port
# make sure that the port state is properly set to up and back down
# when created and deleted.
AT_SETUP([port state up and down])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 lp1
ovn-nbctl lsp-set-addresses lp1 unknown

net_add n1
sim_add hv1
as hv1 ovs-vsctl add-br br-phys
as hv1 ovn_attach n1 br-phys 192.168.0.1

as hv1 ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp1` = xup])

as hv1 ovs-vsctl del-port br-int vif1
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp1` = xdown])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# 1 hypervisor, 1 port
# make sure that the OF rules created to support a datapath are added/cleared
# when logical switch is created and removed.
AT_SETUP([datapath rules added/removed])
AT_KEYWORDS([cleanup])
ovn_start

net_add n1
sim_add hv1
as hv1 ovs-vsctl add-br br-phys
as hv1 ovn_attach n1 br-phys 192.168.0.1

# This shell function checks if OF rules in br-int have clauses
# related to OVN datapaths. The caller determines if it should find
# a match in the output, or not.
#
# EXPECT_DATAPATH param determines whether flows that refer to
#                 datapath to should be present or not. 0 means
#                 they should not be.
# STAGE_INFO param is a simple string to help identify the stage
#            in the test when this function was invoked.
test_datapath_in_of_rules() {
    local expect_datapath=$1 stage_info=$2
    echo "------ ovn-nbctl show ${stage_info} ------"
    ovn-nbctl show
    echo "------ ovn-sbctl show ${stage_info} ------"
    ovn-sbctl show
    echo "------ OF rules ${stage_info} ------"
    AT_CHECK([ovs-ofctl dump-flows br-int], [0], [stdout])
    # if there is a datapath mentioned in the output, check for the
    # magic keyword that represents one, based on the exit status of
    # a quiet grep
    if test $expect_datapath != 0; then
       AT_CHECK([grep -q -i 'metadata=' stdout], [0], [ignore-nolog])
    else
       AT_CHECK([grep -q -i 'metadata=' stdout], [1], [ignore-nolog])
    fi
}

test_datapath_in_of_rules 0 "before ls+port create"

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 lp1
ovn-nbctl lsp-set-addresses lp1 unknown

as hv1 ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp1` = xup])

test_datapath_in_of_rules 1 "after port is bound"

as hv1 ovs-vsctl del-port br-int vif1
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp1` = xdown])

ovn-nbctl lsp-set-addresses lp1
ovn-nbctl lsp-del lp1
ovn-nbctl ls-del ls1

# wait for earlier changes to take effect
wait_for_ports_up
check ovn-nbctl --wait=sb sync

# ensure OF rules are no longer present. There used to be a bug here.
test_datapath_in_of_rules 0 "after lport+ls removal"

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([nd_na ])
ovn_start

#TODO: since patch port for IPv6 logical router port is not ready not,
#  so we are not going to test vifs on different lswitches cases. Try
#  to update for that once relevant stuff implemented.

# In this test cases we create 1 lswitch, it has 2 VIF ports attached
# with. NS packet we test, from one VIF for another VIF, will be replied
# by local ovn-controller, but not by target VIF.

# Create hypervisors and logical switch lsw0.
ovn-nbctl ls-add lsw0
net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

# Add vif1 to hv1 and lsw0, turn on l2 port security on vif1.
ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1 options:tx_pcap=hv1/vif1-tx.pcap options:rxq_pcap=hv1/vif1-rx.pcap ofport-request=1
ovn-nbctl lsp-add lsw0 lp1
ovn-nbctl lsp-set-addresses lp1 "fa:16:3e:94:05:98 192.168.0.3 fd81:ce49:a948:0:f816:3eff:fe94:598"
ovn-nbctl lsp-set-port-security lp1 "fa:16:3e:94:05:98 192.168.0.3 fd81:ce49:a948:0:f816:3eff:fe94:598"

# Add vif2 to hv1 and lsw0, turn on l2 port security on vif2.
ovs-vsctl add-port br-int vif2 -- set Interface vif2 external-ids:iface-id=lp2 options:tx_pcap=hv1/vif2-tx.pcap options:rxq_pcap=hv1/vif2-rx.pcap ofport-request=2
ovn-nbctl lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp2 "fa:16:3e:a1:f9:ae 192.168.0.4 fd81:ce49:a948:0:f816:3eff:fea1:f9ae"
ovn-nbctl lsp-set-port-security lp2 "fa:16:3e:a1:f9:ae 192.168.0.4 fd81:ce49:a948:0:f816:3eff:fea1:f9ae"

# Add ACL rule for ICMPv6 on lsw0
ovn-nbctl acl-add lsw0 from-lport 1002 'ip6 && icmp6'  allow-related
ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp1" && ip6 && icmp6'  allow-related
ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp2" && ip6 && icmp6'  allow-related

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

for i in 1 2; do
    : > $i.expected
done

# Complete Neighbor Solicitation packet and Neighbor Advertisement packet
# vif1 -> NS -> vif2.  vif1 <- NA <- ovn-controller.
# vif2 will not receive NS packet, since ovn-controller will reply for it.
ns_packet=3333ffa1f9aefa163e94059886dd6000000000203afffd81ce49a9480000f8163efffe940598fd81ce49a9480000f8163efffea1f9ae8700e01160000000fd81ce49a9480000f8163efffea1f9ae0101fa163e940598
na_packet=fa163e940598fa163ea1f9ae86dd6000000000203afffd81ce49a9480000f8163efffea1f9aefd81ce49a9480000f8163efffe9405988800e9ed60000000fd81ce49a9480000f8163efffea1f9ae0201fa163ea1f9ae

as hv1 ovs-appctl netdev-dummy/receive vif1 $ns_packet
echo $na_packet >> 1.expected

for i in 1 2; do
    OVN_CHECK_PACKETS([hv1/vif$i-tx.pcap], [$i.expected])
done

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([address sets modification/removal smoke test])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

row=`ovn-nbctl create Address_Set name=set1 addresses=\"1.1.1.1\"`
ovn-nbctl set Address_Set $row name=set1 addresses=\"1.1.1.1,1.1.1.2\"
ovn-nbctl --wait=hv destroy Address_Set $row

# A bug previously existed in the address set support code
# that caused ovn-controller to crash after an address set
# was updated and then removed.  This test case ensures
# that ovn-controller is at least still running after
# creating, updating, and deleting an address set.
AT_CHECK([ovs-appctl -t ovn-controller version], [0], [ignore])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ipam])
AT_KEYWORDS([slowtest])
ovn_start

check_dynamic_addresses() {
    local arg
    case $2 in
        ('') arg='[[]]' ;;
        (*) arg="\"$2\"" ;;
    esac
    check_row_count nb:Logical_Switch_Port 1 name="$1" dynamic_addresses="$arg"
}

check ovn-nbctl --wait=sb sync
# Add a port to a switch that does not have a subnet set, then set the
# subnet which should result in an address being allocated for the port.
ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="0a:00:00:00:00:00"
ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 p0 -- lsp-set-addresses p0 dynamic
ovn-nbctl --wait=sb add Logical-Switch sw0 other_config subnet=192.168.1.0/24
check_dynamic_addresses p0 "0a:00:00:a8:01:03 192.168.1.2"

# Add 9 more ports to sw0, addresses should all be unique.
for n in `seq 1 9`; do
    ovn-nbctl --wait=sb lsp-add sw0 "p$n" -- lsp-set-addresses "p$n" dynamic
done
for i in `seq 1 9`; do
    mac=0a:00:00:a8:01:$(printf "%02x" $(expr $i + 3))
    ip=192.168.1.$(expr $i + 2)
    check_dynamic_addresses p$i "$mac $ip"
done

# Trying similar tests with a second switch. MAC addresses should be unique
# across both switches but IP's only need to be unique within the same switch.
ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 p10 -- lsp-set-addresses p10 dynamic
ovn-nbctl --wait=sb add Logical-Switch sw1 other_config subnet=192.168.1.0/24
check_row_count nb:Logical_Switch_Port 1 name=p10 dynamic_addresses='"0a:00:00:a8:01:0d 192.168.1.2"'

for n in `seq 11 19`; do
    ovn-nbctl --wait=sb lsp-add sw1 "p$n" -- lsp-set-addresses "p$n" dynamic
done
for i in `seq 11 19`; do
    mac=0a:00:00:a8:01:$(printf "%02x" $(expr $i + 3))
    ip=192.168.1.$(expr $i - 8)
    check_dynamic_addresses p$i "$mac $ip"
done

# Change a port's address to test for multiple ip's for a single address entry
# and addresses set by the user.
ovn-nbctl lsp-set-addresses p0 "0a:00:00:a8:01:17 192.168.1.2 192.168.1.12 192.168.1.14"
ovn-nbctl --wait=sb lsp-add sw0 p20 -- lsp-set-addresses p20 dynamic
check_dynamic_addresses p20 "0a:00:00:a8:01:18 192.168.1.13"

# Test for logical router port address management.
ovn-nbctl create Logical_Router name=R1
ovn-nbctl -- --id=@lrp create Logical_Router_port name=sw0 \
network="192.168.1.1/24" mac=\"0a:00:00:a8:01:19\" \
-- add Logical_Router R1 ports @lrp -- lsp-add sw0 rp-sw0 \
-- set Logical_Switch_Port rp-sw0 type=router options:router-port=sw0
ovn-nbctl --wait=sb lsp-add sw0 p21 -- lsp-set-addresses p21 dynamic
check_dynamic_addresses p21 "0a:00:00:a8:01:1a 192.168.1.15"

# Test for address reuse after logical port is deleted.
ovn-nbctl lsp-del p0
ovn-nbctl --wait=sb lsp-add sw0 p23 -- lsp-set-addresses p23 dynamic
check_dynamic_addresses p23 "0a:00:00:a8:01:03 192.168.1.2"

# Test for multiple addresses to one logical port.
ovn-nbctl lsp-add sw0 p25 -- lsp-set-addresses p25 \
"0a:00:00:a8:01:1b 192.168.1.12" "0a:00:00:a8:01:1c 192.168.1.14"
ovn-nbctl --wait=sb lsp-add sw0 p26 -- lsp-set-addresses p26 dynamic
check_dynamic_addresses p26 "0a:00:00:a8:01:17 192.168.1.16"

# Test for exhausting subnet address space.
ovn-nbctl ls-add sw2 -- add Logical-Switch sw2 other_config subnet=172.16.1.0/30
ovn-nbctl --wait=sb lsp-add sw2 p27 -- lsp-set-addresses p27 dynamic
check_dynamic_addresses p27 "0a:00:00:10:01:03 172.16.1.2"

ovn-nbctl --wait=sb lsp-add sw2 p28 -- lsp-set-addresses p28 dynamic
check_dynamic_addresses p28 "0a:00:00:00:00:01"

# Test that address management does not add duplicate MAC for lsp/lrp peers.
ovn-nbctl create Logical_Router name=R2
ovn-nbctl ls-add sw3
ovn-nbctl lsp-add sw3 p29 -- lsp-set-addresses p29 \
"0a:00:00:a8:01:18"
ovn-nbctl -- --id=@lrp create Logical_Router_port name=sw3 \
network="192.168.2.1/24" mac=\"0a:00:00:a8:01:18\" \
-- add Logical_Router R2 ports @lrp -- lsp-add sw3 rp-sw3 \
-- set Logical_Switch_Port rp-sw3 type=router options:router-port=sw3
ovn-nbctl --wait=sb lsp-add sw0 p30 -- lsp-set-addresses p30 dynamic
check_dynamic_addresses p30 "0a:00:00:a8:01:1d 192.168.1.17"

# Test static MAC address with dynamically allocated IP
ovn-nbctl --wait=sb lsp-add sw0 p31 -- lsp-set-addresses p31 \
"fe:dc:ba:98:76:54 dynamic"
check_dynamic_addresses p31 "fe:dc:ba:98:76:54 192.168.1.18"

# Update the static MAC address with dynamically allocated IP and check
# if the MAC address is updated in 'Logical_Switch_Port.dynamic_adddresses'
ovn-nbctl --wait=sb lsp-set-addresses p31 "fe:dc:ba:98:76:55 dynamic"
check_dynamic_addresses p31 "fe:dc:ba:98:76:55 192.168.1.18"

ovn-nbctl --wait=sb lsp-set-addresses p31 "dynamic"
check_dynamic_addresses p31 "0a:00:00:a8:01:1e 192.168.1.18"

ovn-nbctl --wait=sb lsp-set-addresses p31 "fe:dc:ba:98:76:56 dynamic"
check_dynamic_addresses p31 "fe:dc:ba:98:76:56 192.168.1.18"

# Test the exclude_ips from the IPAM list
ovn-nbctl --wait=sb set logical_switch sw0 \
other_config:exclude_ips="192.168.1.19 192.168.1.21 192.168.1.23..192.168.1.50"

ovn-nbctl --wait=sb lsp-add sw0 p32 -- lsp-set-addresses p32 "dynamic"
# 192.168.1.20 should be assigned as 192.168.1.19 is excluded.
check_dynamic_addresses p32 "0a:00:00:a8:01:1e 192.168.1.20"

ovn-nbctl --wait=sb lsp-add sw0 p33 -- lsp-set-addresses p33 \
"dynamic"
# 192.168.1.22 should be assigned as 192.168.1.21 is excluded.
check_dynamic_addresses p33 "0a:00:00:a8:01:1f 192.168.1.22"

ovn-nbctl --wait=sb lsp-add sw0 p34 -- lsp-set-addresses p34 \
"dynamic"
# 192.168.1.51 should be assigned as 192.168.1.23-192.168.1.50 is excluded.
check_dynamic_addresses p34 "0a:00:00:a8:01:34 192.168.1.51"

# Now clear the exclude_ips list. 192.168.1.19 should be assigned.
ovn-nbctl --wait=sb set Logical-switch sw0 other_config:exclude_ips="invalid"
ovn-nbctl --wait=sb lsp-add sw0 p35 -- lsp-set-addresses p35 "dynamic"
check_dynamic_addresses p35 "0a:00:00:a8:01:20 192.168.1.19"

# Set invalid data in exclude_ips list. It should be ignored.
ovn-nbctl --wait=sb set Logical-switch sw0 other_config:exclude_ips="182.168.1.30"
ovn-nbctl --wait=sb lsp-add sw0 p36 -- lsp-set-addresses p36 \
"dynamic"
# 192.168.1.21 should be assigned as that's the next free one.
check_dynamic_addresses p36 "0a:00:00:a8:01:21 192.168.1.21"

# Clear the dynamic addresses assignment request.
ovn-nbctl --wait=sb clear logical_switch_port p36 addresses
check_dynamic_addresses p36

# Set IPv6 prefix
ovn-nbctl --wait=sb set Logical-switch sw0 other_config:ipv6_prefix="aef0::"
ovn-nbctl --wait=sb lsp-add sw0 p37 -- lsp-set-addresses p37 "dynamic"

# With prefix aef0 and mac 0a:00:00:00:00:26, the dynamic IPv6 should be
# - aef0::800:ff:fe00:26 (EUI64)
check_dynamic_addresses p37 "0a:00:00:a8:01:21 192.168.1.21 aef0::800:ff:fea8:121"

ovn-nbctl --wait=sb ls-add sw4
ovn-nbctl --wait=sb set Logical-switch sw4 other_config:ipv6_prefix="bef0::" \
-- set Logical-switch sw4 other_config:subnet=192.168.2.0/30
ovn-nbctl --wait=sb lsp-add sw4 p38 -- lsp-set-addresses p38 "dynamic"

check_dynamic_addresses p38 "0a:00:00:a8:02:03 192.168.2.2 bef0::800:ff:fea8:203"

ovn-nbctl --wait=sb lsp-add sw4 p39 -- lsp-set-addresses p39 \
"f0:00:00:00:10:12 dynamic"

check_dynamic_addresses p39 "f0:00:00:00:10:12 bef0::f200:ff:fe00:1012"

# Test the case where IPv4 addresses are exhausted and IPv6 prefix is set
# p40 should not have an IPv4 address since the pool is exhausted
ovn-nbctl --wait=sb lsp-add sw4 p40 -- lsp-set-addresses p40 \
"dynamic"
check_dynamic_addresses p40 "0a:00:00:00:00:02 bef0::800:ff:fe00:2"

# Test dynamic changes on switch ports.
#
ovn-nbctl --wait=sb ls-add sw5
ovn-nbctl --wait=sb lsp-add sw5 p41 -- lsp-set-addresses p41 \
"dynamic"
# p41 will start with nothing
check_dynamic_addresses p41 ''

# Set a subnet. Now p41 should have an ipv4 address, too
ovn-nbctl --wait=sb add Logical-Switch sw5 other_config subnet=192.168.1.0/24
check_dynamic_addresses p41 "0a:00:00:a8:01:22 192.168.1.2"

# Clear the other_config. The IPv4 address should be gone
ovn-nbctl --wait=sb clear Logical-Switch sw5 other_config
check_dynamic_addresses p41 ''

# Set an IPv6 prefix. Now p41 should have an IPv6 address.
ovn-nbctl --wait=sb set Logical-Switch sw5 other_config:ipv6_prefix="aef0::"
check_dynamic_addresses p41 "0a:00:00:00:00:03 aef0::800:ff:fe00:3"

# Change the MAC address to a static one. The IPv6 address should update.
ovn-nbctl --wait=sb lsp-set-addresses p41 "f0:00:00:00:10:2b dynamic"
check_dynamic_addresses p41 "f0:00:00:00:10:2b aef0::f200:ff:fe00:102b"

# Change the IPv6 prefix. The IPv6 address should update.
ovn-nbctl --wait=sb set Logical-Switch sw5 other_config:ipv6_prefix="bef0::"
check_dynamic_addresses p41 "f0:00:00:00:10:2b bef0::f200:ff:fe00:102b"

# Clear the other_config. The IPv6 address should be gone
ovn-nbctl --wait=sb clear Logical-Switch sw5 other_config
check_dynamic_addresses p41 ''

# Set the subnet again. Now p41 should get the IPv4 address again.
ovn-nbctl --wait=sb add Logical-Switch sw5 other_config subnet=192.168.1.0/24
check_dynamic_addresses p41 "f0:00:00:00:10:2b 192.168.1.2"

# Add an excluded IP address that conflicts with p41. p41 should update.
ovn-nbctl --wait=sb add Logical-Switch sw5 other_config \
exclude_ips="192.168.1.2"
check_dynamic_addresses p41 "f0:00:00:00:10:2b 192.168.1.3"

# Add static ip address
ovn-nbctl --wait=sb lsp-set-addresses p41 "dynamic 192.168.1.100"
ovn-nbctl list Logical-Switch-Port p41
ovn-nbctl --wait=sb lsp-add sw5 p42 -- lsp-set-addresses p42 \
"dynamic 192.168.1.101"
check_dynamic_addresses p41 "0a:00:00:a8:01:65 192.168.1.100"
check_dynamic_addresses p42 "0a:00:00:a8:01:66 192.168.1.101"

# define a mac address prefix
ovn-nbctl ls-add sw6
ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="00:11:22:33:44:55"
ovn-nbctl --wait=sb set Logical-Switch sw6 other_config:subnet=192.168.100.0/24
for n in $(seq 1 3); do
    ovn-nbctl --wait=sb lsp-add sw6 "p5$n" -- lsp-set-addresses "p5$n" dynamic
done
check_dynamic_addresses p51 "00:11:22:a8:64:03 192.168.100.2"
check_dynamic_addresses p52 "00:11:22:a8:64:04 192.168.100.3"
check_dynamic_addresses p53 "00:11:22:a8:64:05 192.168.100.4"

# verify configuration order does not break IPAM/MACAM
ovn-nbctl ls-add sw7
for n in $(seq 1 3); do
    ovn-nbctl --wait=sb lsp-add sw7 "p7$n" -- lsp-set-addresses "p7$n" dynamic
done
ovn-nbctl --wait=sb set Logical-Switch sw7 other_config:ipv6_prefix="bef0::"
p71_addr=$(ovn-nbctl get Logical-Switch-Port p71 dynamic_addresses)
p72_addr=$(ovn-nbctl get Logical-Switch-Port p72 dynamic_addresses)
p73_addr=$(ovn-nbctl get Logical-Switch-Port p73 dynamic_addresses)
AT_CHECK([test "$p71_addr" != "$p72_addr"], [0], [])
AT_CHECK([test "$p71_addr" != "$p73_addr"], [0], [])
AT_CHECK([test "$p72_addr" != "$p73_addr"], [0], [])

# request to assign mac only
#
ovn-nbctl ls-add sw8
ovn-nbctl --wait=sb set Logical-Switch sw8 other_config:mac_only=true
for n in $(seq 1 3); do
    ovn-nbctl --wait=sb lsp-add sw8 "p8$n" -- lsp-set-addresses "p8$n" dynamic
done
check_dynamic_addresses p81 "00:11:22:00:00:06"
check_dynamic_addresses p82 "00:11:22:00:00:07"
check_dynamic_addresses p83 "00:11:22:00:00:08"

# clear mac_prefix and check it is allocated in a random manner
ovn-nbctl --wait=hv remove NB_Global . options mac_prefix
ovn-nbctl ls-add sw9
ovn-nbctl --wait=sb set Logical-Switch sw9 other_config:mac_only=true
ovn-nbctl --wait=sb lsp-add sw9 p91 -- lsp-set-addresses p91 dynamic

mac_prefix=$(ovn-nbctl --wait=sb get NB_Global . options:mac_prefix | tr -d \")
port_addr=$(ovn-nbctl get Logical-Switch-Port p91 dynamic_addresses | tr -d \")
AT_CHECK([test "$port_addr" = "${mac_prefix}:00:00:09"], [0], [])

# set mac_prefix to all-zeroes and check it is allocated in a random manner
ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="00:00:00:00:00:00"
ovn-nbctl ls-add sw14
ovn-nbctl --wait=sb set Logical-Switch sw14 other_config:mac_only=true
ovn-nbctl --wait=sb lsp-add sw14 p141 -- lsp-set-addresses p141 dynamic

mac_prefix=$(ovn-nbctl --wait=sb get NB_Global . options:mac_prefix | tr -d \")
port_addr=$(ovn-nbctl get Logical-Switch-Port p141 dynamic_addresses | tr -d \")
AT_CHECK([test "$mac_prefix" != "00:00:00:00:00:00"], [0], [])
AT_CHECK([test "$port_addr" = "${mac_prefix}:00:00:0a"], [0], [])
ovn-nbctl --wait=sb lsp-del sw14 p141
ovn-nbctl --wait=sb ls-del sw14

ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="00:11:22"
ovn-nbctl ls-add sw10
ovn-nbctl --wait=sb set Logical-Switch sw10 other_config:ipv6_prefix="ae01::"
ovn-nbctl --wait=sb lsp-add sw10 p101 -- lsp-set-addresses p101 "dynamic ae01::1"
check_dynamic_addresses p101 "00:11:22:00:00:0a ae01::1"

ovn-nbctl --wait=sb set Logical-Switch sw10 other_config:subnet=192.168.110.0/24
ovn-nbctl --wait=sb lsp-add sw10 p102 -- lsp-set-addresses p102 "dynamic 192.168.110.10 ae01::2"
check_dynamic_addresses p102 "00:11:22:a8:6e:0b 192.168.110.10 ae01::2"

# Configure subnet using address from middle of the subnet and ensure
# address is allocated from the beginning.

ovn-nbctl ls-add sw11
ovn-nbctl --wait=sb set Logical-Switch sw11 other_config:subnet=172.16.1.254/29
ovn-nbctl --wait=sb lsp-add sw11 p103 -- lsp-set-addresses p103 "22:33:44:55:66:77 dynamic"

check_dynamic_addresses p103 "22:33:44:55:66:77 172.16.1.250"

ovn-nbctl ls-add sw12
for i in $(seq 0 1); do
    for j in $(seq 1 99); do
        idx=$((i*100+j))
        ovn-nbctl lsp-add sw12 sw12-p${idx} -- \
        lsp-set-addresses sw12-p${idx} "00:00:00:00:$i:$j dynamic"
    done
done
ovn-nbctl --wait=sb set Logical-Switch sw12 other_config:subnet=192.10.2.0/24
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.127], [0], [ignore])
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.128], [0], [ignore])
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.180], [0], [ignore])

ovn-nbctl --wait=sb set Logical-Switch sw12 other_config:subnet=192.10.2.0/25
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.127], [1])
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.128], [1])
AT_CHECK([ovn-nbctl list Logical-Switch-Port | grep 192.10.2.180], [1])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ipam connectivity])
ovn_start

ovn-nbctl --wait=sb lr-add R1

# Test for a ping using dynamically allocated addresses.
ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="0a:00:00:00:00:00"
ovn-nbctl ls-add foo -- add Logical_Switch foo other_config subnet=192.168.1.0/24
ovn-nbctl ls-add alice -- add Logical_Switch alice other_config subnet=192.168.2.0/24

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:00:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
          options:router-port=foo \
          -- lsp-set-addresses rp-foo router

# Connect alice to R1
ovn-nbctl lrp-add R1 alice 00:00:00:01:02:04 192.168.2.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice type=router \
          options:router-port=alice addresses=\"00:00:00:01:02:04\"

# Create logical port foo1 in foo
ovn-nbctl --wait=sb lsp-add foo foo1 \
-- lsp-set-addresses foo1 "dynamic"
check ovn-nbctl wait-until Logical-Switch-Port foo1 dynamic_addresses='"0a:00:00:a8:01:03 192.168.1.2"'

# Create logical port alice1 in alice
ovn-nbctl --wait=sb lsp-add alice alice1 \
-- lsp-set-addresses alice1 "dynamic"
check ovn-nbctl wait-until Logical-Switch-Port alice1 dynamic_addresses='"0a:00:00:a8:02:03 192.168.2.2"'

# Create logical port foo2 in foo
ovn-nbctl --wait=sb lsp-add foo foo2 \
-- lsp-set-addresses foo2 "dynamic"
check ovn-nbctl wait-until Logical-Switch-Port foo2 dynamic_addresses='"0a:00:00:a8:01:04 192.168.1.3"'

# Create a hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=foo2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=alice1 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Send ip packets between foo1 and foo2
src_mac="0a0000a80103"
dst_mac="0a0000a80104"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 1 3`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Send ip packets between foo1 and alice1
src_mac="0a0000a80103"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int

# Packet to Expect at foo2
src_mac="0a0000a80103"
dst_mac="0a0000a80104"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 1 3`
expected=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > received1.packets
echo $expected > expout
AT_CHECK([cat received1.packets], [0], [expout])

# Packet to Expect at alice1
src_mac="000000010204"
dst_mac="0a0000a80203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
expected=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif3-tx.pcap > received2.packets
echo $expected > expout
AT_CHECK([cat received2.packets], [0], [expout])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovs-vswitchd restart])
AT_KEYWORDS([vswitchd])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

ovn-nbctl lsp-set-port-security ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

OVN_POPULATE_ARP
sleep 2

as hv1 ovs-vsctl show

echo "---------------------"
ovn-sbctl dump-flows
echo "---------------------"

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl dump-flows br-int
total_flows=`as hv1 ovs-ofctl dump-flows br-int | wc -l`

echo "Total flows before vswitchd restart = " $total_flows

# Code taken from ovs-save utility
save_flows () {
    echo "ovs-ofctl add-flows br-int - << EOF" > restore_flows.sh
    as hv1 ovs-ofctl dump-flows "br-int" | sed -e '/NXST_FLOW/d' \
            -e 's/\(idle\|hard\)_age=[^,]*,//g' >> restore_flows.sh
    echo "EOF" >> restore_flows.sh
}

restart_vswitchd () {
    restore_flows=$1

    if test $restore_flows = true; then
        save_flows
    fi

    as hv1
    OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])

    if test $restore_flows = true; then
        as hv1
        ovs-vsctl --no-wait set open_vswitch . other_config:flow-restore-wait="true"
    fi

    as hv1
    start_daemon ovs-vswitchd --enable-dummy=system -vvconn -vofproto_dpif -vunixctl
    ovs-ofctl dump-flows br-int

    if test $restore_flows = true; then
        sh ./restore_flows.sh
        echo "Flows after restore"
        as hv1
        ovs-ofctl dump-flows br-int
        ovs-vsctl --no-wait --if-exists remove open_vswitch . other_config \
            flow-restore-wait="true"
    fi
}

# Save the flows, restart vswitchd and restore the flows
restart_vswitchd true
OVS_WAIT_UNTIL([
    total_flows_after_restart=`as hv1 ovs-ofctl dump-flows br-int | wc -l`
    echo "Total flows after vswitchd restart = " $total_flows_after_restart
    test "${total_flows}" = "${total_flows_after_restart}"
])

# Restart vswitchd without restoring
restart_vswitchd false
OVS_WAIT_UNTIL([
    total_flows_after_restart=`as hv1 ovs-ofctl dump-flows br-int | wc -l`
    echo "Total flows after vswitchd restart = " $total_flows_after_restart
    test "${total_flows}" = "${total_flows_after_restart}"
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([send arp for nexthop])
ovn_start

# Topology: Two LSs - ls1 and ls2 are connected via router r0

# Create logical switches
ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Create  router
ovn-nbctl create Logical_Router name=lr0

# Add router ls1p1 port to gateway router
ovn-nbctl lrp-add lr0 lrp-ls1lp1 f0:00:00:00:00:01 192.168.0.1/24
ovn-nbctl lsp-add ls1 ls1lp1 -- set Logical_Switch_Port ls1lp1  \
    type=router options:router-port=lrp-ls1lp1 \
    addresses='"f0:00:00:00:00:01 192.168.0.1"'

# Add router ls2p2 port to gateway router
ovn-nbctl lrp-add lr0 lrp-ls2lp1 f0:00:00:00:00:02 192.168.1.1/24
ovn-nbctl lsp-add ls2 ls2lp1 -- set Logical_Switch_Port ls2lp1 \
    type=router options:router-port=lrp-ls2lp1 \
    addresses='"f0:00:00:00:00:02 192.168.1.1"'

# Set default gateway (nexthop) to 192.168.1.254
ovn-nbctl lr-route-add lr0 "0.0.0.0/0" 192.168.1.254 lrp-ls2lp1

# Create logical port ls1lp2 in ls1
ovn-nbctl lsp-add ls1 ls1lp2 \
-- lsp-set-addresses ls1lp2 "f0:00:00:00:00:03 192.168.0.2"

# Create logical port ls2lp2 in ls2
ovn-nbctl lsp-add ls2 ls2lp2 \
-- lsp-set-addresses ls2lp2 "f0:00:00:00:00:04 192.168.1.10"

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-ls1lp2 -- \
    set interface hv1-ls1lp2 external-ids:iface-id=ls1lp2 \
    options:tx_pcap=hv1/ls1lp2-tx.pcap \
    options:rxq_pcap=hv1/ls1lp2-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-ls2lp2 -- \
    set interface hv1-ls2lp2 external-ids:iface-id=ls2lp2 \
    options:tx_pcap=hv1/ls2lp2-tx.pcap \
    options:rxq_pcap=hv1/ls2lp2-rx.pcap \
    ofport-request=2

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

src_mac="f00000000003"
dst_mac="f00000000001"
src_ip=`ip_to_hex 192 168 0 2`
dst_ip=`ip_to_hex 8 8 8 8`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

# Send IP packet destined to 8.8.8.8 from lsp1lp2
as hv1 ovs-appctl netdev-dummy/receive hv1-ls1lp2 $packet

# ARP packet should be received with Target IP Address set to 192.168.1.254 and
# not 8.8.8.8

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/ls2lp2-tx.pcap | trim_zeros > packets
expected="fffffffffffff0000000000208060001080006040001f00000000002c0a80101000000000000c0a801fe"
echo $expected > expout
AT_CHECK([cat packets], [0], [expout])
cat packets

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([send gratuitous arp for nat ips in localnet])
ovn_start
# Create logical switch
ovn-nbctl ls-add ls0
# Create gateway router
ovn-nbctl create Logical_Router name=lr0 options:chassis=hv1
# Add router port to gateway router
ovn-nbctl lrp-add lr0 lrp0 f0:00:00:00:00:01 192.168.0.1/24
ovn-nbctl lsp-add ls0 lrp0-rp -- set Logical_Switch_Port lrp0-rp \
    type=router options:router-port=lrp0 addresses='"f0:00:00:00:00:01"'
# Add nat-address option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="f0:00:00:00:00:01 192.168.0.2"

net_add n1
sim_add hv1
as hv1
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0

ovn_attach n1 br-phys 192.168.0.1

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
AT_CHECK([ovs-vsctl add-port br-eth0 snoopvif -- set Interface snoopvif options:tx_pcap=hv1/snoopvif-tx.pcap options:rxq_pcap=hv1/snoopvif-rx.pcap])

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl --wait=hv lsp-set-options ln_port network_name=physnet1])

# Wait until the patch ports are created in hv1 to connect br-int to br-eth0
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-vsctl show | \
grep "Port patch-br-int-to-ln_port" | wc -l`])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Wait for packet to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 140])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros |sort | uniq > packets
AT_CHECK([sort packets], [0], [dnl
fffffffffffff0000000000108060001080006040001f00000000001c0a80001000000000000c0a80001
fffffffffffff0000000000108060001080006040001f00000000001c0a80002000000000000c0a80002
])

# Temporarily remove nat-addresses option to avoid race conditions
# due to GARP backoff
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses=""
# Let's use gw router port now
hv1_uuid=$(ovn-sbctl --bare --columns _uuid list chassis hv1)
ovn-nbctl remove logical_router lr0 options chassis
ovn-nbctl lrp-set-gateway-chassis lrp0 hv1 20
OVS_WAIT_UNTIL([
    cr_lrp0_ch=$(ovn-sbctl --bare --columns chassis list port_binding cr-lrp0)
    test "$cr_lrp0_ch" = $hv1_uuid
])
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="f0:00:00:00:00:03 192.168.0.3"

reset_pcap_file snoopvif hv1/snoopvif
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 140])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | sort | uniq | trim_zeros > packets
AT_CHECK([sort packets], [0], [dnl
fffffffffffff0000000000108060001080006040001f00000000001c0a80001000000000000c0a80001
fffffffffffff0000000000308060001080006040001f00000000003c0a80003000000000000c0a80003
])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([send gratuitous arp for l3gateway only on selected chassis])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
ovn_start

# Create logical switch
ovn-nbctl ls-add ls0
# Create gateway router
ovn-nbctl lr-add lr0
# Add router port to gateway router
ovn-nbctl lrp-add lr0 lr0-ls0 f0:00:00:00:00:01 192.168.0.1/24
ovn-nbctl lsp-add ls0 ls0-lr0 -- set Logical_Switch_Port ls0-lr0 \
    type=router options:router-port=lr0-ls0 addresses='"f0:00:00:00:00:01"'

# Create a localnet port.
ovn-nbctl lsp-add ls0 ln_port
ovn-nbctl lsp-set-addresses ln_port unknown
ovn-nbctl lsp-set-type ln_port localnet
ovn-nbctl --wait=hv lsp-set-options ln_port network_name=physnet1

# Prepare packets
touch empty_expected
echo "fffffffffffff0000000000108060001080006040001f00000000001c0a80001000000000000c0a80001" > arp_expected

net_add n1
sim_add hv1
as hv1
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0

ovn_attach n1 br-phys 192.168.0.10

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
AT_CHECK([ovs-vsctl add-port br-eth0 snoopvif -- set Interface snoopvif options:tx_pcap=hv1/snoopvif-tx.pcap options:rxq_pcap=hv1/snoopvif-rx.pcap])

sim_add hv2
as hv2
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0

ovn_attach n1 br-phys 192.168.0.20

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
AT_CHECK([ovs-vsctl add-port br-eth0 snoopvif -- set Interface snoopvif options:tx_pcap=hv2/snoopvif-tx.pcap options:rxq_pcap=hv2/snoopvif-rx.pcap])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Wait until the patch ports are created in hv1 and hv2 to connect br-int to br-eth0
AT_CHECK([ovn-nbctl set logical_router lr0 options:chassis=hv1])
OVN_WAIT_PATCH_PORT_FLOWS(["ln_port"], ["hv1"])
AT_CHECK([ovn-nbctl set logical_router lr0 options:chassis=hv2])
OVN_WAIT_PATCH_PORT_FLOWS(["ln_port"], ["hv2"])

# Temporarily remove lr0 chassis
# Wait for hv confirmation to make sure chassis is removed before we reset pcap
# Otherwise a garp might be sent after pcap have been reset but before chassis is removed
AT_CHECK([ovn-nbctl --wait=hv remove logical_router lr0 options chassis])

as hv1 reset_pcap_file snoopvif hv1/snoopvif
as hv2 reset_pcap_file snoopvif hv2/snoopvif

hv1_uuid=$(ovn-sbctl --bare --columns _uuid list chassis hv1)
AT_CHECK([ovn-nbctl set logical_router lr0 options:chassis=hv1])
OVS_WAIT_UNTIL([
    ls0_lr0=$(ovn-sbctl --bare --columns chassis list port_binding ls0-lr0)
    test "$ls0_lr0" = $hv1_uuid
])

sleep 2
OVN_CHECK_PACKETS_CONTAIN([hv1/snoopvif-tx.pcap], [arp_expected])
OVN_CHECK_PACKETS([hv2/snoopvif-tx.pcap], [empty_expected])

# Temporarily remove lr0 chassis
AT_CHECK([ovn-nbctl remove logical_router lr0 options chassis])

as hv1 reset_pcap_file snoopvif hv1/snoopvif
as hv2 reset_pcap_file snoopvif hv2/snoopvif

hv2_uuid=$(ovn-sbctl --bare --columns _uuid list chassis hv2)
AT_CHECK([ovn-nbctl set logical_router lr0 options:chassis=hv2])
OVS_WAIT_UNTIL([
    ls0_lr0=$(ovn-sbctl --bare --columns chassis list port_binding ls0-lr0)
    test "$ls0_lr0" = $hv2_uuid
])

sleep 2
OVN_CHECK_PACKETS_CONTAIN([hv2/snoopvif-tx.pcap], [arp_expected])
OVN_CHECK_PACKETS([hv1/snoopvif-tx.pcap], [empty_expected])

# Temporarily remove lr0 chassis
AT_CHECK([ovn-nbctl --wait=hv remove logical_router lr0 options chassis])

as hv1 reset_pcap_file snoopvif hv1/snoopvif
as hv2 reset_pcap_file snoopvif hv2/snoopvif

AT_CHECK([ovn-nbctl --wait=hv set logical_router lr0 options:chassis=hv1])
# set garp max timeout to 2s
AT_CHECK([as hv1 ovs-vsctl set Open_vSwitch . external-ids:garp-max-timeout-sec=2])

OVS_WAIT_UNTIL([
n_arp=$(tcpdump -c 10 -ner hv1/snoopvif-tx.pcap arp | wc -l)
test "$n_arp" = 10
])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([send gratuitous arp with nat-addresses router in localnet])
ovn_start
# Create logical switch
ovn-nbctl ls-add ls0
# Create gateway router
ovn-nbctl create Logical_Router name=lr0 options:chassis=hv1
# Add router port to gateway router
ovn-nbctl lrp-add lr0 lrp0 f0:00:00:00:00:01 192.168.0.1/24
ovn-nbctl lsp-add ls0 lrp0-rp -- set Logical_Switch_Port lrp0-rp \
    type=router options:router-port=lrp0 addresses='"f0:00:00:00:00:01"'
# Add nat-address option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"
# Add NAT rules
AT_CHECK([ovn-nbctl lr-nat-add lr0 snat 192.168.0.1 10.0.0.0/24])
AT_CHECK([ovn-nbctl lr-nat-add lr0 dnat 192.168.0.2 10.0.0.1])
# Add load balancers
AT_CHECK([ovn-nbctl lb-add lb0 192.168.0.3:80 10.0.0.2:80,10.0.0.3:80])
AT_CHECK([ovn-nbctl lr-lb-add lr0 lb0])
AT_CHECK([ovn-nbctl lb-add lb1 192.168.0.3:8080 10.0.0.2:8080,10.0.0.3:8080])
AT_CHECK([ovn-nbctl lr-lb-add lr0 lb1])

net_add n1
sim_add hv1
as hv1
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0

ovn_attach n1 br-phys 192.168.0.1

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
AT_CHECK([ovs-vsctl add-port br-eth0 snoopvif -- set Interface snoopvif options:tx_pcap=hv1/snoopvif-tx.pcap options:rxq_pcap=hv1/snoopvif-rx.pcap])

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])

# Wait until the patch ports are created to connect br-int to br-eth0
OVS_WAIT_UNTIL([test 1 = `ovs-vsctl show | \
grep "Port patch-br-int-to-ln_port" | wc -l`])

ovn-sbctl list port_binding lrp0-rp
echo "*****"
ovn-nbctl list logical_switch_port lrp0-rp
ovn-nbctl list logical_router_port lrp0
ovn-nbctl show
# Wait for packet to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 50])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros | sort | uniq > packets
expected="fffffffffffff0000000000108060001080006040001f00000000001c0a80001000000000000c0a80001"
echo $expected > expout
expected="fffffffffffff0000000000108060001080006040001f00000000001c0a80002000000000000c0a80002"
echo $expected >> expout
expected="fffffffffffff0000000000108060001080006040001f00000000001c0a80003000000000000c0a80003"
echo $expected >> expout
AT_CHECK([sort packets], [0], [expout])

# Temporarily remove nat-addresses option to avoid race conditions
# due to GARP backoff
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses=""

as hv1 reset_pcap_file snoopvif hv1/snoopvif

# Re-add nat-addresses option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router" exclude-lb-vips-from-garp="true"

# Wait for packets to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 250])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros > packets
g0="fffffffffffff0000000000108060001080006040001f00000000001c0a80001000000000000c0a80001"
echo $g0 > expout
g1="fffffffffffff0000000000108060001080006040001f00000000001c0a80002000000000000c0a80002"
echo $g1 >> expout

grep $g0 packets | head -1 > exp
grep $g1 packets | head -1 >> exp
AT_CHECK([cat exp], [0], [expout])

g3="fffffffffffff0000000000108060001080006040001f00000000001c0a80003000000000000c0a80003"
AT_CHECK([grep -q $g3 packets], [1])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([send reverse arp for router without ipv4 address])
ovn_start
# Create logical switch
ovn-nbctl ls-add ls0
# Create gateway router
ovn-nbctl create Logical_Router name=lr0 options:chassis=hv1
# Add router port to gateway router
ovn-nbctl lrp-add lr0 lrp0 f0:00:00:00:00:01 fd12:3456:789a:1::1/64
ovn-nbctl lsp-add ls0 lrp0-rp -- set Logical_Switch_Port lrp0-rp \
    type=router options:router-port=lrp0 addresses='"f0:00:00:00:00:01"'
# Add nat-address option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"

net_add n1
sim_add hv1
as hv1
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0

ovn_attach n1 br-phys fd12:3456:789a:1::1 64

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
AT_CHECK([ovs-vsctl add-port br-eth0 snoopvif -- set Interface snoopvif options:tx_pcap=hv1/snoopvif-tx.pcap options:rxq_pcap=hv1/snoopvif-rx.pcap])

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])

# Wait until the patch ports are created to connect br-int to br-eth0
OVS_WAIT_UNTIL([test 1 = `ovs-vsctl show | \
grep "Port patch-br-int-to-ln_port" | wc -l`])

ovn-sbctl list port_binding lrp0-rp
echo "*****"
ovn-nbctl list logical_switch_port lrp0-rp
ovn-nbctl list logical_router_port lrp0
ovn-nbctl show
# Wait for packet to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 50])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap  | sort | uniq > packets
expected="fffffffffffff0000000000180350001080006040003f0000000000100000000f0000000000100000000"
echo $expected > expout
AT_CHECK([sort packets], [0], [expout])

# Temporarily remove nat-addresses option to avoid race conditions
# due to GARP backoff
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses=""

as hv1 reset_pcap_file snoopvif hv1/snoopvif

# Re-add nat-addresses option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router" exclude-lb-vips-from-garp="true"

# Wait for packets to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 50])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap  > packets
expected="fffffffffffff0000000000180350001080006040003f0000000000100000000f0000000000100000000"
echo $expected > expout
AT_CHECK([sort packets], [0], [expout])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([delete mac bindings])
ovn_start
net_add n1
sim_add hv1
as hv1
ovs-vsctl -- add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
# Create logical router lr0
ovn-nbctl lr-add lr0
# Create ports lrp0, lrp1 in lr0
ovn-nbctl lrp-add lr0 lrp0 f0:00:00:00:00:01 192.168.0.1/24
ovn-nbctl lrp-add lr0 lrp1 f0:00:00:00:00:02 192.168.1.1/24
dp_uuid=$(fetch_column Datapath_Binding _uuid)
ovn-sbctl create MAC_Binding ip=10.0.0.1 datapath=$dp_uuid logical_port=lrp0 mac="mac1"
ovn-sbctl create MAC_Binding ip=10.0.0.1 datapath=$dp_uuid logical_port=lrp1 mac="mac2"
ovn-sbctl find MAC_Binding
# Delete port lrp0 and check that its MAC_Binding is deleted.
ovn-nbctl lrp-del lrp0
ovn-sbctl find MAC_Binding
wait_row_count MAC_Binding 0 logical_port=lrp0
# Delete logical switch lr0 and check that its MAC_Binding is deleted.
ovn-nbctl lr-del lr0
ovn-sbctl find MAC_Binding
wait_row_count MAC_Binding 0

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([conntrack zone allocation])
ovn_start

# Logical network:
# 2 logical switches "foo" (192.168.1.0/24) and "bar" (172.16.1.0/24)
# connected to a router R1.
# foo has foo1 to act as a client.
# bar has bar1, bar2, bar3 to act as servers.

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
for i in foo1 bar1 bar2 bar3; do
    ovs-vsctl -- add-port br-int $i -- \
        set interface $i external-ids:iface-id=$i \
        options:tx_pcap=hv1/$i-tx.pcap \
        options:rxq_pcap=hv1/$i-rx.pcap
done

ovn-nbctl create Logical_Router name=R1
ovn-nbctl ls-add foo
ovn-nbctl ls-add bar

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 172.16.1.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port bar1, bar2 and bar3 in bar
for i in `seq 1 3`; do
    ip=`expr $i + 1`
    ovn-nbctl lsp-add bar bar$i \
    -- lsp-set-addresses bar$i "f0:00:0a:01:02:$i 172.16.1.$ip"
done

OVS_WAIT_UNTIL([test `ovs-ofctl dump-flows br-int table=0 | grep REG13 | wc -l` -eq 4])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([tag allocation])
ovn_start

AT_CHECK([ovn-nbctl ls-add ls0])
AT_CHECK([ovn-nbctl lsp-add ls0 parent1])
AT_CHECK([ovn-nbctl lsp-add ls0 parent2])
AT_CHECK([ovn-nbctl ls-add ls1])

AS_BOX([requested tag for parent1])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c0 parent1 3])
c0_tag=$(ovn-nbctl lsp-get-tag c0)
echo c0_tag=$c0_tag
check test "$c0_tag" = 3
dnl The same 'tag' gets created in southbound database.
check_row_count Port_Binding 1 logical_port=c0 tag=$c0_tag

AS_BOX([tag allocation 1 for parent1])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c1 parent1 0])
c1_tag=$(ovn-nbctl lsp-get-tag c1)
echo c1_tag=$c1_tag
check test "$c1_tag" != "$c0_tag"
check_row_count Port_Binding 1 logical_port=c1 tag=$c1_tag

AS_BOX([tag allocation 2 for parent1])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c2 parent1 0])
c2_tag=$(ovn-nbctl lsp-get-tag c2)
echo c2_tag=$c2_tag
check test "$c2_tag" != "$c0_tag"
check test "$c2_tag" != "$c1_tag"
check_row_count Port_Binding 1 logical_port=c2 tag=$c2_tag

AS_BOX([tag allocation 3 for parent1])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c3 parent1 0])
c3_tag=$(ovn-nbctl lsp-get-tag c3)
echo c3_tag=$c3_tag
check test "$c3_tag" != "$c0_tag"
check test "$c3_tag" != "$c1_tag"
check test "$c3_tag" != "$c2_tag"
check_row_count Port_Binding 1 logical_port=c3 tag=$c3_tag

AS_BOX([tag allocation 1 for parent2])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c4 parent2 0])
c4_tag=$(ovn-nbctl lsp-get-tag c4)
echo c4_tag=$c4_tag
check_row_count Port_Binding 1 logical_port=c4 tag=$c4_tag

AS_BOX([tag allocation 2 for parent2])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c5 parent2 0])
c5_tag=$(ovn-nbctl lsp-get-tag c5)
echo c5_tag=$c5_tag
check test "$c5_tag" != "$c4_tag"
check_row_count Port_Binding 1 logical_port=c5 tag=$c5_tag

AS_BOX([delete and add tag allocation for parent1])
AT_CHECK([ovn-nbctl --wait=sb lsp-del c1])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c6 parent1 0])
c6_tag=$(ovn-nbctl lsp-get-tag c6)
echo c6_tag=$c6_tag
check_row_count Port_Binding 1 logical_port=c6 tag=$c6_tag
check test "$c6_tag" != "$c0_tag"
check test "$c6_tag" != "$c2_tag"
check test "$c6_tag" != "$c3_tag"

AS_BOX([restart northd and make sure tag allocation is stable])
as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])
start_daemon NORTHD_TYPE \
    --ovnnb-db=unix:"$ovs_base"/ovn-nb/ovn-nb.sock \
    --ovnsb-db=unix:"$ovs_base"/ovn-sb/ovn-sb.sock

dnl Create a switch to make sure that ovn-northd has run through the main loop.
AT_CHECK([ovn-nbctl --wait=sb ls-add ls-dummy])

AT_CHECK_UNQUOTED([
    for lsp in c0 c2 c3 c4 c5 c6; do
        ovn-nbctl lsp-get-tag $lsp
    done], [0],
[$c0_tag
$c2_tag
$c3_tag
$c4_tag
$c5_tag
$c6_tag
])

dnl Create a switch port with a tag that has already been allocated.
dnl It should go through fine with a duplicate tag.
AS_BOX([request duplicate tag])
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls1 c7 parent2 $c5_tag])
AT_CHECK([ovn-nbctl lsp-get-tag c7], [0], [2
])
check_row_count Port_Binding 1 logical_port=c7 tag=$c5_tag
check_row_count Port_Binding 1 logical_port=c5 tag=$c5_tag
check_row_count Port_Binding 2 parent_port=parent2 tag=$c5_tag

AS_BOX([tag_request without parent_name])
AT_CHECK([ovn-nbctl ls-add ls2])
dnl When there is no parent_name provided (for say, 'localnet'), 'tag_request'
dnl gets copied to 'tag'
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls2 local0 "" 25])
AT_CHECK([ovn-nbctl lsp-get-tag local0], [0], [25
])
dnl The same 'tag' gets created in southbound database.
AT_CHECK([ovn-sbctl --data=bare --no-heading --columns=tag find port_binding \
logical_port="local0"], [0], [25
])
dnl If 'tag_request' is 0 for localnet, nothing gets written to 'tag'
AT_CHECK([ovn-nbctl --wait=sb lsp-add ls2 local1 "" 0])
AT_CHECK([ovn-nbctl lsp-get-tag local1])
dnl change the tag_request.
AT_CHECK([ovn-nbctl --wait=sb  set logical_switch_port local1 tag_request=50])
AT_CHECK([ovn-nbctl lsp-get-tag local1], [0], [50
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([lsp deletion and broadcast-flow deletion on localnet])
ovn_start
ovn-nbctl ls-add lsw0
net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    ovs-vsctl add-br br-eth0
    AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0])
done

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add lsw0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])


# Create 3 vifs.
AT_CHECK([ovn-nbctl lsp-add lsw0 localvif1])
AT_CHECK([ovn-nbctl lsp-set-addresses localvif1 "f0:00:00:00:00:01 192.168.1.1"])
AT_CHECK([ovn-nbctl lsp-set-port-security localvif1 "f0:00:00:00:00:01"])
AT_CHECK([ovn-nbctl lsp-add lsw0 localvif2])
AT_CHECK([ovn-nbctl lsp-set-addresses localvif2 "f0:00:00:00:00:02 192.168.1.2"])
AT_CHECK([ovn-nbctl lsp-set-port-security localvif2 "f0:00:00:00:00:02"])
AT_CHECK([ovn-nbctl lsp-add lsw0 localvif3])
AT_CHECK([ovn-nbctl lsp-set-addresses localvif3 "f0:00:00:00:00:03 192.168.1.3"])
AT_CHECK([ovn-nbctl lsp-set-port-security localvif3 "f0:00:00:00:00:03"])

# Bind the localvif1 to hv1.
as hv1
AT_CHECK([ovs-vsctl add-port br-int localvif1 -- set Interface localvif1 external_ids:iface-id=localvif1])

# On hv1, check that there are no flows outputting bcast to tunnel
OVS_WAIT_UNTIL([test `ovs-ofctl dump-flows br-int table=37 | ofctl_strip | grep output | wc -l` -eq 0])

# On hv2, check that no flow outputs bcast to tunnel to hv1.
as hv2
OVS_WAIT_UNTIL([test `ovs-ofctl dump-flows br-int table=37 | ofctl_strip | grep output | wc -l` -eq 0])

# Now bind vif2 on hv2.
AT_CHECK([ovs-vsctl add-port br-int localvif2 -- set Interface localvif2 external_ids:iface-id=localvif2])

# At this point, the broadcast flow on vif2 should be deleted.
# because, there is now a localnet vif bound (table=37 programming logic)
OVS_WAIT_UNTIL([test `ovs-ofctl dump-flows br-int table=37 | ofctl_strip | grep output | wc -l` -eq 0])

# Verify that the local net patch port exists on hv2.
OVS_WAIT_UNTIL([test `ovs-vsctl show | grep "Port patch-br-int-to-ln_port" | wc -l` -eq 1])

# Now bind vif3 on hv2.
AT_CHECK([ovs-vsctl add-port br-int localvif3 -- set Interface localvif3 external_ids:iface-id=localvif3])

# Verify that the local net patch port still exists on hv2
OVS_WAIT_UNTIL([test `ovs-vsctl show | grep "Port patch-br-int-to-ln_port" | wc -l` -eq 1])

# Delete localvif2
AT_CHECK([ovn-nbctl lsp-del localvif2])

# Verify that the local net patch port still exists on hv2,
# because, localvif3 is still bound.
OVS_WAIT_UNTIL([test `ovs-vsctl show | grep "Port patch-br-int-to-ln_port" | wc -l` -eq 1])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL logging])
AT_KEYWORDS([ovn])
ovn_start

net_add n1

sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
for i in lp1 lp2; do
    ovs-vsctl -- add-port br-int $i -- \
        set interface $i external-ids:iface-id=$i \
        options:tx_pcap=hv/$i-tx.pcap \
        options:rxq_pcap=hv/$i-rx.pcap
done

lp1_mac="f0:00:00:00:00:01"
lp1_ip="192.168.1.2"

lp2_mac="f0:00:00:00:00:02"
lp2_ip="192.168.1.3"

ovn-nbctl ls-add lsw0
ovn-nbctl --wait=sb lsp-add lsw0 lp1
ovn-nbctl --wait=sb lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp1 $lp1_mac
ovn-nbctl lsp-set-addresses lp2 $lp2_mac
ovn-nbctl --wait=sb sync
wait_for_ports_up

ovn-nbctl acl-add lsw0 from-lport 1000 'tcp.dst==80' drop
ovn-nbctl --log --severity=alert --name=drop-flow acl-add lsw0 from-lport 1000 'tcp.dst==81' drop

ovn-nbctl acl-add lsw0 to-lport 1000 'tcp.dst==180' drop
ovn-nbctl --log --severity=alert --name=drop-flow acl-add lsw0 to-lport 1000 'tcp.dst==181' drop

ovn-nbctl acl-add lsw0 from-lport 1000 'tcp.dst==82' allow
ovn-nbctl --log --severity=info --name=allow-flow acl-add lsw0 from-lport 1000 'tcp.dst==83' allow

ovn-nbctl acl-add lsw0 to-lport 1000 'tcp.dst==82' allow
ovn-nbctl --log --severity=info --name=allow-flow acl-add lsw0 to-lport 1000 'tcp.dst==83' allow

ovn-nbctl acl-add lsw0 from-lport 1000 'tcp.dst==84' allow-related
ovn-nbctl --log acl-add lsw0 from-lport 1000 'tcp.dst==85' allow-related

ovn-nbctl acl-add lsw0 to-lport 1000 'tcp.dst==84' allow-related
ovn-nbctl --log acl-add lsw0 to-lport 1000 'tcp.dst==85' allow-related

ovn-nbctl acl-add lsw0 from-lport 1000 'tcp.dst==86' reject
ovn-nbctl --log --severity=alert --name=reject-flow acl-add lsw0 from-lport 1000 'tcp.dst==87' reject

ovn-nbctl acl-add lsw0 to-lport 1000 'tcp.dst==186' reject
ovn-nbctl --log --severity=alert --name=reject-flow acl-add lsw0 to-lport 1000 'tcp.dst==187' reject

ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Send packet that should be dropped without logging in the ingress pipeline.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4360 && tcp.dst==80"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should be dropped with logging in the ingress pipeline.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4361 && tcp.dst==81"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should be dropped without logging in the eggress pipeline.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4360 && tcp.dst==180"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should be dropped with logging in the egress pipeline.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4361 && tcp.dst==181"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should be allowed without logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4362 && tcp.dst==82"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should be allowed with logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4363 && tcp.dst==83"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should allow related flows without logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4364 && tcp.dst==84"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should allow related flows with logging.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4365 && tcp.dst==85"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should be rejected without logging in the ingress pipeline.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4366 && tcp.dst==86"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should be rejected with logging in the ingress pipeline.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4367 && tcp.dst==87"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should be rejected without logging in the egress pipeline.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4366 && tcp.dst==186"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Send packet that should be rejected with logging in the egress pipeline.
packet="inport==\"lp1\" && eth.src==$lp1_mac && eth.dst==$lp2_mac &&
        ip4 && ip.ttl==64 && ip4.src==$lp1_ip && ip4.dst==$lp2_ip &&
        tcp && tcp.flags==2 && tcp.src==4367 && tcp.dst==187"
OVS_WAIT_UNTIL([as hv ovs-appctl -t ovn-controller inject-pkt "$packet"])

OVS_WAIT_UNTIL([ test 8 = $(grep -c 'acl_log' hv/ovn-controller.log) ])

AT_CHECK([grep 'acl_log' hv/ovn-controller.log | sed 's/.*name=/name=/' | strip_nw_frag], [0], [dnl
name="drop-flow", verdict=drop, severity=alert, direction=from-lport: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4361,tp_dst=81,tcp_flags=syn
name="drop-flow", verdict=drop, severity=alert, direction=to-lport: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4361,tp_dst=181,tcp_flags=syn
name="allow-flow", verdict=allow, severity=info, direction=from-lport: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4363,tp_dst=83,tcp_flags=syn
name="allow-flow", verdict=allow, severity=info, direction=to-lport: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4363,tp_dst=83,tcp_flags=syn
name="<unnamed>", verdict=allow, severity=info, direction=from-lport: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4365,tp_dst=85,tcp_flags=syn
name="<unnamed>", verdict=allow, severity=info, direction=to-lport: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4365,tp_dst=85,tcp_flags=syn
name="reject-flow", verdict=reject, severity=alert, direction=from-lport: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4367,tp_dst=87,tcp_flags=syn
name="reject-flow", verdict=reject, severity=alert, direction=to-lport: tcp,vlan_tci=0x0000,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,nw_src=192.168.1.2,nw_dst=192.168.1.3,nw_tos=0,nw_ecn=0,nw_ttl=64,tp_src=4367,tp_dst=187,tcp_flags=syn
])

OVN_CLEANUP([hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL rate-limited logging])
AT_KEYWORDS([ovn])
ovn_start

net_add n1

sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
for i in lp1 lp2; do
    ovs-vsctl -- add-port br-int $i -- \
        set interface $i external-ids:iface-id=$i \
        options:tx_pcap=hv/$i-tx.pcap \
        options:rxq_pcap=hv/$i-rx.pcap
done

lp1_mac="f0:00:00:00:00:01"
lp1_ip="192.168.1.2"

lp2_mac="f0:00:00:00:00:02"
lp2_ip="192.168.1.3"

ovn-nbctl ls-add lsw0
ovn-nbctl --wait=sb lsp-add lsw0 lp1
ovn-nbctl --wait=sb lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp1 $lp1_mac
ovn-nbctl lsp-set-addresses lp2 $lp2_mac
ovn-nbctl --wait=sb sync
wait_for_ports_up


# Add an ACL that rate-limits logs at 10 per second.
ovn-nbctl meter-add http-rl1 drop 10 pktps
ovn-nbctl --log --severity=alert --meter=http-rl1 --name=http-acl1 acl-add lsw0 to-lport 1000 'tcp.dst==80' drop
check ovn-nbctl --wait=hv sync

# Add an ACL that rate-limits logs at 5 per second.
ovn-nbctl meter-add http-rl2 drop 5 pktps
ovn-nbctl --log --severity=alert --meter=http-rl2 --name=http-acl2 acl-add lsw0 to-lport 1000 'tcp.dst==81' allow
check ovn-nbctl --wait=hv sync

# Add an ACL that doesn't rate-limit logs.
ovn-nbctl --log --severity=alert --name=http-acl3 acl-add lsw0 to-lport 1000 'tcp.dst==82' drop
ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# For each ACL, send 100 packets.
for i in `seq 1 100`; do
    ovs-appctl netdev-dummy/receive lp1 'in_port(1),eth(src=f0:00:00:00:00:01,dst=f0:00:00:00:00:02),eth_type(0x0800),ipv4(src=192.168.1.2,dst=192.168.1.3,proto=6,tos=0,ttl=64,frag=no),tcp(src=7777,dst=80)'

    ovs-appctl netdev-dummy/receive lp1 'in_port(1),eth(src=f0:00:00:00:00:01,dst=f0:00:00:00:00:02),eth_type(0x0800),ipv4(src=192.168.1.2,dst=192.168.1.3,proto=6,tos=0,ttl=64,frag=no),tcp(src=7777,dst=81)'

    ovs-appctl netdev-dummy/receive lp1 'in_port(1),eth(src=f0:00:00:00:00:01,dst=f0:00:00:00:00:02),eth_type(0x0800),ipv4(src=192.168.1.2,dst=192.168.1.3,proto=6,tos=0,ttl=64,frag=no),tcp(src=7777,dst=82)'
done

# The rate at which packets are sent is highly system-dependent, so we
# can't count on precise drop counts.  To work around that, we just
# check that exactly 100 "http-acl3" actions were logged and that there
# were more "http-acl1" actions than "http-acl2" ones.
OVS_WAIT_UNTIL([ test 100 = $(grep -c 'http-acl3' hv/ovn-controller.log) ])

# On particularly slow or overloaded systems, the transmission rate may
# be lower than the configured meter rate.  To prevent false test
# failures, we check the duration count of the meter, and if it's
# greater than nine seconds, just skip the test.
d_secs=$(as hv ovs-ofctl -O OpenFlow13 meter-stats br-int | grep "meter:1" | sed 's/.* duration:\([[0-9]]\{1,\}\)\.[[0-9]]\+s .*/\1/')

echo "Meter duration: $d_secs"
AT_SKIP_IF([test $d_secs -gt 9])

# Print some information that may help debugging.
AT_CHECK([as hv ovs-appctl -t ovn-controller meter-table-list], [0], [dnl
http-rl1: 1
http-rl2: 2
])
as hv ovs-ofctl -O OpenFlow13 meter-stats br-int

n_acl1=$(grep -c 'http-acl1' hv/ovn-controller.log)
n_acl2=$(grep -c 'http-acl2' hv/ovn-controller.log)
n_acl3=$(grep -c 'http-acl3' hv/ovn-controller.log)

AT_CHECK([ test $n_acl3 -gt $n_acl1 ], [0], [])
AT_CHECK([ test $n_acl1 -gt $n_acl2 ], [0], [])

OVN_CLEANUP([hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([same meter used by multiple logical flows])
AT_KEYWORDS([ovn])
ovn_start

net_add n1

sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
for i in lp1 lp2; do
    ovs-vsctl -- add-port br-int $i -- \
        set interface $i external-ids:iface-id=$i \
        options:tx_pcap=hv/$i-tx.pcap \
        options:rxq_pcap=hv/$i-rx.pcap
done

lp1_mac="f0:00:00:00:00:01"
lp1_ip="192.168.1.2"

lp2_mac="f0:00:00:00:00:02"
lp2_ip="192.168.1.3"

ovn-nbctl ls-add lsw0
ovn-nbctl --wait=sb lsp-add lsw0 lp1
ovn-nbctl --wait=sb lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp1 $lp1_mac
ovn-nbctl lsp-set-addresses lp2 $lp2_mac
ovn-nbctl --wait=sb sync
wait_for_ports_up

ovn-appctl -t ovn-controller vlog/set file:dbg

# Add acl1 and acl2 using same meter.
ovn-nbctl meter-add http-rl1 drop 10 pktps
ovn-nbctl --log --meter=http-rl1 acl-add lsw0 to-lport 1000 'tcp.dst==80' drop \
       -- --log --meter=http-rl1 acl-add lsw0 to-lport 1000 'tcp.dst==81' allow

ovn-nbctl --wait=hv sync

AT_CHECK([ovs-ofctl -O OpenFlow13 dump-meters br-int | grep meter], [0], [ignore], [ignore])

# Delete acl1, meter should be kept in OVS
ovn-nbctl acl-del lsw0 to-lport 1000 'tcp.dst==80'
ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl -O OpenFlow13 dump-meters br-int | grep meter], [0], [ignore], [ignore])

# Delete acl2, meter should be deleted in OVS
ovn-nbctl acl-del lsw0 to-lport 1000 'tcp.dst==81'
ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl -O OpenFlow13 dump-meters br-int | grep meter], [1])

OVN_CLEANUP([hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DSCP marking and meter check])
AT_KEYWORDS([ovn])
ovn_start

check ovn-nbctl ls-add lsw0
check ovn-nbctl --wait=sb lsp-add lsw0 lp1
check ovn-nbctl --wait=sb lsp-add lsw0 lp2
check ovn-nbctl --wait=sb lsp-add lsw0 lp3
check ovn-nbctl lsp-set-addresses lp1 f0:00:00:00:00:01
check ovn-nbctl lsp-set-addresses lp2 f0:00:00:00:00:02
check ovn-nbctl lsp-set-addresses lp3 f0:00:00:00:00:03
check ovn-nbctl lsp-set-port-security lp1 f0:00:00:00:00:01
check ovn-nbctl lsp-set-port-security lp2 f0:00:00:00:00:02
check ovn-nbctl --wait=sb sync
net_add n1
sim_add hv
as hv
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1 options:tx_pcap=vif1-tx.pcap options:rxq_pcap=vif1-rx.pcap ofport-request=1
check ovs-vsctl add-port br-int vif2 -- set Interface vif2 external-ids:iface-id=lp2 options:tx_pcap=vif2-tx.pcap options:rxq_pcap=vif2-rx.pcap ofport-request=2
wait_for_ports_up lp1 lp2

# Extracts nw_tos from the final flow from ofproto/trace output and prints
# it on stdout.  Prints "none" if no nw_tos was included.
get_final_nw_tos() {
    if flow=$(grep '^Final flow:' stdout); then :; else
       # The output didn't have a final flow.
       return 99
    fi

    tos=$(echo "$flow" | sed -n 's/.*nw_tos=\([[0-9]]\{1,\}\).*/\1/p')
    case $tos in
        '') echo none ;;
        *) echo $tos ;;
    esac
}

# check_tos TOS
#
# Checks that a packet from 1.1.1.1 to 1.1.1.2 gets its DSCP set to TOS.
check_tos() {
    # First check with ovn-trace for logical flows.
    echo "checking for tos $1"
    (if test $1 != 0; then echo "ip.dscp = $1;"; fi;
     echo 'output("lp2");') > expout
    AT_CHECK_UNQUOTED([ovn_trace --minimal lsw0 'inport == "lp1" && eth.src == f0:00:00:00:00:01 && eth.dst == f0:00:00:00:00:02 && ip4.src == 1.1.1.1 && ip4.dst == 1.1.1.2'], [0], [expout])

    # Then re-check with ofproto/trace for a physical packet.
    AT_CHECK([ovs-appctl ofproto/trace br-int 'in_port=1,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02,dl_type=0x800,nw_src=1.1.1.1,nw_dst=1.1.1.2'], [0], [stdout-nolog])
    AT_CHECK_UNQUOTED([get_final_nw_tos], [0], [`expr $1 \* 4`
])
}

# check at L2
AT_CHECK([ovn_trace --minimal lsw0 'inport == "lp1" && eth.src == f0:00:00:00:00:01 && eth.dst == f0:00:00:00:00:02'], [0], [output("lp2");
])
AT_CHECK([ovs-appctl ofproto/trace br-int 'in_port=1,dl_src=f0:00:00:00:00:01,dl_dst=f0:00:00:00:00:02'], [0], [stdout-nolog])
AT_CHECK([get_final_nw_tos], [0], [none
])

# check at L3 without dscp marking
check_tos 0

# Mark DSCP with a valid value
qos_id=$(ovn-nbctl --wait=hv -- --id=@lp1-qos create QoS priority=100 action=dscp=48 match="inport\=\=\"lp1\"\ &&\ is_chassis_resident(\"lp1\")" direction="from-lport" -- set Logical_Switch lsw0 qos_rules=@lp1-qos)
as hv check_row_count nb:QoS 1
check_tos 48

# check at hv without qos meter
AT_CHECK([as hv ovs-ofctl dump-flows br-int -O OpenFlow13 | grep meter | wc -l], [0], [0
])

# Update the meter rate
check ovn-nbctl --wait=hv set QoS $qos_id bandwidth=rate=100

# check at hv with a qos meter table
AT_CHECK([as hv ovs-ofctl dump-meters br-int -O OpenFlow13 | grep rate=100 | wc -l], [0], [1
])
AT_CHECK([as hv ovs-ofctl dump-flows br-int -O OpenFlow13 | grep meter | wc -l], [0], [1
])

# Update the DSCP marking
check ovn-nbctl --wait=hv set QoS $qos_id action=dscp=63
check_tos 63

# Update the meter rate
check ovn-nbctl --wait=hv set QoS $qos_id bandwidth=rate=4294967295,burst=4294967295

# check at hv with a qos meter table
AT_CHECK([as hv ovs-ofctl dump-meters br-int -O OpenFlow13 | grep burst_size=4294967295 | wc -l], [0], [1
])
AT_CHECK([as hv ovs-ofctl dump-flows br-int -O OpenFlow13 | grep meter | wc -l], [0], [1
])

check ovn-nbctl --wait=hv set QoS $qos_id match="outport\=\=\"lp2\"" direction="to-lport"
check_tos 63

# Disable DSCP marking
check ovn-nbctl --wait=hv qos-del lsw0
as hv check_row_count nb:QoS 0
check_tos 0

# check at hv without qos meter
AT_CHECK([as hv ovs-ofctl dump-flows br-int -O OpenFlow13 | grep meter | wc -l], [0], [0
])

# check meter with chassis not resident
check ovn-nbctl --wait=hv qos-add lsw0 to-lport 1001 'inport=="lp3" && is_chassis_resident("lp3")' rate=11123 burst=111230
as hv check_row_count nb:QoS 1

# check no meter table
AT_CHECK([as hv ovs-ofctl dump-flows br-int -O OpenFlow13 | grep meter | wc -l], [0], [0
])
AT_CHECK([as hv ovs-ofctl dump-meters br-int -O OpenFlow13 | grep rate=11123 | wc -l], [0], [0
])

# Check multiple qos meters
check ovn-nbctl qos-del lsw0
check ovn-nbctl qos-add lsw0 to-lport 1001 'inport=="lp1" && is_chassis_resident("lp1")' rate=100000 burst=100000
check ovn-nbctl qos-add lsw0 to-lport 1001 'inport=="lp2" && is_chassis_resident("lp2")' rate=100000 burst=100000
check ovn-nbctl qos-add lsw0 to-lport 1002 'inport=="lp1" && is_chassis_resident("lp1")' rate=100001 burst=100001
check ovn-nbctl --wait=hv qos-add lsw0 to-lport 1002 'inport=="lp2" && is_chassis_resident("lp2")' rate=100001 burst=100001

AT_CHECK([as hv ovs-ofctl dump-meters br-int -O OpenFlow13 | grep meter | wc -l], [0], [4
])

check ovn-nbctl --wait=hv qos-del lsw0
AT_CHECK([as hv ovs-ofctl dump-meters br-int -O OpenFlow13 | grep meter | wc -l], [0], [0
])

OVN_CLEANUP([hv])
AT_CLEANUP
])

AT_SETUP([read-only sb db:ptcp access])

: > .$1.db.~lock~
ovsdb-tool create ovn-sb.db "$abs_top_srcdir"/ovn-sb.ovsschema

# Add read-only remote to sb ovsdb-server
AT_CHECK(
  [ovsdb-tool transact ovn-sb.db \
     ['["OVN_Southbound",
       {"op": "insert",
        "table": "SB_Global",
        "row": {
          "connections": ["set", [["named-uuid", "xyz"]]]}},
       {"op": "insert",
        "table": "Connection",
        "uuid-name": "xyz",
        "row": {"target": "ptcp:0:127.0.0.1",
               "read_only": true}}]']], [0], [ignore], [ignore])

start_daemon ovsdb-server --remote=punix:ovn-sb.sock --remote=db:OVN_Southbound,SB_Global,connections ovn-sb.db

PARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])

# read-only accesses should succeed
AT_CHECK([ovn-sbctl --db=tcp:127.0.0.1:$TCP_PORT list SB_Global], [0], [stdout], [ignore])
AT_CHECK([ovn-sbctl --db=tcp:127.0.0.1:$TCP_PORT list Connection], [0], [stdout], [ignore])

# write access should fail
AT_CHECK([ovn-sbctl --db=tcp:127.0.0.1:$TCP_PORT chassis-add ch vxlan 1.2.4.8], [1], [ignore],
[ovn-sbctl: transaction error: {"details":"insert operation not allowed when database server is in read only mode","error":"not allowed"}
])

OVS_APP_EXIT_AND_WAIT([ovsdb-server])
AT_CLEANUP

AT_SETUP([read-only sb db:pssl access])
AT_SKIP_IF([test "$HAVE_OPENSSL" = no])
PKIDIR="$(cd $abs_top_builddir/tests && pwd)"
AT_SKIP_IF([expr "$PKIDIR" : ".*[[ 	'\"
\\]]"])

: > .$1.db.~lock~
ovsdb-tool create ovn-sb.db "$abs_top_srcdir"/ovn-sb.ovsschema

# Add read-only remote to sb ovsdb-server
AT_CHECK(
  [ovsdb-tool transact ovn-sb.db \
     ['["OVN_Southbound",
       {"op": "insert",
        "table": "SB_Global",
        "row": {
          "connections": ["set", [["named-uuid", "xyz"]]]}},
       {"op": "insert",
        "table": "Connection",
        "uuid-name": "xyz",
        "row": {"target": "pssl:0:127.0.0.1",
               "read_only": true}}]']], [0], [ignore], [ignore])

start_daemon ovsdb-server --remote=punix:ovn-sb.sock \
                          --remote=db:OVN_Southbound,SB_Global,connections \
                          --private-key="$PKIDIR/testpki-test2-privkey.pem" \
                          --certificate="$PKIDIR/testpki-test2-cert.pem" \
                          --ca-cert="$PKIDIR/testpki-cacert.pem" \
                          ovn-sb.db

PARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])

# read-only accesses should succeed
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-test-privkey.pem \
                    --certificate=$PKIDIR/testpki-test-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
                    list SB_Global], [0], [stdout], [ignore])
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-test-privkey.pem \
                    --certificate=$PKIDIR/testpki-test-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
                    list Connection], [0], [stdout], [ignore])

# write access should fail
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-test-privkey.pem \
                    --certificate=$PKIDIR/testpki-test-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
                    chassis-add ch vxlan 1.2.4.8], [1], [ignore],
[ovn-sbctl: transaction error: {"details":"insert operation not allowed when database server is in read only mode","error":"not allowed"}
])

OVS_APP_EXIT_AND_WAIT([ovsdb-server])
AT_CLEANUP

AT_SETUP([nb connection/ssl commands])
AT_SKIP_IF([test "$HAVE_OPENSSL" = no])
PKIDIR="$(cd $abs_top_builddir/tests && pwd)"
AT_SKIP_IF([expr "$PKIDIR" : ".*[[ 	'\"
\\]]"])

: > .$1.db.~lock~
ovsdb-tool create ovn-nb.db "$abs_top_srcdir"/ovn-nb.ovsschema

# Start nb db server using db connection/ssl entries (unpopulated initially)
start_daemon ovsdb-server --remote=punix:ovnnb_db.sock \
                          --remote=db:OVN_Northbound,NB_Global,connections \
                          --private-key=db:OVN_Northbound,SSL,private_key \
                          --certificate=db:OVN_Northbound,SSL,certificate \
                          --ca-cert=db:OVN_Northbound,SSL,ca_cert \
                          ovn-nb.db

# Populate SSL configuration entries in nb db
AT_CHECK(
    [ovn-nbctl set-ssl $PKIDIR/testpki-test-privkey.pem \
                       $PKIDIR/testpki-test-cert.pem \
                       $PKIDIR/testpki-cacert.pem], [0], [stdout], [ignore])

# Populate a passive SSL connection in nb db
AT_CHECK([ovn-nbctl set-connection pssl:0:127.0.0.1], [0], [stdout], [ignore])

PARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])

# Verify SSL connetivity to nb db server
AT_CHECK([ovn-nbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-test-privkey.pem \
                    --certificate=$PKIDIR/testpki-test-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          list NB_Global],
         [0], [stdout], [ignore])
AT_CHECK([ovn-nbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-test-privkey.pem \
                    --certificate=$PKIDIR/testpki-test-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          list Connection],
         [0], [stdout], [ignore])
AT_CHECK([ovn-nbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-test-privkey.pem \
                    --certificate=$PKIDIR/testpki-test-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          get-connection],
         [0], [stdout], [ignore])

OVS_APP_EXIT_AND_WAIT([ovsdb-server])
AT_CLEANUP

AT_SETUP([sb connection/ssl commands])
AT_SKIP_IF([test "$HAVE_OPENSSL" = no])
PKIDIR="$(cd $abs_top_builddir/tests && pwd)"
AT_SKIP_IF([expr "$PKIDIR" : ".*[[ 	'\"
\\]]"])

: > .$1.db.~lock~
ovsdb-tool create ovn-sb.db "$abs_top_srcdir"/ovn-sb.ovsschema

# Start sb db server using db connection/ssl entries (unpopulated initially)
start_daemon ovsdb-server --remote=punix:ovnsb_db.sock \
                          --remote=db:OVN_Southbound,SB_Global,connections \
                          --private-key=db:OVN_Southbound,SSL,private_key \
                          --certificate=db:OVN_Southbound,SSL,certificate \
                          --ca-cert=db:OVN_Southbound,SSL,ca_cert \
                          ovn-sb.db

# Populate SSL configuration entries in sb db
AT_CHECK(
    [ovn-sbctl set-ssl $PKIDIR/testpki-test-privkey.pem \
                       $PKIDIR/testpki-test-cert.pem \
                       $PKIDIR/testpki-cacert.pem], [0], [stdout], [ignore])

# Populate a passive SSL connection in sb db
AT_CHECK([ovn-sbctl set-connection pssl:0:127.0.0.1], [0], [stdout], [ignore])

PARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])

# Verify SSL connetivity to sb db server
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-test-privkey.pem \
                    --certificate=$PKIDIR/testpki-test-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          list SB_Global],
         [0], [stdout], [ignore])
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-test-privkey.pem \
                    --certificate=$PKIDIR/testpki-test-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          list Connection],
         [0], [stdout], [ignore])
AT_CHECK([ovn-sbctl --db=ssl:127.0.0.1:$TCP_PORT \
                    --private-key=$PKIDIR/testpki-test-privkey.pem \
                    --certificate=$PKIDIR/testpki-test-cert.pem \
                    --ca-cert=$PKIDIR/testpki-cacert.pem \
          get-connection],
         [0], [stdout], [ignore])

OVS_APP_EXIT_AND_WAIT([ovsdb-server])
AT_CLEANUP

OVN_FOR_EACH_NORTHD([
AT_SETUP([nested containers])
ovn_start

# Physical network:
# 2 HVs. HV1 has 2 VMs - "VM1" and "bar3". HV2 has 1 VM - "VM2"

# Logical network:
# 3 Logical switches - "mgmt" (172.16.1.0/24), "foo" (192.168.1.0/24)
# and "bar" (192.168.2.0/24). They are all connected to router R1.

ovn-nbctl lr-add R1
ovn-nbctl ls-add mgmt
ovn-nbctl ls-add foo
ovn-nbctl ls-add bar

# Connect mgmt to R1
ovn-nbctl lrp-add R1 mgmt 00:00:00:01:02:02 172.16.1.1/24
ovn-nbctl lsp-add mgmt rp-mgmt -- set Logical_Switch_Port rp-mgmt type=router \
          options:router-port=mgmt addresses=\"00:00:00:01:02:02\"

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:00:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
          options:router-port=foo addresses=\"00:00:00:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:00:01:02:04 192.168.2.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar type=router \
          options:router-port=bar addresses=\"00:00:00:01:02:04\"

# "mgmt" has VM1 and VM2 connected
ovn-nbctl lsp-add mgmt vm1 \
-- lsp-set-addresses vm1 "f0:00:00:01:02:03 172.16.1.2"

ovn-nbctl lsp-add mgmt vm2 \
-- lsp-set-addresses vm2 "f0:00:00:01:02:04 172.16.1.3"

# "foo1" and "foo2" are containers belonging to switch "foo"
# "foo1" has "VM1" as parent_port and "foo2" has "VM2" as parent_port.
ovn-nbctl lsp-add foo foo1 vm1 1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:05 192.168.1.2"

ovn-nbctl lsp-add foo foo2 vm2 2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 192.168.1.3"

# "bar1" and "bar2" are containers belonging to switch "bar"
# "bar1" has "VM1" as parent_port and "bar2" has "VM2" as parent_port.
ovn-nbctl lsp-add bar bar1 vm1 2 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:07 192.168.2.2"

ovn-nbctl lsp-add bar bar2 vm2 1 \
-- lsp-set-addresses bar2 "f0:00:00:01:02:08 192.168.2.3"

# bar3 is a standalone VM belonging to switch "bar"
ovn-nbctl lsp-add bar bar3 \
-- lsp-set-addresses bar3 "f0:00:00:01:02:09 192.168.2.4"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vm1 -- \
    set interface vm1 external-ids:iface-id=vm1 \
    options:tx_pcap=hv1/vm1-tx.pcap \
    options:rxq_pcap=hv1/vm1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int bar3 -- \
    set interface bar3 external-ids:iface-id=bar3 \
    options:tx_pcap=hv1/bar3-tx.pcap \
    options:rxq_pcap=hv1/bar3-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int vm2 -- \
    set interface vm2 external-ids:iface-id=vm2 \
    options:tx_pcap=hv2/vm2-tx.pcap \
    options:rxq_pcap=hv2/vm2-rx.pcap \
    ofport-request=1

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Test that ovn-controllers create ct-zone entry for container ports.
foo1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-foo1)
AT_CHECK([test ! -z $foo1_zoneid])

bar1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-bar1)
AT_CHECK([test ! -z $bar1_zoneid])

bar3_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-bar3)
AT_CHECK([test ! -z $bar3_zoneid])

foo2_zoneid=$(as hv2 ovs-vsctl get bridge br-int external_ids:ct-zone-foo2)
AT_CHECK([test ! -z $foo2_zoneid])

bar2_zoneid=$(as hv2 ovs-vsctl get bridge br-int external_ids:ct-zone-bar2)
AT_CHECK([test ! -z $bar2_zoneid])

# When a port is removed from a logical switch, the ct-zone is flushed, then
# the ct-zone-id is removed from external_ids. This is done in two steps(
# ct-zone-id is removed when the transaction flushing the ct_zone is complete).
# ovn-nbctl --wait=hv sync does not take this into account, and hence we need
# two "wait=hv" before we are sure that the ct-zone-id is removed from
# external_ids.
ovn-nbctl --wait=hv lsp-del bar2
ovn-nbctl --wait=hv sync

bar2_zoneid=$(as hv2 ovs-vsctl get bridge br-int external_ids:ct-zone-bar2)
AT_CHECK([test  -z $bar2_zoneid])

# Add back bar2
# Same comment as above: two "wait=hv" are needed.
ovn-nbctl --wait=hv lsp-add bar bar2 vm2 1 \
-- lsp-set-addresses bar2 "f0:00:00:01:02:08 192.168.2.3"
wait_for_ports_up
ovn-nbctl --wait=hv sync

bar2_zoneid=$(as hv2 ovs-vsctl get bridge br-int external_ids:ct-zone-bar2)
AT_CHECK([test ! -z $bar2_zoneid])

# Send ip packets between foo1 and foo2 (same switch, different HVs and
# different VLAN tags).
src_mac="f00000010205"
dst_mac="f00000010206"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 1 3`
packet=${dst_mac}${src_mac}8100000108004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at foo2
packet=${dst_mac}${src_mac}8100000208004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
echo  $packet > expected2
OVN_CHECK_PACKETS([hv2/vm2-tx.pcap], [expected2])

# Send ip packets between foo1 and bar2 (different switch, different HV)
src_mac="f00000010205"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 3`
packet=${dst_mac}${src_mac}8100000108004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at bar2
src_mac="000000010204"
dst_mac="f00000010208"
packet=${dst_mac}${src_mac}8100000108004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
echo  $packet >> expected2
OVN_CHECK_PACKETS([hv2/vm2-tx.pcap], [expected2])

# Send ip packets between foo1 and bar1
# (different switch, loopback to same vm but different tag)
src_mac="f00000010205"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
packet=${dst_mac}${src_mac}8100000108004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at bar1
src_mac="000000010204"
dst_mac="f00000010207"
packet=${dst_mac}${src_mac}8100000208004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
echo  $packet > expected1
OVN_CHECK_PACKETS([hv1/vm1-tx.pcap], [expected1])

# Send ip packets between bar1 and bar3
# (same switch. But one is container and another is a standalone VM)
src_mac="f00000010207"
dst_mac="f00000010209"
src_ip=`ip_to_hex 192 168 2 2`
dst_ip=`ip_to_hex 192 168 2 3`
packet=${dst_mac}${src_mac}8100000208004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at bar3
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
echo  $packet > expected3
OVN_CHECK_PACKETS([hv1/bar3-tx.pcap], [expected3])

# Send ip packets between foo1 and vm1.
# (different switch, container to the VM hosting it.)
src_mac="f00000010205"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 2`
packet=${dst_mac}${src_mac}8100000108004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at vm1
src_mac="000000010202"
dst_mac="f00000010203"
packet=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
echo  $packet >> expected1
OVN_CHECK_PACKETS([hv1/vm1-tx.pcap], [expected1])

# Send packets from vm1 to bar1.
# (different switch, A hosting VM to a container inside it)
src_mac="f00000010203"
dst_mac="000000010202"
src_ip=`ip_to_hex 172 16 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at vm1
src_mac="000000010204"
dst_mac="f00000010207"
packet=${dst_mac}${src_mac}8100000208004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
echo  $packet >> expected1
OVN_CHECK_PACKETS([hv1/vm1-tx.pcap], [expected1])

# Send broadcast packet from foo1. foo1 should not receive the same packet.
# But foo2 should.
src_mac="f00000010205"
dst_mac="ffffffffffff"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 255 255 255 255`
packet=${dst_mac}${src_mac}8100000108004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive vm1 $packet

# expected packet at VM1
OVN_CHECK_PACKETS([hv1/vm1-tx.pcap], [expected1])

# expected packet at foo2
packet=${dst_mac}${src_mac}8100000208004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
echo  $packet >> expected2
OVN_CHECK_PACKETS([hv2/vm2-tx.pcap], [expected2])

# Test binding of parent and container ports.
ovn-nbctl lsp-set-options vm1 requested-chassis=foo

OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up bar1)])

ovn-nbctl clear logical_switch_port vm1 options
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up bar1)])

as hv1 ovs-vsctl set interface vm1 external_ids:iface-id=foo
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up bar1)])

as hv1 ovs-vsctl set interface vm1 external_ids:iface-id=vm1
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up bar1)])

ovn-nbctl lsp-del vm1
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up bar1)])

ovn-nbctl lsp-add mgmt vm1
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up bar1)])

# Move VM1 to a new logical switch.
ovn-nbctl ls-add mgmt2
ovn-nbctl lsp-del vm1 -- lsp-add mgmt2 vm1
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xup = x$(ovn-nbctl lsp-get-up bar1)])

as hv1 ovs-vsctl del-port vm1
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up vm1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up foo1)])
OVS_WAIT_UNTIL([test xdown = x$(ovn-nbctl lsp-get-up bar1)])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([3 HVs, 3 LRs connected via LS, source IP based routes])
ovn_start

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and bar
# (192.168.2.0/24) connected to it.
#
# R2 and R3 are gateway routers.
# R2 has alice (172.16.1.0/24) and R3 has bob (172.16.1.0/24)
# connected to it. Note how both alice and bob have the same subnet behind it.
# We are trying to simulate external network via those 2 switches. In real
# world the switch ports of these switches will have addresses set as "unknown"
# to make them learning switches. Or those switches will be "localnet" ones.

# Create three hypervisors and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=bar1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=alice1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=bob1 \
    options:tx_pcap=hv3/vif1-tx.pcap \
    options:rxq_pcap=hv3/vif1-rx.pcap \
    ofport-request=1


ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis="hv2"
ovn-nbctl create Logical_Router name=R3 options:chassis="hv3"

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
    options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar type=router \
    options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24
ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.1.0/24 20.0.0.2
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.2.0/24 20.0.0.3

# Install static routes with destination ip address as the policy for routing.
ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1

ovn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port bar1 in bar
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 192.168.2.2"

# Create logical port alice1 in alice
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 172.16.1.3"

# Create logical port bob1 in bob
ovn-nbctl --wait=hv lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.1.4"

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Send ip packets between foo1 and bar1
# (East-west traffic should flow normally)
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Send ip packets between foo1 and alice1
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 3`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
as hv1 ovs-appctl ofproto/trace br-int in_port=1 $packet

# Send ip packets between bar1 and bob1
src_mac="f00000010204"
dst_mac="000001010204"
src_ip=`ip_to_hex 192 168 2 2`
dst_ip=`ip_to_hex 172 16 1 4`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif2 $packet
#as hv1 ovs-appctl ofproto/trace br-int in_port=2 $packet

# Packet to expect at bar1
src_mac="000001010204"
dst_mac="f00000010204"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 192 168 2 2`
expected=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
echo $expected > expected
OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

# Packet to Expect at alice1
src_mac="000002010203"
dst_mac="f00000010205"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 3`
expected=${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000
echo $expected > expected
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Packet to Expect at bob1
src_mac="000003010203"
dst_mac="f00000010206"
src_ip=`ip_to_hex 192 168 2 2`
dst_ip=`ip_to_hex 172 16 1 4`
expected=${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000
echo $expected > expected
OVN_CHECK_PACKETS([hv3/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([dns lookup : 1 HV, 2 LS, 2 LSPs/LS])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4 aef0::4"

ovn-nbctl lsp-set-port-security ls1-lp1 "f0:00:00:00:00:01 10.0.0.4 aef0::4"

ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02 10.0.0.6 20.0.0.4"

ovn-nbctl lsp-set-port-security ls1-lp2 "f0:00:00:00:00:02 10.0.0.6 20.0.0.4"

DNS1=`ovn-nbctl create DNS records={}`
DNS2=`ovn-nbctl create DNS records={}`
DNS3=`ovn-nbctl create DNS records={}`

ovn-nbctl set DNS $DNS1 records:vm1.ovn.org="10.0.0.4 aef0::4"
ovn-nbctl set DNS $DNS1 records:vm2.ovn.org="10.0.0.6 20.0.0.4"
ovn-nbctl set DNS $DNS2 records:vm3.ovn.org="40.0.0.4"
ovn-nbctl set DNS $DNS3 records:4.0.0.10.in-addr.arpa="vm1.ovn.org"
ovn-nbctl set DNS $DNS3 records:4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.f.e.a.ip6.arpa="vm1.ovn.org"

ovn-nbctl set Logical_switch ls1 dns_records="$DNS1"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync
as hv1 ovs-vsctl show

ovn-sbctl list DNS > dns
AT_CAPTURE_FILE([dns])
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# set_dns_params host_name
# Sets the dns_req_data and dns_resp_data
set_dns_params() {
    local hname=$1
    local ttl=00000e10
    an_count=0001
    type=0001
    case $hname in
    vm1)
        # vm1.ovn.org
        query_name=03766d31036f766e036f726700
        # IPv4 address - 10.0.0.4
        expected_dns_answer=${query_name}00010001${ttl}00040a000004
        ;;
    VM1)
        # VM1.OVN.ORG
        query_name=03564d31034f564e034f524700
        # IPv4 address - 10.0.0.4
        expected_dns_answer=${query_name}00010001${ttl}00040a000004
        ;;
    vm2)
        # vm2.ovn.org
        query_name=03766d32036f766e036f726700
        # IPv4 address - 10.0.0.6
        expected_dns_answer=${query_name}00010001${ttl}00040a000006
        # IPv4 address - 20.0.0.4
        expected_dns_answer=${expected_dns_answer}${query_name}00010001${ttl}000414000004
        an_count=0002
        ;;
    vm3)
        # vm3.ovn.org
        query_name=03766d33036f766e036f726700
        # IPv4 address - 40.0.0.4
        expected_dns_answer=${query_name}00010001${ttl}000428000004
        ;;
    vm1_ipv6_only)
        # vm1.ovn.org
        query_name=03766d31036f766e036f726700
        # IPv6 address - aef0::4
        type=001c
        expected_dns_answer=${query_name}${type}0001${ttl}0010aef00000000000000000000000000004
        ;;
    vm1_ipv4_v6)
        # vm1.ovn.org
        query_name=03766d31036f766e036f726700
        type=00ff
        an_count=0002
        # IPv4 address - 10.0.0.4
        # IPv6 address - aef0::4
        expected_dns_answer=${query_name}00010001${ttl}00040a000004
        expected_dns_answer=${expected_dns_answer}${query_name}001c0001${ttl}0010
        expected_dns_answer=${expected_dns_answer}aef00000000000000000000000000004
        ;;
    vm1_invalid_type)
        # vm1.ovn.org
        query_name=03766d31036f766e036f726700
        # IPv6 address - aef0::4
        type=0002
        ;;
    vm1_incomplete)
        # set type to none
        type=''
        ;;
    vm1_ipv4_ptr)
        # 4.0.0.10.in-addr.arpa
        query_name=01340130013002313007696e2d61646472046172706100
        type=000c
        # vm1.ovn.org
        expected_dns_answer=${query_name}${type}0001${ttl}000d03766d31036f766e036f726700
        ;;
    vm1_ipv6_ptr)
        # 4.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.f.e.a.ip6.arpa
        query_name=0134013001300130013001300130013001300130013001300130013001300130013001300130013001300130013001300130013001300130013001660165016103697036046172706100
        type=000c
        # vm1.ovn.org
        expected_dns_answer=${query_name}${type}0001${ttl}000d03766d31036f766e036f726700
        ;;
    esac
    # TTL - 3600
    local dns_req_header=010201200001000000000000
    local dns_resp_header=010281200001${an_count}00000000
    dns_req_data=${dns_req_header}${query_name}${type}0001
    dns_resp_data=${dns_resp_header}${query_name}${type}0001${expected_dns_answer}
}

# This shell function sends a DNS request packet
# test_dns INPORT SRC_MAC DST_MAC SRC_IP DST_IP DNS_QUERY EXPEC
test_dns() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 dns_reply=$6
    local dns_query_data=$7
    shift; shift; shift; shift; shift; shift; shift;
    # Packet size => IPv4 header (20) + UDP header (8) +
    #                DNS data (header + query)
    ip_len=`expr 28 + ${#dns_query_data} / 2`
    udp_len=`expr $ip_len - 20`
    ip_len=$(printf "%x" $ip_len)
    udp_len=$(printf "%x" $udp_len)
    local request=${dst_mac}${src_mac}0800450000${ip_len}0000000080110000
    request=${request}${src_ip}${dst_ip}9234003500${udp_len}0000
    # dns data
    request=${request}${dns_query_data}

    if test $dns_reply != 0; then
        local dns_reply=$1
        ip_len=`expr 28 + ${#dns_reply} / 2`
        udp_len=`expr $ip_len - 20`
        ip_len=$(printf "%x" $ip_len)
        udp_len=$(printf "%x" $udp_len)
        local reply=${src_mac}${dst_mac}0800450000${ip_len}0000000080110000
        reply=${reply}${dst_ip}${src_ip}0035923400${udp_len}0000${dns_reply}
        echo $reply >> $inport.expected
    else
        for outport; do
            echo $request >> $outport.expected
        done
    fi
    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $request
}

test_dns6() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 dns_reply=$6
    local dns_query_data=$7
    shift; shift; shift; shift; shift; shift; shift;
    # Packet size => UDP header (8) +
    #                DNS data (header + query)
    ip_len=`expr 8 + ${#dns_query_data} / 2`
    udp_len=$ip_len
    ip_len=$(printf "%x" $ip_len)
    udp_len=$(printf "%x" $udp_len)
    local request=${dst_mac}${src_mac}86dd6000000000${ip_len}11ff${src_ip}${dst_ip}
    request=${request}9234003500${udp_len}0000
    #dns data
    request=${request}${dns_query_data}

    if test $dns_reply != 0; then
        local dns_reply=$1
        ip_len=`expr 8 + ${#dns_reply} / 2`
        udp_len=$ip_len
        ip_len=$(printf "%x" $ip_len)
        udp_len=$(printf "%x" $udp_len)
        local reply=${src_mac}${dst_mac}86dd6000000000${ip_len}11ff${dst_ip}${src_ip}
        reply=${reply}0035923400${udp_len}0000${dns_reply}
        echo $reply >> $inport.expected
    else
        for outport; do
            echo $request >> $outport.expected
        done
    fi
    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $request
}

AT_CAPTURE_FILE([ofctl_monitor0.log])
as hv1 ovs-ofctl -t 300 monitor br-int resume --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0.log

set_dns_params vm2
src_ip=`ip_to_hex 10 0 0 4`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 1 f00000000001 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 1.
OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected], ["cut -c 53-"])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


set_dns_params vm1
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [2.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [2.expected], ["cut -c 53-"])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


AS_BOX([Try vm1 again but an all-caps query name])
set_dns_params VM1
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 3.
OVS_WAIT_UNTIL([test 3 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [2.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [2.expected], ["cut -c 53-"])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


AS_BOX([Clear the query name options for ls1-lp2])
ovn-nbctl --wait=hv remove DNS $DNS1 records vm2.ovn.org
ovn-sbctl list DNS > dns2
AT_CAPTURE_FILE([dns2])
ovn-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

set_dns_params vm2
src_ip=`ip_to_hex 10 0 0 4`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=0
test_dns 1 f00000000001 f00000000002 $src_ip $dst_ip $dns_reply $dns_req_data

# NXT_RESUMEs should be 4.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap > 1.packets
AT_CHECK([cat 1.packets], [0], [])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


AS_BOX([Clear the query name for ls1-lp1])
# Since ls1 has no query names configued,
# ovn-northd should not add the DNS flows.
ovn-nbctl --wait=hv remove DNS $DNS1 records vm1.ovn.org
ovn-sbctl list DNS > dns3
AT_CAPTURE_FILE([dns3])
ovn-sbctl dump-flows > sbflows3
AT_CAPTURE_FILE([sbflows3])

set_dns_params vm1
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=0
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data

# NXT_RESUMEs should be 4 only.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


AS_BOX([Test IPv6 (AAAA records) using IPv4 packet.])
# Add back the DNS options for ls1-lp1.
ovn-nbctl --wait=hv set DNS $DNS1 records:vm1.ovn.org="10.0.0.4 aef0::4"
ovn-sbctl list DNS > dns4
AT_CAPTURE_FILE([dns4])
ovn-sbctl dump-flows > sbflows4
AT_CAPTURE_FILE([sbflows4])

set_dns_params vm1_ipv6_only
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 5.
OVS_WAIT_UNTIL([test 5 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [2.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [2.expected], ["cut -c 53-"])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


AS_BOX([Test both IPv4 (A) and IPv6 (AAAA records) using IPv4 packet.])
set_dns_params vm1_ipv4_v6
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 6.
OVS_WAIT_UNTIL([test 6 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [2.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [2.expected], ["cut -c 53-"])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


AS_BOX([Invalid type])
set_dns_params vm1_invalid_type
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=0
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data

# NXT_RESUMEs should be 7.
OVS_WAIT_UNTIL([test 7 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


AS_BOX([Incomplete DNS packet])
set_dns_params vm1_incomplete
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=0
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data

# NXT_RESUMEs should be 8.
OVS_WAIT_UNTIL([test 8 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


AS_BOX([Add one more DNS record to the ls1])
ovn-nbctl --wait=hv set Logical_switch ls1 dns_records="$DNS1 $DNS2"
ovn-sbctl list DNS > dns5
AT_CAPTURE_FILE([dns5])
ovn-sbctl dump-flows > sbflows5
AT_CAPTURE_FILE([sbflows5])

set_dns_params vm3
src_ip=`ip_to_hex 10 0 0 4`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 1 f00000000001 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 9.
OVS_WAIT_UNTIL([test 9 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected], ["cut -c 53-"])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


AS_BOX([Try DNS query over IPv6])
set_dns_params vm1
src_ip=aef00000000000000000000000000004
dst_ip=aef00000000000000000000000000001
dns_reply=1
test_dns6 1 f00000000001 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 10
OVS_WAIT_UNTIL([test 10 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

# Skipping the UDP checksum.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected], ["cut -c 1-120,125-"])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


# Add one more DNS record to the ls1.
ovn-nbctl --wait=hv set Logical_switch ls1 dns_records="$DNS1 $DNS2 $DNS3"
echo "*************************"
ovn-sbctl list DNS
echo "*************************"
ovn-nbctl list DNS
echo "*************************"

# Test PTR record for IPv4 address using IPv4 packet.
set_dns_params vm1_ipv4_ptr
src_ip=`ip_to_hex 10 0 0 4`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 1 f00000000001 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 11.
OVS_WAIT_UNTIL([test 11 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected], ["cut -c 53-"])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected


# Test PTR record for IPv6 address using IPv4 packet.
set_dns_params vm1_ipv6_ptr
src_ip=`ip_to_hex 10 0 0 4`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 1 f00000000001 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 12.
OVS_WAIT_UNTIL([test 12 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected], ["cut -c 53-"])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# send AAAA query for a server known domain that don't have
# any IPV6 address associated with this domain, and expected
# server refused DNS reply to save the sender time of waiting for timeout.
AS_BOX([Test IPv6 (AAAA records) NO timeout.])
# Add back the DNS options for ls1-lp1 without ipv6.
check ovn-nbctl remove DNS $DNS1 records vm1.ovn.org
check ovn-nbctl set DNS $DNS1 records:vm1.ovn.org="10.0.0.4"
check ovn-nbctl --wait=hv set DNS $DNS1 options:ovn-owned=true
ovn-sbctl list DNS > dns6
AT_CAPTURE_FILE([dns6])
ovn-sbctl dump-flows > sbflows6
AT_CAPTURE_FILE([sbflows6])

set_dns_params vm1_ipv6_only
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 13.
OVS_WAIT_UNTIL([test 13 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
# dns hdr with server refuse RCODE
echo "01028125"  > expout
# only check for the DNS HDR flags since we are not getting any DNS answer
AT_CHECK([cat 2.packets | cut -c -92 | cut -c 85-], [0], [expout])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected

# send A query for a server known domain that don't have
# any IPv4 address associated with this domain, and expected
# server refused DNS reply to save the sender time of waiting for timeout.
AS_BOX([Test IPv4 (A records) NO timeout.])
# Add back the DNS options for ls1-lp1 without ipv4.
check ovn-nbctl remove DNS $DNS1 records vm1.ovn.org
check ovn-nbctl set DNS $DNS1 records:vm1.ovn.org="aef0::4"
check ovn-nbctl --wait=hv set DNS $DNS1 options:ovn-owned=true
ovn-sbctl list DNS > dns7
AT_CAPTURE_FILE([dns7])
ovn-sbctl dump-flows > sbflows7
AT_CAPTURE_FILE([sbflows7])

set_dns_params vm1
src_ip=`ip_to_hex 10 0 0 6`
dst_ip=`ip_to_hex 10 0 0 1`
dns_reply=1
test_dns 2 f00000000002 f000000000f0 $src_ip $dst_ip $dns_reply $dns_req_data $dns_resp_data

# NXT_RESUMEs should be 14.
OVS_WAIT_UNTIL([test 14 = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
# dns hdr with server refuse RCODE
echo "01028125"  > expout
# only check for the DNS HDR flags since we are not getting any DNS answer
AT_CHECK([cat 2.packets | cut -c -92 | cut -c 85-], [0], [expout])

reset_pcap_file hv1-vif1 hv1/vif1
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 1.expected
rm -f 2.expected
OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([4 HV, 1 LS, 1 LR, packet test with HA distributed router gateway port])
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add gw1
as gw1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

sim_add gw2
as gw2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.4

sim_add ext1
as ext1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
check ovs-vsctl -- add-port br-int ext1-vif1 -- \
    set interface ext1-vif1 external-ids:iface-id=outside1 \
    options:tx_pcap=ext1/vif1-tx.pcap \
    options:rxq_pcap=ext1/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl --wait=hv set NB_Global . options:"bfd-mult"=15
# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

AT_CHECK([ovn-nbctl create Logical_Router name=R1 | uuidfilt], [0], [<0>
])

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add outside

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect alice to R1 as distributed router gateway port on gw1
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24

AT_CHECK([ovn-nbctl \
          --id=@gc0 create Gateway_Chassis name=alice_gw1 \
                                           chassis_name=gw1 \
                                           priority=20 -- \
          --id=@gc1 create Gateway_Chassis name=alice_gw2 \
                                           chassis_name=gw2 \
                                           priority=10 -- \
          set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]' \
          | uuidfilt], [0], [<0>
<1>
])

check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Create logical port foo1 in foo
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port outside1 in outside
check ovn-nbctl lsp-add outside outside1 \
-- lsp-set-addresses outside1 "f0:00:00:01:02:04 172.16.1.3"

# Create localnet port in alice
check ovn-nbctl lsp-add alice ln-alice
check ovn-nbctl lsp-set-addresses ln-alice unknown
check ovn-nbctl lsp-set-type ln-alice localnet
check ovn-nbctl lsp-set-options ln-alice network_name=phys

# Create localnet port in outside
check ovn-nbctl lsp-add outside ln-outside
check ovn-nbctl lsp-set-addresses ln-outside unknown
check ovn-nbctl lsp-set-type ln-outside localnet
check ovn-nbctl lsp-set-options ln-outside network_name=phys

# Create bridge-mappings on gw1, gw2 and ext1, hv1 doesn't need
# mapping to the external network, is the one generating packets
check as gw1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
check as gw2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
check as ext1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

wait_for_ports_up
AT_CHECK([ovn-nbctl --wait=sb sync], [0], [ignore])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

hv1_gw1_ofport=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw1-0)
hv1_gw2_ofport=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw2-0)

OVS_WAIT_UNTIL([
    test 1 = $(as hv1 ovs-ofctl dump-flows br-int table=39 | grep -c "active_backup,ofport,members:$hv1_gw1_ofport,$hv1_gw2_ofport")
])

test_ip_packet()
{
    local active_gw=$1
    local backup_gw=$2
    local backup_vswitchd_dead=$3

    # Send ip packet between foo1 and outside1
    src_mac="f00000010203" # foo1 mac
    dst_mac="000001010203" # rp-foo mac (internal router leg)
    src_ip=`ip_to_hex 192 168 1 2`
    dst_ip=`ip_to_hex 172 16 1 3`
    packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

    # ARP request packet to expect at outside1
    #arp_request=ffffffffffff${src_mac}08060001080006040001${src_mac}${src_ip}000000000000${dst_ip}

    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

    # Send ARP reply from outside1 back to the router
    # XXX: note, we could avoid this if we plug this port into a netns
    # and setup the IP address into the port, so the kernel would simply reply
    src_mac="000002010203"
    reply_mac="f00000010204"
    dst_ip=`ip_to_hex 172 16 1 3`
    src_ip=`ip_to_hex 172 16 1 1`
    arp_reply=${src_mac}${reply_mac}08060001080006040002${reply_mac}${dst_ip}${src_mac}${src_ip}

    check as ext1 ovs-appctl netdev-dummy/receive ext1-vif1 $arp_reply

    AT_CAPTURE_FILE([offlows])
    OVS_WAIT_UNTIL([
        as $active_gw ovs-ofctl dump-flows br-int > offlows
        test `grep table=66 offlows | grep actions=mod_dl_dst:f0:00:00:01:02:04 | wc -l` -eq 1
    ])

    # Packet to Expect at ext1 chassis, outside1 port
    src_mac="000002010203"
    dst_mac="f00000010204"
    src_ip=`ip_to_hex 192 168 1 2`
    dst_ip=`ip_to_hex 172 16 1 3`
    expected=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000
    echo $expected > ext1-vif1.expected
    exp_gw_ip_garp=ffffffffffff00000201020308060001080006040001000002010203ac100101000000000000ac100101
    echo $exp_gw_ip_garp >> ext1-vif1.expected
    as $active_gw reset_pcap_file br-phys_n1 $active_gw/br-phys_n1

    if test $backup_vswitchd_dead != 1; then
        # Reset the file only if vswitchd in backup gw is alive
        as $backup_gw reset_pcap_file br-phys_n1 $backup_gw/br-phys_n1
    fi
    as ext1 reset_pcap_file ext1-vif1 ext1/vif1

    # Resend packet from foo1 to outside1
    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

    OVN_CHECK_PACKETS_CONTAIN([ext1/vif1-tx.pcap], [ext1-vif1.expected])

    if test $backup_vswitchd_dead != 1; then
        # Check for backup gw only if vswitchd is alive
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $backup_gw/br-phys_n1-tx.pcap  > packets
        AT_CHECK([grep $expected packets | sort], [0], [])
    fi
}

# Wait for BFD to be up, then for ovn-controller to handle that change
ovn_wait_for_bfd_up hv1 gw1 gw2
check ovn-nbctl --wait=hv sync

test_ip_packet gw1 gw2 0

AT_CHECK(
  [ovn-nbctl --wait=hv \
    --id=@gc0 create Gateway_Chassis name=alice_gw1 \
                                     chassis_name=gw1 \
                                     priority=10 -- \
    --id=@gc1 create Gateway_Chassis name=alice_gw2 \
                                     chassis_name=gw2 \
                                     priority=20 -- \
    set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]' | uuidfilt], 0,
  [<0>
<1>
])

OVS_WAIT_UNTIL([
    test 1 = $(as hv1 ovs-ofctl dump-flows br-int table=39 | grep -c "active_backup,ofport,members:$hv1_gw2_ofport,$hv1_gw1_ofport")
])

test_ip_packet gw2 gw1 0

# Get the claim count of both gw1 and gw2.
gw1_claim_ct=`grep "cr-alice: Claiming" gw1/ovn-controller.log | wc -l`
gw2_claim_ct=`grep "cr-alice: Claiming" gw2/ovn-controller.log | wc -l`

# Stop ovs-vswitchd in gw2. gw1 should claim the gateway port.
as gw2
OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])

# gw1 should claim the cr-alice and the claim count of gw1 should be
# incremented by 1.
gw1_claim_ct=$((gw1_claim_ct+1))

OVS_WAIT_UNTIL([test $gw1_claim_ct = `cat gw1/ovn-controller.log \
| grep -c "cr-alice: Claiming"`])

AT_CHECK([test $gw2_claim_ct = `cat gw2/ovn-controller.log | \
grep -c "cr-alice: Claiming"`])

OVS_WAIT_UNTIL([
    bfd_status=$(as hv1 ovs-vsctl get interface ovn-gw2-0 bfd_status:state)
    echo "bfd status = $bfd_status"
    test "$bfd_status" = "down"
])

test_ip_packet gw1 gw2 1

as gw2
OVS_APP_EXIT_AND_WAIT([ovn-controller])
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

OVN_CLEANUP([hv1],[gw1],[ext1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([4 HV, 3 LS, 2 LR, packet test with HA distributed router gateway port])
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add gw1
as gw1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

sim_add gw2
as gw2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.4

sim_add ext1
as ext1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
check ovs-vsctl -- add-port br-int ext1-vif1 -- \
    set interface ext1-vif1 external-ids:iface-id=outside1 \
    options:tx_pcap=ext1/vif1-tx.pcap \
    options:rxq_pcap=ext1/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl --wait=hv set NB_Global . options:"bfd-mult"=15
# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

AT_CHECK([ovn-nbctl create Logical_Router name=R0 -- \
          create Logical_Router name=R1 | uuidfilt], [0], [<0>
<1>
])

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add join
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add outside

#Connect foo to R0
check ovn-nbctl lrp-add R0 R0-foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo foo-R0 -- set Logical_Switch_Port foo-R0 \
    type=router options:router-port=R0-foo \
    -- lsp-set-addresses foo-R0 router

#Connect R0 to join
check ovn-nbctl lrp-add R0 R0-join 00:00:0d:01:02:03 100.60.1.1/24
check ovn-nbctl lsp-add join join-R0 -- set Logical_Switch_Port join-R0 \
    type=router options:router-port=R0-join \
    -- lsp-set-addresses join-R0 router

#Connect join to R1
check ovn-nbctl lrp-add R1 R1-join 00:00:0e:01:02:03 100.60.1.2/24
check ovn-nbctl lsp-add join join-R1 -- set Logical_Switch_Port join-R1 \
    type=router options:router-port=R1-join \
    -- lsp-set-addresses join-R1 router

#add route rules
check ovn-nbctl lr-route-add R0 0.0.0.0/0 100.60.1.2
check ovn-nbctl lr-route-add R1 192.168.0.0/16 100.60.1.1

# Connect alice to R1 as distributed router gateway port on gw1
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24

AT_CHECK([ovn-nbctl \
    --id=@gc0 create Gateway_Chassis name=alice_gw1 \
                                     chassis_name=gw1 \
                                     priority=20 -- \
    --id=@gc1 create Gateway_Chassis name=alice_gw2 \
                                     chassis_name=gw2 \
                                     priority=10 -- \
    set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]' | uuidfilt], [0], [<0>
<1>
])

check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Create logical port foo1 in foo
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port outside1 in outside
check ovn-nbctl lsp-add outside outside1 \
-- lsp-set-addresses outside1 "f0:00:00:01:02:04 172.16.1.3"

# Create localnet port in alice
check ovn-nbctl lsp-add alice ln-alice
check ovn-nbctl lsp-set-addresses ln-alice unknown
check ovn-nbctl lsp-set-type ln-alice localnet
check ovn-nbctl lsp-set-options ln-alice network_name=phys

# Create localnet port in outside
check ovn-nbctl lsp-add outside ln-outside
check ovn-nbctl lsp-set-addresses ln-outside unknown
check ovn-nbctl lsp-set-type ln-outside localnet
check ovn-nbctl lsp-set-options ln-outside network_name=phys

# Create bridge-mappings on gw1, gw2 and ext1, hv1 doesn't need
# mapping to the external network, is the one generating packets
check as gw1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
check as gw2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
check as ext1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

wait_for_ports_up
check ovn-nbctl --wait=sb sync
OVN_WAIT_PATCH_PORT_FLOWS(["ln-alice"], ["gw1"] ["gw2"])
OVN_WAIT_PATCH_PORT_FLOWS(["ln-outside"], ["ext1"])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# hv1 should be in 'ref_chassis' of the ha_chasssi_group as logical
# switch 'foo' can reach the router 'R1' (which has gw router port)
# via foo1 -> foo -> R0 -> join -> R1
hv1_ch_uuid=$(fetch_column Chassis _uuid name=hv1)
wait_column "$hv1_ch_uuid" HA_Chassis_Group ref_chassis

# Allow some time for ovn-northd and ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

hv1_gw1_ofport=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw1-0)
hv1_gw2_ofport=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw2-0)

OVS_WAIT_UNTIL([
    test 1 = $(as hv1 ovs-ofctl dump-flows br-int table=39 | grep -c "active_backup,ofport,members:$hv1_gw1_ofport,$hv1_gw2_ofport")
])

test_ip_packet()
{
    local active_gw=$1
    local backup_gw=$2

    # Send ip packet between foo1 and outside1
    src_mac="f00000010203" # foo1 mac
    dst_mac="000001010203" # foo-R0 mac (internal router leg)
    src_ip=`ip_to_hex 192 168 1 2`
    dst_ip=`ip_to_hex 172 16 1 3`
    packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

    # ARP request packet to expect at outside1
    #arp_request=ffffffffffff${src_mac}08060001080006040001${src_mac}${src_ip}000000000000${dst_ip}

    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

    # Send ARP reply from outside1 back to the router
    # XXX: note, we could avoid this if we plug this port into a netns
    # and setup the IP address into the port, so the kernel would simply reply
    src_mac="000002010203"
    reply_mac="f00000010204"
    dst_ip=`ip_to_hex 172 16 1 3`
    src_ip=`ip_to_hex 172 16 1 1`
    arp_reply=${src_mac}${reply_mac}08060001080006040002${reply_mac}${dst_ip}${src_mac}${src_ip}

    check as ext1 ovs-appctl netdev-dummy/receive ext1-vif1 $arp_reply

    OVS_WAIT_UNTIL([
        test `as $active_gw ovs-ofctl dump-flows br-int | grep table=66 | \
grep actions=mod_dl_dst:f0:00:00:01:02:04 | wc -l` -eq 1
    ])

    # Packet to Expect at ext1 chassis, outside1 port
    src_mac="000002010203"
    dst_mac="f00000010204"
    src_ip=`ip_to_hex 192 168 1 2`
    dst_ip=`ip_to_hex 172 16 1 3`
    expected=${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000
    echo $expected > ext1-vif1.expected
    exp_gw_ip_garp=ffffffffffff00000201020308060001080006040001000002010203ac100101000000000000ac100101
    echo $exp_gw_ip_garp >> ext1-vif1.expected

    as $active_gw reset_pcap_file br-phys_n1 $active_gw/br-phys_n1
    as $backup_gw reset_pcap_file br-phys_n1 $backup_gw/br-phys_n1
    as ext1 reset_pcap_file ext1-vif1 ext1/vif1

    # Resend packet from foo1 to outside1
    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

    OVN_CHECK_PACKETS_UNIQ([ext1/vif1-tx.pcap], [ext1-vif1.expected])
    # We might have to wait for the garp, as it might have been deleted
    # from the pcap last time we reset it.
    # We might have BFD packets on br-phys_n1-tx; ignore them.
    OVN_CHECK_PACKETS_CONTAIN([$active_gw/br-phys_n1-tx.pcap], [ext1-vif1.expected])

    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $backup_gw/br-phys_n1-tx.pcap  > packets
    AT_CHECK([grep $expected packets | sort], [0], [])
}

# Wait for BFD to be up, then for ovn-controller to handle that change
ovn_wait_for_bfd_up hv1 gw1 gw2
check ovn-nbctl --wait=hv sync
test_ip_packet gw1 gw2

AT_CHECK([ovn-nbctl --wait=hv \
    --id=@gc0 create Gateway_Chassis name=alice_gw1 \
                                     chassis_name=gw1 \
                                     priority=10 -- \
    --id=@gc1 create Gateway_Chassis name=alice_gw2 \
                                     chassis_name=gw2 \
                                     priority=20 -- \
    set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]' | uuidfilt], [0], [<0>
<1>
])

OVS_WAIT_UNTIL([
    test 1 = $(as hv1 ovs-ofctl dump-flows br-int table=39 | grep -c "active_backup,ofport,members:$hv1_gw2_ofport,$hv1_gw1_ofport")
])

test_ip_packet gw2 gw1

OVN_CLEANUP([hv1],[gw1],[gw2],[ext1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([1 LR with distributed router gateway port])
ovn_start

# Logical network:
# One LR R1 that has switches foo (192.168.1.0/24) and
# alice (172.16.1.0/24) connected to it.  The logical port
# between R1 and alice has a gateway chassis specified,
# i.e. it is the distributed router gateway port.
# Switch alice also has a localnet port defined.
# An additional switch outside has a localnet port and the
# same subnet as alice (172.16.1.0/24).

# Physical network:
# Three hypervisors hv[123].
# hv1 hosts vif foo1.
# hv2 is the gateway chassis that hosts the distributed
# router gateway port.
# hv3 hosts vif outside1.
# In order to show that connectivity works only through hv2,
# an initial round of tests is run without any bridge-mapping
# defined for the localnet on hv2.  These tests are expected
# to fail.
# Subsequent tests are run after defining the bridge-mapping
# for the localnet on hv2. These tests are expected to succeed.

# Create three hypervisors and create OVS ports corresponding
# to logical ports.
net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

sim_add hv3
as hv3
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
check ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=outside1 \
    options:tx_pcap=hv3/vif1-tx.pcap \
    options:rxq_pcap=hv3/vif1-rx.pcap \
    ofport-request=1

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

check ovn-nbctl lr-add R1 -- set Logical_Router R1 options:requested-tnl-key=1

check ovn-nbctl ls-add foo -- set Logical_Switch foo other_config:requested-tnl-key=2
check ovn-nbctl ls-add alice -- set Logical_Switch alice other_config:requested-tnl-key=3
check ovn-nbctl ls-add outside -- set Logical_Switch outside other_config:requested-tnl-key=4

# Connect foo to R1
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 \
    -- set Logical_Router_Port foo options:requested-tnl-key=1
check ovn-nbctl lsp-add foo rp-foo \
    -- set Logical_Switch_Port rp-foo type=router options:router-port=foo options:requested-tnl-key=1 \
    -- lsp-set-addresses rp-foo router

# Connect alice to R1 as distributed router gateway port on hv2
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \
    -- set Logical_Router_Port alice options:requested-tnl-key=2 \
    -- lrp-set-gateway-chassis alice hv2
check ovn-nbctl lsp-add alice rp-alice \
    -- set Logical_Switch_Port rp-alice type=router options:router-port=alice options:requested-tnl-key=1 \
    -- lsp-set-addresses rp-alice router

# Create logical port foo1 in foo
check ovn-nbctl lsp-add foo foo1 \
    -- set Logical_Switch_Port foo1 options:requested-tnl-key=2 \
    -- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port outside1 in outside
check ovn-nbctl lsp-add outside outside1 \
    -- set Logical_Switch_Port outside1 options:requested-tnl-key=1 \
    -- lsp-set-addresses outside1 "f0:00:00:01:02:04 172.16.1.3"

# Create localnet port in alice
check ovn-nbctl --wait=sb lsp-add alice ln-alice \
    -- set Logical_Switch_Port ln-alice options:requested-tnl-key=2
check ovn-nbctl lsp-set-addresses ln-alice unknown
check ovn-nbctl lsp-set-type ln-alice localnet
check ovn-nbctl lsp-set-options ln-alice network_name=phys

# Create localnet port in outside
check ovn-nbctl --wait=sb lsp-add outside ln-outside \
    -- set Logical_Switch_Port ln-outside options:requested-tnl-key=2
check ovn-nbctl lsp-set-addresses ln-outside unknown
check ovn-nbctl lsp-set-type ln-outside localnet
check ovn-nbctl lsp-set-options ln-outside network_name=phys

# Create bridge-mappings on hv1 and hv3, leaving hv2 for later
check as hv1 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
check as hv3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys


dnl Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
ovn-nbctl --wait=hv sync
OVN_WAIT_PATCH_PORT_FLOWS(["ln-outside"], ["hv3"])

(echo "---------NB dump-----"
 ovn-nbctl show
 echo "---------------------"
 ovn-nbctl list logical_router
 echo "---------------------"
 ovn-nbctl list logical_router_port) > nbdump
AT_CAPTURE_FILE([nbdump])

(echo "---------SB dump-----"
 ovn-sbctl list datapath_binding
 echo "---------------------"
 ovn-sbctl list port_binding
 echo "---------------------"
 ovn-sbctl list chassis
 ovn-sbctl list encap
 echo "------ Gateway_Chassis dump (SBDB) -------"
 ovn-sbctl list Gateway_Chassis
 echo "------ Port_Binding chassisredirect -------"
 ovn-sbctl find Port_Binding type=chassisredirect) > sbdump
AT_CAPTURE_FILE([sbdump])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

(echo "------ hv1 dump ----------"
 as hv1 ovs-ofctl show br-int
 as hv1 ovs-ofctl dump-flows br-int
 echo "------ hv2 dump ----------"
 as hv2 ovs-ofctl show br-int
 as hv2 ovs-ofctl dump-flows br-int
 echo "------ hv3 dump ----------"
 as hv3 ovs-ofctl show br-int
 as hv3 ovs-ofctl dump-flows br-int) > hvdump
AT_CAPTURE_FILE([hvdump])

as hv1 ovs-ofctl dump-flows br-int > hv1flows
as hv2 ovs-ofctl dump-flows br-int > hv2flows
AT_CAPTURE_FILE([hv1flows])
AT_CAPTURE_FILE([hv2flows])

AT_CHECK(
  [# Check that redirect mapping is programmed only on hv2
   grep table=40 hv1flows | grep =0x3,metadata=0x1 | wc -l
   grep table=40 hv2flows | grep =0x3,metadata=0x1 | grep load:0x2- | wc -l

   # Check that hv1 sends chassisredirect port traffic to hv2
   grep table=39 hv1flows | grep =0x3,metadata=0x1 | grep output | wc -l
   grep table=39 hv2flows | grep =0x3,metadata=0x1 | wc -l

   # Check that arp reply on distributed gateway port is only programmed on hv2
   grep arp hv1flows | grep load:0x2- | grep =0x2,metadata=0x1 | wc -l
   grep arp hv2flows | grep load:0x2- | grep =0x2,metadata=0x1 | wc -l], [0],
  [0
1
1
0
0
1
])

: > hv2-vif1.expected
: > hv3-vif1.expected

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local hv=$1 inport=$2 sha=$3 spa=$4 tpa=$5 reply_ha=$6
    local request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request

    if test X$reply_ha != X; then
        # Expect to receive the reply, if any.
        local reply=${sha}${reply_ha}08060001080006040002${reply_ha}${tpa}${sha}${spa}
        echo $reply >> hv${hv}-vif$inport.expected
    fi
}

rtr_ip=$(ip_to_hex 172 16 1 1)
foo_ip=$(ip_to_hex 192 168 1 2)
outside_ip=$(ip_to_hex 172 16 1 3)

echo $rtr_ip
echo $foo_ip
echo $outside_ip

# ARP for router IP address from outside1, no response expected
test_arp 3 1 f00000010204 $outside_ip $rtr_ip

# Now check the packets actually received against the ones expected.
OVN_CHECK_PACKETS_UNIQ([hv3/vif1-tx.pcap], [hv3-vif1.expected])

# Send ip packet between foo1 and outside1
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 3`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

# Now check the packets actually received against the ones expected.
OVN_CHECK_PACKETS_UNIQ([hv3/vif1-tx.pcap], [hv3-vif1.expected])

# Now add bridge-mappings on hv2, which should make everything work
as hv2 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

# Wait until the patch ports are created in hv2 to connect br-int to br-phys
OVN_WAIT_PATCH_PORT_FLOWS(["ln-alice"], ["hv2"])

dnl Allow some time for ovn-controller to catch up.
wait_for_ports_up
ovn-nbctl --wait=hv sync

# ARP for router IP address from outside1
test_arp 3 1 f00000010204 $outside_ip $rtr_ip 000002010203

# hv3-vif1.expected should also have the gw router port garp packet.
exp_gw_ip_garp=ffffffffffff00000201020308060001080006040001000002010203ac100101000000000000ac100101
echo $exp_gw_ip_garp >> hv3-vif1.expected

# Now check the packets actually received against the ones expected.
OVN_CHECK_PACKETS_UNIQ([hv3/vif1-tx.pcap], [hv3-vif1.expected])

# Send ip packet between foo1 and outside1
src_mac="f00000010203"
dst_mac="000001010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 172 16 1 3`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

# Packet to Expect at outside1
src_mac="000002010203"
dst_mac="f00000010204"
expected=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000

as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

echo "------ hv1 dump ----------"
as hv1 ovs-ofctl show br-int
as hv1 ovs-ofctl dump-flows br-int
echo "------ hv2 dump ----------"
as hv2 ovs-ofctl show br-int
as hv2 ovs-ofctl dump-flows br-int
echo "------ hv3 dump ----------"
as hv3 ovs-ofctl show br-int
as hv3 ovs-ofctl dump-flows br-int
echo "----------------------------"

echo $expected >> hv3-vif1.expected
OVN_CHECK_PACKETS_UNIQ([hv3/vif1-tx.pcap], [hv3-vif1.expected])

#Check ovn-trace over "chassisredirect" port
echo 'ip.ttl--;' > expout
echo 'eth.src = 00:00:02:01:02:03;' >> expout
echo 'eth.dst = f0:00:00:01:02:04;' >> expout
echo 'output("ln-alice");' >> expout
AT_CHECK_UNQUOTED([ovn_trace --minimal foo 'inport == "foo1" && eth.src == f0:00:00:01:02:03 && eth.dst == 00:00:01:01:02:03 && ip4.src == 192.168.1.2 && ip4.dst == 172.16.1.3 && ip.ttl == 0xff'], [0], [expout])

# Create logical port alice1 in alice on hv1
as hv1 ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=alice1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1

ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 172.16.1.4"

# Create logical port foo2 in foo on hv2
as hv2 ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=foo2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 192.168.1.3"

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync
OVN_WAIT_PATCH_PORT_FLOWS(["ln-alice"], ["hv1"])

: > hv1-vif2.expected

# Send ip packet between alice1 and foo2
src_mac="f00000010205"
dst_mac="000002010203"
src_ip=`ip_to_hex 172 16 1 4`
dst_ip=`ip_to_hex 192 168 1 3`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

as hv1 ovs-appctl netdev-dummy/receive hv1-vif2 $packet

# Packet to Expect at foo2
src_mac="000001010203"
dst_mac="f00000010206"
src_ip=`ip_to_hex 172 16 1 4`
dst_ip=`ip_to_hex 192 168 1 3`
expected=${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000

echo $expected >> hv2-vif1.expected
OVN_CHECK_PACKETS_UNIQ([hv2/vif1-tx.pcap], [hv2-vif1.expected])

check_row_count Port_Binding 1 logical_port=cr-alice

check ovn-nbctl --wait=sb lrp-del-gateway-chassis alice hv2

check_row_count Port_Binding 0 logical_port=cr-alice

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([send gratuitous arp for NAT rules on distributed router])
ovn_start
# Create logical switches
ovn-nbctl ls-add ls0
ovn-nbctl ls-add ls1
# Create distributed router
ovn-nbctl create Logical_Router name=lr0
# Add distributed gateway port to distributed router
ovn-nbctl lrp-add lr0 lrp0 f0:00:00:00:00:01 192.168.0.1/24 \
    -- lrp-set-gateway-chassis lrp0 hv2
ovn-nbctl lsp-add ls0 lrp0-rp -- set Logical_Switch_Port lrp0-rp \
    type=router options:router-port=lrp0 addresses="router"
# Add router port to ls1
ovn-nbctl lrp-add lr0 lrp1 f0:00:00:00:00:02 10.0.0.1/24
ovn-nbctl lsp-add ls1 lrp1-rp -- set Logical_Switch_Port lrp1-rp \
    type=router options:router-port=lrp1 addresses="router"
# Add logical ports for NAT rules
ovn-nbctl lsp-add ls1 foo1 \
-- lsp-set-addresses foo1 "00:00:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-add ls1 foo2 \
-- lsp-set-addresses foo2 "00:00:00:00:00:04 10.0.0.4"
# Add nat-addresses option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"
# Add NAT rules
AT_CHECK([ovn-nbctl lr-nat-add lr0 snat 192.168.0.1 10.0.0.0/24])
AT_CHECK([ovn-nbctl lr-nat-add lr0 dnat 192.168.0.2 10.0.0.2])
AT_CHECK([ovn-nbctl lr-nat-add lr0 dnat_and_snat 192.168.0.3 10.0.0.3 foo1 f0:00:00:00:00:03])
AT_CHECK([ovn-nbctl lr-nat-add lr0 dnat_and_snat 192.168.0.4 10.0.0.4 foo2 f0:00:00:00:00:04])

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])
AT_CHECK([ovs-vsctl add-port br-phys snoopvif -- set Interface snoopvif options:tx_pcap=hv1/snoopvif-tx.pcap options:rxq_pcap=hv1/snoopvif-rx.pcap])

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
# Initially test with no bridge-mapping on hv2, expect to receive no packets

sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
# Initially test with no bridge-mapping on hv3

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl --wait=hv lsp-set-options ln_port network_name=physnet1])

# Expect no packets when hv2 bridge-mapping is not present
: > packets
OVN_CHECK_PACKETS([hv1/snoopvif-tx.pcap], [packets])

# Add bridge-mapping on hv2
AT_CHECK([as hv2 ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])

# Wait until the patch ports are created in hv2 to connect br-int to br-phys
OVN_WAIT_PATCH_PORT_FLOWS(["ln_port"], ["hv2"])

# Wait for packets to be received.
OVS_WAIT_UNTIL([test `wc -c < "hv1/snoopvif-tx.pcap"` -ge 100])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/snoopvif-tx.pcap | trim_zeros > packets
expected="fffffffffffff0000000000108060001080006040001f00000000001c0a80001000000000000c0a80001"
echo $expected > expout
expected="fffffffffffff0000000000108060001080006040001f00000000001c0a80002000000000000c0a80002"
echo $expected >> expout
AT_CHECK([sort packets | uniq], [0], [expout])
sort packets | cat

# Temporarily remove nat-addresses option to avoid race conditions
# due to GARP backoff
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses=""

as hv1 reset_pcap_file snoopvif hv1/snoopvif

# Add OVS ports for foo1 and foo2 on hv3
ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=foo1 \
    ofport-request=1
ovs-vsctl -- add-port br-int hv3-vif2 -- \
    set interface hv3-vif2 external-ids:iface-id=foo2 \
    ofport-request=2

# Add bridge-mapping on hv3
AT_CHECK([as hv3 ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])

# Wait until the patch ports are created in hv3 to connect br-int to br-phys
OVN_WAIT_PATCH_PORT_FLOWS(["ln_port"], ["hv3"])

# Re-add nat-addresses option
ovn-nbctl lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"

garp_1="fffffffffffff0000000000308060001080006040001f00000000003c0a80003000000000000c0a80003"
echo $garp_1 > expected_out
garp_2="fffffffffffff0000000000408060001080006040001f00000000004c0a80004000000000000c0a80004"
echo $garp_2 >> expected_out

OVN_CHECK_PACKETS_CONTAIN([hv1/snoopvif-tx.pcap], [expected_out], "trim_zeros")

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

# VLAN traffic for external network redirected through distributed router
# gateway port should use vlans(i.e input network vlan tag) across hypervisors
# instead of tunneling.
OVN_FOR_EACH_NORTHD([
AT_SETUP([vlan traffic for external network with distributed router gateway port])
ovn_start

# Logical network:
# # One LR R1 that has switches foo (192.168.1.0/24) and
# # alice (172.16.1.0/24) connected to it.  The logical port
# # between R1 and alice has a gateway chassis specified,
# # i.e. it is the distributed router gateway port(172.16.1.6).
# # Switch alice also has a localnet port defined.
# # An additional switch outside has the same subnet as alice
# # (172.16.1.0/24), a localnet port and nexthop port(172.16.1.1)
# # which will receive the packet destined for external network
# # (i.e 8.8.8.8 as destination ip).

# Physical network:
# # Four hypervisors hv[1234].
# # hv1 hosts vif foo1.
# # hv2 is the gateway chassis that hosts the distributed router gateway port.
# # Later to test GARPs for the router port - foo, hv2 and hv4 are added to the ha_chassis_group
# # hv3 hosts nexthop port vif outside1.
# # All other tests connect hypervisors to network n1 through br-phys for tunneling.
# # But in this test, hv1 won't connect to n1(and no br-phys in hv1), and
# # in order to show vlans(instead of tunneling) used between hv1 and hv2,
# # a new network n2 created and hv1 and hv2 connected to this network through br-ex.
# # hv2 and hv3 are still connected to n1 network through br-phys.
net_add n1

# We are not calling ovn_attach for hv1, to avoid adding br-phys.
# Tunneling won't work in hv1 as ovn-encap-ip is not added to any bridge in hv1
sim_add hv1
as hv1
check ovs-vsctl \
    -- set Open_vSwitch . external-ids:system-id=hv1 \
    -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
    -- set Open_vSwitch . external-ids:ovn-encap-type=geneve,vxlan \
    -- set Open_vSwitch . external-ids:ovn-encap-ip=192.168.0.1 \
    -- add-br br-int \
    -- set bridge br-int fail-mode=secure other-config:disable-in-band=true \
    -- set Open_vSwitch . external-ids:ovn-bridge-mappings=public:br-ex

start_daemon ovn-controller
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings="public:br-ex,phys:br-phys"

sim_add hv3
as hv3
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
check ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=outside1 \
    options:tx_pcap=hv3/vif1-tx.pcap \
    options:rxq_pcap=hv3/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings="phys:br-phys"

sim_add hv4
as hv4
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.4
check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings="public:br-ex,phys:br-phys"

# Create network n2 for vlan connectivity between hv1 and hv2
net_add n2

as hv1
check ovs-vsctl add-br br-ex
net_attach n2 br-ex

as hv2
check ovs-vsctl add-br br-ex
net_attach n2 br-ex

as hv4
check ovs-vsctl add-br br-ex
net_attach n2 br-ex

OVN_POPULATE_ARP

AT_CHECK([ovn-nbctl create Logical_Router name=R1 | uuidfilt], [0], [<0>
])

check ovn-nbctl ls-add foo
check ovn-nbctl ls-add alice
check ovn-nbctl ls-add outside

AS_BOX([Connect foo to R1])
check ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

AS_BOX([Connect alice to R1 as distributed router gateway port (172.16.1.6) on hv2])
check ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.6/24 \
    -- lrp-set-gateway-chassis alice hv2
check ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router \

AS_BOX([Create logical port foo1 in foo])
check ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

AS_BOX([Create logical port outside1 in outside])
dnl This is a nexthop address for 172.16.1.0/24
check ovn-nbctl lsp-add outside outside1 \
-- lsp-set-addresses outside1 "f0:00:00:01:02:04 172.16.1.1"

AS_BOX([Set default gateway (nexthop) to 172.16.1.1])
check ovn-nbctl lr-route-add R1 "0.0.0.0/0" 172.16.1.1 alice
AT_CHECK([ovn-nbctl lr-nat-add R1 snat 172.16.1.6 192.168.1.1/24])
check ovn-nbctl set Logical_Switch_Port rp-alice options:nat-addresses=router

check ovn-nbctl lsp-add foo ln-foo
check ovn-nbctl lsp-set-addresses ln-foo unknown
check ovn-nbctl lsp-set-options ln-foo network_name=public
check ovn-nbctl lsp-set-type ln-foo localnet
check ovn-nbctl set Logical_Switch_Port ln-foo tag_request=2

AS_BOX([Create localnet port in alice])
check ovn-nbctl lsp-add alice ln-alice
check ovn-nbctl lsp-set-addresses ln-alice unknown
check ovn-nbctl lsp-set-type ln-alice localnet
check ovn-nbctl lsp-set-options ln-alice network_name=phys

AS_BOX([Create localnet port in outside])
check ovn-nbctl lsp-add outside ln-outside
check ovn-nbctl lsp-set-addresses ln-outside unknown
check ovn-nbctl lsp-set-type ln-outside localnet
check ovn-nbctl lsp-set-options ln-outside network_name=phys

AS_BOX([Verify logical flow to set outport to rp-foo])
OVS_WAIT_UNTIL([test 1 = `ovn-sbctl dump-flows foo | grep ls_in_l2_lkup | \
grep rp-foo | grep -v is_chassis_resident | grep priority=50 -c`])

AS_BOX([Set the option 'reside-on-redirect-chassis' for foo])
check ovn-nbctl set logical_router_port foo options:reside-on-redirect-chassis=true
wait_for_ports_up
check ovn-nbctl --wait=hv sync

AS_BOX([Verify logical flow to set outport to rp-foo with is_chassis_redirect])
OVS_WAIT_UNTIL([ovn-sbctl dump-flows foo > sbflows
    test 1 = `grep ls_in_l2_lkup sbflows | \
        grep rp-foo | grep is_chassis_resident | grep priority=50 -c`])
AT_CAPTURE_FILE([sbflows])

(echo "---------NB dump-----"
 ovn-nbctl show
 echo "---------------------"
 ovn-nbctl list logical_router
 echo "---------------------"
 ovn-nbctl list nat
 echo "---------------------"
 ovn-nbctl list logical_router_port
 echo "---------------------") > nbdump
AT_CAPTURE_FILE([nbdump])

(echo "---------SB dump-----"
 ovn-sbctl list datapath_binding
 echo "---------------------"
 ovn-sbctl list port_binding
 echo "---------------------"
 ovn-sbctl list chassis
 echo "---------------------") > sbdump
AT_CAPTURE_FILE([sbdump])

for chassis in hv1 hv2 hv3; do
    (as $chassis
     echo "------ $chassis dump ----------"
     ovs-vsctl show
     ovs-ofctl show br-int
     ovs-ofctl dump-flows br-int
     echo "--------------------------") > ${chassis}dump
done
AT_CAPTURE_FILE([hv1dump])
AT_CAPTURE_FILE([hv2dump])
AT_CAPTURE_FILE([hv3dump])

foo1_ip=$(ip_to_hex 192 168 1 2)
gw_ip=$(ip_to_hex 172 16 1 6)
dst_ip=$(ip_to_hex 8 8 8 8)
nexthop_ip=$(ip_to_hex 172 16 1 1)

foo1_mac="f00000010203"
foo_mac="000001010203"
gw_mac="000002010203"
nexthop_mac="f00000010204"

AS_BOX([Send ip packet from foo1 to 8.8.8.8])
src_mac="f00000010203"
dst_mac="000001010203"
packet=${foo_mac}${foo1_mac}080045000028000000004006a916${foo1_ip}${dst_ip}0035111112345678000000005002faf069450000

AS_BOX([Wait for GARPs announcing gw IP to arrive])
OVS_WAIT_UNTIL([
    test `as hv2 ovs-ofctl dump-flows br-int | grep table=66 | \
grep actions=mod_dl_dst:f0:00:00:01:02:04 | wc -l` -eq 1
    ])

AS_BOX([Verify VLAN tagged packet on bridge connecting hv1 and hv2])
# VLAN tagged packet with router port(192.168.1.1) MAC as destination MAC
# is expected on bridge connecting hv1 and hv2
expected=${foo_mac}${foo1_mac}81000002080045000028000000004006a916${foo1_ip}${dst_ip}0035111112345678000000005002faf069450000
echo $expected > hv1-br-ex_n2.expected

AS_BOX([Verify packet at outside1 i.e nexthop(172.16.1.1) port])
# Packet to Expect at outside1 i.e nexthop(172.16.1.1) port.
expected=${nexthop_mac}${gw_mac}080045000028000000003f06beaa${gw_ip}${dst_ip}0035111112345678000000005002faf07dd90000
echo $expected > hv3-vif1.expected

check as hv1 ovs-appctl revalidator/purge

as hv1 reset_pcap_file br-ex_n2 hv1/br-ex_n2
as hv3 reset_pcap_file hv3-vif1 hv3/vif1
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
as hv1 ovs-appctl ofproto/trace br-int in_port=hv1-vif1 $packet
sleep 2

AS_BOX([On hv1, table 40 check that no packet goes via the tunnel port])
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=39 \
| grep "NXM_NX_TUN_ID" | grep -v n_packets=0 | wc -l], [0], [[0
]])

ip_packet() {
    grep "1010203f00000010203"
}

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

AS_BOX([Check vlan tagged packet hv1<->hv2 with foo1's MAC])
# Check vlan tagged packet on the bridge connecting hv1 and hv2 with the
# foo1's mac.
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-ex_n2-tx.pcap | ip_packet | uniq > hv1-br-ex_n2
cat hv1-br-ex_n2.expected > expout
AT_CHECK([sort hv1-br-ex_n2], [0], [expout])

AS_BOX([Check expected packet on nexthop interface])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv3/vif1-tx.pcap | grep ${gw_ip}${dst_ip} | uniq > hv3-vif1
cat hv3-vif1.expected > expout
AT_CHECK([sort hv3-vif1], [0], [expout])

AS_BOX([Test the GARP for the router port ip - 192.168.1.1])
ovn-nbctl --wait=sb ha-chassis-group-add hagrp1

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file br-ex_n2 hv2/br-ex_n2
as hv4 reset_pcap_file br-ex_n2 hv4/br-ex_n2

ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 hv2 30
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 hv4 20

hagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp1`
ovn-nbctl lrp-del-gateway-chassis alice hv2
ovn-nbctl --wait=sb set logical_router_port alice ha_chassis_group=$hagrp1_uuid

# When hv2 claims the gw router port cr-alice, it should send out
# GARP for 192.168.1.1 and it should be received by foo1 on hv1.

AS_BOX([foo1 (on hv1) should receive GARP without VLAN tag])
exp_garp_on_foo1="ffffffffffff00000101020308060001080006040001000001010203c0a80101000000000000c0a80101"
echo $exp_garp_on_foo1 > foo1.expout

AS_BOX([ovn-controller on hv2 should send garp with VLAN tag])
sent_garp="ffffffffffff0000010102038100000208060001080006040001000001010203c0a80101000000000000c0a80101"

OVN_CHECK_PACKETS_CONTAIN([hv1/vif1-tx.pcap], [foo1.expout])
# Wait until we receive atleast 1 packet
OVS_WAIT_UNTIL([test `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-ex_n2-tx.pcap | wc -l` -ge 1])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-ex_n2-tx.pcap | head -1 > packets
echo $sent_garp > expout
AT_CHECK([uniq packets], [0], [expout])
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv4/br-ex_n2-tx.pcap > empty
AT_CHECK([cat empty], [0], [])

AS_BOX([Make hv4 master])
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv4 reset_pcap_file br-ex_n2 hv4/br-ex_n2
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 hv4 40

AS_BOX([Wait till cr-alice is claimed by hv4])
hv4_chassis=$(fetch_column Chassis _uuid name=hv4)
AS_BOX([check that the chassis redirect port has been claimed by the gw1 chassis])
wait_row_count Port_Binding 1 logical_port=cr-alice chassis=$hv4_chassis

AS_BOX([Reset the pcap file for hv2/br-ex_n2])
# From now on ovn-controller in hv2 should not send GARPs for the router ports.
as hv2 reset_pcap_file br-ex_n2 hv2/br-ex_n2

echo $sent_garp > br-ex_n2.expout
OVN_CHECK_PACKETS_CONTAIN([hv1/vif1-tx.pcap], [foo1.expout])
OVN_CHECK_PACKETS_CONTAIN([hv4/br-ex_n2-tx.pcap], [br-ex_n2.expout])

sleep 2

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-ex_n2-tx.pcap > empty
AT_CHECK([cat empty], [0], [])

OVN_CLEANUP([hv1],[hv2],[hv3], [hv4])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IPv6 ND Router Solicitation responder])
AT_SKIP_IF([test $HAVE_SCAPY = no])
AT_KEYWORDS([ovn-nd_ra])
ovn_start

# In this test case we create 1 lswitch with 3 VIF ports attached,
# and a lrouter connected to the lswitch.
# We generate the Router solicitation packet and verify the Router Advertisement
# reply packet from the ovn-controller.

# Create hypervisor and logical switch lsw0, logical router lr0, attach lsw0
# onto lr0, set Logical_Router_Port.ipv6_ra_configs:address_mode column to
# 'slaac' to allow lrp0 send RA for SLAAC mode.
ovn-nbctl ls-add lsw0
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lrp0 fa:16:3e:00:00:01 fdad:1234:5678::1/64
ovn-nbctl set Logical_Router_Port lrp0 ipv6_ra_configs:address_mode="slaac"
ovn-nbctl \
    -- lsp-add lsw0 lsp0 \
    -- set Logical_Switch_Port lsp0 type=router \
                     options:router-port=lrp0 \
                     addresses='"fa:16:3e:00:00:01 fdad:1234:5678::1"'
net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

ovn-nbctl lsp-add lsw0 lp1
ovn-nbctl lsp-set-addresses lp1 "fa:16:3e:00:00:02 10.0.0.12 fdad:1234:5678:0:f816:3eff:fe:2"
ovn-nbctl lsp-set-port-security lp1 "fa:16:3e:00:00:02 10.0.0.12 fdad:1234:5678:0:f816:3eff:fe:2"

ovn-nbctl lsp-add lsw0 lp2
ovn-nbctl lsp-set-addresses lp2 "fa:16:3e:00:00:03 10.0.0.13 fdad:1234:5678:0:f816:3eff:fe:3"
ovn-nbctl lsp-set-port-security lp2 "fa:16:3e:00:00:03 10.0.0.13 fdad:1234:5678:0:f816:3eff:fe:3"

ovn-nbctl lsp-add lsw0 lp3
ovn-nbctl lsp-set-addresses lp3 "fa:16:3e:00:00:04 10.0.0.14 fdad:1234:5678:0:f816:3eff:fe:4"
ovn-nbctl lsp-set-port-security lp3 "fa:16:3e:00:00:04 10.0.0.14 fdad:1234:5678:0:f816:3eff:fe:4"

# Add ACL rule for ICMPv6 on lsw0
ovn-nbctl acl-add lsw0 from-lport 1002 'ip6 && icmp6'  allow-related
ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp1" && ip6 && icmp6'  allow-related
ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp2" && ip6 && icmp6'  allow-related
ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp3" && ip6 && icmp6'  allow-related

ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=lp3 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

n_resume=1

# Make sure that ovn-controller has installed the corresponding OF Flow.
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int | grep -c "ipv6_dst=ff02::2,nw_ttl=255,icmp_type=133,icmp_code=0"`])

# This shell function sends a Router Solicitation packet.
# test_ipv6_ra INPORT SRC_MAC SRC_LLA RA_OPT MTU PREFIX RDNSS DNSSL ROUTES
test_ipv6_ra() {
    local inport=$1 src_mac=$2 src_ip=$3 ra=$4 mtu=$5 prefix=$6
    local rdnss=$7 dnssl=$8 routes=$9

    local request=$(fmt_pkt "Ether(dst='33:33:00:00:00:02', src='${src_mac}')/ \
                             IPv6(dst='ff02::2', src='${src_ip}')/ \
                             ICMPv6ND_RS()/ \
                             ICMPv6NDOptSrcLLAddr(lladdr='${src_mac}')")

    local reply_dst=$src_ip
    if test "${reply_dst}" = "::"; then
        reply_dst="ff02::1"
    fi

    local rep_scapy="Ether(dst='${src_mac}', src='fa:16:3e:00:00:01')/ \
                     IPv6(dst='${reply_dst}', src='fe80::f816:3eff:fe00:1')/ \
                     ${ra}/ \
                     ICMPv6NDOptSrcLLAddr(lladdr='fa:16:3e:00:00:01')"

    if test "${mtu}" != "0"; then
        rep_scapy="${rep_scapy}/ICMPv6NDOptMTU(mtu=${mtu})"
    fi

    if test -n "${rdnss}"; then
        rep_scapy="${rep_scapy}/ICMPv6NDOptRDNSS(dns=[['${rdnss}']])"
    fi

    if test -n "${dnssl}"; then
        rep_scapy="${rep_scapy}/ICMPv6NDOptDNSSL(searchlist=[['${dnssl}']])"
    fi

    if test -n "${routes}"; then
        rep_scapy="${rep_scapy}/${routes}"
    fi

    if test -n "${prefix}"; then
        local a_flag=$(echo $ra | grep -vc "M=1")
        rep_scapy="${rep_scapy}/ICMPv6NDOptPrefixInfo(prefix='${prefix}', A=${a_flag})"
    fi

    local reply=$(fmt_pkt "${rep_scapy}")
    echo $reply >> $inport.expected

    as hv1 ovs-appctl netdev-dummy/receive hv1-vif${inport} $request

    OVS_WAIT_UNTIL([test $n_resume = `cat ofctl_monitor*.log | grep -c NXT_RESUME`])
    n_resume=$((n_resume + 1))
}

check_packets() {
    local port=$1

    # Skipping UDP checksum
    OVN_CHECK_PACKETS([hv1/vif$port-tx.pcap], [$port.expected], ["cut -c 1-112,117-"])

    rm $port.packets
    rm $port.expected

    reset_pcap_file hv1-vif1 hv1/vif1
    reset_pcap_file hv1-vif2 hv1/vif2
    reset_pcap_file hv1-vif3 hv1/vif3
}

prepare_ra_opt() {
    local mode=$1 priority=$2

    if test "${mode}" = "stateful"; then
        echo "ICMPv6ND_RA(chlim=255, routerlifetime=65535, M=1, prf=${priority})"
    elif test "${mode}" = "stateless"; then
        echo "ICMPv6ND_RA(chlim=255, routerlifetime=65535, O=1, prf=${priority})"
    else
        echo "ICMPv6ND_RA(chlim=255, routerlifetime=65535, prf=${priority})"
    fi
}

prepare_route_opt() {
    local prefix=$1 priority=$2 plen=$3

    local len=2
    if test $plen -gt 64; then
        len=3
    fi

    echo "ICMPv6NDOptRouteInfo(len=$len, prf=${priority}, prefix='${prefix}', plen=$plen)"
}

AT_CAPTURE_FILE([ofctl_monitor0.log])
as hv1 ovs-ofctl monitor br-int resume --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0.log

prefix="fdad:1234:5678::"

# MTU is not set and the address mode is set to slaac
ra=$(prepare_ra_opt "" 0)
src_mac="fa:16:3e:00:00:02"
src_lla="fe80::f816:3eff:fe00:2"

test_ipv6_ra 1 $src_mac $src_lla "$ra" 0 $prefix "" "" ""
check_packets 1

# Check with RA with src being "::".
ovn-nbctl --wait=hv lsp-set-port-security lp1 ""

test_ipv6_ra 1 $src_mac "::" "$ra" 0 $prefix "" "" ""
check_packets 1

ovn-nbctl --wait=hv lsp-set-port-security lp1 "fa:16:3e:00:00:02 10.0.0.12 fdad:1234:5678:0:f816:3eff:fe:2"

# Set the MTU to 1500, send_periodic to false, preference to LOW
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:mtu=1500
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:send_periodic="false"
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:router_preference="LOW"
ovn-nbctl --wait=hv set Logical_Router_port lrp0 ipv6_ra_configs:rdnss=1000::11
ovn-nbctl --wait=hv set Logical_Router_port lrp0 ipv6_ra_configs:dnssl=aa.bb.cc
ovn-nbctl --wait=hv set Logical_Router_port lrp0 ipv6_ra_configs:route_info=HIGH-1001::11/48,LOW-1002::11/96

# Make sure that ovn-controller has installed the corresponding OF Flow.
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int | grep -c "ipv6_dst=ff02::2,nw_ttl=255,icmp_type=133,icmp_code=0"`])

# addr_mode byte also includes router preference information
ra=$(prepare_ra_opt "" 3)
routes=$(prepare_route_opt '1001::' 1 48)
routes="${routes}/$(prepare_route_opt '1002::' 3 96)"
src_mac="fa:16:3e:00:00:03"
src_lla="fe80::f816:3eff:fe00:3"

test_ipv6_ra 2 $src_mac $src_lla "$ra" 1500 $prefix "1000::11" "aa.bb.cc" "$routes"
check_packets 2

# Set the address mode to dhcpv6_stateful, router_preference to HIGH
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:address_mode=dhcpv6_stateful
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:router_preference="HIGH"
ovn-nbctl --wait=hv remove Logical_Router_Port lrp0 ipv6_ra_configs rdnss
ovn-nbctl --wait=hv remove Logical_Router_Port lrp0 ipv6_ra_configs route_info
# Make sure that ovn-controller has installed the corresponding OF Flow.
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int | grep -c "ipv6_dst=ff02::2,nw_ttl=255,icmp_type=133,icmp_code=0"`])

# addr_mode byte also includes router preference information
ra=$(prepare_ra_opt "stateful" 1)
src_mac="fa:16:3e:00:00:04"
src_lla="fe80::f816:3eff:fe00:4"

test_ipv6_ra 3 $src_mac $src_lla "$ra" 1500 $prefix "" "aa.bb.cc" ""
check_packets 3

# Set the address mode to dhcpv6_stateless, reset router preference to default
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:address_mode=dhcpv6_stateless
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:router_preference="MEDIUM"
ovn-nbctl --wait=hv remove Logical_Router_Port lrp0 ipv6_ra_configs dnssl
# Make sure that ovn-controller has installed the corresponding OF Flow.
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int | grep -c "ipv6_dst=ff02::2,nw_ttl=255,icmp_type=133,icmp_code=0"`])

ra=$(prepare_ra_opt "stateless" 0)
src_mac="fa:16:3e:00:00:02"
src_lla="fe80::f816:3eff:fe00:2"

test_ipv6_ra 1 $src_mac $src_lla "$ra" 1500 $prefix "" "" ""
check_packets 1

# Set the address mode to invalid.
ovn-nbctl --wait=hv set Logical_Router_Port lrp0 ipv6_ra_configs:address_mode=invalid
# Make sure that ovn-controller has not installed any OF Flow for IPv6 ND RA.
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | grep -c "ipv6_dst=ff02::2,nw_ttl=255,icmp_type=133,icmp_code=0"`])

ra=$(prepare_ra_opt "stateless" 0)

src_mac="fa:16:3e:00:00:02"
src_lla="fe80::f816:3eff:fe00:2"

# This shouldn't produce any NXT_RESUME.
n_resume=$((n_resume - 1))

test_ipv6_ra 1 $src_mac $src_lla "$ra" 1500 "" "" "" ""

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap  > 1.packets
AT_CHECK([cat 1.packets], [0], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([/32 router IP address])
ovn_start

# Logical network:
# 2 LS 'foo' and 'alice' connected via router R1.
# R1 connects to 'alice' with a /32 IP address. We use static routes and
# nexthop to push traffic to a logical port in switch 'alice'

ovn-nbctl lr-add R1

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:00:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo type=router \
          options:router-port=foo addresses=\"00:00:00:01:02:03\"

# Connect alice to R1.
ovn-nbctl lrp-add R1 alice 00:00:00:01:02:04 172.16.1.1/32
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
          type=router options:router-port=alice addresses=\"00:00:00:01:02:04\"

# Create logical port foo1 in foo
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical port alice1 in alice
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 10.0.0.2"

#install default route in R1 to use alice1's IP address as nexthop
ovn-nbctl lr-route-add R1 0.0.0.0/0 10.0.0.2 alice

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=foo1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=alice1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Send ip packets between foo1 and alice1
src_mac="f00000010203"
dst_mac="000000010203"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 10 0 0 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000

# Send the first packet to trigger a ARP response and population of
# mac_bindings table.
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
wait_row_count MAC_Binding 1 ip="10.0.0.2"
ovn-nbctl --wait=hv sync

# Packet to Expect at 'alice1'
src_mac="000000010204"
dst_mac="f00000010204"
src_ip=`ip_to_hex 192 168 1 2`
dst_ip=`ip_to_hex 10 0 0 2`
echo "${dst_mac}${src_mac}08004500001c000000003f110100${src_ip}${dst_ip}0035111100080000" > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 1 lport/HV, localport ports])
ovn_start

ovn-nbctl ls-add ls1

# Add localport to the switch
ovn-nbctl lsp-add ls1 lp01
ovn-nbctl lsp-set-addresses lp01 f0:00:00:00:00:01
ovn-nbctl lsp-set-type lp01 localport

net_add n1

for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    ovs-vsctl add-port br-int vif01 -- \
        set Interface vif01 external-ids:iface-id=lp01 \
                              options:tx_pcap=hv${i}/vif${i}0-tx.pcap \
                              options:rxq_pcap=hv${i}/vif${i}0-rx.pcap \
                              ofport-request=${i}0

    ovs-vsctl add-port br-int vif${i}1 -- \
        set Interface vif${i}1 external-ids:iface-id=lp${i}1 \
                              options:tx_pcap=hv${i}/vif${i}1-tx.pcap \
                              options:rxq_pcap=hv${i}/vif${i}1-rx.pcap \
                              ofport-request=${i}1

    ovn-nbctl lsp-add ls1 lp${i}1
    ovn-nbctl lsp-set-addresses lp${i}1 f0:00:00:00:00:${i}1
    ovn-nbctl lsp-set-port-security lp${i}1 f0:00:00:00:00:${i}1

        OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp${i}1` = xup])
done

wait_for_ports_up
ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows

OVN_POPULATE_ARP

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}
#
# test_packet INPORT DST SRC ETHTYPE EOUT LOUT DEFHV
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  INPORT is specified as
# logical switch port numbers, e.g. 11 for vif11.
#
# EOUT is the end-to-end output port, that is, where the packet will end up
# after possibly bouncing through one or more localnet ports.  LOUT is the
# logical output port, which might be a localnet port, as seen by ovn-trace
# (which doesn't know what localnet ports are connected to and therefore can't
# figure out the end-to-end answer).
#
# DEFHV is the default hypervisor from where the packet is going to be sent
# if the source port is a localport.
for i in 1 2; do
    for j in 0 1; do
        : > $i$j.expected
    done
done
test_packet() {
    local inport=$1 dst=$2 src=$3 eth=$4 eout=$5 lout=$6 defhv=$7
    echo "$@"

    # First try tracing the packet.
    uflow="inport==\"lp$inport\" && eth.dst==$dst && eth.src==$src && eth.type==0x$eth"
    if test $lout != drop; then
        echo "output(\"$lout\");"
    fi > expout
    AT_CHECK([ovn_trace --minimal ls1 "$uflow"], [0], [expout])

    # Then actually send a packet, for an end-to-end test.
    local packet=$(echo $dst$src | sed 's/://g')${eth}
    hv=`vif_to_hv $inport`
    # If hypervisor 0 (localport) use the defhv parameter
    if test $hv = hv0; then
        hv=$defhv
    fi
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet

    # For packets sent to localport, differentiate localport per hypervisor
    if test $eout = lp01; then
        echo $packet >> ${hv#hv}0.expected
    else
        if test $eout != drop; then
            echo $packet >> ${eout#lp}.expected
        fi
    fi
}


# lp11 and lp21 are on different hypervisors
test_packet 11 f0:00:00:00:00:21 f0:00:00:00:00:11 1121 lp21 lp21
test_packet 21 f0:00:00:00:00:11 f0:00:00:00:00:21 2111 lp11 lp11

# Both VIFs should be able to reach the localport on their own HV
test_packet 11 f0:00:00:00:00:01 f0:00:00:00:00:11 1101 lp01 lp01
test_packet 21 f0:00:00:00:00:01 f0:00:00:00:00:21 2101 lp01 lp01

# Packet sent from localport on same hv should reach the vif
test_packet 01 f0:00:00:00:00:11 f0:00:00:00:00:01 0111 lp11 lp11 hv1
test_packet 01 f0:00:00:00:00:21 f0:00:00:00:00:01 0121 lp21 lp21 hv2

# Packet sent from localport on different hv should be dropped
test_packet 01 f0:00:00:00:00:21 f0:00:00:00:00:01 0121 drop lp21 hv1
test_packet 01 f0:00:00:00:00:11 f0:00:00:00:00:01 0111 drop lp11 hv2

# Now check the packets actually received against the ones expected.
for i in 1 2; do
    for j in 0 1; do
        OVN_CHECK_PACKETS([hv$i/vif$i$j-tx.pcap], [$i$j.expected])
    done
done

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int |awk '/table=65/ && !/actions=drop/{print substr($8, 16, length($8))}' |sort -n], [0], [dnl
10
11
])

# remove the localport from br-int and re-create it
as hv1
check ovs-vsctl del-port vif01
check ovn-nbctl --wait=hv sync
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int |awk '/table=65/ && !/actions=drop/{print substr($8, 16, length($8))}' |sort -n], [0], [dnl
11
])

as hv1
check ovs-vsctl add-port br-int vif01 \
    -- set Interface vif01 external-ids:iface-id=lp01
check ovn-nbctl --wait=hv sync
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int |awk '/table=65/ && !/actions=drop/{print substr($8, 16, length($8))}' |sort -n], [0], [dnl
2
11
])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([localport suppress gARP])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
ovn_start

send_garp() {
    local inport=$1 eth_src=$2 eth_dst=$3 spa=$4 tpa=$5
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as hv1 ovs-appctl netdev-dummy/receive vif$inport $request
}

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

check ovn-nbctl ls-add ls \
    -- lsp-add ls lp \
    -- lsp-set-type lp localport \
    -- lsp-set-addresses lp "00:00:00:00:00:01 10.0.0.1" \
    -- lsp-add ls ln \
    -- lsp-set-type ln localnet \
    -- lsp-set-addresses ln unknown \
    -- lsp-set-options ln network_name=phys \
    -- lsp-add ls lsp \
    -- lsp-set-addresses lsp "00:00:00:00:00:02 10.0.0.2"

dnl First bind the localport.
check ovs-vsctl add-port br-int vif1 \
    -- set Interface vif1 external-ids:iface-id=lp
check ovn-nbctl --wait=hv sync

dnl Then bind the regular vif.
check ovs-vsctl add-port br-int vif2 \
    -- set Interface vif2 external-ids:iface-id=lsp \
        options:tx_pcap=hv1/vif2-tx.pcap \
        options:rxq_pcap=hv1/vif2-rx.pcap

wait_for_ports_up lsp
check ovn-nbctl --wait=hv sync

dnl Wait for at least two gARPs from lsp (10.0.0.2).
lsp_garp=ffffffffffff000000000002080600010800060400010000000000020a0000020000000000000a000002
OVS_WAIT_UNTIL([
    garps=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys-tx.pcap | grep ${lsp_garp} -c`
    test $garps -ge 2
])

dnl At this point it's safe to assume that ovn-controller skipped sending gARP
dnl for the localport.  Check that there are no other packets than the gARPs
dnl for the regular vif.
AT_CHECK([
    pkts=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys-tx.pcap | grep -v ${lsp_garp} -c`
    test 0 -eq $pkts
])

spa=$(ip_to_hex 10 0 0 1)
tpa=$(ip_to_hex 10 0 0 100)
send_garp 1 000000000001 ffffffffffff $spa $tpa

dnl traffic from localport should not be sent to localnet
AT_CHECK([tcpdump -r hv1/br-phys_n1-tx.pcap arp[[24:4]]=0x0a000064 | wc -l],[0],[dnl
0
],[ignore])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([localport doesn't suppress ARP directed to external port])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])

ovn_start
net_add n1

check ovs-vsctl add-br br-phys
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl ls-add ls

# create topology to allow to talk from localport through localnet to external port
check ovn-nbctl lsp-add ls lp
check ovn-nbctl lsp-set-addresses lp "00:00:00:00:00:01 10.0.0.1"
check ovn-nbctl lsp-set-type lp localport
check ovs-vsctl add-port br-int lp -- set Interface lp external-ids:iface-id=lp

check ovn-nbctl --wait=sb ha-chassis-group-add hagrp
check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp main 10
check ovn-nbctl lsp-add ls lext
check ovn-nbctl lsp-set-addresses lext "00:00:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-type lext external
hagrp_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp`
check ovn-nbctl set logical_switch_port lext ha_chassis_group=$hagrp_uuid

check ovn-nbctl lsp-add ls ln
check ovn-nbctl lsp-set-addresses ln unknown
check ovn-nbctl lsp-set-type ln localnet
check ovn-nbctl lsp-set-options ln network_name=phys
check ovn-nbctl --wait=hv sync

# also create second external port AFTER localnet to check that order is irrelevant
check ovn-nbctl lsp-add ls lext2
check ovn-nbctl lsp-set-addresses lext2 "00:00:00:00:00:10 10.0.0.10"
check ovn-nbctl lsp-set-type lext2 external
check ovn-nbctl set logical_switch_port lext2 ha_chassis_group=$hagrp_uuid
check ovn-nbctl --wait=hv sync

# create and immediately delete an external port to later check that flows for
# deleted ports are not left over in flow table
check ovn-nbctl lsp-add ls lext-deleted
check ovn-nbctl lsp-set-addresses lext-deleted "00:00:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-type lext-deleted external
check ovn-nbctl set logical_switch_port lext-deleted ha_chassis_group=$hagrp_uuid
check ovn-nbctl --wait=hv sync
check ovn-nbctl lsp-del lext-deleted
check ovn-nbctl --wait=hv sync

send_garp() {
    local inport=$1 eth_src=$2 eth_dst=$3 spa=$4 tpa=$5
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    ovs-appctl netdev-dummy/receive $inport $request
}

send_frames() {
    spa=$(ip_to_hex 10 0 0 1)
    tpa=$(ip_to_hex 10 0 0 2)
    send_garp lp 000000000001 000000000002 $spa $tpa

    spa=$(ip_to_hex 10 0 0 1)
    tpa=$(ip_to_hex 10 0 0 10)
    send_garp lp 000000000001 000000000010 $spa $tpa

    spa=$(ip_to_hex 10 0 0 1)
    tpa=$(ip_to_hex 10 0 0 3)
    send_garp lp 000000000001 000000000003 $spa $tpa
}

send_frames

dnl external traffic from localport should be sent to localnet
AT_CHECK([tcpdump -r main/br-phys_n1-tx.pcap arp[[24:4]]=0x0a000002 | wc -l],[0],[dnl
1
],[ignore])

dnl ...regardless of localnet / external ports creation order
AT_CHECK([tcpdump -r main/br-phys_n1-tx.pcap arp[[24:4]]=0x0a00000a | wc -l],[0],[dnl
1
],[ignore])

dnl traffic from localport should not be sent to deleted external port
AT_CHECK([tcpdump -r main/br-phys_n1-tx.pcap arp[[24:4]]=0x0a000003 | wc -l],[0],[dnl
0
],[ignore])

# now disown both external ports, one by moving to another (non-existing)
# chassis, another by removing the port from any ha groups
check ovn-nbctl --wait=sb ha-chassis-group-add fake_hagrp
fake_hagrp_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name=fake_hagrp`
check ovn-nbctl set logical_switch_port lext ha_chassis_group=$fake_hagrp_uuid
check ovn-nbctl clear logical_switch_port lext2 ha_chassis_group
check ovn-nbctl --wait=hv sync

# check that traffic no longer leaks into localnet
send_frames

for suffix in 2 a; do
    AT_CHECK([tcpdump -r main/br-phys_n1-tx.pcap arp[[24:4]]=0x0a00000${suffix} | wc -l],[0],[dnl
1
],[ignore])
done

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([localport takes part in broadcast ARP delivery])

ovn_start
net_add n1

check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# enable vlan transparency to disable local arp responder and allow ovn deliver
# the request to the other side
ovn-nbctl ls-add ls -- add Logical_Switch ls other_config vlan-passthru=true

check ovn-nbctl lsp-add ls lp
check ovn-nbctl lsp-set-addresses lp "00:00:00:00:00:01 10.0.0.1"
check ovn-nbctl lsp-set-type lp localport
check ovs-vsctl add-port br-int lp \
    -- set Interface lp external-ids:iface-id=lp \
        options:tx_pcap=lp-tx.pcap \
        options:rxq_pcap=lp-rx.pcap

check ovn-nbctl lsp-add ls lsp
check ovn-nbctl lsp-set-addresses lsp "00:00:00:00:00:02 10.0.0.2"
check ovs-vsctl add-port br-int lsp \
    -- set Interface lsp external-ids:iface-id=lsp

wait_for_ports_up
check ovn-nbctl --wait=hv sync

: > lp.expected

send_arp_request() {
    local inport=$1 outport=$2 eth_src=$3 spa=$4 tpa=$5
    local eth_dst=ffffffffffff
    local eth_type=0806
    local eth=${eth_dst}${eth_src}${eth_type}

    local arp=0001080006040001${eth_src}${spa}${eth_dst}${tpa}

    local request=${eth}${arp}
    check ovs-appctl netdev-dummy/receive $inport $request
    echo $request >> $outport.expected
}

src_mac=000000000002
src_ip=$(ip_to_hex 10 0 0 2)
dst_ip=$(ip_to_hex 10 0 0 1)
send_arp_request lsp lp ${src_mac} ${src_ip} ${dst_ip}

OVN_CHECK_PACKETS([lp-tx.pcap], [lp.expected])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([1 LR with HA distributed router gateway port])
ovn_start

net_add n1

# create gateways with external network connectivity

for i in 1 2; do
    sim_add gw$i
    as gw$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
done

ovn-nbctl ls-add inside
ovn-nbctl ls-add outside

# create hypervisors with a vif port each to an internal network

for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.1$i
    ovs-vsctl -- add-port br-int hv$i-vif1 -- \
        set interface hv$i-vif1 external-ids:iface-id=inside$i \
        options:tx_pcap=hv$i/vif1-tx.pcap \
        options:rxq_pcap=hv$i/vif1-rx.pcap \
        ofport-request=1

        ovn-nbctl lsp-add inside inside$i \
            -- lsp-set-addresses inside$i "f0:00:00:01:22:$i 192.168.1.10$i"

done

OVN_POPULATE_ARP

ovn-nbctl create Logical_Router name=R1

# Connect inside to R1
ovn-nbctl lrp-add R1 inside 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add inside rp-inside -- set Logical_Switch_Port rp-inside \
    type=router options:router-port=inside \
    -- lsp-set-addresses rp-inside router

# Connect outside to R1 as distributed router gateway port on gw1+gw2
ovn-nbctl lrp-add R1 outside 00:00:02:01:02:04 192.168.0.101/24

ovn-nbctl --id=@gc0 create Gateway_Chassis \
                    name=outside_gw1 chassis_name=gw1 priority=20 -- \
          --id=@gc1 create Gateway_Chassis \
                    name=outside_gw2 chassis_name=gw2 priority=10 -- \
          set Logical_Router_Port outside 'gateway_chassis=[@gc0,@gc1]'

ovn-nbctl lsp-add outside rp-outside -- set Logical_Switch_Port rp-outside \
    type=router options:router-port=outside \
    -- lsp-set-addresses rp-outside router

# Create localnet port in outside
ovn-nbctl lsp-add outside ln-outside
ovn-nbctl lsp-set-addresses ln-outside unknown
ovn-nbctl lsp-set-type ln-outside localnet
ovn-nbctl lsp-set-options ln-outside network_name=phys

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"
ovn-sbctl dump-flows
echo "---------------------"
ovn-sbctl list chassis
ovn-sbctl list encap
echo "---------------------"
echo "------ ha_Chassis_Group dump (SBDB) -------"
ovn-sbctl list HA_Chassis_Group
echo "------ ha_Chassis dump (SBDB) -------"
ovn-sbctl list HA_Chassis
echo "------ Port_Binding chassisredirect -------"
ovn-sbctl find Port_Binding type=chassisredirect
echo "-------------------------------------------"

# There should be one ha_chassis_group with the name "outside"
check_row_count HA_Chassis_Group 1 name=outside

# There should be 2 ha_chassis rows in SB DB.
check_row_count HA_Chassis 2 'chassis!=[[]]'

ha_ch=$(fetch_column HA_Chassis_Group ha_chassis)
check_column "$ha_ch" HA_Chassis _uuid

for chassis in gw1 gw2 hv1 hv2; do
    as $chassis
    echo "------ $chassis dump ----------"
    ovs-ofctl show br-int
    ovs-ofctl dump-flows br-int
    echo "--------------------------"
done
bfd_dump() {
    for chassis in gw1 gw2 hv1 hv2; do
        as $chassis
        echo "------ $chassis dump (BFD)----"
        echo "BFD (from $chassis):"
        # dump BFD config and status to the other chassis
        for chassis2 in gw1 gw2 hv1 hv2; do
            if [[ "$chassis" != "$chassis2" ]]; then
                echo " -> $chassis2:"
                echo "   $(ovs-vsctl --bare --columns bfd,bfd_status find Interface name=ovn-$chassis2-0)"
            fi
        done
        echo "--------------------------"
    done
}

bfd_dump

hv1_gw1_ofport=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw1-0)
hv1_gw2_ofport=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw2-0)
hv2_gw1_ofport=$(as hv2 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw1-0)
hv2_gw2_ofport=$(as hv2 ovs-vsctl --bare --columns ofport find Interface name=ovn-gw2-0)

echo $hv1_gw1_ofport
echo $hv1_gw2_ofport
echo $hv2_gw1_ofport
echo $hv2_gw2_ofport

echo "--- hv1 ---"
as hv1 ovs-ofctl dump-flows br-int table=39

echo "--- hv2 ---"
as hv2 ovs-ofctl dump-flows br-int table=39

gw1_chassis=$(fetch_column Chassis _uuid name=gw1)
gw2_chassis=$(fetch_column Chassis _uuid name=gw2)

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=39 | \
grep active_backup | grep members:$hv1_gw1_ofport,$hv1_gw2_ofport \
| wc -l], [0], [1
])

OVS_WAIT_FOR_OUTPUT([as hv2 ovs-ofctl dump-flows br-int table=39 | \
grep active_backup | grep members:$hv2_gw1_ofport,$hv2_gw2_ofport \
| wc -l], [0], [1
])

# make sure that flows for handling the outside router port reside on gw1 through ls_in_l2_lkup table

sleep 10

as gw1 ovs-ofctl dump-flows br-int

OVS_WAIT_FOR_OUTPUT([as gw1 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[1
]])
OVS_WAIT_FOR_OUTPUT([as gw2 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[0
]])

# make sure ARP responder flows for outside router port reside on gw1 too through ls_in_arp_rsp table
OVS_WAIT_UNTIL([test `as gw1 ovs-ofctl dump-flows br-int table=29 | \
grep arp_tpa=192.168.0.101 | wc -l` -ge 1])

# check that the chassis redirect port has been claimed by the gw1 chassis
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw1_chassis

hv1_ch_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_ch_uuid=$(fetch_column Chassis _uuid name=hv2)
exp_ref_ch_list="$hv1_ch_uuid $hv2_ch_uuid"
wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# at this point, we invert the priority of the gw chassis between gw1 and gw2

ovn-nbctl --id=@gc0 create Gateway_Chassis \
                    name=outside_gw1 chassis_name=gw1 priority=10 -- \
          --id=@gc1 create Gateway_Chassis \
                    name=outside_gw2 chassis_name=gw2 priority=20 -- \
          set Logical_Router_Port outside 'gateway_chassis=[@gc0,@gc1]'


wait_for_ports_up
check ovn-nbctl --wait=hv sync

# we make sure that the hypervisors noticed, and inverted the slave ports
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=39 | \
grep active_backup | grep members:$hv1_gw2_ofport,$hv1_gw1_ofport \
| wc -l], [0], [1
])

OVS_WAIT_FOR_OUTPUT([as hv2 ovs-ofctl dump-flows br-int table=39 | \
grep active_backup | grep members:$hv2_gw2_ofport,$hv2_gw1_ofport \
| wc -l], [0], [1
])

wait_bfd_enabled() {
    interface=$1
    OVS_WAIT_UNTIL([test 1 = `ovs-vsctl --bare --columns bfd find Interface name=$interface | \
grep "enable=true" | wc -l`
])
}

# check that the chassis redirect port has been reclaimed by the gw2 chassis
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw2_chassis

# check BFD enablement on tunnel ports from gw1 #########
as gw1
for chassis in gw2 hv1 hv2; do
    echo "checking gw1 -> $chassis"
    wait_bfd_enabled ovn-$chassis-0
done

# check BFD enablement on tunnel ports from gw2 ##########
as gw2
for chassis in gw1 hv1 hv2; do
    echo "checking gw2 -> $chassis"
    wait_bfd_enabled ovn-$chassis-0
done

# check BFD enablement on tunnel ports from hv1 ###########
as hv1
for chassis in gw1 gw2; do
    echo "checking hv1 -> $chassis"
    wait_bfd_enabled ovn-$chassis-0
done
# make sure BFD is not enabled to hv2, we don't need it
AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-hv2-0],[0],
         [[
]])


# check BFD enablement on tunnel ports from hv2 ##########
as hv2
for chassis in gw1 gw2; do
    echo "checking hv2 -> $chassis"
    wait_bfd_enabled ovn-$chassis-0
done
# make sure BFD is not enabled to hv1, we don't need it
AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-hv1-0],[0],
         [[
]])

# make sure that flows for handling the outside router port reside on gw2 now
OVS_WAIT_FOR_OUTPUT([as gw2 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[1
]])
OVS_WAIT_FOR_OUTPUT([as gw1 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[0
]])

# disconnect GW2 from the network, GW1 should take over
as gw2
port=${sandbox}_br-phys
as main ovs-vsctl del-port n1 $port

bfd_dump

# make sure that flows for handling the outside router port reside on gw1 now
OVS_WAIT_FOR_OUTPUT([as gw1 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[1
]])
OVS_WAIT_FOR_OUTPUT([as gw2 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[0
]])

# check that the chassis redirect port has been reclaimed by the gw1 chassis
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw1_chassis

ovn-nbctl --wait=hv set NB_Global . options:"bfd-min-rx"=2000
as gw2
for chassis in gw1 hv1 hv2; do
    echo "checking gw2 -> $chassis"
    OVS_WAIT_UNTIL([
    bfd_cfg=$(ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0)
    test "$bfd_cfg" = "enable=true min_rx=2000"
])
done
ovn-nbctl --wait=hv set NB_Global . options:"bfd-min-tx"=1500
for chassis in gw1 hv1 hv2; do
    echo "checking gw2 -> $chassis"
    OVS_WAIT_UNTIL([
    bfd_cfg=$(ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0)
    test "$bfd_cfg" = "enable=true min_rx=2000 min_tx=1500"
])
done
ovn-nbctl remove NB_Global . options "bfd-min-rx"
ovn-nbctl --wait=hv set NB_Global . options:"bfd-mult"=15
for chassis in gw1 hv1 hv2; do
    echo "checking gw2 -> $chassis"
    OVS_WAIT_UNTIL([
    bfd_cfg=$(ovs-vsctl --bare --columns bfd find Interface name=ovn-$chassis-0)
    test "$bfd_cfg" = "enable=true min_tx=1500 mult=15"
])
done

# Delete the inside1 vif. The ref_chassis in ha_chassis_group shouldn't have
# reference to hv1.
as hv1 ovs-vsctl del-port hv1-vif1

wait_column "$hv2_ch_uuid" HA_Chassis_Group ref_chassis

# Delete the inside2 vif.
ovn-sbctl show

echo "Deleting hv2-vif1"
as hv2 ovs-vsctl del-port hv2-vif1

# ref_chassis of ha_chassis_group should be empty
wait_column '' HA_Chassis_Group ref_chassis

# Delete the Gateway_Chassis for lrp - outside
ovn-nbctl clear Logical_Router_Port outside gateway_chassis

# There shoud be no ha_chassis_group rows in SB DB.
wait_row_count HA_Chassis_Group 0
wait_row_count HA_Chassis 0

ovn-nbctl remove NB_Global . options "bfd-min-rx"
ovn-nbctl remove NB_Global . options "bfd-min-tx"
ovn-nbctl remove NB_Global . options "bfd-mult"

# Now test with HA chassis group instead of Gateway chassis in NB DB
ovn-nbctl --wait=sb ha-chassis-group-add hagrp1

ovn-nbctl list ha_chassis_group
ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp1
hagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp1`
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 gw1 30
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 gw2 20

# ovn-northd should not create HA chassis group and HA chassis rows
# unless the HA chassis group in OVN NB DB is associated to
# a logical router port.
wait_row_count HA_Chassis 0

# Associate hagrp1 to outside logical router port
ovn-nbctl set Logical_Router_Port outside ha_chassis_group=$hagrp1_uuid

wait_row_count HA_Chassis_Group 1
wait_row_count HA_Chassis 2

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=39 | \
grep active_backup | grep members:$hv1_gw1_ofport,$hv1_gw2_ofport \
| wc -l], [0], [0
])

OVS_WAIT_FOR_OUTPUT([as hv2 ovs-ofctl dump-flows br-int table=39 | \
grep active_backup | grep members:$hv2_gw1_ofport,$hv2_gw2_ofport \
| wc -l], [0], [0
])

# Re add the ovs ports.
for i in 1 2; do
    as hv$i
    ovs-vsctl -- add-port br-int hv$i-vif1 -- \
        set interface hv$i-vif1 external-ids:iface-id=inside$i \
        options:tx_pcap=hv$i/vif1-tx.pcap \
        options:rxq_pcap=hv$i/vif1-rx.pcap \
        ofport-request=1
done

# Re-add gw2
as gw2 ovn_attach n1 br-phys 192.168.0.1

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=39 | \
grep active_backup | grep members:$hv1_gw1_ofport,$hv1_gw2_ofport \
| wc -l], [0], [1
])

OVS_WAIT_FOR_OUTPUT([as hv2 ovs-ofctl dump-flows br-int table=39 | \
grep active_backup | grep members:$hv2_gw1_ofport,$hv2_gw2_ofport \
| wc -l], [0], [1
])

# make sure that flows for handling the outside router port reside on gw1
OVS_WAIT_FOR_OUTPUT([as gw1 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[1
]])
OVS_WAIT_FOR_OUTPUT([as gw2 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst:00:00:02:01:02:04" | wc -l], [0], [[0
]])

# make sure ARP responder flows for outside router port reside on gw1 too
OVS_WAIT_UNTIL([test `as gw1 ovs-ofctl dump-flows br-int table=29 | \
grep arp_tpa=192.168.0.101 | wc -l` -ge 1 ])

# check that the chassis redirect port has been claimed by the gw1 chassis
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw1_chassis

hv1_ch_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_ch_uuid=$(fetch_column Chassis _uuid name=hv2)
exp_ref_ch_list="$hv1_ch_uuid $hv2_ch_uuid"
wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# Increase the priority of gw2
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 gw2 40

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=39 | \
grep active_backup | grep members:$hv1_gw2_ofport,$hv1_gw1_ofport \
| wc -l], [0], [1
])

OVS_WAIT_FOR_OUTPUT([as hv2 ovs-ofctl dump-flows br-int table=39 | \
grep active_backup | grep members:$hv2_gw2_ofport,$hv2_gw1_ofport \
| wc -l], [0], [1
])

# check that the chassis redirect port has been reclaimed by the gw2 chassis
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw2_chassis

# check BFD enablement on tunnel ports from gw1 #########
as gw1
for chassis in gw2 hv1 hv2; do
    echo "checking gw1 -> $chassis"
    wait_bfd_enabled ovn-$chassis-0
done

# check BFD enablement on tunnel ports from gw2 ##########
as gw2
for chassis in gw1 hv1 hv2; do
    echo "checking gw2 -> $chassis"
    wait_bfd_enabled ovn-$chassis-0
done

# check BFD enablement on tunnel ports from hv1 ###########
as hv1
for chassis in gw1 gw2; do
    echo "checking hv1 -> $chassis"
    wait_bfd_enabled ovn-$chassis-0
done
# make sure BFD is not enabled to hv2, we don't need it
AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-hv2-0],[0],
         [[
]])

# check BFD enablement on tunnel ports from hv2 ##########
as hv2
for chassis in gw1 gw2; do
    echo "checking hv2 -> $chassis"
    wait_bfd_enabled ovn-$chassis-0
done
# make sure BFD is not enabled to hv1, we don't need it
AT_CHECK([ovs-vsctl --bare --columns bfd find Interface name=ovn-hv1-0],[0],
         [[
]])

# make sure that flows for handling the outside router port reside on gw2 now
OVS_WAIT_FOR_OUTPUT([as gw2 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[1
]])
OVS_WAIT_FOR_OUTPUT([as gw1 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[0
]])

# disconnect GW2 from the network, GW1 should take over
as gw2
port=${sandbox}_br-phys
as main ovs-vsctl del-port n1 $port

bfd_dump

# make sure that flows for handling the outside router port reside on gw2 now
OVS_WAIT_FOR_OUTPUT([as gw1 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[1
]])
OVS_WAIT_FOR_OUTPUT([as gw2 ovs-ofctl dump-flows br-int table=35 | \
grep "dl_dst=00:00:02:01:02:04" | wc -l], [0], [[0
]])

# check that the chassis redirect port has been reclaimed by the gw1 chassis
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw1_chassis

OVN_CLEANUP([gw1],[gw2],[hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([send gratuitous ARP for NAT rules on HA distributed router])
ovn_start
ovn-nbctl ls-add ls0
ovn-nbctl ls-add ls1
ovn-nbctl create Logical_Router name=lr0
ovn-nbctl lrp-add lr0 lrp0 f0:00:00:00:00:01 192.168.0.100/24

ovn-nbctl --id=@gc0 create Gateway_Chassis \
                    name=outside_gw1 chassis_name=hv2 priority=10 -- \
          --id=@gc1 create Gateway_Chassis \
                    name=outside_gw2 chassis_name=hv3 priority=1 -- \
          set Logical_Router_Port lrp0 'gateway_chassis=[@gc0,@gc1]'

ovn-nbctl lsp-add ls0 lrp0-rp -- set Logical_Switch_Port lrp0-rp \
    type=router options:router-port=lrp0 addresses="router"
ovn-nbctl lrp-add lr0 lrp1 f0:00:00:00:00:02 10.0.0.1/24
ovn-nbctl lsp-add ls1 lrp1-rp -- set Logical_Switch_Port lrp1-rp \
    type=router options:router-port=lrp1 addresses="router"

# Add NAT rules
AT_CHECK([ovn-nbctl lr-nat-add lr0 snat 192.168.0.100 10.0.0.0/24])

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])
AT_CHECK([ovs-vsctl add-port br-phys snoopvif -- set Interface snoopvif options:tx_pcap=hv1/snoopvif-tx.pcap options:rxq_pcap=hv1/snoopvif-rx.pcap])

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
AT_CHECK([as hv2 ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])

sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
AT_CHECK([as hv3 ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])

# Create a localnet port.
AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])

# wait for earlier changes to take effect
wait_for_ports_up
check ovn-nbctl --wait=hv sync
OVN_WAIT_PATCH_PORT_FLOWS(["ln_port"], ["hv2"] ["hv3"])

# reset hv1/snoopvif after hv2/br-phys_n1 and hv3/br-phys_n1 as we wait
# for packets to be received on hv1/snoopvif-tx.
# Otherwise, after we received a packet on hv1/snoopvif it might get reset
# in hv2/br-phys_n1 or hv3/br-phys_n1.
as hv2 reset_pcap_file br-phys_n1 hv2/br-phys_n1
as hv3 reset_pcap_file br-phys_n1 hv3/br-phys_n1
as hv1 reset_pcap_file snoopvif hv1/snoopvif
# add nat-addresses option
ovn-nbctl --wait=hv lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"

only_broadcast_from_lrp1() {
    grep "fffffffffffff00000000001"
}

garp="fffffffffffff0000000000108060001080006040001f00000000001c0a80064000000000000c0a80064"
echo $garp > expected_out

OVN_CHECK_PACKETS_CONTAIN([hv1/snoopvif-tx.pcap], [expected_out], "trim_zeros")
OVN_CHECK_PACKETS_CONTAIN([hv2/br-phys_n1-tx.pcap], [expected_out], "trim_zeros")
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv3/br-phys_n1-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq > hv3_br_phys_tx
echo "packets on hv3 br-phys tx"
cat hv3_br_phys_tx
AT_CHECK([grep $garp hv3_br_phys_tx | sort], [0], [])


# at this point, we invert the priority of the gw chassis between hv2 and hv3

ovn-nbctl --wait=hv \
          --id=@gc0 create Gateway_Chassis \
                    name=outside_gw1 chassis_name=hv2 priority=1 -- \
          --id=@gc1 create Gateway_Chassis \
                    name=outside_gw2 chassis_name=hv3 priority=10 -- \
          set Logical_Router_Port lrp0 'gateway_chassis=[@gc0,@gc1]'

# We expect not to receive garp on hv2 after inverting the priority.
# Hence  reset hv2 after inverting priority as otherwise a garp might
# be received on hv2 between the reset and the priority change.

as hv2 reset_pcap_file br-phys_n1 hv2/br-phys_n1
as hv3 reset_pcap_file br-phys_n1 hv3/br-phys_n1
as hv1 reset_pcap_file snoopvif hv1/snoopvif


OVN_CHECK_PACKETS_CONTAIN([hv1/snoopvif-tx.pcap], [expected_out], "trim_zeros")
OVN_CHECK_PACKETS_CONTAIN([hv3/br-phys_n1-tx.pcap], [expected_out], "trim_zeros")
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq > hv2_br_phys_tx
AT_CHECK([grep $garp hv2_br_phys_tx | sort], [0], [])

# change localnet port tag.
check ovn-nbctl set Logical_Switch_Port ln_port tag_request=2014

# wait for earlier changes to take effect
OVS_WAIT_UNTIL([test 1 = `as hv2 ovs-ofctl dump-flows br-int table=65 | \
grep "actions=mod_vlan_vid:2014" | wc -l`
])

OVS_WAIT_UNTIL([test 1 = `as hv3 ovs-ofctl dump-flows br-int table=65 | \
grep "actions=mod_vlan_vid:2014" | wc -l`
])

# update nat-addresses option
ovn-nbctl --wait=hv clear logical_switch_port lrp0-rp options

#Wait until the Port_Binding.nat_addresses is cleared.
OVS_WAIT_UNTIL([test 0 = `ovn-sbctl --bare --columns nat_addresses find port_binding \
logical_port=lrp0-rp | grep is_chassis | wc -l`])

as hv2 reset_pcap_file br-phys_n1 hv2/br-phys_n1
as hv3 reset_pcap_file br-phys_n1 hv3/br-phys_n1
as hv1 reset_pcap_file snoopvif hv1/snoopvif

ovn-nbctl --wait=hv lsp-set-options lrp0-rp router-port=lrp0 nat-addresses="router"

#Wait until the Port_Binding.nat_addresses is set.
OVS_WAIT_UNTIL([test 1 = `ovn-sbctl --bare --columns nat_addresses find port_binding \
logical_port=lrp0-rp | grep is_chassis | wc -l`])

garp="fffffffffffff00000000001810007de08060001080006040001f00000000001c0a80064000000000000c0a80064"
echo $garp > expected_out

OVN_CHECK_PACKETS_CONTAIN([hv1/snoopvif-tx.pcap], [expected_out], "trim_zeros")
OVN_CHECK_PACKETS_CONTAIN([hv3/br-phys_n1-tx.pcap], [expected_out], "trim_zeros")
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap | trim_zeros | only_broadcast_from_lrp1 | uniq > hv2_br_phys_tx
AT_CHECK([grep $garp hv2_br_phys_tx | sort], [0], [])

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ensure one gw controller restart in HA doesn't bounce the master])
ovn_start

net_add n1

# create two gateways with external network connectivity
for i in 1 2; do
    sim_add gw$i
    as gw$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
done

ovn-nbctl ls-add inside
ovn-nbctl ls-add outside

# create one hypervisors with a vif port the internal network
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=inside1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl lsp-add inside inside1 \
        -- lsp-set-addresses inside1 "f0:00:00:01:22:01 192.168.1.101"


OVN_POPULATE_ARP

ovn-nbctl create Logical_Router name=R1

# Connect inside to R1
ovn-nbctl lrp-add R1 inside 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add inside rp-inside -- set Logical_Switch_Port rp-inside \
    type=router options:router-port=inside \
    -- lsp-set-addresses rp-inside router

# Connect outside to R1 as distributed router gateway port on gw1+gw2
ovn-nbctl lrp-add R1 outside 00:00:02:01:02:04 192.168.0.101/24

ovn-nbctl --id=@gc0 create Gateway_Chassis \
                    name=outside_gw1 chassis_name=gw1 priority=20 -- \
          --id=@gc1 create Gateway_Chassis \
                    name=outside_gw2 chassis_name=gw2 priority=10 -- \
          set Logical_Router_Port outside 'gateway_chassis=[@gc0,@gc1]'

ovn-nbctl lsp-add outside rp-outside -- set Logical_Switch_Port rp-outside \
    type=router options:router-port=outside \
    -- lsp-set-addresses rp-outside router

# Create localnet port in outside
ovn-nbctl lsp-add outside ln-outside
ovn-nbctl lsp-set-addresses ln-outside unknown
ovn-nbctl lsp-set-type ln-outside localnet
ovn-nbctl lsp-set-options ln-outside network_name=phys

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# currently when ovn-controller is restarted, the old entry is deleted
# and a new one is created, which leaves the Gateway_Chassis with
# an empty chassis for a while. NOTE: restarting ovn-controller in tests
# doesn't have the same effect because "name" is conserved, and the
# Chassis entry is not replaced.

gw2_chassis=$(ovn-sbctl --bare --columns=_uuid find Chassis name=gw2)
ovn-sbctl destroy Chassis $gw2_chassis

# Wait for the gw2_chassis row is recreated.
wait_row_count Chassis 1 name=gw2

# When gw2 chassis row is destroyed, it gets recreated. There
# is a small window in which gw2 may claim the cr-outside port if
# it has not established bfd tunnel with gw1.
# So make sure that, cr-outside is claimed by gw1 finally.
gw1_chassis=$(fetch_column Chassis _uuid name=gw1)
wait_row_count Port_Binding 1 logical_port=cr-outside chassis=$gw1_chassis

OVN_CLEANUP([gw1],[gw2],[hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([allow IPv6 RA / NA / MLD by default])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start
net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

lsp_mac_prefix=50:64:00:00:00:0
lsp_ip_prefix=10.0.0.
lsp_ip6_prefix=aef0::5264:00ff:fe00:000

check ovn-nbctl ls-add ls0
for i in 1 2; do
  check ovn-nbctl lsp-add ls0 lsp$i
  check ovn-nbctl lsp-set-addresses lsp$i \
    "${lsp_mac_prefix}$i ${lsp_ip_prefix}$i ${lsp_ip6_prefix}$i"

  # forbid all traffic for the ports
  check ovn-nbctl acl-add ls0 \
      from-lport 1000 "inport == \"lsp$i\"" drop
  check ovn-nbctl --apply-after-lb acl-add ls0\
      from-lport 1000 "inport == \"lsp$i\"" drop
  check ovn-nbctl acl-add ls0 \
      to-lport 1000 "outport == \"lsp$i\"" drop

  check ovs-vsctl -- add-port br-int vif$i -- \
      set interface vif$i external-ids:iface-id=lsp$i \
      options:tx_pcap=hv1/vif$i-tx.pcap \
      options:rxq_pcap=hv1/vif$i-rx.pcap
  : > $i.expected
done

router_mac=fa:16:3e:00:00:01
router_prefix=fdad:1234:5678::
router_ip=${router_prefix}1
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lrp0 ${router_mac} ${router_ip}/64
check ovn-nbctl set Logical_Router_Port lrp0 ipv6_ra_configs:address_mode="slaac"
check ovn-nbctl \
    -- lsp-add ls0 rp0 \
    -- set Logical_Switch_Port rp0 type=router \
                     options:router-port=lrp0 \
                     addresses='"${router_mac} ${router_ip}"'

wait_for_ports_up

test_ns_na() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5

    packet=$(fmt_pkt "
        Ether(dst='ff:ff:ff:ff:ff:ff', src='${src_mac}') /
        IPv6(src='${src_ip}', dst='ff02::1:ff00:2') /
        ICMPv6ND_NS(tgt='${dst_ip}')
    ")
    as hv1 ovs-appctl netdev-dummy/receive vif${inport} $packet

    expected_packet=$(fmt_pkt "
        Ether(dst='${src_mac}', src='${dst_mac}') /
        IPv6(src='${dst_ip}', dst='${src_ip}') /
        ICMPv6ND_NA(tgt='${dst_ip}', R=0, S=1) /
        ICMPv6NDOptDstLLAddr(lladdr='${dst_mac}')
    ")
    echo $expected_packet >> $inport.expected
}

test_rs_ra() {
    local inport=$1 src_mac=$2 src_ip=$3
    local router_mac=$4 router_prefix=$5 router_ip=$6

    packet=$(fmt_pkt "
        Ether(dst='ff:ff:ff:ff:ff:ff', src='${src_mac}') /
        IPv6(src='${src_ip}', dst='ff02::2') /
        ICMPv6ND_RS()
    ")
    as hv1 ovs-appctl netdev-dummy/receive vif${inport} $packet

    expected_packet=$(fmt_pkt "
        Ether(dst='${src_mac}', src='${router_mac}') /
        IPv6(src='${router_ip}', dst='${src_ip}') /
        ICMPv6ND_RA(chlim=255, prf=0, routerlifetime=65535) /
        ICMPv6NDOptSrcLLAddr(lladdr='${router_mac}') /
        ICMPv6NDOptPrefixInfo(prefix='${router_prefix}')
    ")
    echo $expected_packet >> $inport.expected
}

test_mldv2() {
    local inport=$1 outport=$2 src_mac=$3 src_ip=$4

    packet=$(fmt_pkt "
        Ether(dst='ff:ff:ff:ff:ff:ff', src='${src_mac}') /
        IPv6(src='${src_ip}', dst='ff02::2') /
        ICMPv6MLQuery2()
    ")
    as hv1 ovs-appctl netdev-dummy/receive vif${inport} $packet

    expected_packet=$packet
    echo $expected_packet >> $outport.expected
}

src_mac=${lsp_mac_prefix}1
dst_mac=${lsp_mac_prefix}2
src_ip=${lsp_ip6_prefix}1
dst_ip=${lsp_ip6_prefix}2

as hv1
test_ns_na 1 $src_mac $dst_mac $src_ip $dst_ip

as hv1
router_local_ip=fe80::f816:3eff:fe00:1
test_rs_ra 1 $src_mac $src_ip $router_mac $router_prefix $router_local_ip

as hv1
src_ip=fe80::1
test_mldv2 1 2 $src_mac $src_ip

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])
OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [2.expected])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IPv6 Neighbor Solicitation for unknown MAC])
AT_KEYWORDS([ovn-nd_ns for unknown mac])
ovn_start

ovn-nbctl ls-add sw0_ip6
ovn-nbctl lsp-add sw0_ip6 sw0_ip6-port1
ovn-nbctl lsp-set-addresses sw0_ip6-port1 \
"50:64:00:00:00:02 aef0::5264:00ff:fe00:0002"

ovn-nbctl lsp-set-port-security sw0_ip6-port1 \
"50:64:00:00:00:02 aef0::5264:00ff:fe00:0002"

ovn-nbctl lr-add lr0_ip6
ovn-nbctl lrp-add lr0_ip6 lrp0_ip6 00:00:00:00:af:01 aef0:0:0:0:0:0:0:0/64
ovn-nbctl lsp-add sw0_ip6 lrp0_ip6-attachment
ovn-nbctl lsp-set-type lrp0_ip6-attachment router
ovn-nbctl lsp-set-addresses lrp0_ip6-attachment router
ovn-nbctl lsp-set-options lrp0_ip6-attachment router-port=lrp0_ip6
ovn-nbctl set logical_router_port lrp0_ip6 ipv6_ra_configs:address_mode=slaac

ovn-nbctl ls-add public
ovn-nbctl lsp-add public ln-public
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl lsp-set-options ln-public network_name=phys

ovn-nbctl lrp-add lr0_ip6 ip6_public 00:00:02:01:02:04 \
2001:db8:1:0:200:02ff:fe01:0204/64 \
-- lrp-set-gateway-chassis ip6_public hv1

# Install default static route.
ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
ip_prefix="\:\:/0" nexthop="2001\:db8\:1\:0\:200\:02ff\:fe01\:1305" \
-- add Logical_Router lr0_ip6 static_routes @lrt

ovn-nbctl lsp-add public rp-ip6_public -- set Logical_Switch_Port \
rp-ip6_public  type=router options:router-port=ip6_public \
-- lsp-set-addresses rp-ip6_public router

# Add a second router connected to "public" and make sure the NS packets
# from the first router are not looped on the pysical network and
# don't cross routing domains.
ovn-nbctl ls-add sw1_ip6
ovn-nbctl lsp-add sw1_ip6 sw1_ip6-port1
ovn-nbctl lsp-set-addresses sw1_ip6-port1 \
"50:64:00:00:01:02 aef1::5264:00ff:fe00:0002"

ovn-nbctl lr-add lr1_ip6
ovn-nbctl lrp-add lr1_ip6 00:00:00:01:af:01 aef1:0:0:0:0:0:0:0/64
ovn-nbctl lsp-add sw1_ip6 lrp1_ip6-attachment
ovn-nbctl lsp-set-type lrp1_ip6-attachment router
ovn-nbctl lsp-set-addresses lrp1_ip6-attachment router
ovn-nbctl lsp-set-options lrp1_ip6-attachment router-port=lrp1_ip6

ovn-nbctl lrp-add lr1_ip6 ip6_public_1 00:01:02:01:02:04 \
2002:db8:1:0:200:02ff:fe01:0204/64 \
-- lrp-set-gateway-chassis ip6_public_1 hv2

# Install default static route.
ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
ip_prefix="\:\:/0" nexthop="2002\:db8\:1\:0\:200\:02ff\:fe01\:1305" \
-- add Logical_Router lr1_ip6 static_routes @lrt

ovn-nbctl lsp-add public rp-ip6_public_1 -- set Logical_Switch_Port \
rp-ip6_public_1 type=router options:router-port=ip6_public_1 \
-- lsp-set-addresses rp-ip6_public_1 router

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0_ip6-port1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3

ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1_ip6-port1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

ovn-nbctl --wait=sb sync
wait_for_ports_up

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# There should be 2 Neighbor Advertisement flows for the router port
# aef0:: ip address in logical switch pipeline with action nd_na_router.
AT_CHECK([ovn-sbctl dump-flows sw0_ip6 | grep ls_in_arp_rsp | \
grep "nd_na_router" | wc -l], [0], [2
])

# There should be 4 Neighbor Advertisement flows with action nd_na_router
# in the router pipeline for the router lr0_ip6.
AT_CHECK([ovn-sbctl dump-flows lr0_ip6 | grep nd_na_router | \
wc -l], [0], [4
])

# Get the redirect chassis uuid.
chassis_uuid=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=cr-ip6_public chassis=$chassis_uuid

# Test the IPv6 Neighbor Solicitation (NS) - nd_ns action for unknown MAC
# addresses. ovn-controller should generate an IPv6 NS request for IPv6
# packets whose MAC is unknown (in the ARP_REQUEST router pipeline stage.
# test_ipv6 INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
# This function sends ipv6 packet
test_ipv6() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local dst_mcast_mac=$6 mcast_node_ip=$7 nd_target=$8 nd_src_ip=$9

    local packet=${dst_mac}${src_mac}86dd6000000000083aff${src_ip}${dst_ip}
    packet=${packet}8000000000000000

    src_mac=000002010204
    expected_packet=${dst_mcast_mac}${src_mac}86dd6000000000203aff${nd_src_ip}
    expected_packet=${expected_packet}${mcast_node_ip}8700XXXX00000000
    expected_packet=${expected_packet}${nd_target}0101${src_mac}

    as hv1 ovs-appctl netdev-dummy/receive hv1-vif${inport} $packet
    rm -f ipv6_ns.expected
    echo $expected_packet >> ipv6_ns.expected
}

src_mac=506400000002
dst_mac=00000000af01
src_ip=aef0000000000000526400fffe000002
nd_src_ip=fe80000000000000020002fffe010204
dst_ip=20010db800010000020002fffe010205
dst_mcast_mac=3333ff010205
mcast_node_ip=ff0200000000000000000001ff010205
nd_target=20010db800010000020002fffe010205
# Send an IPv6 packet. Generated IPv6 Neighbor solicitation packet
# should be received by the ports attached to br-phys.
as hv1 test_ipv6 1 $src_mac $dst_mac $src_ip $dst_ip $dst_mcast_mac \
$mcast_node_ip $nd_target $nd_src_ip

OVS_WAIT_WHILE([test 24 = $(wc -c hv1/br-phys_n1-tx.pcap | cut -d " " -f1)])
OVS_WAIT_WHILE([test 24 = $(wc -c hv1/br-phys-tx.pcap | cut -d " " -f1)])

# Use the grep here to filter out rarp packets that might have arrived
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys_n1-tx.pcap | \
grep -v ffffffffffff | trim_zeros > 1.packets
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys-tx.pcap | \
grep -v ffffffffffff | trim_zeros > 2.packets

cat ipv6_ns.expected | cut -c -112 > expout
AT_CHECK([cat 1.packets | cut -c -112], [0], [expout])
AT_CHECK([cat 2.packets | cut -c -112], [0], [expout])

# Skipping the ICMPv6 checksum
cat ipv6_ns.expected | cut -c 117- > expout
AT_CHECK([cat 1.packets | cut -c 117-], [0], [expout])
AT_CHECK([cat 2.packets | cut -c 117-], [0], [expout])

# Check that NS packets are not flooded across routing domains. That means
# that hv2 should not send any packets across the physical network.
# Use the grep here to filter out rarp packets that might have arrived
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap | \
grep -v ffffffffffff | trim_zeros > 2.packets
AT_CHECK([cat 2.packets], [0], [])

# Now send a packet with destination ip other than
# 2001:db8:1:0:200:02ff:fe01:0204/64 prefix.
as hv1
reset_pcap_file br-phys_n1 hv1/br-phys_n1
reset_pcap_file br-phys hv1/br-phys

src_mac=506400000002
dst_mac=00000000af01
src_ip=aef0000000000000526400fffe000002
dst_ip=20020ab8000100000200020000020306
# multicast mac of the nexthop IP - 2001:db8:1:0:200:02ff:fe01:1305
dst_mcast_mac=3333ff011305
mcast_node_ip=ff0200000000000000000001ff011305
nd_target=20010db800010000020002fffe011305
as hv1 test_ipv6 1 $src_mac $dst_mac $src_ip $dst_ip $dst_mcast_mac \
$mcast_node_ip $nd_target $nd_src_ip

OVS_WAIT_WHILE([test 24 = $(wc -c hv1/br-phys_n1-tx.pcap | cut -d " " -f1)])
OVS_WAIT_WHILE([test 24 = $(wc -c hv1/br-phys-tx.pcap | cut -d " " -f1)])

# Use the grep here to filter out rarp packets that might have arrived
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys_n1-tx.pcap | \
grep -v ffffffffffff | trim_zeros > 1.packets
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys-tx.pcap | \
grep -v ffffffffffff | trim_zeros > 2.packets

cat ipv6_ns.expected | cut -c -112 > expout
AT_CHECK([cat 1.packets | cut -c -112], [0], [expout])
AT_CHECK([cat 2.packets | cut -c -112], [0], [expout])

# Skipping the ICMPv6 checksum
cat ipv6_ns.expected | cut -c 117- > expout
AT_CHECK([cat 1.packets | cut -c 117-], [0], [expout])
AT_CHECK([cat 2.packets | cut -c 117-], [0], [expout])

# Check that NS packets are not flooded across routing domains. That means
# that hv2 should not send any packets across the physical network.
# Use the grep here to filter out rarp packets that might have arrived
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap | \
grep -v ffffffffffff | trim_zeros > 2.packets
AT_CHECK([cat 2.packets], [0], [])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([options:multiple requested-chassis for logical port])
AT_KEYWORDS([multi-chassis])
TAG_UNSTABLE
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.12

check ovn-nbctl ls-add ls0
check ovn-nbctl lsp-add ls0 lsp0

# Allow only chassis hv1 to bind logical port lsp0.
check ovn-nbctl lsp-set-options lsp0 requested-chassis=hv1

as hv1 check ovs-vsctl -- add-port br-int lsp0 -- \
    set Interface lsp0 external-ids:iface-id=lsp0
as hv2 check ovs-vsctl -- add-port br-int lsp0 -- \
    set Interface lsp0 external-ids:iface-id=lsp0

wait_row_count Chassis 1 name=hv1
wait_row_count Chassis 1 name=hv2
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)

wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "" Port_Binding additional_chassis logical_port=lsp0
wait_column "" Port_Binding requested_additional_chassis logical_port=lsp0

# Request port binding at an additional chassis
check ovn-nbctl lsp-set-options lsp0 \
    requested-chassis=hv1,hv2

wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "$hv2_uuid" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv2_uuid" Port_Binding requested_additional_chassis logical_port=lsp0

# Check ovn-installed updated for both chassis
wait_for_ports_up

for hv in hv1 hv2; do
    OVS_WAIT_UNTIL([test `as $hv ovs-vsctl get Interface lsp0 external_ids:ovn-installed` = '"true"'])
done

# Check that setting iface:encap-ip populates Port_Binding:additional_encap
wait_row_count Encap 2 chassis_name=hv1
wait_row_count Encap 2 chassis_name=hv2
encap_hv1_uuid=$(fetch_column Encap _uuid chassis_name=hv1 type=geneve)
encap_hv2_uuid=$(fetch_column Encap _uuid chassis_name=hv2 type=geneve)

wait_column "" Port_Binding encap logical_port=lsp0
wait_column "" Port_Binding additional_encap logical_port=lsp0

as hv1 check ovs-vsctl -- \
    set Interface lsp0 external-ids:encap-ip=192.168.0.11
as hv2 check ovs-vsctl -- \
    set Interface lsp0 external-ids:encap-ip=192.168.0.12

wait_column "$encap_hv1_uuid" Port_Binding encap logical_port=lsp0
wait_column "$encap_hv2_uuid" Port_Binding additional_encap logical_port=lsp0

# Complete moving the binding to the new location
check ovn-nbctl lsp-set-options lsp0 requested-chassis=hv2

wait_column "$hv2_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv2_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "" Port_Binding additional_chassis logical_port=lsp0
wait_column "" Port_Binding requested_additional_chassis logical_port=lsp0

# Check ovn-installed updated for main chassis and removed from additional chassis
wait_for_ports_up
OVS_WAIT_UNTIL([test `as hv2 ovs-vsctl get Interface lsp0 external_ids:ovn-installed` = '"true"'])
OVS_WAIT_UNTIL([test x`as hv1 ovs-vsctl get Interface lsp0 external_ids:ovn-installed` = x])

# Check that additional_encap is cleared
wait_column "" Port_Binding additional_encap logical_port=lsp0

# Check that abrupted port migration clears additional_encap
check ovn-nbctl lsp-set-options lsp0 \
    requested-chassis=hv2,hv1
wait_column "$hv2_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv2_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_additional_chassis logical_port=lsp0
check ovn-nbctl lsp-set-options lsp0 requested-chassis=hv2
wait_column "" Port_Binding additional_encap logical_port=lsp0

# Migration with some race conditions
check ovn-nbctl lsp-set-options lsp0 \
    requested-chassis=hv2,hv1
wait_column "$hv2_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv2_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_additional_chassis logical_port=lsp0

# Check ovn-installed updated for both chassis
wait_for_ports_up

for hv in hv1 hv2; do
    OVS_WAIT_UNTIL([test `as $hv ovs-vsctl get Interface lsp0 external_ids:ovn-installed` = '"true"'])
done

# Complete moving the binding to the new location
sleep_controller hv2
check ovn-nbctl lsp-set-options lsp0 requested-chassis=hv1

wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "" Port_Binding additional_chassis logical_port=lsp0
wait_column "" Port_Binding requested_additional_chassis logical_port=lsp0
wake_up_controller hv2
# Check ovn-installed updated for main chassis and removed from additional chassis
wait_for_ports_up
OVS_WAIT_UNTIL([test `as hv1 ovs-vsctl get Interface lsp0 external_ids:ovn-installed` = '"true"'])
OVS_WAIT_UNTIL([test x`as hv2 ovs-vsctl get Interface lsp0 external_ids:ovn-installed` = x])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([options:multiple requested-chassis for logical port: change chassis role])
AT_KEYWORDS([multi-chassis])
TAG_UNSTABLE
ovn_start

net_add n1

for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.1$i
done

check ovn-nbctl ls-add ls0
check ovn-nbctl lsp-add ls0 lsp0

# Bind the port to all of them
check ovn-nbctl lsp-set-options lsp0 requested-chassis=hv1,hv2,hv3

for i in 1 2 3; do
    as hv$i check ovs-vsctl -- add-port br-int lsp0 -- \
        set Interface lsp0 external-ids:iface-id=lsp0
done

for i in 1 2 3; do
    wait_row_count Chassis 1 name=hv$i
done
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)
hv3_uuid=$(fetch_column Chassis _uuid name=hv3)

wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv3_uuid" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv3_uuid" Port_Binding requested_additional_chassis logical_port=lsp0

# Now swap hv1 and hv2 chassis roles: main <-> additional
check ovn-nbctl lsp-set-options lsp0 requested-chassis=hv3,hv2,hv1

wait_column "$hv3_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv3_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv1_uuid" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv1_uuid" Port_Binding requested_additional_chassis logical_port=lsp0

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([options:multiple requested-chassis for logical port: unclaimed behavior])
AT_KEYWORDS([multi-chassis])
TAG_UNSTABLE
ovn_start

net_add n1

for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.1$i
done

check ovn-nbctl ls-add ls0
check ovn-nbctl lsp-add ls0 lsp0

# Bind the port to all of them
check ovn-nbctl lsp-set-options lsp0 requested-chassis=hv1,hv2,hv3

for i in 1 2 3; do
    wait_row_count Chassis 1 name=hv$i
done
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)
hv3_uuid=$(fetch_column Chassis _uuid name=hv3)

# Port not claimed by any of chassis
wait_column "" Port_Binding chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv3_uuid" Port_Binding requested_additional_chassis logical_port=lsp0

# Now claim on main chassis
as hv1 check ovs-vsctl -- add-port br-int lsp0 -- \
    set Interface lsp0 external-ids:iface-id=lsp0

wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv3_uuid" Port_Binding requested_additional_chassis logical_port=lsp0

# Now claim on the second additional chassis
as hv3 check ovs-vsctl -- add-port br-int lsp0 -- \
    set Interface lsp0 external-ids:iface-id=lsp0

wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "$hv3_uuid" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv3_uuid" Port_Binding requested_additional_chassis logical_port=lsp0

# Now claim the other additional chassis
as hv2 check ovs-vsctl -- add-port br-int lsp0 -- \
    set Interface lsp0 external-ids:iface-id=lsp0

wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv3_uuid" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv3_uuid" Port_Binding requested_additional_chassis logical_port=lsp0

# Now unclaim from the main chassis
as hv1 check ovs-vsctl -- del-port br-int lsp0

wait_column "" Port_Binding chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv3_uuid" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv3_uuid" Port_Binding requested_additional_chassis logical_port=lsp0

# Now unclaim from an additional chassis
as hv3 check ovs-vsctl -- del-port br-int lsp0

wait_column "" Port_Binding chassis logical_port=lsp0
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=lsp0
wait_column "$hv2_uuid" Port_Binding additional_chassis logical_port=lsp0
wait_column "$hv2_uuid $hv3_uuid" Port_Binding requested_additional_chassis logical_port=lsp0

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([basic connectivity with multiple requested-chassis])
AT_KEYWORDS([multi-chassis])
AT_KEYWORDS([slowtest])
ovn_start

net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done

# Disable local ARP responder to pass ARP requests through tunnels
check ovn-nbctl ls-add ls0 -- add Logical_Switch ls0 other_config vlan-passthru=true

check ovn-nbctl lsp-add ls0 first
check ovn-nbctl lsp-add ls0 second
check ovn-nbctl lsp-add ls0 third
check ovn-nbctl lsp-add ls0 migrator
check ovn-nbctl lsp-set-addresses first "00:00:00:00:00:01 10.0.0.1"
check ovn-nbctl lsp-set-addresses second "00:00:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-addresses third "00:00:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-addresses migrator "00:00:00:00:00:ff 10.0.0.100"

# The test scenario will migrate Migrator port between hv1 and hv2 and check
# that connectivity to and from the port is functioning properly for both
# chassis locations. Connectivity will be checked for resources located at hv1
# (First) and hv2 (Second) as well as for hv3 (Third) that does not take part
# in port migration.
check ovn-nbctl lsp-set-options first requested-chassis=hv1
check ovn-nbctl lsp-set-options second requested-chassis=hv2
check ovn-nbctl lsp-set-options third requested-chassis=hv3

as hv1 check ovs-vsctl -- add-port br-int first -- \
    set Interface first external-ids:iface-id=first \
    options:tx_pcap=hv1/first-tx.pcap \
    options:rxq_pcap=hv1/first-rx.pcap
as hv2 check ovs-vsctl -- add-port br-int second -- \
    set Interface second external-ids:iface-id=second \
    options:tx_pcap=hv2/second-tx.pcap \
    options:rxq_pcap=hv2/second-rx.pcap
as hv3 check ovs-vsctl -- add-port br-int third -- \
    set Interface third external-ids:iface-id=third \
    options:tx_pcap=hv3/third-tx.pcap \
    options:rxq_pcap=hv3/third-rx.pcap

# Create Migrator interfaces on both hv1 and hv2
for hv in hv1 hv2; do
    as $hv check ovs-vsctl -- add-port br-int migrator -- \
        set Interface migrator external-ids:iface-id=migrator \
        options:tx_pcap=$hv/migrator-tx.pcap \
        options:rxq_pcap=$hv/migrator-rx.pcap
done

send_arp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as ${hv} ovs-appctl netdev-dummy/receive $inport $request
    echo "${request}"
}

reset_env() {
    as hv1 reset_pcap_file first hv1/first
    as hv2 reset_pcap_file second hv2/second
    as hv3 reset_pcap_file third hv3/third
    as hv1 reset_pcap_file migrator hv1/migrator
    as hv2 reset_pcap_file migrator hv2/migrator

    for port in hv1/migrator hv2/migrator hv1/first hv2/second hv3/third; do
        : > $port.expected
    done
}

check_packets() {
    OVN_CHECK_PACKETS([hv1/migrator-tx.pcap], [hv1/migrator.expected])
    OVN_CHECK_PACKETS([hv2/migrator-tx.pcap], [hv2/migrator.expected])
    OVN_CHECK_PACKETS([hv1/first-tx.pcap], [hv1/first.expected])
    OVN_CHECK_PACKETS([hv2/second-tx.pcap], [hv2/second.expected])
    OVN_CHECK_PACKETS([hv3/third-tx.pcap], [hv3/third.expected])
}

migrator_tpa=$(ip_to_hex 10 0 0 100)
first_spa=$(ip_to_hex 10 0 0 1)
second_spa=$(ip_to_hex 10 0 0 2)
third_spa=$(ip_to_hex 10 0 0 3)

for hv in hv1 hv2 hv3; do
    wait_row_count Chassis 1 name=$hv
done
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)

# Start with Migrator on hv1 but not hv2
check ovn-nbctl lsp-set-options migrator requested-chassis=hv1
wait_for_ports_up
wait_column "$hv1_uuid" Port_Binding chassis logical_port=migrator
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=migrator
wait_column "" Port_Binding additional_chassis logical_port=migrator
wait_column "" Port_Binding requested_additional_chassis logical_port=migrator
wait_for_ports_up

reset_env

OVN_POPULATE_ARP

# check that...
# unicast from First arrives to hv1:Migrator
# unicast from First doesn't arrive to hv2:Migrator
request=$(send_arp hv1 first 000000000001 0000000000ff $first_spa $migrator_tpa)
echo $request >> hv1/migrator.expected

# mcast from First arrives to hv1:Migrator
# mcast from First doesn't arrive to hv2:Migrator
request=$(send_arp hv1 first 000000000001 ffffffffffff $first_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected

# unicast from Second arrives to hv1:Migrator
# unicast from Second doesn't arrive to hv2:Migrator
request=$(send_arp hv2 second 000000000002 0000000000ff $second_spa $migrator_tpa)
echo $request >> hv1/migrator.expected

# mcast from Second arrives to hv1:Migrator
# mcast from Second doesn't arrive to hv2:Migrator
request=$(send_arp hv2 second 000000000002 ffffffffffff $second_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv1/first.expected
echo $request >> hv3/third.expected

# unicast from Third arrives to hv1:Migrator
# unicast from Third doesn't arrive to hv2:Migrator
request=$(send_arp hv3 third 000000000003 0000000000ff $third_spa $migrator_tpa)
echo $request >> hv1/migrator.expected

# mcast from Third arrives to hv1:Migrator
# mcast from Third doesn't arrive to hv2:Migrator
request=$(send_arp hv3 third 000000000003 ffffffffffff $third_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected

# unicast from hv1:Migrator arrives to First, Second, and Third
request=$(send_arp hv1 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
request=$(send_arp hv1 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
echo $request >> hv2/second.expected
request=$(send_arp hv1 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)
echo $request >> hv3/third.expected

# unicast from hv2:Migrator doesn't arrive to First, Second, or Third
request=$(send_arp hv2 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
request=$(send_arp hv2 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
request=$(send_arp hv2 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)

# mcast from hv1:Migrator arrives to First, Second, and Third
request=$(send_arp hv1 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected

# mcast from hv2:Migrator doesn't arrive to First, Second, or Third
request=$(send_arp hv2 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)

check_packets
reset_env

# Start port migration hv1 -> hv2: both hypervisors are now bound
check ovn-nbctl lsp-set-options migrator requested-chassis=hv1,hv2
wait_for_ports_up
wait_column "$hv1_uuid" Port_Binding chassis logical_port=migrator
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=migrator
wait_column "$hv2_uuid" Port_Binding additional_chassis logical_port=migrator
wait_column "$hv2_uuid" Port_Binding requested_additional_chassis logical_port=migrator

# Port should be up (and flows installed) when migration is completed on hv1.
# However, neither ports up nor additional_chassis do guarantee that flows on hv2 are fully installed.
# ovn-installed on hv2 should guarantee that.
OVS_WAIT_UNTIL([test `as hv2 ovs-vsctl get Interface migrator external_ids:ovn-installed` = '"true"'])

# Still, this does not guarantee that all flows are installed on hv3: hv3 (might) still need to receive and handle
# additional_chassis for migrator port
ovn-nbctl --wait=hv sync

# check that...
# unicast from First arrives to hv1:Migrator
# unicast from First arrives to hv2:Migrator
request=$(send_arp hv1 first 000000000001 0000000000ff $first_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected

# mcast from First arrives to hv1:Migrator
# mcast from First arrives to hv2:Migrator
request=$(send_arp hv1 first 000000000001 ffffffffffff $first_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected
echo $request >> hv3/third.expected
echo $request >> hv2/second.expected

# unicast from Second arrives to hv1:Migrator
# unicast from Second arrives to hv2:Migrator
request=$(send_arp hv2 second 000000000002 0000000000ff $second_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected

# mcast from Second arrives to hv1:Migrator
# mcast from Second arrives to hv2:Migrator
request=$(send_arp hv2 second 000000000002 ffffffffffff $second_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected
echo $request >> hv3/third.expected
echo $request >> hv1/first.expected

# unicast from Third arrives to hv1:Migrator binding
# unicast from Third arrives to hv2:Migrator binding
request=$(send_arp hv3 third 000000000003 0000000000ff $third_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected

# mcast from Third arrives to hv1:Migrator
# mcast from Third arrives to hv2:Migrator
request=$(send_arp hv3 third 000000000003 ffffffffffff $third_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected

# unicast from hv1:Migrator arrives to First, Second, and Third
request=$(send_arp hv1 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
request=$(send_arp hv1 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
echo $request >> hv2/second.expected
request=$(send_arp hv1 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)
echo $request >> hv3/third.expected

# unicast from hv2:Migrator arrives to First, Second, and Third
request=$(send_arp hv2 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
request=$(send_arp hv2 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
echo $request >> hv2/second.expected
request=$(send_arp hv2 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)
echo $request >> hv3/third.expected

# mcast from hv1:Migrator arrives to First, Second, and Third
request=$(send_arp hv1 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected

# mcast from hv2:Migrator arrives to First, Second, and Third
request=$(send_arp hv2 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected

check_packets
reset_env

# Complete migration: destination is bound
check ovn-nbctl lsp-set-options migrator requested-chassis=hv2
wait_for_ports_up
wait_column "$hv2_uuid" Port_Binding chassis logical_port=migrator
wait_column "$hv2_uuid" Port_Binding requested_chassis logical_port=migrator
wait_column "" Port_Binding additional_chassis logical_port=migrator
wait_column "" Port_Binding requested_additional_chassis logical_port=migrator

# Previous wait_for_ports_up does not guarantee that the flows are already properly installed.
# For instance, migrator port might still be up from prior to complete migration to hv2
OVS_WAIT_UNTIL([test `as hv2 ovs-vsctl get Interface migrator external_ids:ovn-installed` = '"true"'])

# Give time for hv3 to handle the change of Port_Binding  for migrator port
ovn-nbctl --wait=hv sync

# check that...
# unicast from Third doesn't arrive to hv1:Migrator
# unicast from Third arrives to hv2:Migrator
request=$(send_arp hv3 third 000000000003 0000000000ff $third_spa $migrator_tpa)
echo $request >> hv2/migrator.expected

# mcast from Third doesn't arrive to hv1:Migrator
# mcast from Third arrives to hv2:Migrator
request=$(send_arp hv3 third 000000000003 ffffffffffff $third_spa $migrator_tpa)
echo $request >> hv2/migrator.expected
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected

# unicast from First doesn't arrive to hv1:Migrator
# unicast from First arrives to hv2:Migrator
request=$(send_arp hv1 first 000000000001 0000000000ff $first_spa $migrator_tpa)
echo $request >> hv2/migrator.expected

# mcast from First doesn't arrive to hv1:Migrator
# mcast from First arrives to hv2:Migrator binding
request=$(send_arp hv1 first 000000000001 ffffffffffff $first_spa $migrator_tpa)
echo $request >> hv2/migrator.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected

# unicast from Second doesn't arrive to hv1:Migrator
# unicast from Second arrives to hv2:Migrator
request=$(send_arp hv2 second 000000000002 0000000000ff $second_spa $migrator_tpa)
echo $request >> hv2/migrator.expected

# mcast from Second doesn't arrive to hv1:Migrator
# mcast from Second arrives to hv2:Migrator
request=$(send_arp hv2 second 000000000002 ffffffffffff $second_spa $migrator_tpa)
echo $request >> hv2/migrator.expected
echo $request >> hv1/first.expected
echo $request >> hv3/third.expected

# unicast from hv1:Migrator doesn't arrive to First, Second, or Third
request=$(send_arp hv1 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
request=$(send_arp hv1 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
request=$(send_arp hv1 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)

# unicast from hv2:Migrator arrives to First, Second, and Third
request=$(send_arp hv2 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
request=$(send_arp hv2 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
echo $request >> hv2/second.expected
request=$(send_arp hv2 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)
echo $request >> hv3/third.expected

# mcast from hv1:Migrator doesn't arrive to First, Second, or Third
request=$(send_arp hv1 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)

# mcast from hv2:Migrator arrives to First, Second, and Third
request=$(send_arp hv2 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected

check_packets

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([localnet connectivity with multiple requested-chassis])
AT_KEYWORDS([multi-chassis])
ovn_start

net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
done

# Disable local ARP responder to pass ARP requests through tunnels
check ovn-nbctl ls-add ls0 -- add Logical_Switch ls0 other_config vlan-passthru=true

check ovn-nbctl lsp-add ls0 first
check ovn-nbctl lsp-add ls0 second
check ovn-nbctl lsp-add ls0 third
check ovn-nbctl lsp-add ls0 migrator
check ovn-nbctl lsp-set-addresses first "00:00:00:00:00:01 10.0.0.1"
check ovn-nbctl lsp-set-addresses second "00:00:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-addresses third "00:00:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-addresses migrator "00:00:00:00:00:ff 10.0.0.100"

check ovn-nbctl lsp-add ls0 public
check ovn-nbctl lsp-set-type public localnet
check ovn-nbctl lsp-set-addresses public unknown
check ovn-nbctl lsp-set-options public network_name=phys

# The test scenario will migrate Migrator port between hv1 and hv2 and check
# that connectivity to and from the port is functioning properly for both
# chassis locations. Connectivity will be checked for resources located at hv1
# (First) and hv2 (Second) as well as for hv3 (Third) that does not take part
# in port migration.
check ovn-nbctl lsp-set-options first requested-chassis=hv1
check ovn-nbctl lsp-set-options second requested-chassis=hv2
check ovn-nbctl lsp-set-options third requested-chassis=hv3

as hv1 check ovs-vsctl -- add-port br-int first -- \
    set Interface first external-ids:iface-id=first \
    options:tx_pcap=hv1/first-tx.pcap \
    options:rxq_pcap=hv1/first-rx.pcap
as hv2 check ovs-vsctl -- add-port br-int second -- \
    set Interface second external-ids:iface-id=second \
    options:tx_pcap=hv2/second-tx.pcap \
    options:rxq_pcap=hv2/second-rx.pcap
as hv3 check ovs-vsctl -- add-port br-int third -- \
    set Interface third external-ids:iface-id=third \
    options:tx_pcap=hv3/third-tx.pcap \
    options:rxq_pcap=hv3/third-rx.pcap

# Create Migrator interfaces on both hv1 and hv2
for hv in hv1 hv2; do
    as $hv check ovs-vsctl -- add-port br-int migrator -- \
        set Interface migrator external-ids:iface-id=migrator \
        options:tx_pcap=$hv/migrator-tx.pcap \
        options:rxq_pcap=$hv/migrator-rx.pcap
done

send_arp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as ${hv} ovs-appctl netdev-dummy/receive $inport $request
    echo "${request}"
}

send_garp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040002${eth_src}${spa}${eth_dst}${tpa}
    as ${hv} ovs-appctl netdev-dummy/receive $inport $request
    echo "${request}"
}

reset_env() {
    as hv1 reset_pcap_file first hv1/first
    as hv2 reset_pcap_file second hv2/second
    as hv3 reset_pcap_file third hv3/third
    as hv1 reset_pcap_file migrator hv1/migrator
    as hv2 reset_pcap_file migrator hv2/migrator

    for port in hv1/migrator hv2/migrator hv1/first hv2/second hv3/third; do
        : > $port.expected
    done

    for hv in hv1 hv2 hv3; do
        : > $hv/n1.expected
    done

    as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
    as hv2 reset_pcap_file br-phys_n1 hv2/br-phys_n1
    as hv3 reset_pcap_file br-phys_n1 hv3/br-phys_n1
}

check_packets() {
    # the test scenario gets spurious garps generated by vifs because of localnet
    # attachment, hence using CONTAIN instead of strict matching
    OVN_CHECK_PACKETS_CONTAIN([hv1/migrator-tx.pcap], [hv1/migrator.expected])
    OVN_CHECK_PACKETS_CONTAIN([hv2/migrator-tx.pcap], [hv2/migrator.expected])
    OVN_CHECK_PACKETS_CONTAIN([hv1/first-tx.pcap], [hv1/first.expected])
    OVN_CHECK_PACKETS_CONTAIN([hv2/second-tx.pcap], [hv2/second.expected])
    OVN_CHECK_PACKETS_CONTAIN([hv3/third-tx.pcap], [hv3/third.expected])

    OVN_CHECK_PACKETS_CONTAIN([hv1/br-phys_n1-tx.pcap], [hv1/n1.expected])
    OVN_CHECK_PACKETS_CONTAIN([hv2/br-phys_n1-tx.pcap], [hv2/n1.expected])
    OVN_CHECK_PACKETS_CONTAIN([hv3/br-phys_n1-tx.pcap], [hv3/n1.expected])
}

migrator_tpa=$(ip_to_hex 10 0 0 100)
first_spa=$(ip_to_hex 10 0 0 1)
second_spa=$(ip_to_hex 10 0 0 2)
third_spa=$(ip_to_hex 10 0 0 3)

for hv in hv1 hv2 hv3; do
    wait_row_count Chassis 1 name=$hv
done
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)

OVN_POPULATE_ARP

# Start with Migrator on hv1 but not hv2
check ovn-nbctl lsp-set-options migrator requested-chassis=hv1
wait_column "$hv1_uuid" Port_Binding chassis logical_port=migrator
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=migrator
wait_column "" Port_Binding additional_chassis logical_port=migrator
wait_column "" Port_Binding requested_additional_chassis logical_port=migrator
wait_for_ports_up

# advertise location of ports through localnet port
send_garp hv1 migrator 0000000000ff ffffffffffff $migrator_tpa $migrator_tpa
send_garp hv1 first 000000000001 ffffffffffff $first_spa $first_spa
send_garp hv2 second 000000000002 ffffffffffff $second_spa $second_spa
send_garp hv3 third 000000000003 ffffffffffff $third_spa $third_spa
reset_env

# check that...
# unicast from First arrives to hv1:Migrator
# unicast from First doesn't arrive to hv2:Migrator
request=$(send_arp hv1 first 000000000001 0000000000ff $first_spa $migrator_tpa)
echo $request >> hv1/migrator.expected

# mcast from First arrives to hv1:Migrator
# mcast from First doesn't arrive to hv2:Migrator
request=$(send_arp hv1 first 000000000001 ffffffffffff $first_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected

# unicast from Second arrives to hv1:Migrator
# unicast from Second doesn't arrive to hv2:Migrator
request=$(send_arp hv2 second 000000000002 0000000000ff $second_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/n1.expected

# mcast from Second arrives to hv1:Migrator
# mcast from Second doesn't arrive to hv2:Migrator
request=$(send_arp hv2 second 000000000002 ffffffffffff $second_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv1/first.expected
echo $request >> hv3/third.expected
echo $request >> hv2/n1.expected

# unicast from Third arrives to hv1:Migrator
# unicast from Third doesn't arrive to hv2:Migrator
request=$(send_arp hv3 third 000000000003 0000000000ff $third_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv3/n1.expected

# mcast from Third arrives to hv1:Migrator
# mcast from Third doesn't arrive to hv2:Migrator
request=$(send_arp hv3 third 000000000003 ffffffffffff $third_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected
echo $request >> hv3/n1.expected

# unicast from hv1:Migrator arrives to First, Second, and Third
request=$(send_arp hv1 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
request=$(send_arp hv1 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
echo $request >> hv2/second.expected
echo $request >> hv1/n1.expected
request=$(send_arp hv1 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)
echo $request >> hv3/third.expected
echo $request >> hv1/n1.expected

# unicast from hv2:Migrator doesn't arrive to First, Second, or Third
request=$(send_arp hv2 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
request=$(send_arp hv2 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
request=$(send_arp hv2 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)

# mcast from hv1:Migrator arrives to First, Second, and Third
request=$(send_arp hv1 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected
echo $request >> hv1/n1.expected

# mcast from hv2:Migrator doesn't arrive to First, Second, or Third
request=$(send_arp hv2 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)

check_packets
reset_env

# Start port migration hv1 -> hv2: both hypervisors are now bound
check ovn-nbctl lsp-set-options migrator requested-chassis=hv1,hv2
wait_for_ports_up
OVN_WAIT_PATCH_PORT_FLOWS(["public"], ["hv1"])
OVN_WAIT_PATCH_PORT_FLOWS(["public"], ["hv2"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv1"],["hv2"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv2"],["hv1"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv3"],[hv1"])
OVN_WAIT_REMOTE_OUTPUT_FLOWS(["hv3"],[hv2"])

wait_column "$hv1_uuid" Port_Binding chassis logical_port=migrator
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=migrator
wait_column "$hv2_uuid" Port_Binding additional_chassis logical_port=migrator
wait_column "$hv2_uuid" Port_Binding requested_additional_chassis logical_port=migrator

# check that...
# unicast from First arrives to hv1:Migrator
# unicast from First arrives to hv2:Migrator
request=$(send_arp hv1 first 000000000001 0000000000ff $first_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected

# mcast from First arrives to hv1:Migrator
# mcast from First arrives to hv2:Migrator
request=$(send_arp hv1 first 000000000001 ffffffffffff $first_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected
echo $request >> hv3/third.expected
echo $request >> hv2/second.expected

# unicast from Second arrives to hv1:Migrator
# unicast from Second arrives to hv2:Migrator
request=$(send_arp hv2 second 000000000002 0000000000ff $second_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected

# mcast from Second arrives to hv1:Migrator
# mcast from Second arrives to hv2:Migrator
request=$(send_arp hv2 second 000000000002 ffffffffffff $second_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected
echo $request >> hv3/third.expected
echo $request >> hv1/first.expected

# unicast from Third arrives to hv1:Migrator binding
# unicast from Third arrives to hv2:Migrator binding
request=$(send_arp hv3 third 000000000003 0000000000ff $third_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected

# mcast from Third arrives to hv1:Migrator
# mcast from Third arrives to hv2:Migrator
request=$(send_arp hv3 third 000000000003 ffffffffffff $third_spa $migrator_tpa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected

# unicast from hv1:Migrator arrives to First, Second, and Third
request=$(send_arp hv1 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
request=$(send_arp hv1 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
echo $request >> hv2/second.expected
request=$(send_arp hv1 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)
echo $request >> hv3/third.expected

# unicast from hv2:Migrator arrives to First, Second, and Third
request=$(send_arp hv2 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
request=$(send_arp hv2 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
echo $request >> hv2/second.expected
request=$(send_arp hv2 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)
echo $request >> hv3/third.expected

# mcast from hv1:Migrator arrives to First, Second, and Third
request=$(send_arp hv1 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected

# mcast from hv2:Migrator arrives to First, Second, and Third
request=$(send_arp hv2 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected

# unicast from Second arrives to Third through localnet port
request=$(send_arp hv2 second 000000000002 000000000003 $second_spa $third_spa)
echo $request >> hv2/n1.expected

check_packets

# Wait for MAC address of migrator to be on hv1 related port in main switch.
# Hence the MAC will not migrate back unexpectedly later.
p1=$(as main ovs-ofctl show n1 | grep hv1_br-phys | awk '{print int($1)}')
p2=$(as main ovs-ofctl show n1 | grep hv2_br-phys | awk '{print int($1)}')
OVS_WAIT_UNTIL([test x`as main ovs-appctl fdb/show n1 | grep 00:00:00:00:00:ff  | awk '{print $1}'` = x$p1])

# Complete migration: destination is bound
check ovn-nbctl lsp-set-options migrator requested-chassis=hv2
wait_column "$hv2_uuid" Port_Binding chassis logical_port=migrator
wait_column "$hv2_uuid" Port_Binding requested_chassis logical_port=migrator
wait_column "" Port_Binding additional_chassis logical_port=migrator
wait_column "" Port_Binding requested_additional_chassis logical_port=migrator
wait_for_ports_up

check ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([test `as hv2 ovs-vsctl get Interface migrator external_ids:ovn-installed` = '"true"'])

# advertise new location of the port through localnet port
send_garp hv2 migrator 0000000000ff ffffffffffff $migrator_tpa $migrator_tpa

reset_env

# Wait for MAC address of migrator to be on hv2 port in main switch
OVS_WAIT_UNTIL([test x`as main ovs-appctl fdb/show n1 | grep 00:00:00:00:00:ff  | awk '{print $1}'` = x$p2])

# check that...
# unicast from Third doesn't arrive to hv1:Migrator
# unicast from Third arrives to hv2:Migrator
request=$(send_arp hv3 third 000000000003 0000000000ff $third_spa $migrator_tpa)
echo $request >> hv2/migrator.expected
echo $request >> hv3/n1.expected

# mcast from Third doesn't arrive to hv1:Migrator
# mcast from Third arrives to hv2:Migrator
request=$(send_arp hv3 third 000000000003 ffffffffffff $third_spa $migrator_tpa)
echo $request >> hv2/migrator.expected
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected
echo $request >> hv3/n1.expected

# unicast from First doesn't arrive to hv1:Migrator
# unicast from First arrives to hv2:Migrator
request=$(send_arp hv1 first 000000000001 0000000000ff $first_spa $migrator_tpa)
echo $request >> hv2/migrator.expected
echo $request >> hv1/n1.expected

# mcast from First doesn't arrive to hv1:Migrator
# mcast from First arrives to hv2:Migrator binding
request=$(send_arp hv1 first 000000000001 ffffffffffff $first_spa $migrator_tpa)
echo $request >> hv2/migrator.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected
echo $request >> hv1/n1.expected

# unicast from Second doesn't arrive to hv1:Migrator
# unicast from Second arrives to hv2:Migrator
request=$(send_arp hv2 second 000000000002 0000000000ff $second_spa $migrator_tpa)
echo $request >> hv2/migrator.expected

# mcast from Second doesn't arrive to hv1:Migrator
# mcast from Second arrives to hv2:Migrator
request=$(send_arp hv2 second 000000000002 ffffffffffff $second_spa $migrator_tpa)
echo $request >> hv2/migrator.expected
echo $request >> hv1/first.expected
echo $request >> hv3/third.expected

# unicast from hv1:Migrator doesn't arrive to First, Second, or Third
request=$(send_arp hv1 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
request=$(send_arp hv1 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
request=$(send_arp hv1 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)

# unicast from hv2:Migrator arrives to First, Second, and Third
request=$(send_arp hv2 migrator 0000000000ff 000000000001 $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
echo $request >> hv2/n1.expected
request=$(send_arp hv2 migrator 0000000000ff 000000000002 $migrator_tpa $second_spa)
echo $request >> hv2/second.expected
request=$(send_arp hv2 migrator 0000000000ff 000000000003 $migrator_tpa $third_spa)
echo $request >> hv3/third.expected
echo $request >> hv2/n1.expected

# mcast from hv1:Migrator doesn't arrive to First, Second, or Third
request=$(send_arp hv1 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)

# mcast from hv2:Migrator arrives to First, Second, and Third
request=$(send_arp hv2 migrator 0000000000ff ffffffffffff $migrator_tpa $first_spa)
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected
echo $request >> hv3/third.expected
echo $request >> hv2/n1.expected

check_packets

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

m4_define([MULTICHASSIS_PATH_MTU_DISCOVERY_TEST],
  [OVN_FOR_EACH_NORTHD([
   AT_SETUP([localnet connectivity with multiple requested-chassis, path mtu discovery (ip=$1, tunnel=$2, mtu=$3)])
   AT_KEYWORDS([multi-chassis])
   AT_SKIP_IF([test $HAVE_SCAPY = no])

   ovn_start

   net_add n1
   for i in 1 2; do
       sim_add hv$i
       as hv$i
       check ovs-vsctl add-br br-phys
       if test "x$1" = "xipv6"; then
           ovn_attach n1 br-phys fd00::$i 64 $2
       else
           ovn_attach n1 br-phys 192.168.0.$i 24 $2
       fi
       check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
   done

   first_mac=00:00:00:00:00:01
   second_mac=00:00:00:00:00:02
   multi1_mac=00:00:00:00:00:f0
   multi2_mac=00:00:00:00:00:f1
   first_ip=10.0.0.1
   second_ip=10.0.0.2
   multi1_ip=10.0.0.10
   multi2_ip=10.0.0.20
   first_ip6=abcd::1
   second_ip6=abcd::2
   multi1_ip6=abcd::f0
   multi2_ip6=abcd::f1

   check ovn-nbctl ls-add ls0
   check ovn-nbctl lsp-add ls0 first
   check ovn-nbctl lsp-add ls0 second
   check ovn-nbctl lsp-add ls0 multi1
   check ovn-nbctl lsp-add ls0 multi2
   check ovn-nbctl lsp-set-addresses first "${first_mac} ${first_ip} ${first_ip6}"
   check ovn-nbctl lsp-set-addresses second "${second_mac} ${second_ip} ${second_ip6}"
   check ovn-nbctl lsp-set-addresses multi1 "${multi1_mac} ${multi1_ip} ${multi1_ip6}"
   check ovn-nbctl lsp-set-addresses multi2 "${multi2_mac} ${multi2_ip} ${multi2_ip6}"

   check ovn-nbctl lsp-add ls0 public
   check ovn-nbctl lsp-set-type public localnet
   check ovn-nbctl lsp-set-addresses public unknown
   check ovn-nbctl lsp-set-options public network_name=phys

   check ovn-nbctl lsp-set-options first requested-chassis=hv1
   check ovn-nbctl lsp-set-options second requested-chassis=hv2
   check ovn-nbctl lsp-set-options multi1 requested-chassis=hv1,hv2
   check ovn-nbctl lsp-set-options multi2 requested-chassis=hv1,hv2

   as hv1 check ovs-vsctl -- add-port br-int first -- \
       set Interface first external-ids:iface-id=first \
       options:tx_pcap=hv1/first-tx.pcap \
       options:rxq_pcap=hv1/first-rx.pcap \
       ofport-request=1
   as hv2 check ovs-vsctl -- add-port br-int second -- \
       set Interface second external-ids:iface-id=second \
       options:tx_pcap=hv2/second-tx.pcap \
       options:rxq_pcap=hv2/second-rx.pcap \
       ofport-request=2

   # Create interfaces for multichassis ports on both hv1 and hv2
   for hv in hv1 hv2; do
       for i in 1 2; do
           as $hv check ovs-vsctl -- add-port br-int multi${i} -- \
               set Interface multi${i} external-ids:iface-id=multi${i} \
               options:tx_pcap=$hv/multi${i}-tx.pcap \
               options:rxq_pcap=$hv/multi${i}-rx.pcap \
               ofport-request=${i}00
       done
   done

   send_ip_packet() {
       local inport=${1} hv=${2} eth_src=${3} eth_dst=${4} ipv4_src=${5} ipv4_dst=${6} data=${7} fail=${8} mtu=${9:-$3}
       packet=$(fmt_pkt "
           Ether(dst='${eth_dst}', src='${eth_src}') /
           IP(src='${ipv4_src}', dst='${ipv4_dst}') /
           ICMP(type=8) / bytes.fromhex('${data}')
       ")
       as hv${hv} ovs-appctl netdev-dummy/receive ${inport} ${packet}
       if [[ x"${fail}" != x0 ]]; then
         original_ip_frame=$(fmt_pkt "
           IP(src='${ipv4_src}', dst='${ipv4_dst}') /
           ICMP(type=8) / bytes.fromhex('${data}')
         ")
         # IP(flags=2) means DF (Don't Fragment) = 1
         # ICMP(type=3, code=4) means Destination Unreachable, Fragmentation Needed
         packet=$(fmt_pkt "
             Ether(dst='${eth_src}', src='${eth_dst}') /
             IP(src='${ipv4_dst}', dst='${ipv4_src}', ttl=255, flags=2, id=0) /
             ICMP(type=3, code=4, nexthopmtu=${mtu}) /
             bytes.fromhex('${original_ip_frame:0:$((534 * 2))}')
         ")
       fi
       echo ${packet}
   }

   send_ip6_packet() {
       local inport=${1} hv=${2} eth_src=${3} eth_dst=${4} ipv6_src=${5} ipv6_dst=${6} data=${7} fail=${8} mtu=${9:-$3}
       packet=$(fmt_pkt "
           Ether(dst='${eth_dst}', src='${eth_src}') /
           IPv6(src='${ipv6_src}', dst='${ipv6_dst}') /
           ICMPv6EchoRequest() / bytes.fromhex('${data}')
       ")
       as hv${hv} ovs-appctl netdev-dummy/receive ${inport} ${packet}
       if [[ x"${fail}" != x0 ]]; then
         original_ip_frame=$(fmt_pkt "
           IPv6(src='${ipv6_src}', dst='${ipv6_dst}') /
           ICMPv6EchoRequest() / bytes.fromhex('${data}')
         ")
         packet=$(fmt_pkt "
             Ether(dst='${eth_src}', src='${eth_dst}') /
             IPv6(src='${ipv6_dst}', dst='${ipv6_src}', hlim=255) /
             ICMPv6PacketTooBig(mtu=${mtu}) /
             bytes.fromhex('${original_ip_frame:0:$((1218 * 2))}')
         ")
       fi
       echo ${packet}
   }

   reset_env() {
       for port in first multi1 multi2; do
           as hv1 reset_pcap_file $port hv1/$port
       done
       for port in second multi1 multi2; do
           as hv2 reset_pcap_file $port hv2/$port
       done
       for port in hv1/multi1 hv2/multi1 hv1/multi2 hv2/multi2 hv1/first hv2/second; do
           : > $port.expected
       done
   }

   check_pkts() {
       for port in hv1/multi1 hv2/multi1 hv1/multi2 hv2/multi2 hv1/first hv2/second; do
           OVN_CHECK_PACKETS_REMOVE_BROADCAST([${port}-tx.pcap], [${port}.expected])
       done
   }

   payload() {
       echo $(cat /dev/urandom | tr -cd 'a-f0-9' | head -c ${1})
   }

   wait_for_ports_up
   OVN_POPULATE_ARP

   reset_env

   AS_BOX([Packets of proper size are delivered from multichassis to regular ports])

   len=1000
   packet=$(send_ip_packet multi1 1 $multi1_mac $first_mac $multi1_ip $first_ip $(payload $len) 0)
   echo $packet >> hv1/first.expected

   packet=$(send_ip_packet multi1 1 $multi1_mac $second_mac $multi1_ip $second_ip $(payload $len) 0)
   echo $packet >> hv2/second.expected

   packet=$(send_ip6_packet multi1 1 $multi1_mac $first_mac $multi1_ip6 $first_ip6 $(payload $len) 0)
   echo $packet >> hv1/first.expected

   packet=$(send_ip6_packet multi1 1 $multi1_mac $second_mac $multi1_ip6 $second_ip6 $(payload $len) 0)
   echo $packet >> hv2/second.expected

   check_pkts
   reset_env

   AS_BOX([Oversized packets are not delivered from multichassis to regular ports])

   len=3000
   packet=$(send_ip_packet multi1 1 $multi1_mac $first_mac $multi1_ip $first_ip $(payload $len) 1)
   echo $packet >> hv1/multi1.expected

   packet=$(send_ip_packet multi1 1 $multi1_mac $second_mac $multi1_ip $second_ip $(payload $len) 1)
   echo $packet >> hv1/multi1.expected

   packet=$(send_ip6_packet multi1 1 $multi1_mac $first_mac $multi1_ip6 $first_ip6 $(payload $len) 1)
   echo $packet >> hv1/multi1.expected

   packet=$(send_ip6_packet multi1 1 $multi1_mac $second_mac $multi1_ip6 $second_ip6 $(payload $len) 1)
   echo $packet >> hv1/multi1.expected

   check_pkts
   reset_env

   AS_BOX([Packets of proper size are delivered from regular to multichassis ports])

   len=1000
   packet=$(send_ip_packet first 1 $first_mac $multi1_mac $first_ip $multi1_ip $(payload $len) 0)
   echo $packet >> hv1/multi1.expected
   echo $packet >> hv2/multi1.expected

   packet=$(send_ip_packet second 2 $second_mac $multi1_mac $second_ip $multi1_ip $(payload $len) 0)
   echo $packet >> hv1/multi1.expected
   echo $packet >> hv2/multi1.expected

   packet=$(send_ip6_packet first 1 $first_mac $multi1_mac $first_ip6 $multi1_ip6 $(payload $len) 0)
   echo $packet >> hv1/multi1.expected
   echo $packet >> hv2/multi1.expected

   packet=$(send_ip6_packet second 2 $second_mac $multi1_mac $second_ip6 $multi1_ip6 $(payload $len) 0)
   echo $packet >> hv1/multi1.expected
   echo $packet >> hv2/multi1.expected

   check_pkts
   reset_env

   AS_BOX([Oversized packets are not delivered from regular to multichassis ports])

   len=3000
   packet=$(send_ip_packet first 1 $first_mac $multi1_mac $first_ip $multi1_ip $(payload $len) 1)
   echo $packet >> hv1/first.expected

   packet=$(send_ip_packet second 2 $second_mac $multi1_mac $second_ip $multi1_ip $(payload $len) 1)
   echo $packet >> hv2/second.expected

   packet=$(send_ip6_packet first 1 $first_mac $multi1_mac $first_ip6 $multi1_ip6 $(payload $len) 1)
   echo $packet >> hv1/first.expected

   packet=$(send_ip6_packet second 2 $second_mac $multi1_mac $second_ip6 $multi1_ip6 $(payload $len) 1)
   echo $packet >> hv2/second.expected

   check_pkts
   reset_env

   AS_BOX([Packets of proper size are delivered from multichassis to multichassis ports])

   len=1000
   packet=$(send_ip_packet multi1 1 $multi1_mac $multi2_mac $multi1_ip $multi2_ip $(payload $len) 0)
   echo $packet >> hv1/multi2.expected
   echo $packet >> hv2/multi2.expected

   packet=$(send_ip6_packet multi1 1 $multi1_mac $multi2_mac $multi1_ip6 $multi2_ip6 $(payload $len) 0)
   echo $packet >> hv1/multi2.expected
   echo $packet >> hv2/multi2.expected

   check_pkts
   reset_env

   AS_BOX([Oversized packets are not delivered from multichassis to multichassis ports])

   len=3000
   packet=$(send_ip_packet multi1 1 $multi1_mac $multi2_mac $multi1_ip $multi2_ip $(payload $len) 1)
   echo $packet >> hv1/multi1.expected

   packet=$(send_ip6_packet multi1 1 $multi1_mac $multi2_mac $multi1_ip6 $multi2_ip6 $(payload $len) 1)
   echo $packet >> hv1/multi1.expected

   check_pkts
   reset_env

   AS_BOX([MTU updates are honored in ICMP Path MTU calculation])

   set_mtu() {
       local hv=${1} iface=${2} new_mtu=${3}

       iface_uuid=$(as ${hv} ovs-vsctl --bare --columns _uuid find Interface name=${iface})
       check as ${hv} ovs-vsctl set interface ${iface_uuid} mtu_request=${new_mtu}
   }

   set_mtu_for_all_ports() {
       for port in multi1 multi2 first; do
           set_mtu hv1 ${port} ${1}
       done
       for port in multi1 multi2 second; do
           set_mtu hv2 ${port} ${1}
       done
   }

   initial_mtu=1500  # all interfaces are 1500 by default
   new_mtu=1400
   set_mtu_for_all_ports ${new_mtu}
   mtu_diff=$((${initial_mtu} - ${new_mtu}))

   len=3000
   expected_ip_mtu=$(($3 - ${mtu_diff}))
   packet=$(send_ip_packet first 1 $first_mac $multi1_mac $first_ip $multi1_ip $(payload $len) 1 ${expected_ip_mtu})
   echo $packet >> hv1/first.expected

   packet=$(send_ip_packet second 2 $second_mac $multi1_mac $second_ip $multi1_ip $(payload $len) 1 ${expected_ip_mtu})
   echo $packet >> hv2/second.expected

   packet=$(send_ip6_packet first 1 $first_mac $multi1_mac $first_ip6 $multi1_ip6 $(payload $len) 1 ${expected_ip_mtu})
   echo $packet >> hv1/first.expected

   packet=$(send_ip6_packet second 2 $second_mac $multi1_mac $second_ip6 $multi1_ip6 $(payload $len) 1 ${expected_ip_mtu})
   echo $packet >> hv2/second.expected

   packet=$(send_ip_packet multi1 1 $multi1_mac $first_mac $multi1_ip $first_ip $(payload $len) 1 ${expected_ip_mtu})
   echo $packet >> hv1/multi1.expected

   packet=$(send_ip_packet multi1 1 $multi1_mac $second_mac $multi1_ip $second_ip $(payload $len) 1 ${expected_ip_mtu})
   echo $packet >> hv1/multi1.expected

   packet=$(send_ip6_packet multi1 1 $multi1_mac $first_mac $multi1_ip6 $first_ip6 $(payload $len) 1 ${expected_ip_mtu})
   echo $packet >> hv1/multi1.expected

   packet=$(send_ip6_packet multi1 1 $multi1_mac $second_mac $multi1_ip6 $second_ip6 $(payload $len) 1 ${expected_ip_mtu})
   echo $packet >> hv1/multi1.expected

   packet=$(send_ip_packet multi1 1 $multi1_mac $multi2_mac $multi1_ip $multi2_ip $(payload $len) 1 ${expected_ip_mtu})
   echo $packet >> hv1/multi1.expected

   packet=$(send_ip6_packet multi1 1 $multi1_mac $multi2_mac $multi1_ip6 $multi2_ip6 $(payload $len) 1 ${expected_ip_mtu})
   echo $packet >> hv1/multi1.expected

   check_pkts

   OVN_CLEANUP([hv1],[hv2])

   AT_CLEANUP
   ])])

# NOTE(ihar) no STT variants because it's not supported by upstream kernels
MULTICHASSIS_PATH_MTU_DISCOVERY_TEST([ipv4], [geneve], [1424])
MULTICHASSIS_PATH_MTU_DISCOVERY_TEST([ipv6], [geneve], [1404])
MULTICHASSIS_PATH_MTU_DISCOVERY_TEST([ipv4], [vxlan], [1432])
MULTICHASSIS_PATH_MTU_DISCOVERY_TEST([ipv6], [vxlan], [1412])

OVN_FOR_EACH_NORTHD([
AT_SETUP([options:activation-strategy for logical port])
AT_KEYWORDS([multi-chassis])
AT_KEYWORDS([slowtest])
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.12

sim_add hv3
as hv3
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.13

# Disable local ARP responder to pass ARP requests through tunnels
check ovn-nbctl ls-add ls0 -- add Logical_Switch ls0 other_config vlan-passthru=true

check ovn-nbctl lsp-add ls0 migrator
check ovn-nbctl lsp-set-options migrator requested-chassis=hv1,hv2 \
                                         activation-strategy=rarp

check ovn-nbctl lsp-add ls0 first
check ovn-nbctl lsp-set-options first requested-chassis=hv1
check ovn-nbctl lsp-add ls0 second
check ovn-nbctl lsp-set-options second requested-chassis=hv2
check ovn-nbctl lsp-add ls0 outside
check ovn-nbctl lsp-set-options outside requested-chassis=hv3

check ovn-nbctl lsp-set-addresses migrator "00:00:00:00:00:10 10.0.0.10"
check ovn-nbctl lsp-set-addresses first "00:00:00:00:00:01 10.0.0.1"
check ovn-nbctl lsp-set-addresses second "00:00:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-addresses outside "00:00:00:00:00:03 10.0.0.3"

for hv in hv1 hv2; do
    as $hv check ovs-vsctl -- add-port br-int migrator -- \
        set Interface migrator external-ids:iface-id=migrator \
                               options:tx_pcap=$hv/migrator-tx.pcap \
                               options:rxq_pcap=$hv/migrator-rx.pcap
done

as hv1 check ovs-vsctl -- add-port br-int first -- \
    set Interface first external-ids:iface-id=first
as hv2 check ovs-vsctl -- add-port br-int second -- \
    set Interface second external-ids:iface-id=second
as hv3 check ovs-vsctl -- add-port br-int outside -- \
    set Interface outside external-ids:iface-id=outside

for hv in hv1 hv2 hv3; do
    wait_row_count Chassis 1 name=$hv
done
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)
hv3_uuid=$(fetch_column Chassis _uuid name=hv3)

wait_column "$hv1_uuid" Port_Binding chassis logical_port=migrator
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=migrator
wait_column "$hv2_uuid" Port_Binding additional_chassis logical_port=migrator
wait_column "$hv2_uuid" Port_Binding requested_additional_chassis logical_port=migrator

wait_column "$hv1_uuid" Port_Binding chassis logical_port=first
wait_column "$hv2_uuid" Port_Binding chassis logical_port=second
wait_column "$hv3_uuid" Port_Binding chassis logical_port=outside

OVN_POPULATE_ARP

send_arp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as ${hv} ovs-appctl netdev-dummy/receive $inport $request
    echo "${request}"
}

send_rarp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}80350001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as ${hv} ovs-appctl netdev-dummy/receive $inport $request
    echo "${request}"
}

reset_env() {
    as hv1 reset_pcap_file migrator hv1/migrator
    as hv2 reset_pcap_file migrator hv2/migrator
    as hv1 reset_pcap_file first hv1/first
    as hv2 reset_pcap_file second hv2/second
    as hv3 reset_pcap_file outside hv3/outside

    for port in hv1/migrator hv2/migrator hv1/first hv2/second hv3/outside; do
        : > $port.expected
    done
}

check_packets() {
    OVN_CHECK_PACKETS([hv1/migrator-tx.pcap], [hv1/migrator.expected])
    OVN_CHECK_PACKETS([hv2/migrator-tx.pcap], [hv2/migrator.expected])
    OVN_CHECK_PACKETS([hv3/outside-tx.pcap], [hv3/outside.expected])
    OVN_CHECK_PACKETS([hv1/first-tx.pcap], [hv1/first.expected])
    OVN_CHECK_PACKETS([hv2/second-tx.pcap], [hv2/second.expected])
}

migrator_spa=$(ip_to_hex 10 0 0 10)
first_spa=$(ip_to_hex 10 0 0 1)
second_spa=$(ip_to_hex 10 0 0 2)
outside_spa=$(ip_to_hex 10 0 0 3)

reset_env

# Packet from hv3:Outside arrives to hv1:Migrator
# hv3:Outside cannot reach hv2:Migrator because it is blocked by RARP strategy
request=$(send_arp hv3 outside 000000000003 000000000010 $outside_spa $migrator_spa)
echo $request >> hv1/migrator.expected

# Packet from hv1:First arrives to hv1:Migrator
# hv1:First cannot reach hv2:Migrator because it is blocked by RARP strategy
request=$(send_arp hv1 first 000000000001 000000000010 $first_spa $migrator_spa)
echo $request >> hv1/migrator.expected

# Packet from hv2:Second arrives to hv1:Migrator
# hv2:Second cannot reach hv2:Migrator because it is blocked by RARP strategy
request=$(send_arp hv2 second 000000000002 000000000010 $second_spa $migrator_spa)
echo $request >> hv1/migrator.expected

check_packets
reset_env

# Packet from hv1:Migrator arrives to hv3:Outside
request=$(send_arp hv1 migrator 000000000010 000000000003 $migrator_spa $outside_spa)
echo $request >> hv3/outside.expected

# Packet from hv1:Migrator arrives to hv1:First
request=$(send_arp hv1 migrator 000000000010 000000000001 $migrator_spa $first_spa)
echo $request >> hv1/first.expected

# Packet from hv1:Migrator arrives to hv2:Second
request=$(send_arp hv1 migrator 000000000010 000000000002 $migrator_spa $second_spa)
echo $request >> hv2/second.expected

check_packets
reset_env

# hv2:Migrator cannot reach to hv3:Outside because it is blocked by RARP strategy
request=$(send_arp hv2 migrator 000000000010 000000000003 $migrator_spa $outside_spa)

check_packets
reset_env

AT_CHECK([ovn-sbctl find port_binding logical_port=migrator | grep -q additional-chassis-activated], [1])

# Now activate hv2:Migrator location
request=$(send_rarp hv2 migrator 000000000010 ffffffffffff $migrator_spa $migrator_spa)

# RARP was reinjected into the pipeline
echo $request >> hv3/outside.expected
echo $request >> hv1/first.expected
echo $request >> hv2/second.expected

check_packets
reset_env

pb_uuid=$(ovn-sbctl --bare --columns _uuid find Port_Binding logical_port=migrator)
OVS_WAIT_UNTIL([test xhv2 = x$(ovn-sbctl get Port_Binding $pb_uuid options:additional-chassis-activated | tr -d '""')])

# Now packet arrives to both locations
request=$(send_arp hv3 outside 000000000003 000000000010 $outside_spa $migrator_spa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected

check_packets
reset_env

# Packet from hv1:Migrator still arrives to hv3:Outside
request=$(send_arp hv1 migrator 000000000010 000000000003 $migrator_spa $outside_spa)
echo $request >> hv3/outside.expected

check_packets
reset_env

# hv2:Migrator can now reach to hv3:Outside because RARP strategy activated it
request=$(send_arp hv2 migrator 000000000010 000000000003 $migrator_spa $outside_spa)
echo $request >> hv3/outside.expected

check_packets

# complete port migration and check that -activated flag is reset
check ovn-nbctl lsp-set-options migrator requested-chassis=hv2
OVS_WAIT_UNTIL([test x = x$(ovn-sbctl get Port_Binding $pb_uuid options:additional-chassis-activated)])

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([options:activation-strategy=rarp is not waiting for southbound db])
AT_KEYWORDS([multi-chassis])
# unskip when ovn-controller is able to process incremental updates to flow
# table without ovsdb transaction available
AT_SKIP_IF([true])

ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.12

# Disable local ARP responder to pass ARP requests through tunnels
check ovn-nbctl ls-add ls0 -- add Logical_Switch ls0 other_config vlan-passthru=true

check ovn-nbctl lsp-add ls0 migrator
check ovn-nbctl lsp-set-options migrator requested-chassis=hv1,hv2 \
                                         activation-strategy=rarp

check ovn-nbctl lsp-add ls0 first
check ovn-nbctl lsp-set-options first requested-chassis=hv1

check ovn-nbctl lsp-set-addresses migrator "00:00:00:00:00:10 10.0.0.10"
check ovn-nbctl lsp-set-addresses first "00:00:00:00:00:01 10.0.0.1"

for hv in hv1 hv2; do
    as $hv check ovs-vsctl -- add-port br-int migrator -- \
        set Interface migrator external-ids:iface-id=migrator \
                               options:tx_pcap=$hv/migrator-tx.pcap \
                               options:rxq_pcap=$hv/migrator-rx.pcap
done

as hv1 check ovs-vsctl -- add-port br-int first -- \
    set Interface first external-ids:iface-id=first

for hv in hv1 hv2; do
    wait_row_count Chassis 1 name=$hv
done
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)

wait_column "$hv1_uuid" Port_Binding chassis logical_port=migrator
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=migrator
wait_column "$hv2_uuid" Port_Binding additional_chassis logical_port=migrator
wait_column "$hv2_uuid" Port_Binding requested_additional_chassis logical_port=migrator

wait_column "$hv1_uuid" Port_Binding chassis logical_port=first

OVN_POPULATE_ARP

send_arp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as ${hv} ovs-appctl netdev-dummy/receive $inport $request
    echo "${request}"
}

send_rarp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}80350001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as ${hv} ovs-appctl netdev-dummy/receive $inport $request
    echo "${request}"
}

reset_env() {
    as hv1 reset_pcap_file migrator hv1/migrator
    as hv2 reset_pcap_file migrator hv2/migrator
    as hv1 reset_pcap_file first hv1/first

    for port in hv1/migrator hv2/migrator hv1/first; do
        : > $port.expected
    done
}

check_packets() {
    OVN_CHECK_PACKETS([hv1/migrator-tx.pcap], [hv1/migrator.expected])
    OVN_CHECK_PACKETS([hv2/migrator-tx.pcap], [hv2/migrator.expected])
    OVN_CHECK_PACKETS([hv1/first-tx.pcap], [hv1/first.expected])
}

migrator_spa=$(ip_to_hex 10 0 0 10)
first_spa=$(ip_to_hex 10 0 0 1)

reset_env

# Packet from hv1:First arrives to hv1:Migrator
# hv1:First cannot reach hv2:Migrator because it is blocked by RARP strategy
request=$(send_arp hv1 first 000000000001 000000000010 $first_spa $migrator_spa)
echo $request >> hv1/migrator.expected

check_packets
reset_env

# Packet from hv1:Migrator arrives to hv1:First
request=$(send_arp hv1 migrator 000000000010 000000000001 $migrator_spa $first_spa)
echo $request >> hv1/first.expected

check_packets
reset_env

# hv2:Migrator cannot reach to hv1:First because it is blocked by RARP strategy
request=$(send_arp hv2 migrator 000000000010 000000000001 $migrator_spa $first_spa)

check_packets
reset_env

# Before proceeding, stop ovsdb-server to make sure we test in the environment
# that can't remove flows triggered by updates to database
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

# Now activate hv2:Migrator location
request=$(send_rarp hv2 migrator 000000000010 ffffffffffff $migrator_spa $migrator_spa)

# RARP was reinjected into the pipeline
echo $request >> hv1/first.expected

# Now packet from hv1:First arrives to both locations
request=$(send_arp hv1 first 000000000001 000000000010 $first_spa $migrator_spa)
echo $request >> hv1/migrator.expected
echo $request >> hv2/migrator.expected

# Packet from hv1:Migrator still arrives to hv1:First
request=$(send_arp hv1 migrator 000000000010 000000000001 $migrator_spa $first_spa)
echo $request >> hv1/first.expected

# hv2:Migrator can now reach to hv1:First because RARP strategy activated it
request=$(send_arp hv2 migrator 000000000010 000000000001 $migrator_spa $first_spa)
echo $request >> hv1/first.expected

check_packets

# restart ovsdb-server before cleaning up to give ovn-controller a chance to
# exit gracefully
mv $ovs_base/ovn-sb/ovsdb-server.log $ovs_base/ovn-sb/ovsdb-server.log.prev
as ovn-sb start_daemon ovsdb-server \
        -vjsonrpc \
        --remote=punix:$ovs_base/ovn-sb/$1.sock \
        --remote=db:OVN_Southbound,SB_Global,connections \
        --private-key=$PKIDIR/testpki-test-privkey.pem \
        --certificate=$PKIDIR/testpki-test-cert.pem \
        --ca-cert=$PKIDIR/testpki-cacert.pem \
        $ovs_base/ovn-sb/ovn-sb.db

PARSE_LISTENING_PORT([$ovs_base/ovn-sb/ovsdb-server.log], [TCP_PORT])
for i in 1 2; do
    as hv$i
    ovs-vsctl \
        -- set Open_vSwitch . external-ids:ovn-remote=ssl:127.0.0.1:$TCP_PORT
done
OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([options:requested-chassis for logical port])
ovn_start

net_add n1

ovn-nbctl ls-add ls0
ovn-nbctl lsp-add ls0 lsp0

# create two hypervisors, each with one vif port
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11
ovs-vsctl -- add-port br-int hv1-vif0 -- \
set Interface hv1-vif0 ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.12
ovs-vsctl -- add-port br-int hv2-vif0 -- \
set Interface hv2-vif0 ofport-request=1

# Allow only chassis hv1 to bind logical port lsp0.
ovn-nbctl lsp-set-options lsp0 requested-chassis=hv1

# Allow some time for ovn-northd and ovn-controller to catch up.
check ovn-nbctl --wait=hv sync

# Retrieve hv1 and hv2 chassis UUIDs from southbound database
wait_row_count Chassis 1 name=hv1
wait_row_count Chassis 1 name=hv2
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)

# (1) Chassis hv2 should not bind lsp0 when requested-chassis is hv1.
echo "verifying that hv2 does not bind lsp0 when hv2 physical/logical mapping is added"
as hv2
ovs-vsctl set interface hv2-vif0 external-ids:iface-id=lsp0

OVS_WAIT_UNTIL([test 1 = $(grep -c "Not claiming lport lsp0" hv2/ovn-controller.log)])
wait_row_count Port_Binding 1 logical_port=lsp0 'chassis=[[]]'

# (2) Chassis hv2 should not add flows in OFTABLE_PHY_TO_LOG and OFTABLE_LOG_TO_PHY tables.
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [1], [])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=65 | grep output], [1], [])

# (3) Chassis hv1 should bind lsp0 when physical to logical mapping exists on hv1.
echo "verifying that hv1 binds lsp0 when hv1 physical/logical mapping is added"
as hv1
ovs-vsctl set interface hv1-vif0 external-ids:iface-id=lsp0

OVS_WAIT_UNTIL([test 1 = $(grep -c "Claiming lport lsp0" hv1/ovn-controller.log)])
wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0

# (4) Chassis hv1 should add flows in OFTABLE_PHY_TO_LOG and OFTABLE_LOG_TO_PHY tables.
as hv1 ovs-ofctl dump-flows br-int
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [0], [ignore])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=65 | grep actions=output:1], [0], [ignore])

# (5) Chassis hv1 should release lsp0 binding and chassis hv2 should bind lsp0 when
# the requested chassis for lsp0 is changed from hv1 to hv2.
echo "verifying that lsp0 binding moves when requested-chassis is changed"

ovn-nbctl lsp-set-options lsp0 requested-chassis=hv2
# We might see multiple "Releasing lport ...", when sb is read only
OVS_WAIT_UNTIL([test 1 -le $(grep -c "Releasing lport lsp0" hv1/ovn-controller.log)])

wait_column "$hv2_uuid" Port_Binding chassis logical_port=lsp0

# (6) Chassis hv2 should add flows and hv1 should not.
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [0], [ignore])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=65 | grep actions=output:1], [0], [ignore])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [1], [])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=65 | grep output], [1], [])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([tug-of-war between two chassis for the same port])
TAG_UNSTABLE
ovn_start

ovn-nbctl ls-add ls0
ovn-nbctl lsp-add ls0 lsp0

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done

for i in 1 2; do
    as hv$i
    ovs-vsctl -- add-port br-int vif \
              -- set Interface vif external-ids:iface-id=lsp0
done

# give controllers some time to fight for the port binding
sleep 3

# calculate the number of port claims registered by each fighting chassis
hv1_claims=$(as hv1 grep -c 'Claiming\|Changing chassis' hv1/ovn-controller.log)
hv2_claims=$(as hv2 grep -c 'Claiming\|Changing chassis' hv2/ovn-controller.log)

echo "hv1 claimed ${hv1_claims} times"
echo "hv2 claimed ${hv2_claims} times"

# check that neither registered an outrageous number of port claims
max_claims=20
AT_CHECK([test "${hv1_claims}" -le "${max_claims}"], [0], [])
AT_CHECK([test "${hv2_claims}" -le "${max_claims}"], [0], [])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([options:requested-chassis with hostname])

ovn_start

ovn-nbctl ls-add ls0
ovn-nbctl lsp-add ls0 lsp0

net_add n1
sim_add hv1
as hv1
ovs-vsctl set Open_vSwitch . external-ids:hostname=hv1-hostname
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11
ovs-vsctl -- add-port br-int hv1-vif0 -- set Interface hv1-vif0 ofport-request=1

wait_row_count Chassis 1 name=hv1
hv1_hostname=$(fetch_column Chassis hostname name=hv1)
echo "hv1_hostname=${hv1_hostname}"
AT_CHECK([test -n "${hv1_hostname}" -a "${hv1_hostname}" != hv1], [1], [])
check ovn-nbctl --wait=hv lsp-set-options lsp0 requested-chassis=${hv1_hostname}
as hv1 ovs-vsctl set interface hv1-vif0 external-ids:iface-id=lsp0

hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
echo "hv1_uuid=${hv1_uuid}"
OVS_WAIT_UNTIL([test 1 = $(grep -c "Claiming lport lsp0" hv1/ovn-controller.log)])
wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp0
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [0], [ignore])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=65 | grep actions=output:1], [0], [ignore])

check ovn-nbctl --wait=hv lsp-set-options lsp0 requested-chassis=non-existant-chassis
OVS_WAIT_UNTIL([test 1 -le $(grep -c "Releasing lport lsp0" hv1/ovn-controller.log)])
check ovn-nbctl --wait=hv sync
wait_column '' Port_Binding chasssi logical_port=lsp0
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep in_port=1], [1], [])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=65 | grep output], [1], [])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IPv6 periodic RA])
ovn_start

# This test sets up two hypervisors.
# hv1 and hv2 run ovn-controllers, and
# each has a VIF connected to the same
# logical switch in OVN. The logical
# switch is connected to a logical
# router port that is configured to send
# periodic router advertisements.
#
# The reason for having two ovn-controller
# hypervisors is to ensure that the
# periodic RAs being sent by each ovn-controller
# are kept to their local hypervisors. If the
# packets are not kept local, then each port
# will receive too many RAs.

net_add n1
sim_add hv1
sim_add hv2
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3

ovn-nbctl lr-add ro
ovn-nbctl lrp-add ro ro-sw 00:00:00:00:00:01 aef0:0:0:0:0:0:0:1/64

ovn-nbctl ls-add sw
ovn-nbctl lsp-add sw sw-ro
ovn-nbctl lsp-set-type sw-ro router
ovn-nbctl lsp-set-options sw-ro router-port=ro-sw
ovn-nbctl lsp-set-addresses sw-ro 00:00:00:00:00:01
ovn-nbctl lsp-add sw sw-p1
ovn-nbctl lsp-set-addresses sw-p1 "00:00:00:00:00:02 aef0::200:ff:fe00:2"
ovn-nbctl lsp-add sw sw-p2
ovn-nbctl lsp-set-addresses sw-p2 "00:00:00:00:00:03 aef0::200:ff:fe00:3"

ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:send_periodic=true
ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=slaac
ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=4
ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=3

for i in 1 2 ; do
    as hv$i
    ovs-vsctl -- add-port br-int hv$i-vif1 -- \
        set interface hv$i-vif1 external-ids:iface-id=sw-p$i \
        options:tx_pcap=hv$i/vif1-tx.pcap \
        options:rxq_pcap=hv$i/vif1-rx.pcap \
        ofport-request=1
done

OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up sw-p1` = xup])
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up sw-p2` = xup])

construct_expected_ra() {
    local src_mac=000000000001
    local dst_mac=333300000001
    local src_addr=fe80000000000000020000fffe000001
    local dst_addr=ff020000000000000000000000000001

    local mtu=$1
    local ra_mo=$2
    local rdnss=$3
    local dnssl=$4
    local route_info=$5
    local ra_prefix_la=$6

    local slla=0101${src_mac}
    local mtu_opt=""
    if test $mtu != 0; then
        mtu_opt=05010000${mtu}
    fi
    shift 6

    local prefix=""
    while [[ $# -gt 0 ]] ; do
        local size=$1
        local net=$2
        prefix=${prefix}0304${size}${ra_prefix_la}ffffffffffffffff00000000${net}
        shift 2
    done

    local rdnss_opt=""
    if test $rdnss != 0; then
        rdnss_opt=19030000ffffffff${rdnss}
    fi
    local dnssl_opt=""
    if test $dnssl != 0; then
        dnssl_opt=1f030000ffffffff${dnssl}
    fi
    local route_info_opt=""
    if test $route_info != 0; then
        route_info_opt=${route_info}
    fi

    local ra=ff${ra_mo}ffff0000000000000000${slla}${mtu_opt}${prefix}${rdnss_opt}${dnssl_opt}${route_info_opt}
    local icmp=8600XXXX${ra}

    local ip_len=$(expr ${#icmp} / 2)
    ip_len=$(echo "$ip_len" | awk '{printf "%0.4x\n", $0}')

    local ip=60000000${ip_len}3aff${src_addr}${dst_addr}${icmp}
    local eth=${dst_mac}${src_mac}86dd${ip}
    local packet=${eth}
    echo $packet | sort >> expected
}

ra_test() {
    construct_expected_ra $@

    for i in hv1 hv2 ; do
        as $i reset_pcap_file $i-vif1 $i/vif1

        OVS_WAIT_WHILE([test 24 = $(wc -c $i/vif1-tx.pcap | cut -d " " -f1)])

        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $i/vif1-tx.pcap | sort | uniq > packets

        cat expected | cut -c -112 > expout
        AT_CHECK([cat packets | cut -c -112], [0], [expout])

        # Skip ICMPv6 checksum.
        cat expected | cut -c 117- > expout
        AT_CHECK([cat packets | cut -c 117-], [0], [expout])

        rm -f packets
        as $i reset_pcap_file $i-vif1 $i/vif1
    done

    rm -f expected
}

echo "Baseline test with no MTU"
ra_test 0 00 0 0 0 c0 40 aef00000000000000000000000000000

echo "Now make sure an MTU option makes it"
ovn-nbctl --wait=hv set Logical_Router_Port ro-sw ipv6_ra_configs:mtu=1500
ra_test 000005dc 00 0 0 0 c0 40 aef00000000000000000000000000000

echo "Now test for multiple network prefixes"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw networks='aef0\:\:1/64 fd0f\:\:1/48'
ra_test 000005dc 00 0 0 0 c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

echo "Test PRF for default gw"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw ipv6_ra_configs:router_preference="LOW"
ra_test 000005dc 18 0 0 0 c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

echo "Now test for RDNSS"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw ipv6_ra_configs:rdnss='aef0::11'
dns_addr=aef00000000000000000000000000011
ra_test 000005dc 18 $dns_addr 0 0 c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

echo "Now test for DNSSL"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw ipv6_ra_configs:dnssl="aa.bb.cc"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw ipv6_ra_configs:router_preference="HIGH"
dnssl=02616102626202636300000000000000
ra_test 000005dc 08 $dns_addr $dnssl 0 c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

echo "Now test Route Info option"
ovn-nbctl --wait=hv set Logical_Router_port ro-sw ipv6_ra_configs:route_info="HIGH-aef1::11/48,LOW-aef2::11/96"
route_info=18023008ffffffffaef100000000000018036018ffffffffaef20000000000000000000000000000
ra_test 000005dc 08 $dns_addr $dnssl $route_info c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000
echo "Test a different address mode now"
ovn-nbctl --wait=hv set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=dhcpv6_stateful
ra_test 000005dc 88 $dns_addr $dnssl $route_info 80 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

echo "And the other address mode"
ovn-nbctl --wait=hv set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=dhcpv6_stateless
ra_test 000005dc 48 $dns_addr $dnssl $route_info c0 40 aef00000000000000000000000000000 30 fd0f0000000000000000000000000000

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([garps disabled when port no longer bound to chassis])
ovn_start

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
    check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
done

check ovn-nbctl ls-add ls0
check ovn-nbctl lsp-add ls0 port
check ovn-nbctl lsp-set-addresses port "00:00:00:00:00:01 10.0.0.1"

check ovn-nbctl lsp-add ls0 public
check ovn-nbctl lsp-set-addresses public unknown
check ovn-nbctl lsp-set-type public localnet
check ovn-nbctl lsp-set-options public network_name=phys

for hv in hv1 hv2; do
    as $hv check ovs-vsctl -- add-port br-int port -- \
        set Interface port external-ids:iface-id=port \
        options:tx_pcap=$hv/port-tx.pcap \
        options:rxq_pcap=$hv/port-rx.pcap
done

reset_env() {
    as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
    as hv2 reset_pcap_file br-phys_n1 hv2/br-phys_n1

    for port in hv1/n1 hv2/n1; do
        : > $port.expected
    done
}

for hv in hv1 hv2; do
    wait_row_count Chassis 1 name=$hv
done
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)

OVN_POPULATE_ARP

# Activate port on each hv giving a chance to each chassis to enable garps
check ovn-nbctl lsp-set-options port requested-chassis=hv1
wait_column "$hv1_uuid" Port_Binding chassis logical_port=port
wait_column "$hv1_uuid" Port_Binding requested_chassis logical_port=port
wait_for_ports_up
reset_env

# give chassis some time to generate garps
sleep 2

expected_garp=ffffffffffff000000000001080600010800060400010000000000010a0000010000000000000a000001

# check hv1 sends garps and hv2 doesn't
echo $expected_garp >> hv1/n1.expected
OVN_CHECK_PACKETS_CONTAIN([hv1/br-phys_n1-tx.pcap], [hv1/n1.expected])
OVN_CHECK_PACKETS([hv2/br-phys_n1-tx.pcap], [hv2/n1.expected])

check ovn-nbctl lsp-set-options port requested-chassis=hv2
wait_column "$hv2_uuid" Port_Binding chassis logical_port=port
wait_column "$hv2_uuid" Port_Binding requested_chassis logical_port=port
wait_for_ports_up
reset_env

# give chassis some time to generate garps
sleep 2

# check hv2 sends garps and hv1 doesn't
echo $expected_garp >> hv2/n1.expected
OVN_CHECK_PACKETS([hv1/br-phys_n1-tx.pcap], [hv1/n1.expected])
OVN_CHECK_PACKETS_CONTAIN([hv2/br-phys_n1-tx.pcap], [hv2/n1.expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IPv6 periodic RA disabled for localnet adjacent switch ports])
ovn_start

net_add n1
sim_add hv1
sim_add hv2
as hv1
check ovs-vsctl add-br br-phys
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.2
as hv2
check ovs-vsctl add-br br-phys
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.3

check ovn-nbctl lr-add ro
check ovn-nbctl lrp-add ro ro-sw 00:00:00:00:00:01 aef0:0:0:0:0:0:0:1/64

check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw ln
check ovn-nbctl lsp-set-addresses ln unknown
check ovn-nbctl lsp-set-type ln localnet
check ovn-nbctl lsp-set-options ln network_name=phys

check ovn-nbctl lsp-add sw sw-ro
check ovn-nbctl lsp-set-type sw-ro router
check ovn-nbctl lsp-set-options sw-ro router-port=ro-sw
check ovn-nbctl lsp-set-addresses sw-ro 00:00:00:00:00:01
check ovn-nbctl lsp-add sw sw-p1
check ovn-nbctl lsp-set-addresses sw-p1 "00:00:00:00:00:02 aef0::200:ff:fe00:2"
check ovn-nbctl lsp-add sw sw-p2
check ovn-nbctl lsp-set-addresses sw-p2 "00:00:00:00:00:03 aef0::200:ff:fe00:3"

check ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:send_periodic=true
check ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=slaac
check ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=1
check ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=1

for i in 1 2 ; do
    as hv$i
    check ovs-vsctl -- add-port br-int hv$i-vif1 -- \
        set interface hv$i-vif1 external-ids:iface-id=sw-p$i \
        options:tx_pcap=hv$i/vif1-tx.pcap \
        options:rxq_pcap=hv$i/vif1-rx.pcap \
        ofport-request=1
done

wait_for_ports_up

construct_expected_ra() {
    local src_mac=000000000001
    local dst_mac=333300000001
    local src_addr=fe80000000000000020000fffe000001
    local dst_addr=ff020000000000000000000000000001

    local mtu=$1
    local ra_mo=$2
    local rdnss=$3
    local dnssl=$4
    local route_info=$5
    local ra_prefix_la=$6

    local slla=0101${src_mac}
    local mtu_opt=""
    if test $mtu != 0; then
        mtu_opt=05010000${mtu}
    fi
    shift 6

    local prefix=""
    while [[ $# -gt 0 ]] ; do
        local size=$1
        local net=$2
        prefix=${prefix}0304${size}${ra_prefix_la}ffffffffffffffff00000000${net}
        shift 2
    done

    local rdnss_opt=""
    if test $rdnss != 0; then
        rdnss_opt=19030000ffffffff${rdnss}
    fi
    local dnssl_opt=""
    if test $dnssl != 0; then
        dnssl_opt=1f030000ffffffff${dnssl}
    fi
    local route_info_opt=""
    if test $route_info != 0; then
        route_info_opt=${route_info}
    fi

    local ra=ff${ra_mo}ffff0000000000000000${slla}${mtu_opt}${prefix}${rdnss_opt}${dnssl_opt}${route_info_opt}
    local icmp=8600XXXX${ra}

    local ip_len=$(expr ${#icmp} / 2)
    ip_len=$(echo "$ip_len" | awk '{printf "%0.4x\n", $0}')

    local ip=60000000${ip_len}3aff${src_addr}${dst_addr}${icmp}
    local eth=${dst_mac}${src_mac}86dd${ip}
    local packet=${eth}
    echo $packet >> expected
}

ra_received() {
    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $1 | sed '/^ffffffffffff/d' | wc -l
}

ra_test() {
    construct_expected_ra $@

    for i in hv1 hv2 ; do
        as $i reset_pcap_file $i-vif1 $i/vif1

        OVS_WAIT_WHILE([test 0 = $(ra_received $i/vif1-tx.pcap)])

        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $i/vif1-tx.pcap > packets
        sed -i '/^ffffffffffff/d' packets

        cat expected | cut -c -112 > expout
        AT_CHECK([head -1 packets | cut -c -112], [0], [expout])

        # Skip ICMPv6 checksum.
        cat expected | cut -c 117- > expout
        AT_CHECK([head -1 packets | cut -c 117-], [0], [expout])

        rm -f packets
        as $i reset_pcap_file $i-vif1 $i/vif1
    done

    rm -f expected
}

# check that RAs are sent to vifs
ra_test 0 00 0 0 0 c0 40 aef00000000000000000000000000000

# check that RAs don't leak into provider networks
for i in hv1 hv2 ; do
    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $i/br-phys-tx.pcap > packets
    sed -i '/^ffffffffffff/d' packets

    > expout
    AT_CHECK([head -1 packets], [0], [expout])
done

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL reject rule test])
AT_KEYWORDS([acl-reject])
ovn_start

# test_ip_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST IP_CHKSUM EXP_IP_CHKSUM EXP_ICMP_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv4 packet with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHKSUM as specified.
# EXP_IP_CHKSUM and EXP_ICMP_CHKSUM are the ip and icmp checksums of the icmp destination
# unreachable frame generated from ACL rule hit
#
# INPORT is a lport number, e.g. 11 for vif11.
# HV is a hypervisor number
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_DST are each 8 hex digits.
# IP_CHKSUM, EXP_IP_CHSUM and EXP_ICMP_CHKSUM are each 4 hex digits
test_ip_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7
    local exp_ip_chksum=$8 exp_icmp_chksum=$9
    shift 9

    local ip_ttl=ff
    local packet=${eth_dst}${eth_src}08004500001400004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}
    local orig_pkt_in_reply=4500001400004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}
    local reply_icmp_ttl=ff
    local icmp_type_code_response=0301
    local icmp_data=00000000
    local reply_icmp_payload=${icmp_type_code_response}${exp_icmp_chksum}${icmp_data}
    local reply=${eth_src}${eth_dst}08004500003000004000${reply_icmp_ttl}01${exp_ip_chksum}${ipv4_dst}${ipv4_src}${reply_icmp_payload}
    echo $reply$orig_pkt_in_reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_ipv6_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST EXP_ICMP_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv6 packet with
# ETH_SRC, ETH_DST, IPV6_SRC, IPV6_DST as specified.
# EXP_ICMP_CHKSUM is the icmp6 checksums of the icmp6 destination unreachable frame generated from ACL rule hit
test_ipv6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6 exp_icmp_chksum=$7
    shift 7

    local ip6_hdr=6000000000083aff${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}0000000000000000

    local reply=${eth_src}${eth_dst}86dd6000000000383aff${ipv6_dst}${ipv6_src}0101${exp_icmp_chksum}00000000${ip6_hdr}0000000000000000
    echo $reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_tcp_syn_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST IP_CHKSUM TCP_SPORT TCP_DPORT TCP_CHKSUM EXP_IP_CHKSUM EXP_TCP_RST_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an TCP syn segment with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHKSUM, TCP_SPORT, TCP_DPORT, TCP_CHKSUM  as specified.
# EXP_IP_CHKSUM and EXP_TCP_RST_CHKSUM are the ip and tcp checksums of the tcp reset segment generated from ACL rule hit
#
# INPORT is an lport number, e.g. 11 for vif11.
# HV is an hypervisor number
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_DST are each 8 hex digits.
# TCP_SPORT and TCP_DPORT are 4 hex digits.
# IP_CHKSUM, TCP_CHKSUM, EXP_IP_CHSUM and EXP_TCP_RST_CHKSUM are each 4 hex digits
test_tcp_syn_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7
    local tcp_sport=$8 tcp_dport=$9 tcp_chksum=${10}
    local exp_ip_chksum=${11} exp_tcp_rst_chksum=${12}
    shift 12

    local ip_ttl=ff
    local packet=${eth_dst}${eth_src}08004500002800004000${ip_ttl}06${ip_chksum}${ipv4_src}${ipv4_dst}${tcp_sport}${tcp_dport}000000010000000050027210${tcp_chksum}0000

    local tcp_rst_ttl=3f
    local reply=${eth_src}${eth_dst}08004500002800004000${tcp_rst_ttl}06${exp_ip_chksum}${ipv4_dst}${ipv4_src}${tcp_dport}${tcp_sport}000000000000000250140000${exp_tcp_rst_chksum}0000
    echo $reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_sctp_init_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST IP_CHKSUM SCTP_SPORT SCTP_DPORT SCTP_INIT_TAG SCTP_CHKSUM EXP_IP_CHKSUM EXP_SCTP_ABORT_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an SCTP INIT chunk with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHKSUM, SCTP_SPORT, SCTP_DPORT, and SCTP_CHKSUM as specified.
# The INIT "initiate_tag" will be set to SCTP_INIT_TAG.
# EXP_IP_CHKSUM and EXP_SCTP_CHKSUM are the ip and sctp checksums of the SCTP ABORT chunk generated from the ACL rule hit
#
# INPORT is an lport number, e.g. 11 for vif11.
# HV is a hypervisor number.
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_DST are each 8 hex digits.
# SCTP_SPORT and SCTP_DPORT are 4 hex digits.
# IP_CHKSUM and EXP_IP_CHKSUM are 4 hex digits.
# SCTP_CHKSUM and EXP_SCTP_CHKSUM are 8 hex digits.
test_sctp_init_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7
    local sctp_sport=$8 sctp_dport=$9 sctp_init_tag=${10} sctp_chksum=${11}
    local exp_ip_chksum=${12} exp_sctp_abort_chksum=${13}

    local ip_ttl=ff
    local eth_hdr=${eth_dst}${eth_src}0800
    local ip_hdr=4500002500004000${ip_ttl}84${ip_chksum}${ipv4_src}${ipv4_dst}
    local sctp_hdr=${sctp_sport}${sctp_dport}00000000${sctp_chksum}
    local sctp_init=01000014${sctp_init_tag}0000000000010001${sctp_init_tag}

    local packet=${eth_hdr}${ip_hdr}${sctp_hdr}${sctp_init}

    local sctp_abort_ttl=3f
    local reply_eth_hdr=${eth_src}${eth_dst}0800
    local reply_ip_hdr=4500002400004000${sctp_abort_ttl}84${exp_ip_chksum}${ipv4_dst}${ipv4_src}
    local reply_sctp_hdr=${sctp_dport}${sctp_sport}${sctp_init_tag}${exp_sctp_abort_chksum}
    local reply_sctp_abort=06000004

    local reply=${reply_eth_hdr}${reply_ip_hdr}${reply_sctp_hdr}${reply_sctp_abort}
    echo $reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# Create hypervisors hv[123].
# Add vif1[123] to hv1, vif2[123] to hv2, vif3[123] to hv3.
# Add all of the vifs to a single logical switch sw0.

net_add n1
check ovn-nbctl ls-add sw0
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2 3; do
        ovn-nbctl lsp-add sw0 sw0-p$i$j -- \
                lsp-set-addresses sw0-p$i$j "00:00:00:00:00:$i$j 192.168.1.$i$j"

        check ovs-vsctl -- add-port br-int vif$i$j -- \
                set interface vif$i$j \
                external-ids:iface-id=sw0-p$i$j \
                options:tx_pcap=hv$i/vif$i$j-tx.pcap \
                options:rxq_pcap=hv$i/vif$i$j-rx.pcap \
                ofport-request=$i$j
    done
done

OVN_POPULATE_ARP

for i in 1 2 3; do
    : > vif${i}1.expected
done

check ovn-nbctl --log acl-add sw0 to-lport 1000 "outport == \"sw0-p12\"" reject
check ovn-nbctl --log acl-add sw0 from-lport 1000 "inport == \"sw0-p11\"" reject
check ovn-nbctl --log acl-add sw0 from-lport 1000 "inport == \"sw0-p21\"" reject

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

test_ip_packet 11 1 000000000011 000000000021 $(ip_to_hex 192 168 1 11) $(ip_to_hex 192 168 1 21) 0000 f85b f576
test_ip_packet 21 2 000000000021 000000000011 $(ip_to_hex 192 168 1 21) $(ip_to_hex 192 168 1 11) 0000 f85b f576
test_ip_packet 31 3 000000000031 000000000012 $(ip_to_hex 192 168 1 31) $(ip_to_hex 192 168 1 12) 0000 f850 f56b

test_ipv6_packet 11 1 000000000011 000000000021 fe80000000000000020001fffe000001 fe80000000000000020001fffe000002 617b

test_tcp_syn_packet 11 1 000000000011 000000000021 $(ip_to_hex 192 168 1 11) $(ip_to_hex 192 168 1 21) 0000 8b40 3039 0000 b85f 70e4
test_tcp_syn_packet 21 2 000000000021 000000000011 $(ip_to_hex 192 168 1 21) $(ip_to_hex 192 168 1 11) 0000 8b40 3039 0000 b85f 70e4
test_tcp_syn_packet 31 3 000000000031 000000000012 $(ip_to_hex 192 168 1 31) $(ip_to_hex 192 168 1 12) 0000 8b40 3039 0000 b854 70d9

test_sctp_init_packet 11 1 000000000011 000000000021 $(ip_to_hex 192 168 1 11) $(ip_to_hex 192 168 1 21) 0000 8b40 3039 00000001 82112601 b7e5 10fe95b6
test_sctp_init_packet 21 2 000000000021 000000000011 $(ip_to_hex 192 168 1 21) $(ip_to_hex 192 168 1 11) 0000 8b40 3039 00000002 C0379D5A b7e5 39f23aaf
test_sctp_init_packet 31 3 000000000031 000000000012 $(ip_to_hex 192 168 1 31) $(ip_to_hex 192 168 1 12) 0000 8b40 3039 00000003 028E263C b7da 7124045b

for i in 1 2 3; do
    OVN_CHECK_PACKETS([hv$i/vif${i}1-tx.pcap], [vif${i}1.expected])
done

OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL Reject ping pong])
AT_KEYWORDS([ACL Reject ping pong])
ovn_start

send_icmp6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6

    local ip6_hdr=6000000000083aff${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}8000dcb662f00001

    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $packet
}

send_icmp_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7 data=$8
    shift 8

    local ip_ttl=ff
    local ip_len=001c
    local packet=${eth_dst}${eth_src}08004500${ip_len}00004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}${data}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $packet
}

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3 1000::3"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4 1000::4"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4 1000::4"

check ovn-nbctl acl-add sw0 to-lport 1002 ip reject

OVN_POPULATE_ARP

wait_for_ports_up
ovn-nbctl --wait=hv sync

# Wait for pinctrl thread to be connected
OVS_WAIT_UNTIL([grep pinctrl hv1/ovn-controller.log | grep -c connected])
OVS_WAIT_UNTIL([grep pinctrl hv2/ovn-controller.log | grep -c connected])

ovn-sbctl dump-flows sw0 > sw0-flows
AT_CAPTURE_FILE([sw0-flows])

AT_CHECK([grep -E 'ls_out_acl' sw0-flows | grep reject | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
])


eth_src=505400000003
eth_dst=505400000004
ip_src=$(ip_to_hex 10 0 0 3)
ip_dst=$(ip_to_hex 10 0 0 4)
ipv6_src=10000000000000000000000000000003
ipv6_dst=10000000000000000000000000000004

send_icmp_packet 1 1 $eth_src $eth_dst $ip_src $ip_dst c4c9 0000000000000000000000
send_icmp6_packet 1 1 $eth_src $eth_dst $ipv6_src $ipv6_dst

# Get total number of ipv4 packets that received on ovs

# sender side
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int table=46 | grep priority=2002 | grep ip,metadata=0x1 | grep -c n_packets=1`])

# receiver side
OVS_WAIT_UNTIL([test 1 = `as hv2 ovs-ofctl dump-flows br-int table=46 | grep priority=2002 | grep ip,metadata=0x1 | grep -c n_packets=1`])

# Get total number of ipv6 packets that received on ovs

# sender side
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int table=46 | grep priority=2002 | grep ipv6,metadata=0x1 | grep -c n_packets=1`])

# receiver side
OVS_WAIT_UNTIL([test 1 = `as hv2 ovs-ofctl dump-flows br-int table=46 | grep priority=2002 | grep ipv6,metadata=0x1 | grep -c n_packets=1`])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Mirror - remote])
AT_KEYWORDS([Mirror])
ovn_start

# Logical network:
# One LR - R1 has switch ls1 (191.168.1.0/24) connected to it,
# and has switch ls2 (172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:f1 192.168.1.1/24
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 \
    type=router options:router-port=ls1 addresses=\"00:00:00:01:02:f1\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 00:00:00:01:02:f2 172.16.1.1/24
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 \
    type=router options:router-port=ls2 addresses=\"00:00:00:01:02:f2\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "00:00:00:01:02:03 192.168.1.2"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "00:00:00:01:02:04 172.16.1.2"

ovn-nbctl lsp-add ls1 ln-public
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-options ln-public network_name=public

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys -- set bridge br-phys other-config:hwaddr=\"00:00:00:01:02:00\"
ovn_attach n1 br-phys 192.168.1.11

ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1

ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-phys

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync
ovn-nbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

for i in 1 2; do
    : > vif$i.expected
done

net_add n2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys -- set bridge br-phys other-config:hwaddr=\"00:00:00:02:02:00\"
ovn_attach n2 br-phys 192.168.1.12

OVN_POPULATE_ARP

as hv1

# test_ipv4_icmp_request INPORT ETH_SRC ETH_DST IPV4_SRC IPV4_DST IP_CHKSUM ICMP_CHKSUM [EXP_IP_CHKSUM EXP_ICMP_CHKSUM] ENCAP_TYPE FILTER
#
# Causes a packet to be received on INPORT.  The packet is an ICMPv4
# request with ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHSUM and
# ICMP_CHKSUM as specified.  If EXP_IP_CHKSUM and EXP_ICMP_CHKSUM are
# provided, then it should be the ip and icmp checksums of the packet
# responded; otherwise, no reply is expected.
# In the absence of an ip checksum calculation helpers, this relies
# on the caller to provide the checksums for the ip and icmp headers.
# XXX This should be more systematic.
#
# INPORT is an lport number, e.g. 11 for vif11.
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_DST are each 8 hex digits.
# IP_CHSUM and ICMP_CHKSUM are each 4 hex digits.
# EXP_IP_CHSUM and EXP_ICMP_CHKSUM are each 4 hex digits.
# ENCAP_TYPE - gre or erspan
# FILTER - Mirror Filter - to-lport / from-lport
test_ipv4_icmp_request() {
    local inport=$1 eth_src=$2 eth_dst=$3 ipv4_src=$4 ipv4_dst=$5 ip_chksum=$6 icmp_chksum=$7
    local exp_ip_chksum=$8 exp_icmp_chksum=$9 mirror_encap_type=${10} mirror_filter=${11}
    shift; shift; shift; shift; shift; shift; shift
    shift; shift; shift; shift;

    # Use ttl to exercise section 4.2.2.9 of RFC1812
    local ip_ttl=02
    local icmp_id=5fbf
    local icmp_seq=0001
    local icmp_data=$(seq 1 56 | xargs printf "%02x")
    local icmp_type_code_request=0800
    local icmp_payload=${icmp_type_code_request}${icmp_chksum}${icmp_id}${icmp_seq}${icmp_data}
    local packet=${eth_dst}${eth_src}08004500005400004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}${icmp_payload}

    as hv1 ovs-appctl netdev-dummy/receive vif$inport $packet

    # Expect to receive the reply, if any. In same port where packet was sent.
    # Note: src and dst fields are expected to be reversed.
    local icmp_type_code_response=0000
    local reply_icmp_ttl=fe
    local reply_icmp_payload=${icmp_type_code_response}${exp_icmp_chksum}${icmp_id}${icmp_seq}${icmp_data}
    local reply=${eth_src}${eth_dst}08004500005400004000${reply_icmp_ttl}01${exp_ip_chksum}${ipv4_dst}${ipv4_src}${reply_icmp_payload}
    echo $reply >> vif$inport.expected
    local remote_mac=000000020200
    local local_mac=000000010200
    if test ${mirror_encap_type} = "gre" ; then
        local ipv4_gre=4500007e00004000402fb6e9c0a8010bc0a8010c2000655800000000
        if test ${mirror_filter} = "to-lport" ; then
            local mirror=${remote_mac}${local_mac}0800${ipv4_gre}${reply}
        elif test ${mirror_filter} = "from-lport" ; then
            local mirror=${remote_mac}${local_mac}0800${ipv4_gre}${packet}
        fi
    elif test ${mirror_encap_type} = "erspan" ; then
        local ipv4_erspan=4500008600004000402fb6e1c0a8010bc0a8010c
        local erspan_seq0=100088be000000001000000000000000
        local erspan_seq1=100088be000000011000000000000000
        if test ${mirror_filter} = "to-lport" ; then
            local mirror=${remote_mac}${local_mac}0800${ipv4_erspan}${erspan_seq0}${reply}
        elif test ${mirror_filter} = "from-lport" ; then
            local mirror=${remote_mac}${local_mac}0800${ipv4_erspan}${erspan_seq1}${packet}
        fi
    fi
    echo $mirror >> br-phys_n1.expected

}

# Set IPs
rtr_l2_ip=$(ip_to_hex 172 16 1 1)
l1_ip=$(ip_to_hex 192 168 1 2)

check ovn-nbctl mirror-add mirror0 gre 0 to-lport 192.168.1.12
check ovn-nbctl --wait=hv lsp-attach-mirror ls1-lp1 mirror0

# Send ping packet and check for mirrored packet of the reply
test_ipv4_icmp_request 1 000000010203 0000000102f1 $l1_ip $rtr_l2_ip 0000 8510 03ff 8d10 "gre" "to-lport"

OVN_CHECK_PACKETS_CONTAIN([hv1/br-phys_n1-tx.pcap], [br-phys_n1.expected])
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [vif1.expected])

as hv1 reset_pcap_file vif1 hv1/vif1
as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
rm -f br-phys_n1.expected
rm -f vif1.expected

check ovn-nbctl --wait=hv set mirror . type=erspan
# Wait for port to get updated
OVS_WAIT_UNTIL([test 1 = `ovs-appctl dpif/show | grep ovn-mirror | grep -c erspan`])

# Send ping packet and check for mirrored packet of the reply
test_ipv4_icmp_request 1 000000010203 0000000102f1 $l1_ip $rtr_l2_ip 0000 8510 03ff 8d10 "erspan" "to-lport"

OVN_CHECK_PACKETS_CONTAIN([hv1/br-phys_n1-tx.pcap], [br-phys_n1.expected])
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [vif1.expected])

as hv1 reset_pcap_file vif1 hv1/vif1
as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
rm -f br-phys_n1.expected
rm -f vif1.expected

check ovn-nbctl --wait=hv set mirror . filter=from-lport

# First make sure conf.db got updated
vif1=$(ovs-vsctl get Port vif1 _uuid)
OVS_WAIT_UNTIL([test `ovs-vsctl get mirror mirror0 select_src_port | tr -d "[[]]"` = $vif1])
# Then make sure ovs-vswitchd got opportunity to run : run some random ovs-apctl command twice, so
# mirror_run could run
ovs-appctl dpif/show
ovs-appctl dpif/show

# Send ping packet and check for mirrored packet of the request
test_ipv4_icmp_request 1 000000010203 0000000102f1 $l1_ip $rtr_l2_ip 0000 8510 03ff 8d10 "erspan" "from-lport"

OVN_CHECK_PACKETS_CONTAIN([hv1/br-phys_n1-tx.pcap], [br-phys_n1.expected])
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [vif1.expected])

as hv1 reset_pcap_file vif1 hv1/vif1
as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
rm -f br-phys_n1.expected
rm -f vif1.expected

check ovn-nbctl --wait=hv set mirror . type=gre
# Wait for port to get updated
OVS_WAIT_UNTIL([test 1 = `ovs-appctl dpif/show | grep ovn-mirror | grep -c gre`])

# Send ping packet and check for mirrored packet of the request
test_ipv4_icmp_request 1 000000010203 0000000102f1 $l1_ip $rtr_l2_ip 0000 8510 03ff 8d10 "gre" "from-lport"

OVN_CHECK_PACKETS_CONTAIN([hv1/br-phys_n1-tx.pcap], [br-phys_n1.expected])
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [vif1.expected])

echo "---------OVN NB Mirror-----"
ovn-nbctl mirror-list

echo "---------OVS Mirror----"
ovs-vsctl list Mirror

echo "-----------------------"

echo "Verifying Mirror deletion in OVS"
# Set vif1 iface-id such that OVN releases port binding
check ovs-vsctl set interface vif1 external_ids:iface-id=foo
check ovn-nbctl --wait=hv sync

AT_CHECK([as hv1 ovs-vsctl list Mirror], [0], [dnl
])

# Set vif1 iface-id back to ls1-lp1
check ovs-vsctl set interface vif1 external_ids:iface-id=ls1-lp1
check ovn-nbctl --wait=hv sync

OVS_WAIT_UNTIL([test $(as hv1 ovs-vsctl get Mirror mirror0 name) = "mirror0"])

# Delete vif1 so that OVN releases port binding
check ovs-vsctl del-port br-int vif1
check ovn-nbctl --wait=hv sync

OVS_WAIT_UNTIL([test 0 = $(as hv1 ovs-vsctl list Mirror | wc -l)])

# Create the vif1 again, and mirror should be recreated.
ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1
OVS_WAIT_UNTIL([test $(as hv1 ovs-vsctl get Mirror mirror0 name) = "mirror0"])

# Delete the mirror port, should recreate.
check ovs-vsctl del-port ovn-mirror0
OVS_WAIT_UNTIL([ovs-vsctl list port ovn-mirror0 | grep ovn-mirror0])

# Delete the mirror port and vif1 at the same time, mirror should be deleted
# properly (without crash)
ovs-vsctl del-port ovn-mirror0 -- del-port vif1
OVS_WAIT_UNTIL([test 0 = $(as hv1 ovs-vsctl list Mirror | wc -l)])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Mirror - local])
AT_KEYWORDS([Mirror])
ovn_start

ovn-nbctl ls-add ls1
# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "00:00:00:01:01:02 10.0.0.2"
ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "00:00:00:01:01:03 10.0.0.3"

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys -- set bridge br-phys other-config:hwaddr=\"00:00:00:01:02:00\"
ovn_attach n1 br-phys 192.168.1.11
ovn-appctl -t ovn-controller vlog/set file:dbg

ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

# Add two ports as mirroring target
ovs-vsctl -- add-port br-int mirror1 -- \
    set interface mirror1 external-ids:mirror-id=sink1 \
    options:tx_pcap=hv1/mirror1-tx.pcap \
    options:rxq_pcap=hv1/mirror1-rx.pcap \
    ofport-request=3
ovs-vsctl -- add-port br-int mirror2 -- \
    set interface mirror2 external-ids:mirror-id=sink2 \
    options:tx_pcap=hv1/mirror2-tx.pcap \
    options:rxq_pcap=hv1/mirror2-rx.pcap \
    ofport-request=4

# Create a NB mirror use DB 'create' command.
uuid1=$(ovn-nbctl create mirror name=mirror-from-lp1 type=local sink=sink1 filter=from-lport)
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror-from-lp1

# Create another NB mirror use 'mirror-add' command.
check ovn-nbctl mirror-add mirror-to-lp2 local to-lport sink2
check ovn-nbctl lsp-attach-mirror ls1-lp2 mirror-to-lp2

wait_for_ports_up
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-vsctl --data=bare --no-heading --columns=name list mirror | grep mirror | sort], [0], [dnl
mirror-from-lp1
mirror-to-lp2
])

# Update to wrong mirror-id, the mirror should be deleted.
check ovn-nbctl set mirror $uuid1 sink=xxx
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-vsctl --data=bare --no-heading --columns=name list mirror | grep mirror | sort], [0], [dnl
mirror-to-lp2
])

# Change back, and the mirror should be created back
check ovn-nbctl set mirror $uuid1 sink=sink1
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-vsctl --data=bare --no-heading --columns=name list mirror | grep mirror | sort], [0], [dnl
mirror-from-lp1
mirror-to-lp2
])

# Send a packet from lp1 to lp2, should be mirrored to both mirror ports.
packet="inport==\"ls1-lp1\" && eth.src==00:00:00:01:01:02 && eth.dst==00:00:00:01:01:03 &&
        ip4 && ip.ttl==64 && ip4.src==10.0.0.2 && ip4.dst==10.0.0.3 && icmp"
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

exp_packet="eth.src==00:00:00:01:01:02 && eth.dst==00:00:00:01:01:03 && ip4 &&
            ip.ttl==64 && ip4.src==10.0.0.2 && ip4.dst==10.0.0.3 && icmp"
echo $exp_packet | ovstest test-ovn expr-to-packets | sort > expout

OVS_WAIT_UNTIL([
    rcv_mirror1=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/mirror1-tx.pcap > mirror1.packets && cat mirror1.packets | wc -l`
    rcv_mirror2=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/mirror2-tx.pcap > mirror2.packets && cat mirror2.packets | wc -l`
    echo $rcv_mirror1 $rcv_mirror2
    test $rcv_mirror1 -eq 1 -a $rcv_mirror2 -eq 1])

AT_CHECK([cat mirror1.packets | sort], [0], [expout])
AT_CHECK([cat mirror2.packets | sort], [0], [expout])

port_src_old=$(ovs-vsctl get mirror mirror-from-lp1 select_src_port)
check ovn-nbctl --wait=hv set mirror $uuid1 filter=both
port_src_new=$(ovs-vsctl get mirror mirror-from-lp1 select_src_port)
port_dst_new=$(ovs-vsctl get mirror mirror-from-lp1 select_dst_port)
AT_CHECK([test $port_src_old = $port_src_new], [0], [])
AT_CHECK([test $port_src_old = $port_dst_new], [0], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Mirror test bulk updates])
AT_KEYWORDS([Mirror test bulk updates])
ovn_start

# Logical network:
# One LR - R1 has switch ls1 (191.168.1.0/24) connected to it,
# and has switch ls2 (172.16.1.0/24) connected to it.

ovn-nbctl lr-add R1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 00:00:00:01:02:f1 192.168.1.1/24
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 \
    type=router options:router-port=ls1 addresses=\"00:00:00:01:02:f1\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 00:00:00:01:02:f2 172.16.1.1/24
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 \
    type=router options:router-port=ls2 addresses=\"00:00:00:01:02:f2\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "00:00:00:01:02:03 192.168.1.2"

# Create logical port ls1-lp2 in ls1
ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "00:00:00:01:03:03 192.168.1.3"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "00:00:00:01:02:04 172.16.1.2"

# Create logical port ls2-lp2 in ls2
ovn-nbctl lsp-add ls2 ls2-lp2 \
-- lsp-set-addresses ls2-lp2 "00:00:00:01:03:04 172.16.1.3"

ovn-nbctl lsp-add ls1 ln-public
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-options ln-public network_name=public

# Create 2 hypervisors and create OVS ports corresponding to logical ports for hv1.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys -- set bridge br-phys other-config:hwaddr=\"00:00:00:01:02:00\"
ovn_attach n1 br-phys 192.168.1.11

net_add n2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys -- set bridge br-phys other-config:hwaddr=\"00:00:00:02:02:00\"
ovn_attach n2 br-phys 192.168.1.12

OVN_POPULATE_ARP

as hv1

ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1

ovs-vsctl -- add-port br-int vif3 -- \
    set interface vif3 external-ids:iface-id=ls1-lp2

ovs-vsctl -- add-port br-int vif4 -- \
    set interface vif4 external-ids:iface-id=ls2-lp2

ovs-vsctl set open . external-ids:ovn-bridge-mappings=public:br-phys

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync
ovn-nbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

check ovn-nbctl mirror-add mirror0 gre 0 to-lport 192.168.1.12
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror0
check ovn-nbctl --wait=hv sync
origA=$(ovs-vsctl get Mirror mirror0 select_dst_port)
check ovn-nbctl lsp-attach-mirror ls2-lp1 mirror0

check ovn-nbctl mirror-add mirror1 gre 1 to-lport 192.168.1.12
check ovn-nbctl lsp-attach-mirror ls1-lp2 mirror1
check ovn-nbctl --wait=hv sync
origB=$(ovs-vsctl get Mirror mirror1 select_dst_port)
check ovn-nbctl lsp-attach-mirror ls2-lp2 mirror1

check ovn-nbctl --wait=hv sync

as hv1
orig1=$(ovs-vsctl get Mirror mirror0 select_dst_port)
orig2=$(ovs-vsctl get Mirror mirror1 select_dst_port)

check ovn-nbctl mirror-del
check ovn-nbctl --wait=hv sync

check ovn-nbctl mirror-add mirror0 gre 0 to-lport 192.168.1.12
check ovn-nbctl mirror-add mirror1 gre 1 to-lport 192.168.1.12

# Attaches multiple mirrors

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-attach-mirror ls2-lp1 mirror0
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror0
check ovn-nbctl lsp-attach-mirror ls2-lp2 mirror1
check ovn-nbctl lsp-attach-mirror ls1-lp2 mirror1
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync

as hv1
new1=$(ovs-vsctl get Mirror mirror0 select_dst_port)
new2=$(ovs-vsctl get Mirror mirror1 select_dst_port)

AT_CHECK([test "$orig1" = "$new1"], [0], [])

AT_CHECK([test "$orig2" = "$new2"], [0], [])

# Equal detaches and attaches
check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-detach-mirror ls1-lp1 mirror0
check ovn-nbctl lsp-detach-mirror ls2-lp1 mirror0
check ovn-nbctl lsp-attach-mirror ls1-lp2 mirror0
check ovn-nbctl lsp-attach-mirror ls2-lp2 mirror0

check ovn-nbctl lsp-detach-mirror ls1-lp2 mirror1
check ovn-nbctl lsp-detach-mirror ls2-lp2 mirror1
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror1
check ovn-nbctl lsp-attach-mirror ls2-lp1 mirror1
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync

# Make sure that ovn-controller has not asserted.
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])

as hv1
new1=$(ovs-vsctl get Mirror mirror0 select_dst_port)
new2=$(ovs-vsctl get Mirror mirror1 select_dst_port)

AT_CHECK([test "$orig1" = "$new2"], [0], [])

AT_CHECK([test "$orig2" = "$new1"], [0], [])

# Detaches more than attaches
check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-detach-mirror ls1-lp1 mirror1
check ovn-nbctl lsp-detach-mirror ls2-lp1 mirror1
check ovn-nbctl lsp-detach-mirror ls1-lp2 mirror0
check ovn-nbctl lsp-detach-mirror ls2-lp2 mirror0
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror0
check ovn-nbctl lsp-attach-mirror ls1-lp2 mirror1
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync
# Make sure that ovn-controller has not asserted.
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])

as hv1
new1=$(ovs-vsctl get Mirror mirror0 select_dst_port)
new2=$(ovs-vsctl get Mirror mirror1 select_dst_port)

AT_CHECK([test "$origA" = "$new1"], [0], [])

AT_CHECK([test "$origB" = "$new2"], [0], [])

# Attaches more than detaches
check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-detach-mirror ls1-lp1 mirror0
check ovn-nbctl lsp-detach-mirror ls1-lp2 mirror1
check ovn-nbctl lsp-attach-mirror ls1-lp2 mirror0
check ovn-nbctl lsp-attach-mirror ls2-lp2 mirror0
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror1
check ovn-nbctl lsp-attach-mirror ls2-lp1 mirror1
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync
# Make sure that ovn-controller has not asserted.
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])

as hv1
new1=$(ovs-vsctl get Mirror mirror0 select_dst_port)
new2=$(ovs-vsctl get Mirror mirror1 select_dst_port)

AT_CHECK([test "$orig1" = "$new2"], [0], [])

AT_CHECK([test "$orig2" = "$new1"], [0], [])

# Detaches all
check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-detach-mirror ls1-lp2 mirror0
check ovn-nbctl lsp-detach-mirror ls2-lp2 mirror0
check ovn-nbctl lsp-detach-mirror ls1-lp1 mirror1
check ovn-nbctl lsp-detach-mirror ls2-lp1 mirror1
check as hv1 ovn-appctl -t ovn-controller debug/resume
check ovn-nbctl --wait=hv sync

OVS_WAIT_UNTIL([test 0 = $(as hv1 ovs-vsctl list Mirror | wc -l)])

check ovn-nbctl mirror-add mirror2 gre 2 to-lport 192.168.1.12
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror2
check ovn-nbctl --wait=hv sync

# Attaches SAME port to multiple mirrors
# and detaches it from existing mirror.
# More attach than detach

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror0
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror1
check ovn-nbctl lsp-detach-mirror ls1-lp1 mirror2
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync

as hv1
new1=$(ovs-vsctl get Mirror mirror0 select_dst_port)
new2=$(ovs-vsctl get Mirror mirror1 select_dst_port)

AT_CHECK([test "$origA" = "$new1"], [0], [])
AT_CHECK([test "$origA" = "$new2"], [0], [])
OVS_WAIT_UNTIL([test 0 = $(as hv1 ovs-vsctl list Mirror mirror2 | wc -l)])

check ovn-nbctl mirror-add mirror3 gre 3 to-lport 192.168.1.12
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror3
check ovn-nbctl --wait=hv sync

# Detaches SAME port from multiple mirrors
# and attaches it to existing mirror.
# More detach than attach

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-detach-mirror ls1-lp1 mirror0
check ovn-nbctl lsp-detach-mirror ls1-lp1 mirror3
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror2
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync

as hv1
new1=$(ovs-vsctl get Mirror mirror1 select_dst_port)
new2=$(ovs-vsctl get Mirror mirror2 select_dst_port)

AT_CHECK([test "$origA" = "$new1"], [0], [])
AT_CHECK([test "$origA" = "$new2"], [0], [])
OVS_WAIT_UNTIL([test 0 = $(as hv1 ovs-vsctl list Mirror mirror0 | wc -l)])
OVS_WAIT_UNTIL([test 0 = $(as hv1 ovs-vsctl list Mirror mirror3 | wc -l)])

check ovn-nbctl mirror-del
check ovn-nbctl --wait=hv sync
check ovn-nbctl mirror-add mirror0 erspan 0 to-lport 192.168.1.12
check ovn-nbctl lsp-attach-mirror ls1-lp1 mirror0
check ovn-nbctl --wait=hv sync

# Make sure different fields of mirror resource set from OVN
# propagates to OVS correctly

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl set mirror . filter=from-lport
check ovn-nbctl set mirror . type=gre
check ovn-nbctl set mirror . index=123
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync

as hv1
new1=$(ovs-vsctl get Mirror mirror0 select_src_port)
AT_CHECK([test "$origA" = "$new1"], [0], [])
type=$(ovs-vsctl get Interface ovn-mirror0 type)
OVS_WAIT_UNTIL([test "gre" = "$type"])
index=$(ovs-vsctl get Interface ovn-mirror0 options:key | grep 123 | wc -l)
OVS_WAIT_UNTIL([test "1" = "$index"])

# pause ovn-controller and delete the mirror and make sure that
# ovn-controller deletes the ovs mirror when it is resumed.

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl --wait=sb mirror-del
check as hv1 ovn-appctl -t ovn-controller debug/resume
check ovn-nbctl --wait=hv sync

AT_CHECK([as hv1 ovs-vsctl list mirror], [0], [])

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Port Groups])
AT_KEYWORDS([ovnpg])
AT_KEYWORDS([slowtest])
ovn_start

# Logical network:
#
# Three logical switches ls1, ls2, ls3.
# One logical router lr0 connected to ls[123],
# with nine subnets, three per logical switch:
#
#    lrp11 on ls1 for subnet 192.168.11.0/24
#    lrp12 on ls1 for subnet 192.168.12.0/24
#    lrp13 on ls1 for subnet 192.168.13.0/24
#    ...
#    lrp33 on ls3 for subnet 192.168.33.0/24
#
# 27 VIFs, 9 per LS, 3 per subnet: lp[123][123][123], where the first two
# digits are the subnet and the last digit distinguishes the VIF.
#
# This test will create two port groups and uses them in ACL.

get_lsp_uuid () {
    ovn-nbctl lsp-list ls${1%??} | grep lp$1 | awk '{ print $1 }'
}

pg1_ports=
pg2_ports=
for i in 1 2 3; do
    ovn-nbctl ls-add ls$i
    for j in 1 2 3; do
        for k in 1 2 3; do
            ovn-nbctl \
                -- lsp-add ls$i lp$i$j$k \
                -- lsp-set-addresses lp$i$j$k \
                   "f0:00:00:00:0$i:$j$k 192.168.$i$j.$k"
            # logical ports lp[12]?1 belongs to port group pg1
            if test $i != 3 && test $k = 1; then
                pg1_ports="$pg1_ports `get_lsp_uuid $i$j$k`"
            fi
            # logical ports lp[23]?2 belongs to port group pg2
            if test $i != 1 && test $k = 2; then
                pg2_ports="$pg2_ports `get_lsp_uuid $i$j$k`"
            fi
        done
    done
done

ovn-nbctl lr-add lr0
for i in 1 2 3; do
    for j in 1 2 3; do
        ovn-nbctl lrp-add lr0 lrp$i$j 00:00:00:00:ff:$i$j 192.168.$i$j.254/24
        ovn-nbctl \
            -- lsp-add ls$i lrp$i$j-attachment \
            -- set Logical_Switch_Port lrp$i$j-attachment type=router \
                             options:router-port=lrp$i$j \
                             addresses='"00:00:00:00:ff:'$i$j'"'
    done
done

ovn-nbctl create Port_Group name=pg1 ports="$pg1_ports"
ovn-nbctl create Port_Group name=pg2 ports="$pg2_ports"

# create ACLs on ls1 and ls2 (where ports of pg1 reside) to drop all traffic
# from pg2 to pg1
ovn-nbctl acl-add ls1 to-lport 1001 'outport == @pg1 && ip4.src == $pg2_ip4' drop
ovn-nbctl acl-add ls2 to-lport 1001 'outport == @pg1 && ip4.src == $pg2_ip4' drop

# Physical network:
#
# Three hypervisors hv[123].
# lp?1[123] spread across hv[123]: lp?11 on hv1, lp?12 on hv2, lp?13 on hv3.
# lp?2[123] spread across hv[23]: lp?21 and lp?22 on hv2, lp?23 on hv3.
# lp?3[123] all on hv3.

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    case $1 in dnl (
        ?11) echo 1 ;; dnl (
        ?12 | ?21 | ?22) echo 2 ;; dnl (
        ?13 | ?23 | ?3?) echo 3 ;;
    esac
}

# Given the name of a logical port, prints the name of its logical router
# port, e.g. "vif_to_lrp 123" yields 12.
vif_to_lrp() {
    echo ${1%?}
}

# Given the name of a logical port, prints the name of its logical
# switch, e.g. "vif_to_ls 123" yields 1.
vif_to_ls() {
    echo ${1%??}
}

net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            hv=`vif_to_hv $i$j$k`
                as hv$hv ovs-vsctl \
                -- add-port br-int vif$i$j$k \
                -- set Interface vif$i$j$k \
                    external-ids:iface-id=lp$i$j$k \
                    options:tx_pcap=hv$hv/vif$i$j$k-tx.pcap \
                    options:rxq_pcap=hv$hv/vif$i$j$k-rx.pcap \
                    ofport-request=$i$j$k
        done
    done
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 123 for vif123.
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            : > $i$j$k.expected
        done
    done
done
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    hv=hv`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive vif$inport $packet
    in_ls=`vif_to_ls $inport`
    in_lrp=`vif_to_lrp $inport`
    for outport; do
        out_ls=`vif_to_ls $outport`
        if test $in_ls = $out_ls; then
            # Ports on the same logical switch receive exactly the same packet.
            echo $packet
        else
            # Routing decrements TTL and updates source and dest MAC
            # (and checksum).
            out_lrp=`vif_to_lrp $outport`
            echo f00000000${outport}00000000ff${out_lrp}08004500001c00000000"3f1101"00${src_ip}${dst_ip}0035111100080000
        fi >> $outport.expected
    done
}

as hv1 ovs-vsctl --columns=name,ofport list interface
as hv1 ovn-sbctl list port_binding
as hv1 ovn-sbctl list datapath_binding
as hv1 ovn-sbctl list port_group
as hv1 ovn-sbctl list address_set
as hv1 ovn-sbctl dump-flows
as hv1 ovs-ofctl dump-flows br-int

# Send IP packets between all pairs of source and destination ports,
# packets matches ACL (pg2 to pg1) should be dropped
for is in 1 2 3; do
  for js in 1 2 3; do
    for ks in 1 2 3; do
      bcast=
      s=$is$js$ks
      smac=f00000000$s
      sip=`ip_to_hex 192 168 $is$js $ks`
      for id in 1 2 3; do
          for jd in 1 2 3; do
              for kd in 1 2 3; do
                d=$id$jd$kd
                dip=`ip_to_hex 192 168 $id$jd $kd`
                if test $is = $id; then dmac=f00000000$d; else dmac=00000000ff$is$js; fi
                if test $d != $s; then unicast=$d; else unicast=; fi

                # packets matches ACL should be dropped
                if test $id != 3 && test $kd = 1; then
                    if test $is != 1 && test $ks = 2; then
                        unicast=
                    fi
                fi
                test_ip $s $smac $dmac $sip $dip $unicast #1
              done
          done
        done
      done
  done
done

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            OVN_CHECK_PACKETS([hv`vif_to_hv $i$j$k`/vif$i$j$k-tx.pcap],
                              [$i$j$k.expected])
        done
    done
done

# Gracefully terminate daemons
OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACLs on Port Groups])
AT_KEYWORDS([ovnpg_acl])
AT_KEYWORDS([slowtest])
ovn_start

# Logical network:
#
# Three logical switches ls1, ls2, ls3.
# One logical router lr0 connected to ls[123],
# with nine subnets, three per logical switch:
#
#    lrp11 on ls1 for subnet 192.168.11.0/24
#    lrp12 on ls1 for subnet 192.168.12.0/24
#    lrp13 on ls1 for subnet 192.168.13.0/24
#    ...
#    lrp33 on ls3 for subnet 192.168.33.0/24
#
# 27 VIFs, 9 per LS, 3 per subnet: lp[123][123][123], where the first two
# digits are the subnet and the last digit distinguishes the VIF.
#
# This test will create two port groups and ACLs will be applied on them.

get_lsp_uuid () {
    ovn-nbctl lsp-list ls${1%??} | grep lp$1 | awk '{ print $1 }'
}

pg1_ports=
pg2_ports=
for i in 1 2 3; do
    ovn-nbctl ls-add ls$i
    for j in 1 2 3; do
        for k in 1 2 3; do
            ovn-nbctl \
                -- lsp-add ls$i lp$i$j$k \
                -- lsp-set-addresses lp$i$j$k \
                   "f0:00:00:00:0$i:$j$k 192.168.$i$j.$k"
            # logical ports lp[12]?1 belongs to port group pg1
            if test $i != 3 && test $k = 1; then
                pg1_ports="$pg1_ports `get_lsp_uuid $i$j$k`"
            fi
            # logical ports lp[23]?2 belongs to port group pg2
            if test $i != 1 && test $k = 2; then
                pg2_ports="$pg2_ports `get_lsp_uuid $i$j$k`"
            fi
        done
    done
done

ovn-nbctl lr-add lr0
for i in 1 2 3; do
    for j in 1 2 3; do
        ovn-nbctl lrp-add lr0 lrp$i$j 00:00:00:00:ff:$i$j 192.168.$i$j.254/24
        ovn-nbctl \
            -- lsp-add ls$i lrp$i$j-attachment \
            -- set Logical_Switch_Port lrp$i$j-attachment type=router \
                             options:router-port=lrp$i$j \
                             addresses='"00:00:00:00:ff:'$i$j'"'
    done
done

ovn-nbctl create Port_Group name=pg1 ports="$pg1_ports"
ovn-nbctl create Port_Group name=pg2 ports="$pg2_ports"

# create ACLs on pg1 to drop traffic from pg2 to pg1
ovn-nbctl acl-add pg1 to-lport 1001 'outport == @pg1' drop
ovn-nbctl --type=port-group acl-add pg1 to-lport 1002 \
        'outport == @pg1 && ip4.src == $pg2_ip4' allow-related

# Physical network:
#
# Three hypervisors hv[123].
# lp?1[123] spread across hv[123]: lp?11 on hv1, lp?12 on hv2, lp?13 on hv3.
# lp?2[123] spread across hv[23]: lp?21 and lp?22 on hv2, lp?23 on hv3.
# lp?3[123] all on hv3.

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    case $1 in dnl (
        ?11) echo 1 ;; dnl (
        ?12 | ?21 | ?22) echo 2 ;; dnl (
        ?13 | ?23 | ?3?) echo 3 ;;
    esac
}

# Given the name of a logical port, prints the name of its logical router
# port, e.g. "vif_to_lrp 123" yields 12.
vif_to_lrp() {
    echo ${1%?}
}

# Given the name of a logical port, prints the name of its logical
# switch, e.g. "vif_to_ls 123" yields 1.
vif_to_ls() {
    echo ${1%??}
}

net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            hv=`vif_to_hv $i$j$k`
                as hv$hv ovs-vsctl \
                -- add-port br-int vif$i$j$k \
                -- set Interface vif$i$j$k \
                    external-ids:iface-id=lp$i$j$k \
                    options:tx_pcap=hv$hv/vif$i$j$k-tx.pcap \
                    options:rxq_pcap=hv$hv/vif$i$j$k-rx.pcap \
                    ofport-request=$i$j$k
        done
    done
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

lsp_to_mac() {
    echo f0:00:00:00:0${1:0:1}:${1:1:2}
}

lrp_to_mac() {
    echo 00:00:00:00:ff:$1
}

# test_icmp INPORT SRC_MAC DST_MAC SRC_IP DST_IP ICMP_TYPE OUTPORT...
#
# This shell function causes a ICMP packet to be received on INPORT.
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 123 for vif123.
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            : > $i$j$k.expected
        done
    done
done

test_icmp() {
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 icmp_type=$6
    local packet="inport==\"lp$inport\" && eth.src==$src_mac &&
                  eth.dst==$dst_mac && ip.ttl==64 && ip4.src==$src_ip
                  && ip4.dst==$dst_ip && icmp4.type==$icmp_type &&
                  icmp4.code==0"
    shift; shift; shift; shift; shift; shift
    hv=hv`vif_to_hv $inport`
    OVS_WAIT_UNTIL([as $hv ovs-appctl -t ovn-controller inject-pkt "$packet"])
    in_ls=`vif_to_ls $inport`
    in_lrp=`vif_to_lrp $inport`
    for outport; do
        out_ls=`vif_to_ls $outport`
        if test $in_ls = $out_ls; then
            # Ports on the same logical switch receive exactly the same packet.
            echo $packet | ovstest test-ovn expr-to-packets
        else
            # Routing decrements TTL and updates source and dest MAC
            # (and checksum).
            out_lrp=`vif_to_lrp $outport`
            exp_smac=`lrp_to_mac $out_lrp`
            exp_dmac=`lsp_to_mac $outport`
            exp_packet="eth.src==$exp_smac && eth.dst==$exp_dmac &&
                ip.ttl==63 && ip4.src==$src_ip && ip4.dst==$dst_ip &&
                icmp4.type==$icmp_type && icmp4.code==0"
            echo $exp_packet | ovstest test-ovn expr-to-packets

        fi >> $outport.expected
    done
}

as hv1 ovs-vsctl --columns=name,ofport list interface
as hv1 ovn-sbctl list port_binding
as hv1 ovn-sbctl list datapath_binding
as hv1 ovn-sbctl list port_group
as hv1 ovn-sbctl list address_set
as hv1 ovn-sbctl dump-flows
as hv1 ovs-ofctl dump-flows br-int

# Send IP packets between all pairs of source and destination ports,
# packets matches ACL1 but not ACL2 should be dropped
# We use the destination as the outer loop, so we can check whether we received
# the icmp echo using 3^3 OVN_CHECK_PACKETS. Using source as the outer loop
# would require 3^6 OVN_CHECK_PACKETS, causing the test duration to increase dramatically
# (by more than a minute).
for id in 1 2 3; do
  for jd in 1 2 3; do
    for kd in 1 2 3; do
      d=$id$jd$kd
      dlsp_mac=`lsp_to_mac $d`
      dlrp_mac=`lrp_to_mac $id$jd`
      dip=192.168.$id$jd.$kd
      for is in 1 2 3; do
        for js in 1 2 3; do
          for ks in 1 2 3; do
                bcast=
                s=$is$js$ks
                slsp_mac=`lsp_to_mac $s`
                slrp_mac=`lrp_to_mac $is$js`
                sip=192.168.$is$js.$ks
                if test $is = $id; then dmac=$dlsp_mac; else dmac=$slrp_mac; fi
                if test $d != $s; then unicast=$d; else unicast=; fi

                # packets matches ACL1 but not ACL2 should be dropped
                if test $id != 3 && test $kd = 1; then
                    if test $is = 1 || test $ks != 2; then
                        unicast=
                    fi
                fi
                # icmp request (type = 8)
                test_icmp $s $slsp_mac $dmac $sip $dip 8 $unicast
              done
          done
        done
        # Make sure icmp echo are received before generating replies
        OVN_CHECK_PACKETS([hv`vif_to_hv $id$jd$kd`/vif$id$jd$kd-tx.pcap],
                          [$id$jd$kd.expected])

      for is in 1 2 3; do
        for js in 1 2 3; do
          for ks in 1 2 3; do
                bcast=
                s=$is$js$ks
                slsp_mac=`lsp_to_mac $s`
                slrp_mac=`lrp_to_mac $is$js`
                sip=192.168.$is$js.$ks
                if test $is = $id; then dmac=$dlsp_mac; else dmac=$slrp_mac; fi
                if test $d != $s; then unicast=$d; else unicast=; fi
                # packets matches ACL1 but not ACL2 should be dropped
                if test $id != 3 && test $kd = 1; then
                    if test $is = 1 || test $ks != 2; then
                        unicast=
                    fi
                fi
                # if packets are not dropped, test the return traffic (icmp echo)
                # to make sure stateful works, too.
                if test x$unicast != x; then
                    if test $is = $id; then dmac=$slsp_mac; else dmac=$dlrp_mac; fi
                    # icmp echo (type = 0)
                    test_icmp $unicast $dlsp_mac $dmac $dip $sip 0 $s
                fi
              done
          done
        done
      done
  done
done

# Now check the packets actually received against the ones expected.
for i in 1 2 3; do
    for j in 1 2 3; do
        for k in 1 2 3; do
            OVN_CHECK_PACKETS([hv`vif_to_hv $i$j$k`/vif$i$j$k-tx.pcap],
                              [$i$j$k.expected])
        done
    done
done

# Gracefully terminate daemons
OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Address Set generation from Port Groups (static addressing)])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 lp1
ovn-nbctl lsp-add ls1 lp2
ovn-nbctl lsp-add ls1 lp3

ovn-nbctl lsp-set-addresses lp1 "02:00:00:00:00:01 10.0.0.1 2001:db8::1"
ovn-nbctl lsp-set-addresses lp2 "02:00:00:00:00:02 10.0.0.2 2001:db8::2"
ovn-nbctl lsp-set-addresses lp3 "02:00:00:00:00:03 10.0.0.3 2001:db8::3"

ovn-nbctl create Port_Group name=pg1
ovn-nbctl create Port_Group name=pg2

ovn-nbctl --id=@p get Logical_Switch_Port lp1 -- add Port_Group pg1 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp2 -- add Port_Group pg1 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp2 -- add Port_Group pg2 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp3 -- add Port_Group pg2 ports @p

ovn-nbctl --wait=sb sync

dnl Check if port group address sets were populated with ports' addresses
check_column '10.0.0.1 10.0.0.2' Address_Set addresses name=pg1_ip4
check_column '10.0.0.2 10.0.0.3' Address_Set addresses name=pg2_ip4
check_column '2001:db8::1 2001:db8::2' Address_Set addresses name=pg1_ip6
check_column '2001:db8::2 2001:db8::3' Address_Set addresses name=pg2_ip6

ovn-nbctl --wait=sb lsp-set-addresses lp1 \
    "02:00:00:00:00:01 10.0.0.11 2001:db8::11"

dnl Check if updated address got propagated to the port group address sets
check_column '10.0.0.11 10.0.0.2' Address_Set addresses name=pg1_ip4
check_column '2001:db8::11 2001:db8::2' Address_Set addresses name=pg1_ip6

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Address Set generation from Port Groups (dynamic addressing)])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl ls-add ls3

ovn-nbctl set Logical_Switch ls1 \
    other_config:subnet=10.1.0.0/24 other_config:ipv6_prefix="2001:db8:1::"
ovn-nbctl set Logical_Switch ls2 \
    other_config:subnet=10.2.0.0/24 other_config:ipv6_prefix="2001:db8:2::"

# A prefix length may be specified, but only if it is /64.
ovn-nbctl set Logical_Switch ls3 \
    other_config:subnet=10.3.0.0/24 other_config:ipv6_prefix="2001:db8:3::/64"

ovn-nbctl lsp-add ls1 lp1
ovn-nbctl lsp-add ls2 lp2
ovn-nbctl lsp-add ls3 lp3

ovn-nbctl lsp-set-addresses lp1 "02:00:00:00:00:01 dynamic"
ovn-nbctl lsp-set-addresses lp2 "02:00:00:00:00:02 dynamic"
ovn-nbctl lsp-set-addresses lp3 "02:00:00:00:00:03 dynamic"

ovn-nbctl create Port_Group name=pg1
ovn-nbctl create Port_Group name=pg2

ovn-nbctl --id=@p get Logical_Switch_Port lp1 -- add Port_Group pg1 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp2 -- add Port_Group pg1 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp2 -- add Port_Group pg2 ports @p
ovn-nbctl --id=@p get Logical_Switch_Port lp3 -- add Port_Group pg2 ports @p

ovn-nbctl --wait=sb sync

dnl Check if port group address sets were populated with ports' addresses
AT_CHECK(
  [ovn-sbctl get Address_Set pg1_ip4 addresses \
          -- get Address_Set pg2_ip4 addresses \
          -- get Address_Set pg1_ip6 addresses \
          -- get Address_Set pg2_ip6 addresses],
  [0],
  [[["10.1.0.2", "10.2.0.2"]]
[["10.2.0.2", "10.3.0.2"]]
[["2001:db8:1::ff:fe00:1", "2001:db8:2::ff:fe00:2"]]
[["2001:db8:2::ff:fe00:2", "2001:db8:3::ff:fe00:3"]]
])

dnl Check if updated address got propagated to the port group address sets
ovn-nbctl --wait=sb set Logical_Switch ls1 \
    other_config:subnet=10.11.0.0/24 other_config:ipv6_prefix="2001:db8:11::"
AT_CHECK(
  [ovn-sbctl get Address_Set pg1_ip4 addresses \
          -- get Address_Set pg2_ip4 addresses \
          -- get Address_Set pg1_ip6 addresses \
          -- get Address_Set pg2_ip6 addresses],
  [0],
  [[["10.11.0.2", "10.2.0.2"]]
[["10.2.0.2", "10.3.0.2"]]
[["2001:db8:11::ff:fe00:1", "2001:db8:2::ff:fe00:2"]]
[["2001:db8:2::ff:fe00:2", "2001:db8:3::ff:fe00:3"]]
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL conjunction])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

ovn-nbctl lsp-set-port-security ls1-lp1 "f0:00:00:00:00:01 10.0.0.4"

ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02 10.0.0.6"

ovn-nbctl lsp-set-port-security ls1-lp2 "f0:00:00:00:00:02 10.0.0.6"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovn-nbctl create Address_Set name=set1 \
addresses=\"10.0.0.4\",\"10.0.0.5\",\"10.0.0.6\"
ovn-nbctl create Address_Set name=set2 \
addresses=\"10.0.0.7\",\"10.0.0.8\",\"10.0.0.9\"
ovn-nbctl acl-add ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == $set1' allow
check ovn-nbctl --wait=hv acl-add ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == $set2' drop

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes an ip packet to be received on INPORT.
# The packet's content has Ethernet destination DST and source SRC
# (each exactly 12 hex digits) and Ethernet type ETHTYPE (4 hex digits).
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 11 for vif11.
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 pcap_file=$6
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}\
${dst_ip}0035111100080000
    shift; shift; shift; shift; shift; shift
    netdev_dummy_receive hv1-vif1 $packet hv1 "$pcap_file"
    for outport; do
        echo $packet >> $outport.expected
    done
}

sip=`ip_to_hex 10 0 0 4`
dip=`ip_to_hex 10 0 0 6`

test_ip 1 f00000000001 f00000000002 $sip $dip hv1/vif2-tx.pcap 2

cat 2.expected > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [expout])

# There should be total of 9 flows present with conjunction action and 2 flows
# with conj match. Eg.
# table=44, priority=2001,conj_id=2,metadata=0x1 actions=resubmit(,45)
# table=44, priority=2001,conj_id=3,metadata=0x1 actions=drop
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.6 actions=conjunction(2,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(2,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.5 actions=conjunction(2,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.7 actions=conjunction(3,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.9 actions=conjunction(3,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.8 actions=conjunction(3,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.6 actions=conjunction(2,1/2),conjunction(3,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.4 actions=conjunction(2,1/2),conjunction(3,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.5 actions=conjunction(2,1/2),conjunction(3,1/2)

OVS_WAIT_UNTIL([test 9 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])
OVS_WAIT_UNTIL([test 3 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])
OVS_WAIT_UNTIL([test 2 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conj_id | wc -l`])

as hv1 ovs-ofctl dump-flows br-int

# Set the ip address for ls1-lp2 from set2 so that the drop ACL flow is hit.
ovn-nbctl lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02 10.0.0.7 20.0.0.4"
ovn-nbctl lsp-set-port-security ls1-lp2 "f0:00:00:00:00:02 10.0.0.7 20.0.0.4"

reset_pcap_file hv1-vif2 hv1/vif2

rm -f 2.packets

sip=`ip_to_hex 10 0 0 4`
dip=`ip_to_hex 10 0 0 7`

test_ip 1 f00000000001 f00000000002 $sip $dip

$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [])

# Remove the first ACL, and verify that the conjunction flows are updated
# properly.
# There should be total of 6 flows present with conjunction action and 1 flow
# with conj match. Eg.
# table=44, priority=2001,conj_id=3,metadata=0x1 actions=drop
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.7 actions=conjunction(4,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.9 actions=conjunction(4,2/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.8 actions=conjunction(4,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.6 actions=conjunction(4,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.4 actions=conjunction(4,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.5 actions=conjunction(4,1/2)

ovn-nbctl acl-del ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == $set1'

OVS_WAIT_UNTIL([test 6 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conj_id | wc -l`])

# Add the ACL back
ovn-nbctl acl-add ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == $set1' allow
# Add one more ACL with more overlapping
ovn-nbctl acl-add ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == {10.0.0.9, 10.0.0.10}' drop

# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.8 actions=conjunction(4,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.7 actions=conjunction(4,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(5,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.5 actions=conjunction(5,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.6 actions=conjunction(5,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.9 actions=conjunction(4,1/2),conjunction(6,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.10 actions=conjunction(6,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.5 actions=conjunction(4,2/2),conjunction(5,2/2),conjunction(6,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.4 actions=conjunction(4,2/2),conjunction(5,2/2),conjunction(6,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.6 actions=conjunction(4,2/2),conjunction(5,2/2),conjunction(6,2/2)

OVS_WAIT_UNTIL([test 10 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])
OVS_WAIT_UNTIL([test 4 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])
OVS_WAIT_UNTIL([test 3 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction.*conjunction | wc -l`])

# Remove 10.0.0.7 from address set2. All flows should be updated properly.
ovn-nbctl set Address_Set set2 \
addresses=\"10.0.0.8\",\"10.0.0.9\"

# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(9,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.10 actions=conjunction(7,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.8 actions=conjunction(8,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.5 actions=conjunction(9,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.9 actions=conjunction(7,1/2),conjunction(8,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.6 actions=conjunction(9,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.5 actions=conjunction(7,2/2),conjunction(8,2/2),conjunction(9,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.6 actions=conjunction(7,2/2),conjunction(8,2/2),conjunction(9,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.4 actions=conjunction(7,2/2),conjunction(8,2/2),conjunction(9,2/2)

OVS_WAIT_UNTIL([test 9 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])
OVS_WAIT_UNTIL([test 4 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])
OVS_WAIT_UNTIL([test 3 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction.*conjunction | wc -l`])

# Remove an ACL again
ovn-nbctl acl-del ls1 to-lport 1001 \
'ip4 && ip4.src == $set1 && ip4.dst == $set1'

wait_for_ports_up
ovn-nbctl --wait=hv sync
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.10 actions=conjunction(10,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.8 actions=conjunction(11,1/2)
# priority=2001,ip,metadata=0x1,nw_dst=10.0.0.9 actions=conjunction(10,1/2),conjunction(11,1/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.5 actions=conjunction(10,2/2),conjunction(11,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.6 actions=conjunction(10,2/2),conjunction(11,2/2)
# priority=2001,ip,metadata=0x1,nw_src=10.0.0.4 actions=conjunction(10,2/2),conjunction(11,2/2)

OVS_WAIT_UNTIL([test 6 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])
OVS_WAIT_UNTIL([test 4 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction.*conjunction | wc -l`])

# Verify that conjunction IDs are consistent between recopmutes
old_conj_ids=`as hv1 ovs-ofctl dump-flows br-int | grep conj_id= | \
              awk -F 'conj_id=' '{ print $2 }' | awk -F ',' '{ print $1 }' | sort`
echo $old_conj_ids

as hv1 ovn-appctl -t ovn-controller recompute
ovn-nbctl --wait=hv sync
new_conj_ids=`as hv1 ovs-ofctl dump-flows br-int | grep conj_id= | \
              awk -F 'conj_id=' '{ print $2 }' | awk -F ',' '{ print $1 }' | sort`
echo $new_conj_ids
AT_CHECK([test x"$old_conj_ids" = x"$new_conj_ids"])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# This test ensures that the incremental flow installation works well when
# handling update->delete->add/update for the same OVS flow.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL conjunction append and reprocess])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Setup the desired state:
# - Two ACLs, each matches its own port-group (pg1 & pg2), and matches the same
#   set of IP addresses.
# - pg1 includes p1, p2, p3
# - pg2 includes p4, p5
check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw p1 -- lsp-set-addresses p1 "00:00:00:00:00:02 192.168.0.2"
check ovn-nbctl lsp-add sw p2 -- lsp-set-addresses p2 "00:00:00:00:00:03 192.168.0.3"
check ovn-nbctl lsp-add sw p3 -- lsp-set-addresses p3 "00:00:00:00:00:04 192.168.0.4"
check ovn-nbctl lsp-add sw p4 -- lsp-set-addresses p4 "00:00:00:00:00:05 192.168.0.5"
check ovn-nbctl lsp-add sw p5 -- lsp-set-addresses p5 "00:00:00:00:00:06 192.168.0.6"
check ovn-nbctl pg-add pg1 p1 p2 p3
check ovn-nbctl pg-add pg2 p4 p5
check ovs-vsctl add-port br-int p1 -- set Interface p1 external_ids:iface-id=p1
check ovs-vsctl add-port br-int p2 -- set Interface p2 external_ids:iface-id=p2
check ovs-vsctl add-port br-int p3 -- set Interface p3 external_ids:iface-id=p3
check ovs-vsctl add-port br-int p4 -- set Interface p4 external_ids:iface-id=p4
check ovs-vsctl add-port br-int p5 -- set Interface p5 external_ids:iface-id=p5
check ovn-nbctl acl-add pg1 to-lport 1000 "outport==@pg1 && ip4 && ip4.src == {10.0.0.1, 10.0.0.2}" allow
check ovn-nbctl acl-add pg2 to-lport 1000 "outport==@pg2 && ip4 && ip4.src == {10.0.0.1, 10.0.0.2}" allow
check ovn-nbctl --wait=hv sync

# Now we should have two flows with combined conjunctions.
OVS_WAIT_UNTIL([test 2 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])


# Test the scenario 10 times to give enough chance to hit the
# "update->delete->add/update" scenario, because we can't decide the order of
# change handling inside ovn-controller.
for i in $(seq 10); do
# Unbind the p3 and p5, the combined conjunctions should be gone.
ovs-vsctl del-port br-int p3
ovs-vsctl del-port br-int p5
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])

# Delete and re-add the ACLs, just to bring some randomness in the lflow
# processing order, so that there is a chance that the order of adding and
# appending are the same before & after the flow deletion, so that the
# generated combined conjunctions are the same before & after the flow
# deletion. (If the order is different, the combined conjunctions order is
# different and the action comparison would fail, so won't trigger the tracked
# flow merging. We want to make sure that we test the merging scenario)
ovn-nbctl acl-del pg1 to-lport 1000 "outport==@pg1 && ip4 && ip4.src == {10.0.0.1, 10.0.0.2}"
ovn-nbctl acl-del pg2 to-lport 1000 "outport==@pg2 && ip4 && ip4.src == {10.0.0.1, 10.0.0.2}"
ovn-nbctl acl-add pg1 to-lport 1000 "outport==@pg1 && ip4 && ip4.src == {10.0.0.1, 10.0.0.2}" allow
ovn-nbctl acl-add pg2 to-lport 1000 "outport==@pg2 && ip4 && ip4.src == {10.0.0.1, 10.0.0.2}" allow
ovn-nbctl --wait=hv sync

# Now re-bind p3 and p5 in the same transaction, so that pg1 and pg2 update are
# handled in the same I-P engine run. The order of pg1 and pg2 can be random.
# If the order is pg2 -> pg1, then it should trigger the OVS flow
# "update->delete->add/update" scenario:
# 1) when pg2 update is handled, the ACL-2 would append conjunctions to
#    the conjunction flows of ACL-1
# 2) when pg1 update is handled, it would flood remove flows of both ACL-1 and
#    ACL-2, including the "appended" conjunction flows. And then reprocess
#    ACL-1 and ACL-2 would re-add and re-append the conjunction flows with
#    combined conjunctions.
ovs-vsctl add-port br-int p3 -- set Interface p3 external_ids:iface-id=p3 -- \
    add-port br-int p5 -- set Interface p5 external_ids:iface-id=p5
ovn-nbctl --wait=hv sync

# Now making sure we end up with two combined conjunctions.
OVS_WAIT_UNTIL([test 2 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction.*conjunction | wc -l`])

done

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Superseding ACLs with conjunction])
ovn_start

check ovn-nbctl set nb_global . options:svc_monitor_mac=66:66:66:66:66:66
check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01" \
-- set logical_switch_port ls1-lp1 options:requested-tnl-key=1

check ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02" \
-- set logical_switch_port ls1-lp1 options:requested-tnl-key=2

net_add n1
sim_add hv1

as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes an ip packet to be received on INPORT.
# The packet's content has Ethernet destination DST and source SRC
# (each exactly 12 hex digits) and Ethernet type ETHTYPE (4 hex digits).
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 11 for vif11.
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}\
${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
    ovs-appctl ofproto/trace br-int in_port=hv1-vif1 "$packet" > trace
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Add a default deny ACL and an allow ACL for specific IP traffic.
check ovn-nbctl acl-add ls1 to-lport 2 'arp' allow
check ovn-nbctl acl-add ls1 to-lport 1 'ip4' drop
check ovn-nbctl acl-add ls1 to-lport 3 '(ip4.src==10.0.0.1 || ip4.src==10.0.0.2) && (ip4.dst == 10.0.0.3 || ip4.dst == 10.0.0.4)' allow
check ovn-nbctl acl-add ls1 to-lport 3 '(ip4.src==10.0.0.1 || ip4.src==10.0.0.42) && (ip4.dst == 10.0.0.3 || ip4.dst == 10.0.0.4)' allow
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.3, 10.0.0.4 should be allowed.
for src in `seq 1 2`; do
    for dst in `seq 3 4`; do
        sip=`ip_to_hex 10 0 0 $src`
        dip=`ip_to_hex 10 0 0 $dst`

        test_ip 1 f00000000001 f00000000002 $sip $dip 2
    done
done

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.5 should be dropped.
dip=`ip_to_hex 10 0 0 5`
for src in `seq 1 2`; do
    sip=`ip_to_hex 10 0 0 $src`

    test_ip 1 f00000000001 f00000000002 $sip $dip
done

cat 2.expected > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [expout])
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 2.packets
> 2.expected

# Trigger recompute and make sure that the traffic still works as expected.
as hv1 ovn-appctl -t ovn-controller recompute

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.3, 10.0.0.4 should be allowed.
for src in `seq 1 2`; do
    for dst in `seq 3 4`; do
        sip=`ip_to_hex 10 0 0 $src`
        dip=`ip_to_hex 10 0 0 $dst`

        test_ip 1 f00000000001 f00000000002 $sip $dip 2
    done
done

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.5 should be dropped.
dip=`ip_to_hex 10 0 0 5`
for src in `seq 1 2`; do
    sip=`ip_to_hex 10 0 0 $src`

    test_ip 1 f00000000001 f00000000002 $sip $dip
done

cat 2.expected > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [expout])
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 2.packets
> 2.expected

# Add two less restrictive allow ACLs for src IP 10.0.0.1.
check ovn-nbctl acl-add ls1 to-lport 3 'ip4.src==10.0.0.1 || ip4.src==10.0.0.1' allow
check ovn-nbctl acl-add ls1 to-lport 3 'ip4.src==10.0.0.1' allow
check ovn-nbctl --wait=hv sync

# Check OVS flows, the less restrictive flows should have been installed.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=46 | ofctl_strip_all |
    grep "priority=1003" | \
    sed 's/conjunction([[^)]]*)/conjunction()/g' | \
    sed 's/conj_id=[[0-9]]*,/conj_id=xxx,/g' | sort], [0], [dnl
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.3 actions=conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.2 actions=conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.42 actions=conjunction()
])

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.3, 10.0.0.4 should be allowed.
for src in `seq 1 2`; do
    for dst in `seq 3 4`; do
        sip=`ip_to_hex 10 0 0 $src`
        dip=`ip_to_hex 10 0 0 $dst`

        test_ip 1 f00000000001 f00000000002 $sip $dip 2
    done
done

# Traffic 10.0.0.2 -> 10.0.0.5 should be dropped.
sip=`ip_to_hex 10 0 0 2`
dip=`ip_to_hex 10 0 0 5`
test_ip 1 f00000000001 f00000000002 $sip $dip

# Traffic 10.0.0.1 -> 10.0.0.5 should be allowed.
sip=`ip_to_hex 10 0 0 1`
dip=`ip_to_hex 10 0 0 5`
test_ip 1 f00000000001 f00000000002 $sip $dip 2

cat 2.expected > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [expout])
reset_pcap_file hv1-vif2 hv1/vif2
rm -f 2.packets
> 2.expected

# Remove the first less restrictive allow ACL.
check ovn-nbctl acl-del ls1 to-lport 3 'ip4.src==10.0.0.1 || ip4.src==10.0.0.1'
check ovn-nbctl --wait=hv sync

# Check OVS flows, the second less restrictive allow ACL should have been installed.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=46 | ofctl_strip_all | \
    grep "priority=1003" | \
    sed 's/conjunction([[^)]]*)/conjunction()/g' | \
    sed 's/conj_id=[[0-9]]*,/conj_id=xxx,/g' | sort], [0], [dnl
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.3 actions=conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.2 actions=conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.42 actions=conjunction()
])

# Remove the less restrictive allow ACL.
check ovn-nbctl acl-del ls1 to-lport 3 'ip4.src==10.0.0.1'
check ovn-nbctl --wait=hv sync

# Check OVS flows, the 10.0.0.1 conjunction should have been reinstalled.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=46 | ofctl_strip_all | \
    grep "priority=1003" | \
    sed 's/conjunction([[^)]]*)/conjunction()/g' | \
    sed 's/conj_id=[[0-9]]*,/conj_id=xxx,/g' | sort], [0], [dnl
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.3 actions=conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.1 actions=conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.2 actions=conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.42 actions=conjunction()
])

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.3, 10.0.0.4 should be allowed.
for src in `seq 1 2`; do
    for dst in `seq 3 4`; do
        sip=`ip_to_hex 10 0 0 $src`
        dip=`ip_to_hex 10 0 0 $dst`

        test_ip 1 f00000000001 f00000000002 $sip $dip 2
    done
done

# Traffic 10.0.0.1, 10.0.0.2 -> 10.0.0.5 should be dropped.
dip=`ip_to_hex 10 0 0 5`
for src in `seq 1 2`; do
    sip=`ip_to_hex 10 0 0 $src`

    test_ip 1 f00000000001 f00000000002 $sip $dip
done

cat 2.expected > expout
$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > 2.packets
AT_CHECK([cat 2.packets], [0], [expout])

# Re-add the less restrictive allow ACL for src IP 10.0.0.1
check ovn-nbctl acl-add ls1 to-lport 3 'ip4.src==10.0.0.1' allow
check ovn-nbctl --wait=hv sync

# Check OVS flows, the less restrictive flows should have been installed.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=46 | ofctl_strip_all | \
   grep "priority=1003" | \
   sed 's/conjunction([[^)]]*)/conjunction()/g' | \
   sed 's/conj_id=[[0-9]]*,/conj_id=xxx,/g' | sort], [0], [dnl
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.3 actions=conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.2 actions=conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.42 actions=conjunction()
])

# Add another ACL that overlaps with the existing less restrictive ones.
check ovn-nbctl acl-add ls1 to-lport 3 'udp || ((ip4.src==10.0.0.1 || ip4.src==10.0.0.2) && (ip4.dst == 10.0.0.3 || ip4.dst == 10.0.0.4))' allow
check ovn-nbctl --wait=hv sync

# Check OVS flows, the same conjunctive flows as above should still be there,
# with an additional conjunction action.
#
# New non-conjunctive flows should be added to match on 'udp'.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=46 | ofctl_strip_all | \
   grep "priority=1003" | \
   sed 's/conjunction([[^)]]*)/conjunction()/g' | \
   sed 's/conj_id=[[0-9]]*,/conj_id=xxx,/g' | sort], [0], [dnl
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,conj_id=xxx,ip,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.3 actions=conjunction(),conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_dst=10.0.0.4 actions=conjunction(),conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.2 actions=conjunction(),conjunction()
 table=46, priority=1003,ip,metadata=0x1,nw_src=10.0.0.42 actions=conjunction()
 table=46, priority=1003,udp,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
 table=46, priority=1003,udp6,metadata=0x1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# Number of conjunctions can change for the same logical flow, which should not
# cause conflict conjunction IDs between logical flows.
OVN_FOR_EACH_NORTHD([
AT_SETUP([n_conjs change])
ovn_start

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01" \
-- set logical_switch_port ls1-lp1 options:requested-tnl-key=1

check ovn-nbctl lsp-add ls1 ls1-lp2 \
-- lsp-set-addresses ls1-lp2 "f0:00:00:00:00:02" \
-- set logical_switch_port ls1-lp1 options:requested-tnl-key=2

net_add n1
sim_add hv1

as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=ls1-lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovn-nbctl create address_set name=as1 addresses="10.0.0.1"
ovn-nbctl create address_set name=as2 addresses="10.0.0.11,10.0.0.12"
ovn-nbctl pg-add pg1 ls1-lp1 ls1-lp2

# The 1st ACL potentially can generate 2 conjunctions, but as1 has only 1 address,
# so it would generate 1 conjunction for now.
check ovn-nbctl acl-add pg1 to-lport 100 \
    '(outport == @pg1 && ip4.src == $as1) || (outport == @pg1 && ip4.dst == $as2)' allow

# The 2nd ACL generates 1 conjunction (use another conjunction ID)
check ovn-nbctl acl-add pg1 to-lport 100 'outport == @pg1 && ip4.src == $as2' allow

wait_for_ports_up
check ovn-nbctl --wait=hv sync
ovs-ofctl dump-flows br-int table=46
AT_CHECK([test `ovs-ofctl dump-flows br-int table=46 | grep -c conj_id` = 2])

echo -------
# Add another address in as1, so that the 1st ACL will now generate 2 conjunctions.
ovn-nbctl set address_set as1 addresses="10.0.0.1,10.0.0.2"
check ovn-nbctl --wait=hv sync

ovs-ofctl dump-flows br-int table=46
# There should be 3 conjunctions in total (2 from 1st ACL + 1 from 2nd ACL)
AT_CHECK([test `ovs-ofctl dump-flows br-int table=46 | grep -c conj_id` = 3])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# 3 hypervisors, one logical switch, 3 logical ports per hypervisor
OVN_FOR_EACH_NORTHD([
AT_SETUP([L2 Drop and Allow ACL w/ Stateful ACL])
ovn_start

# Create hypervisors hv[123].
# Add vif11 to hv1, vif21 to hv2, vif31 to hv3.
# Add all of the vifs to a single logical switch lsw0.
# Create Port Group with vif11 and vif21
# Create Address Set with vif11 and vif21's MAC addresses
# Test 1:
#  Create Drop ACL to drop all packets with ethertype 1234 between 11 and 21
#  No ACL for 31
#  Validate the drop ACL with and without any stateful rule on lsw0.
# Test 2:
#  Create Drop ACL to drop all packets between 11 and 21
#  Create higher priority ACL to allow packet with ethertype 1234 between 11 and 21
#  No ACL for 31
#  Validate the allow ACL with and without any stateful rule on lsw0.
#
ovn-nbctl ls-add lsw0
net_add n1
for i in 1 2 3; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    ovs-vsctl add-port br-int vif${i}1 -- set Interface vif${i}1 external-ids:iface-id=lp${i}1 options:tx_pcap=hv$i/vif${i}1-tx.pcap options:rxq_pcap=hv$i/vif${i}1-rx.pcap ofport-request=${i}1
    ovn-nbctl lsp-add lsw0 lp${i}1
    ovn-nbctl lsp-set-addresses lp${i}1 "f0:00:00:00:00:${i}1 192.168.0.${i}1" unknown
done
#

get_lsp_uuid () {
    ovn-nbctl lsp-list lsw0 | grep $1 | awk '{ print $1 }'
}

# Create Port Group and corresponding Address set.
ovn-nbctl create Port_Group name=pg1 ports=`get_lsp_uuid lp11`,`get_lsp_uuid lp21`
ovn-nbctl create Address_Set name=set1 addresses=\"f0:00:00:00:00:11\",\"f0:00:00:00:00:21\"

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Make sure there is no attempt to adding duplicated flows by ovn-controller
AT_FAIL_IF([test -n "`grep duplicate hv1/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv2/ovn-controller.log`"])
AT_FAIL_IF([test -n "`grep duplicate hv3/ovn-controller.log`"])

# Given the name of a logical port, prints the name of the hypervisor
# on which it is located.
vif_to_hv() {
    echo hv${1%?}
}

# test_packet INPORT DST SRC ETHTYPE OUTPORT...
#
# This shell function causes a packet to be received on INPORT.  The packet's
# content has Ethernet destination DST and source SRC (each exactly 12 hex
# digits) and Ethernet type ETHTYPE (4 hex digits).  The OUTPORTs (zero or
# more) list the VIFs on which the packet should be received.  INPORT and the
# OUTPORTs are specified as logical switch port numbers, e.g. 11 for vif11.
for i in 1 2 3; do
    : > ${i}1.expected
done
test_packet() {
    local inport=$1 packet=$2$3$4; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    vif=vif$inport
    as $hv ovs-appctl netdev-dummy/receive $vif $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Test drop rule
# --------------
ovn-nbctl acl-del lsw0
check ovn-nbctl --wait=hv --log --severity=info --name=drop-acl acl-add lsw0 to-lport 5000 'outport == @pg1 && eth.src == $set1 && eth.type == 0x1234' drop
for sf in 0 1; do
    if test ${sf} = 1; then
        # Add a stateful rule and re-run the check to make sure the
        # drop rule is still effective..
        ovn-nbctl --wait=hv acl-add lsw0 from-lport 2000 'inport == "lp31" && ip' allow-related
    fi
    for is in 1 2 3; do
        s=${is}1
        for id in 1 2 3; do
            d=${id}1

            if test $d != $s;
            then
                if test ${is} = 3 || test ${id} = 3; then
                    test_packet $s f000000000$d f000000000$s 1234 $d # Allow to/from 31
                else
                    test_packet $s f000000000$d f000000000$s 1234    # Drop between 11 and 21
                fi
            fi
        done

        # Broadcast and multicast.
        if test ${is} = 3; then
            bcast="11 21" # Allow from 3
        else
            bcast="31"   # Allow only to 31 from 11 or 21.
        fi
        test_packet $s ffffffffffff f000000000$s 1234 $bcast
        test_packet $s 010000000000 f000000000$s 1234 $bcast
    done
done

check_packets() {
    n_allowed=$1
    > expected
    > received
    for i in 1 2 3; do
        echo "--- hv$i vif${i}1" | tee -a expected >> received
        sort ${i}1.expected >> expected
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv$i/vif${i}1-tx.pcap | sort >> received
        echo | tee -a expected >> received
    done

    # need to verify the log for ACL hit as well, since in the allow case
    # (unlike the drop case) it is tricky to pass just with the expected;
    # since with the stateful rule the packet will still get by (default
    # rule) even if it doesn't hit the allow rule.
    # The hit count for the ACL is 6 (1 unicast + 2 non-unicast) * 2
    # (with/without stateful rule) for hv1 and hv2, each.
    cat >>expected <<EOF
--- acl logging
hv1_drop hit 6
hv2_drop hit 6
hv1_allow hit $n_allowed
hv2_allow hit $n_allowed
EOF

cat >>received <<EOF
--- acl logging
hv1_drop hit `grep -c 'acl_log.*|INFO|name="drop-acl"' hv1/ovn-controller.log`
hv2_drop hit `grep -c 'acl_log.*|INFO|name="drop-acl"' hv2/ovn-controller.log`
hv1_allow hit `grep -c 'acl_log.*|INFO|name="allow-acl"' hv1/ovn-controller.log`
hv2_allow hit `grep -c 'acl_log.*|INFO|name="allow-acl"' hv2/ovn-controller.log`
EOF

    $at_diff expected received >/dev/null
}

# We need to wait and check here that packets are received as they should as otherwise packets
# which were just sent might by handled after setting next ACL (allow) rules.
OVS_WAIT_UNTIL([check_packets 0], [$at_diff -F'^---' expected received])

# Test allow rule
#----------------
ovn-nbctl acl-del lsw0
# drop all packets to 11 and 21.
ovn-nbctl acl-add lsw0 to-lport 5000 'outport == @pg1 && eth.src == $set1' drop
# allow 0x1234 between 11 and 21
check ovn-nbctl --wait=hv --log --severity=info --name=allow-acl acl-add lsw0 to-lport 6000 'outport == @pg1 && eth.src == $set1 && eth.type == 0x1234' allow
for sf in 0 1; do
    if test ${sf} = 1; then
        # Add a stateful rule and re-run the check to make sure the
        # allow rule is still effective..
        check ovn-nbctl --wait=hv acl-add lsw0 from-lport 2000  'inport == "lp31" && ip' allow-related
    fi
    # dump information and flows with counters
    ovn-sbctl dump-flows -- list multicast_group > sbflows$sf
    AT_CAPTURE_FILE([sbflows0])
    AT_CAPTURE_FILE([sbflows1])
    for is in 1 2 3; do
        s=${is}1
        for id in 1 2 3; do
            d=${id}1

            if test $d != $s;
            then
                test_packet $s f000000000$d f000000000$s 1234 $d # allow 1234 to 11, 21, and 31
            fi
        done

        # Broadcast and multicast. Allow from one to the other 2.
        if test ${is} = 1; then
            bcast="21 31"
        elif test ${is} = 2; then
            bcast="11 31"
        else
            bcast="11 21"
        fi
        test_packet $s ffffffffffff f000000000$s 1234 $bcast
        test_packet $s 010000000000 f000000000$s 1234 $bcast
    done
done

as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int > offlows1
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int > offlows2
as hv3 ovs-ofctl -O OpenFlow13 dump-flows br-int > offlows3

# Now check the packets actually received against the ones expected.
AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
OVS_WAIT_UNTIL([check_packets 6], [$at_diff -F'^---' expected received])

OVN_CLEANUP([hv1],[hv2],[hv3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([TTL exceeded])
AT_KEYWORDS([ttl-exceeded])
ovn_start

# test_ip_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST IPV4_ROUTER IP_CHKSUM EXP_IP_CHKSUM EXP_ICMP_CHKSUM SHOULD_REPLY
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv4 packet with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHKSUM as specified and TTL set to 1.
# EXP_IP_CHKSUM and EXP_ICMP_CHKSUM are the ip and icmp checksums of the icmp time exceeded frame
# generated by OVN logical router
#
# INPORT is a lport number, e.g. 11 for vif11.
# HV is a hypervisor number
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC, IPV4_DST and IPV4_ROUTER are each 8 hex digits.
# IP_CHKSUM, EXP_IP_CHSUM and EXP_ICMP_CHKSUM are each 4 hex digits
test_ip_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_router=$7 ip_chksum=$8
    local exp_ip_chksum=$9 exp_icmp_chksum=${10}
    shift 10
    local should_reply=$1

    local ip_ttl=01
    local packet=${eth_dst}${eth_src}08004500001400004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}
    local orig_pkt_in_reply=4500001400004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}
    local reply_icmp_ttl=fe
    local icmp_type_code_response=0b00
    local icmp_data=00000000
    local reply_icmp_payload=${icmp_type_code_response}${exp_icmp_chksum}${icmp_data}
    if test $should_reply == yes; then
        local reply=${eth_src}${eth_dst}08004500003000004000${reply_icmp_ttl}01${exp_ip_chksum}${ip_router}${ipv4_src}${reply_icmp_payload}
        echo $reply$orig_pkt_in_reply >> vif$inport.expected
    fi

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_ip6_packet INPORT HV ETH_SRC ETH_DST IPV6_SRC IPV6_DST IPV6_ROUTER EXP_ICMP_CHKSUM SHOULD_REPLY
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv6
# packet with ETH_SRC, ETH_DST, IPV6_SRC and IPV6_DST as specified.
# IPV6_ROUTER and EXP_ICMP_CHKSUM are the source IP and checksum of the icmpv6 ttl exceeded
# packet sent by OVN logical router
test_ip6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6 ipv6_router=$7 exp_icmp_chksum=$8 should_reply=$9
    shift 8

    local ip6_hdr=6000000000151101${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}dbb8303900155bac6b646f65206676676e6d66720a

    if test $should_reply == yes; then
        local reply=${eth_src}${eth_dst}86dd6000000000453afe${ipv6_router}${ipv6_src}0300${exp_icmp_chksum}00000000${ip6_hdr}dbb8303900155bac6b646f65206676676e6d66720a
        echo $reply >> vif$inport.expected
    fi

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

for i in 1 2; do
    net_add n$i
    ovn-nbctl ls-add sw$i

    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n$i br-phys 192.168.$i.1

    ovn-nbctl lsp-add sw$i sw$i-p${i}0 -- \
        lsp-set-addresses sw$i-p${i}0 "00:00:00:00:00:0$i 192.168.$i.1 2001:db8:$i::11"

    ovs-vsctl -- add-port br-int vif$i -- \
        set interface vif$i \
        external-ids:iface-id=sw$i-p${i}0 \
            options:tx_pcap=hv$i/vif$i-tx.pcap \
            options:rxq_pcap=hv$i/vif$i-rx.pcap \
            ofport-request=$i

    ovs-appctl -t ovn-controller vlog/set file:dbg:pinctrl
done

ovn-nbctl lr-add lr0
for i in 1 2; do
    ovn-nbctl lrp-add lr0 lrp$i 00:00:00:00:ff:0$i 192.168.$i.254/24 2001:db8:$i::1/64
    ovn-nbctl -- lsp-add sw$i lrp$i-attachment \
              -- set Logical_Switch_Port lrp$i-attachment type=router \
                options:router-port=lrp$i addresses='"00:00:00:00:ff:0'$i' 192.168.'$i'.254 2001:db8:'$i'::1"'
done

OVN_POPULATE_ARP
# allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
ovn-nbctl --wait=hv sync

test_ip_packet 1 1 000000000001 00000000ff01 $(ip_to_hex 192 168 1 1) $(ip_to_hex 192 168 2 1) $(ip_to_hex 192 168 1 254) 0000 f87c ea96 yes
test_ip6_packet 1 1 000000000001 00000000ff01 20010db8000100000000000000000011 20010db8000200000000000000000011 20010db8000100000000000000000001 1c22 yes

# Should not send ICMP for multicast
test_ip_packet 1 1 000000000001 01005e7f0001 $(ip_to_hex 192 168 1 1) $(ip_to_hex 239 255 0 1) $(ip_to_hex 192 168 1 254) 0000 000000000 no
test_ip6_packet 1 1 000000000001 333300000001 20010db8000100000000000000000011 ff020000000000000000000000000001 20010db8000100000000000000000001 0000 no

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [vif1.expected])

# Confirm from debug log that we only see 2 packet-ins (no packet-ins for
# multicasts). This is necessary because not seeing ICMP messages doesn't
# necessarily mean the packet-in didn't happen. It is possible that packet-in
# is processed but the ICMP message got dropped.
AT_CHECK([grep -c packet-in hv1/ovn-controller.log], [0], [2
])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([router port unreachable])
AT_KEYWORDS([router-port-unreachable])
ovn_start

# test_ip_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_ROUTER L4_PROTCOL IP_CHKSUM EXP_IP_CHKSUM EXP_ICMP_CHKSUM EXP_ICMP_CODE
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv4 packet with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_ROUTER, L4_PROTCOL, IP_CHKSUM as specified.
# EXP_IP_CHKSUM and EXP_ICMP_CHKSUM are the ip and icmp checksums of the icmp frame generated by OVN logical router
# EXP_ICMP_CODE are code and type of the icmp frame generated by OVN logical router
#
# INPORT is a lport number, e.g. 11 for vif11.
# HV is a hypervisor number
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_ROUTER are each 8 hex digits.
# IP_CHKSUM, EXP_IP_CHSUM and EXP_ICMP_CHKSUM are each 4 hex digits
test_ip_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ip_router=$6 l4_proto=$7 ip_chksum=$8
    local exp_ip_chksum=$9 exp_icmp_chksum=${10} exp_icmp_code=${11}
    shift 11

    local ip_ttl=ff
    local packet=${eth_dst}${eth_src}08004500001400004000${ip_ttl}${l4_proto}${ip_chksum}${ipv4_src}${ip_router}
    local orig_pkt_in_reply=4500001400004000${ip_ttl}${l4_proto}${ip_chksum}${ipv4_src}${ip_router}
    local reply_icmp_ttl=fe
    local icmp_data=00000000
    local reply_icmp_payload=${exp_icmp_code}${exp_icmp_chksum}${icmp_data}
    local reply=${eth_src}${eth_dst}08004500003000004000${reply_icmp_ttl}01${exp_ip_chksum}${ip_router}${ipv4_src}${reply_icmp_payload}
    echo $reply$orig_pkt_in_reply >> vif$inport.expected

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_tcp_syn_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_ROUTER IP_CHKSUM TCP_SPORT TCP_DPORT TCP_CHKSUM EXP_IP_CHKSUM EXP_TCP_RST_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an TCP syn segment with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_ROUTER, IP_CHKSUM, TCP_SPORT, TCP_DPORT, TCP_CHKSUM  as specified.
# EXP_IP_CHKSUM and EXP_TCP_RST_CHKSUM are the ip and tcp checksums of the tcp reset segment generated by OVN logical router
#
# INPORT is an lport number, e.g. 11 for vif11.
# HV is an hypervisor number
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_ROUTER are each 8 hex digits.
# TCP_SPORT and TCP_DPORT are 4 hex digits.
# IP_CHKSUM, TCP_CHKSUM, EXP_IP_CHSUM and EXP_TCP_RST_CHKSUM are each 4 hex digits
test_tcp_syn_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ip_router=$6 ip_chksum=$7
    local tcp_sport=$8 tcp_dport=$9 tcp_chksum=${10}
    local exp_ip_chksum=${11} exp_tcp_rst_chksum=${12}
    shift 12

    local ip_ttl=ff
    local packet=${eth_dst}${eth_src}08004500002800004000${ip_ttl}06${ip_chksum}${ipv4_src}${ip_router}${tcp_sport}${tcp_dport}000000010000000050027210${tcp_chksum}0000

    local tcp_rst_ttl=3e
    local reply=${eth_src}${eth_dst}08004500002800004000${tcp_rst_ttl}06${exp_ip_chksum}${ip_router}${ipv4_src}${tcp_dport}${tcp_sport}000000000000000250140000${exp_tcp_rst_chksum}0000
    echo $reply >> vif$inport.expected

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_sctp_init_packet INPORT HV ETH_SRC ETH_DST IPV4_SRC IPV4_DST IP_CHKSUM SCTP_SPORT SCTP_DPORT SCTP_INIT_TAG SCTP_CHKSUM EXP_IP_CHKSUM EXP_SCTP_ABORT_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an SCTP INIT chunk with
# ETH_SRC, ETH_DST, IPV4_SRC, IPV4_DST, IP_CHKSUM, SCTP_SPORT, SCTP_DPORT, and SCTP_CHKSUM as specified.
# The INIT "initiate_tag" will be set to SCTP_INIT_TAG.
# EXP_IP_CHKSUM and EXP_SCTP_CHKSUM are the ip and sctp checksums of the SCTP ABORT chunk generated by OVN logical router
#
# INPORT is an lport number, e.g. 1 for vif1.
# HV is a hypervisor number.
# ETH_SRC and ETH_DST are each 12 hex digits.
# IPV4_SRC and IPV4_DST are each 8 hex digits.
# SCTP_SPORT and SCTP_DPORT are 4 hex digits.
# IP_CHKSUM and EXP_IP_CHKSUM are 4 hex digits.
# SCTP_CHKSUM and EXP_SCTP_CHKSUM are 8 hex digits.
test_sctp_init_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7
    local sctp_sport=$8 sctp_dport=$9 sctp_init_tag=${10} sctp_chksum=${11}
    local exp_ip_chksum=${12} exp_sctp_abort_chksum=${13}

    local ip_ttl=ff
    local eth_hdr=${eth_dst}${eth_src}0800
    local ip_hdr=4500002500004000${ip_ttl}84${ip_chksum}${ipv4_src}${ipv4_dst}
    local sctp_hdr=${sctp_sport}${sctp_dport}00000000${sctp_chksum}
    local sctp_init=01000014${sctp_init_tag}0000000000010001${sctp_init_tag}

    local packet=${eth_hdr}${ip_hdr}${sctp_hdr}${sctp_init}

    local sctp_abort_ttl=3e
    local reply_eth_hdr=${eth_src}${eth_dst}0800
    local reply_ip_hdr=4500002400004000${sctp_abort_ttl}84${exp_ip_chksum}${ipv4_dst}${ipv4_src}
    local reply_sctp_hdr=${sctp_dport}${sctp_sport}${sctp_init_tag}${exp_sctp_abort_chksum}
    local reply_sctp_abort=06000004

    local reply=${reply_eth_hdr}${reply_ip_hdr}${reply_sctp_hdr}${reply_sctp_abort}
    echo $reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_tcp6_packet INPORT HV ETH_SRC ETH_DST IPV6_SRC IPV6_ROUTER TCP_SPORT TCP_DPORT TCP_CHKSUM EXP_TCP_RST_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is a TCP syn segment with
# ETH_SRC, ETH_DST, IPV6_SRC, IPV6_ROUTER, TCP_SPORT, TCP_DPORT and TCP_CHKSUM as specified.
# EXP_TCP_RST_CHKSUM is the tcp checksums of the tcp reset segment generated by OVN logical router
test_tcp6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_router=$6
    local tcp_sport=$7 tcp_dport=$8 tcp_chksum=$9
    local exp_tcp_rst_chksum=${10}
    shift 10

    local ip6_hdr=60000000001406ff${ipv6_src}${ipv6_router}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}${tcp_sport}${tcp_dport}000000010000000050027210${tcp_chksum}0000

    local reply=${eth_src}${eth_dst}86dd600000000014063e${ipv6_router}${ipv6_src}${tcp_dport}${tcp_sport}000000000000000250140000${exp_tcp_rst_chksum}0000
    echo $reply >> vif$inport.expected

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_tcp6_packet INPORT HV ETH_SRC ETH_DST IPV6_SRC IPV6_ROUTER SCTP_SPORT SCTP_DPORT SCTP_INIT_TAG SCTP_CHKSUM EXP_SCTP_ABORT_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an SCTP INIT chunk with
# ETH_SRC, ETH_DST, IPV6_SRC, IPV6_ROUTER, SCTP_SPORT, SCTP_DPORT and SCTP_CHKSUM as specified.
# The INIT "initiate_tag" will be set to SCTP_INIT_TAG.
# EXP_SCTP_CHKSUM is the sctp checksum of the SCTP ABORT chunk generated by OVN logical router
test_sctp6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_router=$6
    local sctp_sport=$7 sctp_dport=$8 sctp_init_tag=$9 sctp_chksum=${10}
    local exp_sctp_abort_chksum=${11}
    shift 11

    local eth_hdr=${eth_dst}${eth_src}86dd
    local ip_hdr=60000000002084ff${ipv6_src}${ipv6_router}
    local sctp_hdr=${sctp_sport}${sctp_dport}00000000${sctp_chksum}
    local sctp_init=01000014${sctp_init_tag}0000000000010001${sctp_init_tag}

    local packet=${eth_hdr}${ip_hdr}${sctp_hdr}${sctp_init}

    local reply_eth_hdr=${eth_src}${eth_dst}86dd
    local reply_ip_hdr=600000000010843e${ipv6_router}${ipv6_src}
    local reply_sctp_hdr=${sctp_dport}${sctp_sport}${sctp_init_tag}${exp_sctp_abort_chksum}
    local reply_sctp_abort=06000004

    local reply=${reply_eth_hdr}${reply_ip_hdr}${reply_sctp_hdr}${reply_sctp_abort}
    echo $reply >> vif$inport.expected

    check as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

# test_ip6_packet INPORT HV ETH_SRC ETH_DST IPV6_SRC IPV6_DST IPV6_PROTO IPV6_LEN DATA EXP_ICMP_CODE EXP_ICMP_CHKSUM
#
# Causes a packet to be received on INPORT of the hypervisor HV. The packet is an IPv6
# packet with ETH_SRC, ETH_DST, IPV6_SRC, IPV6_DST, IPV6_PROTO, IPV6_LEN and DATA as specified.
# EXP_ICMP_CODE and EXP_ICMP_CHKSUM are the code and checksum of the icmp6 packet sent by OVN logical router
test_ip6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6 ipv6_proto=$7 ipv6_len=$8 data=$9
    local exp_icmp_code=${10} exp_icmp_chksum=${11}
    shift 11

    local ip6_hdr=60000000${ipv6_len}${ipv6_proto}ff${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}${data}

    local reply_ip_len=`expr 48 + ${#data} / 2`
    reply_ip_len=$(printf "%x" $reply_ip_len)
    local reply=${eth_src}${eth_dst}86dd6000000000${reply_ip_len}3afe${ipv6_dst}${ipv6_src}${exp_icmp_code}${exp_icmp_chksum}00000000${ip6_hdr}${data}
    echo $reply >> vif$inport.expected

    as hv$hv ovs-appctl netdev-dummy/receive vif$inport $packet
}

for i in 1 2; do
    net_add n$i
    ovn-nbctl ls-add sw$i

    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n$i br-phys 192.168.$i.1

    ovn-nbctl lsp-add sw$i sw$i-p${i}0 -- \
        lsp-set-addresses sw$i-p${i}0 "00:00:00:00:00:0$i 192.168.$i.1 2001:db8:$i::11"

    ovs-vsctl -- add-port br-int vif$i -- \
        set interface vif$i \
        external-ids:iface-id=sw$i-p${i}0 \
            options:tx_pcap=hv$i/vif$i-tx.pcap \
            options:rxq_pcap=hv$i/vif$i-rx.pcap \
            ofport-request=$i
done

ovn-nbctl lr-add lr0
for i in 1 2; do
    ovn-nbctl lrp-add lr0 lrp$i 00:00:00:00:ff:0$i 192.168.$i.254/24 2001:db8:$i::1/64
    ovn-nbctl -- lsp-add sw$i lrp$i-attachment \
              -- set Logical_Switch_Port lrp$i-attachment type=router \
                options:router-port=lrp$i addresses='"00:00:00:00:ff:0'$i' 192.168.'$i'.254 2001:db8:'$i'::1"'
done

OVN_POPULATE_ARP
# allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

test_ip_packet 1 1 000000000001 00000000ff01 $(ip_to_hex 192 168 1 1) $(ip_to_hex 192 168 1 254) 11 0000 f87c f485 0303
test_ip6_packet 1 1 000000000001 00000000ff01 20010db8000100000000000000000011 20010db8000100000000000000000001 11 0015 dbb8303900155bac6b646f65206676676e6d66720a 0104 1d31
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [vif1.expected])

test_tcp_syn_packet 2 2 000000000002 00000000ff02 $(ip_to_hex 192 168 2 1) $(ip_to_hex 192 168 2 254) 0000 8b40 3039 0000 b680 6e05
test_sctp_init_packet 2 2 000000000002 00000000ff02 $(ip_to_hex 192 168 2 1) $(ip_to_hex 192 168 2 254) 0000 8b40 3039 00000001 82112601 b606 10fe95b6
test_tcp6_packet 2 2 000000000002 00000000ff02 20010db8000200000000000000000011 20010db8000200000000000000000001 8b40 3039 0000 98cd
test_sctp6_packet 2 2 000000000002 00000000ff02 20010db8000200000000000000000011 20010db8000200000000000000000001 8b40 3039 00000002 C0379D5A 39f23aaf
OVN_CHECK_PACKETS([hv2/vif2-tx.pcap], [vif2.expected])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller exit])
ovn_start
# Logical network:
# One Logical Router: ro, with two logical switches sw1 and sw2.
# sw1 is for subnet 10.0.0.0/8
# sw2 is for subnet 20.0.0.0/8
# sw1 has a single port bound on hv1
# sw2 has a single port bound on hv2

ovn-nbctl lr-add ro
ovn-nbctl ls-add sw1
ovn-nbctl ls-add sw2

sw1_ro_mac=00:00:10:00:00:01
sw1_ro_ip=10.0.0.1
sw2_ro_mac=00:00:20:00:00:01
sw2_ro_ip=20.0.0.1
sw1_p1_mac=00:00:10:00:00:02
sw1_p1_ip=10.0.0.2
sw2_p1_mac=00:00:20:00:00:02
sw2_p1_ip=20.0.0.2

ovn-nbctl lrp-add ro ro-sw1 $sw1_ro_mac ${sw1_ro_ip}/8
ovn-nbctl lrp-add ro ro-sw2 $sw2_ro_mac ${sw2_ro_ip}/8
ovn-nbctl lsp-add sw1 sw1-ro -- set Logical_Switch_Port sw1-ro type=router \
  options:router-port=ro-sw1 addresses=\"$sw1_ro_mac\"
ovn-nbctl lsp-add sw2 sw2-ro -- set Logical_Switch_Port sw2-ro type=router \
  options:router-port=ro-sw2 addresses=\"$sw2_ro_mac\"

ovn-nbctl lsp-add sw1 sw1-p1 \
-- lsp-set-addresses sw1-p1 "$sw1_p1_mac $sw1_p1_ip"

ovn-nbctl lsp-add sw2 sw2-p1 \
-- lsp-set-addresses sw2-p1 "$sw2_p1_mac $sw2_p1_ip"

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw2-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

packet="inport==\"sw1-p1\" && eth.src==$sw1_p1_mac && eth.dst==$sw1_ro_mac &&
       ip4 && ip.ttl==64 && ip4.src==$sw1_p1_ip && ip4.dst==$sw2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"

# Start by Sending the packet and make sure it makes it there as expected
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Expected packet has TTL decreased by 1
expected="eth.src==$sw2_ro_mac && eth.dst==$sw2_p1_mac &&
       ip4 && ip.ttl==63 && ip4.src==$sw1_p1_ip && ip4.dst==$sw2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Stop ovn-controller on hv2
as hv2 ovs-appctl -t ovn-controller exit

# Now send the packet again. This time, it should not arrive.
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Start ovn-controller again just so OVN_CLEANUP doesn't complain
as hv2 start_daemon ovn-controller

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([external logical port])
ovn_start

net_add n1
sim_add hv1
sim_add hv2
sim_add hv3

ovn-nbctl --wait=hv set NB_Global . options:"bfd-mult"=15

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.0.0.4 ae70::4"

# Add a couple of external logical port
ovn-nbctl lsp-add ls1 ls1-lp_ext1 \
-- lsp-set-addresses ls1-lp_ext1 "f0:00:00:00:00:03 10.0.0.6 ae70::6"
ovn-nbctl lsp-set-port-security ls1-lp_ext1 \
"f0:00:00:00:00:03 10.0.0.6 ae70::6"
ovn-nbctl lsp-set-type ls1-lp_ext1 external

ovn-nbctl lsp-add ls1 ls1-lp_ext2 \
-- lsp-set-addresses ls1-lp_ext2 "f0:00:00:00:00:04 10.0.0.7 ae70::7"
ovn-nbctl lsp-set-port-security ls1-lp_ext2 \
"f0:00:00:00:00:04 10.0.0.7 ae70::8"
ovn-nbctl lsp-set-type ls1-lp_ext2 external

d1="$(ovn-nbctl create DHCP_Options cidr=10.0.0.0/24 \
options="\"server_id\"=\"10.0.0.1\" \"server_mac\"=\"ff:10:00:00:00:01\" \
\"lease_time\"=\"3600\" \"router\"=\"10.0.0.1\"")"

d2="$(ovn-nbctl create DHCP_Options cidr="ae70\:\:/64" \
options="\"server_id\"=\"00:00:00:10:00:01\"")"

ovn-nbctl lsp-set-dhcpv4-options ls1-lp1 ${d1}
ovn-nbctl lsp-set-dhcpv4-options ls1-lp_ext1 ${d1}
ovn-nbctl lsp-set-dhcpv4-options ls1-lp_ext2 ${d1}

ovn-nbctl lsp-set-dhcpv6-options ls1-lp1 ${d2}
ovn-nbctl lsp-set-dhcpv6-options ls1-lp_ext1 ${d2}
ovn-nbctl lsp-set-dhcpv6-options ls1-lp_ext2 ${d2}

# Create a logical router and connect it to ls1
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-ls1 a0:10:00:00:00:01 10.0.0.1/24
ovn-nbctl lsp-add ls1 ls1-lr0
ovn-nbctl set Logical_Switch_Port ls1-lr0 type=router \
    options:router-port=lr0-ls1 addresses=router

# Create HA chassis group
ovn-nbctl ha-chassis-group-add hagrp1
ovn-nbctl ha-chassis-group-add-chassis hagrp1 hv1 30
ovn-nbctl --wait=sb sync

hagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name="hagrp1"`

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-phys hv1-ext1 -- \
    set interface hv1-ext1 options:tx_pcap=hv1/ext1-tx.pcap \
    options:rxq_pcap=hv1/ext1-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-phys hv2-ext2 -- \
    set interface hv2-ext2 options:tx_pcap=hv2/ext2-tx.pcap \
    options:rxq_pcap=hv2/ext2-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl -- add-port br-phys hv3-ext3 -- \
    set interface hv3-ext3 options:tx_pcap=hv3/ext3-tx.pcap \
    options:rxq_pcap=hv3/ext3-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

# No DHCPv4/v6 flows for the external port - ls1-lp_ext1 - 10.0.0.6 in hv1 and
# hv2 as ha-chassis-group is not set and no localnet port added to ls1.
AT_CHECK([ovn-sbctl dump-flows ls1 | grep "offerip = 10.0.0.6" | \
wc -l], [0], [0
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep table=26 | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | grep table=26 | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep table=26 | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | grep table=26 | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | wc -l], [0], [0
])

wait_row_count Chassis 1 name=hv1
wait_row_count Chassis 1 name=hv2
wait_row_count Chassis 1 name=hv3

hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)
hv3_uuid=$(fetch_column Chassis _uuid name=hv3)

# The port_binding row for ls1-lp_ext1 should have empty chassis
check_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis='[[]]'

# Associate hagrp1 ha-chassis-group to ls1-lp_ext1
ovn-nbctl --wait=hv set Logical_Switch_Port ls1-lp_ext1 \
ha-chassis-group=$hagrp1_uuid

# Get the hagrp1 uuid in SB DB.
sb_hagrp1_uuid=$(fetch_column HA_Chassis_Group _uuid name=hagrp1)

# Wait till ls1-lp_ext1 port_binding has ha_chassis_group set
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 ha_chassis_group=$sb_hagrp1_uuid

# No DHCPv4/v6 flows for the external port - ls1-lp_ext1 - 10.0.0.6 in hv1 and hv2
# as no localnet port added to ls1 yet.
#
# This used to be specific to a particular OpenFlow table, but that can
# easily shift around as OVN evolves, so it's been removed to avoid
# gratuitous breakage.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | wc -l], [0], [0
])

# Add the localnet port to the logical switch ls1
ovn-nbctl lsp-add ls1 ln-public
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl --wait=hv lsp-set-options ln-public network_name=phys

ln_public_key=$(fetch_column Port_Binding tunnel_key logical_port=ln-public)

# The ls1-lp_ext1 should be bound to hv1 as only hv1 is part of the
# ha chassis group.
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv1_uuid

wait_for_ports_up ls1-lp_ext1

# There should be DHCPv4/v6 OF flows for the ls1-lp_ext1 port in hv1
(ovn-sbctl dump-flows lr0; ovn-sbctl dump-flows ls1) > sbflows
as hv1 ovs-ofctl dump-flows br-int > brintflows
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | grep reg14=0x$ln_public_key | \
wc -l], [0], [1
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | \
grep reg14=0x$ln_public_key | wc -l], [0], [1
])

# There should be no DHCPv4/v6 flows for ls1-lp_ext1 on hv2
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | wc -l], [0], [0
])

# No DHCPv4/v6 flows for the external port - ls1-lp_ext2 - 10.0.0.7 in hv1 and
# hv2 as requested-chassis option is not set.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.07" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.07" | wc -l], [0], [0
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.07" | wc -l], [0], [0
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.07" | wc -l], [0], [0
])

as hv1
ovs-vsctl show

# This shell function sends a DHCP request packet
# test_dhcp INPORT SRC_MAC DHCP_TYPE BROADCAST OFFER_IP ...
test_dhcp() {
    local inport=$1 src_mac=$2 dhcp_type=$3 broadcast=$4 offer_ip=$5 use_ip=$6
    shift; shift; shift; shift; shift; shift;

    if test $use_ip != 0; then
        src_ip=$1
        dst_ip=$2
        shift; shift;
    else
        src_ip=`ip_to_hex 0 0 0 0`
        dst_ip=`ip_to_hex 255 255 255 255`
    fi

    if test $broadcast != 0; then
        flags=8000
        reply_dst_ip=`ip_to_hex 255 255 255 255`
    else
        flags=0000
        reply_dst_ip=${offer_ip}
    fi

    local request=ffffffffffff${src_mac}0800451001100000000080110000${src_ip}${dst_ip}
    # udp header and dhcp header
    request=${request}0044004300fc0000
    request=${request}010106006359aa760000${flags}00000000000000000000000000000000${src_mac}
    # client hardware padding
    request=${request}00000000000000000000
    # server hostname
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    # boot file name
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    request=${request}0000000000000000000000000000000000000000000000000000000000000000
    # dhcp magic cookie
    request=${request}63825363
    # dhcp message type
    request=${request}3501${dhcp_type}ff

    local srv_mac=$1 srv_ip=$2 expected_dhcp_opts=$3
    # total IP length will be the IP length of the request packet
    # (which is 272 in our case) + 8 (padding bytes) + (expected_dhcp_opts / 2)
    ip_len=`expr 280 + ${#expected_dhcp_opts} / 2`
    udp_len=`expr $ip_len - 20`
    ip_len=$(printf "%x" $ip_len)
    udp_len=$(printf "%x" $udp_len)
    # $ip_len var will be in 3 digits i.e 134. So adding a '0' before $ip_len
    local reply=${src_mac}${srv_mac}080045100${ip_len}000000008011XXXX${srv_ip}${reply_dst_ip}
    # udp header and dhcp header.
    # $udp_len var will be in 3 digits. So adding a '0' before $udp_len
    reply=${reply}004300440${udp_len}0000020106006359aa760000${flags}00000000
    # your ip address
    reply=${reply}${offer_ip}
    # next server ip address, relay agent ip address, client mac address
    reply=${reply}0000000000000000${src_mac}
    # client hardware padding
    reply=${reply}00000000000000000000
    # server hostname
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    # boot file name
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    reply=${reply}0000000000000000000000000000000000000000000000000000000000000000
    # dhcp magic cookie
    reply=${reply}63825363
    # dhcp message type
    local dhcp_reply_type=02
    if test $dhcp_type = 03; then
        dhcp_reply_type=05
    fi
    reply=${reply}3501${dhcp_reply_type}${expected_dhcp_opts}00000000ff00000000
    echo $reply >> ext1_v4.expected

    as hv1 ovs-appctl netdev-dummy/receive hv${inport}-ext${inport} $request
}

# This shell function sends a DHCPv6 request packet
# test_dhcpv6 INPORT SRC_MAC SRC_LLA DHCPv6_MSG_TYPE OFFER_IP OUTPORT...
# The OUTPORTs (zero or more) list the VIFs on which the original DHCPv6
# packet should be received twice (one from ovn-controller and the other
# from the "ovs-ofctl monitor br-int resume"
test_dhcpv6() {
    local inport=$1 src_mac=$2 src_lla=$3 msg_code=$4 offer_ip=$5
    local req_pkt_in_expected=$6
    local request=ffffffffffff${src_mac}86dd00000000002a1101${src_lla}
    # dst ip ff02::1:2
    request=${request}ff020000000000000000000000010002
    # udp header and dhcpv6 header
    request=${request}02220223002affff${msg_code}010203
    # Client identifier
    request=${request}0001000a00030001${src_mac}
    # IA-NA (Identity Association for Non Temporary Address)
    request=${request}0003000c0102030400000e1000001518
    shift; shift; shift; shift; shift;

    local server_mac=000000100001
    local server_lla=fe80000000000000020000fffe100001
    local reply_code=07
    if test $msg_code = 01; then
        reply_code=02
    fi
    local msg_len=54
    if test $offer_ip = 1; then
        msg_len=28
    fi
    local reply=${src_mac}${server_mac}86dd0000000000${msg_len}1101
    reply=${reply}${server_lla}${src_lla}

    # udp header and dhcpv6 header
    reply=${reply}0223022200${msg_len}ffff${reply_code}010203
    # Client identifier
    reply=${reply}0001000a00030001${src_mac}
    # IA-NA
    if test $offer_ip != 1; then
        reply=${reply}0003002801020304ffffffffffffffff00050018${offer_ip}
        reply=${reply}ffffffffffffffff
    fi
    # Server identifier
    reply=${reply}0002000a00030001${server_mac}

    echo $reply | trim_zeros >> ext${inport}_v6.expected
    # The inport also receives the request packet since it is connected
    # to the br-phys.
    #echo $request >> ext${inport}_v6.expected

    as hv1 ovs-appctl netdev-dummy/receive hv${inport}-ext${inport} $request
}

AT_CAPTURE_FILE([ofctl_monitor0_hv1.log])
as hv1 ovs-ofctl monitor br-int resume --timeout=120 --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0_hv1.log

AT_CAPTURE_FILE([ofctl_monitor0_hv2.log])
as hv2 ovs-ofctl monitor br-int resume --timeout=120 --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0_hv2.log

AT_CAPTURE_FILE([ofctl_monitor0_hv3.log])
as hv3 ovs-ofctl monitor br-int resume --timeout=120 --detach --no-chdir \
--pidfile=ovs-ofctl0.pid 2> ofctl_monitor0_hv3.log

as hv1
reset_pcap_file hv1-ext1 hv1/ext1

# Send DHCPDISCOVER.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
server_mac=ff1000000001
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 1 f00000000003 01 0 $offer_ip 0 $server_mac $server_ip \
$expected_dhcp_opts

# NXT_RESUMEs should be 1 in hv1.
OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 0 in hv2.
OVS_WAIT_UNTIL([test 0 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v4.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v4.expected], ["cut -c 53-"])

# ovs-ofctl also resumes the packets and this causes other ports to receive
# the DHCP request packet. So reset the pcap files so that its easier to test.
as hv1
reset_pcap_file hv1-ext1 hv1/ext1

rm -f ext1_v4.expected
rm -f ext1_v4.packets

# Send DHCPv6 request
src_mac=f00000000003
src_lla=fe80000000000000f20000fffe000003
offer_ip=ae700000000000000000000000000006
test_dhcpv6 1 $src_mac $src_lla 01 $offer_ip

# NXT_RESUMEs should be 2 in hv1.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 0 in hv2.
OVS_WAIT_UNTIL([test 0 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v6.expected], ["cut -c -120"])
# Skipping the UDP checksum
OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v6.expected], ["cut -c 125-"])

rm -f ext1_v6.expected
rm -f ext1_v6.packets

as hv1
reset_pcap_file hv1-ext1 hv1/ext1

# Delete the ha-chassis hv1.
ovn-nbctl ha-chassis-group-remove-chassis hagrp1 hv1
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis='[[]]'

# Add hv2 to the ha chassis group
ovn-nbctl --wait=hv ha-chassis-group-add-chassis hagrp1 hv2 20

ovn-sbctl list ha_chassis_group
ovn-sbctl list ha_chassis

ovn-sbctl find port_binding logical_port=ls1-lp_ext1

# The ls1-lp_ext1 should be bound to hv2
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv2_uuid
wait_for_ports_up ls1-lp_ext1

# There should be OF flows for DHCP4/v6 for the ls1-lp_ext1 port in hv2
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | grep reg14=0x$ln_public_key | \
wc -l], [0], [1
])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | \
grep reg14=0x$ln_public_key | wc -l], [0], [1
])

# There should be no DHCPv4/v6 flows for ls1-lp_ext1 on hv1
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep "0a.00.00.06" | wc -l], [0], [0
])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | \
grep controller | grep tp_src=546 | grep \
"ae.70.00.00.00.00.00.00.00.00.00.00.00.00.00.06" | \
grep reg14=0x$ln_public_key | wc -l], [0], [0
])

# Send DHCPDISCOVER again for hv1/ext1. The DHCP response should come from
# hv2 ovn-controller.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
server_mac=ff1000000001
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 1 f00000000003 01 0 $offer_ip 0 $server_mac $server_ip \
$expected_dhcp_opts

# NXT_RESUMEs should be 2 in hv1.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 1 in hv2.
OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v4.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v4.expected], ["cut -c 53-"])

# ovs-ofctl also resumes the packets and this causes other ports to receive
# the DHCP request packet. So reset the pcap files so that its easier to test.
as hv1
reset_pcap_file hv1-ext1 hv1/ext1

rm -f ext1_v4.expected

# Send DHCPv6 request again
src_mac=f00000000003
src_lla=fe80000000000000f20000fffe000003
offer_ip=ae700000000000000000000000000006
test_dhcpv6 1 $src_mac $src_lla 01 $offer_ip 1

# NXT_RESUMEs should be 2 in hv1.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v6.expected], ["cut -c -120"])
# Skipping the UDP checksum
OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v6.expected], ["cut -c 125-"])

rm -f ext1_v6.expected
rm -f ext1_v6.packets

as hv1
ovs-vsctl show
reset_pcap_file hv1-ext1 hv1/ext1
reset_pcap_file br-phys_n1 hv1/br-phys_n1
reset_pcap_file br-phys hv1/br-phys

as hv2
ovs-vsctl show
reset_pcap_file hv2-ext2 hv2/ext2
reset_pcap_file br-phys_n1 hv2/br-phys_n1
reset_pcap_file br-phys hv2/br-phys

# From  ls1-lp_ext1, send ARP request for the router ip. The ARP
# response should come from the router pipeline of hv2.
ext1_mac=f00000000003
router_mac=a01000000001
ext1_ip=`ip_to_hex 10 0 0 6`
router_ip=`ip_to_hex 10 0 0 1`
arp_request=ffffffffffff${ext1_mac}08060001080006040001${ext1_mac}${ext1_ip}000000000000${router_ip}

as hv1 ovs-appctl netdev-dummy/receive hv1-ext1 $arp_request
expected_response=${src_mac}${router_mac}08060001080006040002${router_mac}${router_ip}${ext1_mac}${ext1_ip}
echo $expected_response > expected_out
OVN_CHECK_PACKETS_CONTAIN([hv1/ext1-tx.pcap], [expected_out])

# Verify that the response came from hv2
OVN_CHECK_PACKETS_CONTAIN([hv2/br-phys_n1-tx.pcap], [expected_out])

# Now add 3 ha chassis to the ha chassis group
ovn-nbctl ha-chassis-group-add-chassis hagrp1 hv1 30
ovn-nbctl ha-chassis-group-add-chassis hagrp1 hv2 20
ovn-nbctl ha-chassis-group-add-chassis hagrp1 hv3 10

ovn_wait_for_bfd_up hv1 hv2 hv3

# hv1 should be master and claim ls1-lp_ext1
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv1_uuid
wait_for_ports_up ls1-lp_ext1

as hv1
ovs-vsctl show
reset_pcap_file hv1-ext1 hv1/ext1
reset_pcap_file br-phys_n1 hv1/br-phys_n1
reset_pcap_file br-phys hv1/br-phys

as hv2
ovs-vsctl show
reset_pcap_file hv2-ext2 hv2/ext2
reset_pcap_file br-phys_n1 hv2/br-phys_n1
reset_pcap_file br-phys hv2/br-phys

as hv3
ovs-vsctl show
reset_pcap_file hv3-ext3 hv3/ext3
reset_pcap_file br-phys_n1 hv3/br-phys_n1
reset_pcap_file br-phys hv3/br-phys

# Send DHCPDISCOVER.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
server_mac=ff1000000001
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 1 f00000000003 01 0 $offer_ip 0 $server_mac $server_ip \
$expected_dhcp_opts

# NXT_RESUMEs should be 3 in hv1.
OVS_WAIT_UNTIL([test 3 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v4.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v4.expected], ["cut -c 53-"])

# ovs-ofctl also resumes the packets and this causes other ports to receive
# the DHCP request packet. So reset the pcap files so that its easier to test.
as hv1
reset_pcap_file hv1-ext1 hv1/ext1

rm -f ext1_v4.expected
rm -f ext1_v4.packets

# Send DHCPv6 request
src_mac=f00000000003
src_lla=fe80000000000000f20000fffe000003
offer_ip=ae700000000000000000000000000006
test_dhcpv6 1 $src_mac $src_lla 01 $offer_ip

# NXT_RESUMEs should be 4 in hv1.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v6.expected], ["cut -c -120"])
# Skipping the UDP checksum
OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v6.expected], ["cut -c 125-"])

rm -f ext1_v6.expected
rm -f ext1_v6.packets
as hv1 reset_pcap_file hv1-ext1 hv1/ext1

# Now increase the priority of hv3 so it becomes master.
ovn-nbctl ha-chassis-group-add-chassis hagrp1 hv3 50

# hv3 should be master and claim ls1-lp_ext1
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv3_uuid
wait_for_ports_up ls1-lp_ext1

as hv1
ovs-vsctl show
reset_pcap_file hv1-ext1 hv1/ext1
reset_pcap_file br-phys_n1 hv1/br-phys_n1
reset_pcap_file br-phys hv1/br-phys

as hv2
ovs-vsctl show
reset_pcap_file hv2-ext2 hv2/ext2
reset_pcap_file br-phys_n1 hv2/br-phys_n1
reset_pcap_file br-phys hv2/br-phys

as hv3
ovs-vsctl show
reset_pcap_file hv3-ext3 hv3/ext3
reset_pcap_file br-phys_n1 hv3/br-phys_n1
reset_pcap_file br-phys hv3/br-phys

# Send DHCPDISCOVER.
offer_ip=`ip_to_hex 10 0 0 6`
server_ip=`ip_to_hex 10 0 0 1`
server_mac=ff1000000001
expected_dhcp_opts=330400000e100104ffffff0003040a00000136040a000001
test_dhcp 1 f00000000003 01 0 $offer_ip 0 $server_mac $server_ip \
$expected_dhcp_opts

# NXT_RESUMEs should be 4 in hv1.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 1 in hv3.
OVS_WAIT_UNTIL([test 1 = `cat ofctl_monitor0_hv3.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v4.expected], ["cut -c -48"])
# Skipping the IPv4 checksum.
OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v4.expected], ["cut -c 53-"])

# ovs-ofctl also resumes the packets and this causes other ports to receive
# the DHCP request packet. So reset the pcap files so that its easier to test.
as hv1
reset_pcap_file hv1-ext1 hv1/ext1

rm -f ext1_v4.expected
rm -f ext1_v4.packets

# Send DHCPv6 request
src_mac=f00000000003
src_lla=fe80000000000000f20000fffe000003
offer_ip=ae700000000000000000000000000006
test_dhcpv6 1 $src_mac $src_lla 01 $offer_ip

# NXT_RESUMEs should be 4 in hv1.
OVS_WAIT_UNTIL([test 4 = `cat ofctl_monitor0_hv1.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv2.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv2.log | grep -c NXT_RESUME`])

# NXT_RESUMEs should be 2 in hv3.
OVS_WAIT_UNTIL([test 2 = `cat ofctl_monitor0_hv3.log | grep -c NXT_RESUME`])

OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v6.expected], ["cut -c -120"])
# Skipping the UDP checksum
OVN_CHECK_PACKETS([hv1/ext1-tx.pcap], [ext1_v6.expected], ["cut -c 125-"])

# disconnect hv3 from the network, hv1 should take over
as hv3
port=${sandbox}_br-phys
as main ovs-vsctl del-port n1 $port

# hv1 should be master and claim ls1-lp_ext1
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv1_uuid
wait_for_ports_up ls1-lp_ext1

# There should be a flow in hv2 to drop traffic from ls1-lp_ext1 destined
# to router mac.
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int \
table=34,dl_src=f0:00:00:00:00:03,dl_dst=a0:10:00:00:00:01 | \
grep -c "actions=drop"], [0], [1
])
# Stop ovn-controllers on hv1 and hv3.
as hv1 ovn-appctl -t ovn-controller exit
as hv3 ovn-appctl -t ovn-controller exit

# hv2 should be master and claim ls1-lp_ext1
wait_row_count Port_Binding 1 logical_port=ls1-lp_ext1 chassis=$hv2_uuid
wait_for_ports_up ls1-lp_ext1

as hv1
OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as hv3
OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

OVN_CLEANUP([hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Address Set Incremental Processing])
AT_KEYWORDS([ovn_as_inc])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

ovn-nbctl ls-add ls1
for i in 1 2; do
    ovn-nbctl lsp-add ls1 lp$i \
        -- lsp-set-addresses lp$i "f0:00:00:00:00:0$i 192.168.1.$i"
    as hv1 ovs-vsctl \
        -- add-port br-int vif$i \
        -- set Interface vif$i \
            external-ids:iface-id=lp$i
done

for i in 1 2 3; do
    as1_uuid=`ovn-nbctl --wait=hv create addr name=as1`
    as2_uuid=`ovn-nbctl --wait=hv create addr name=as2`
    ovn-nbctl --wait=hv acl-add ls1 to-lport 200 \
            'outport=="lp1" && ip4 && ip4.src == {$as1, $as2}' allow-related
    ovn-nbctl --wait=hv set addr as1 addresses="10.1.2.10"
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.10"], [0], [ignore])

    # Update address set as1
    ovn-nbctl --wait=hv set addr as1 addresses="10.1.2.10 10.1.2.11"
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.11"], [0], [ignore])

    # Update address set as2
    ovn-nbctl --wait=hv set addr as2 addresses="10.1.2.12 10.1.2.13"
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.12"], [0], [ignore])

    # Add another ACL referencing as1
    n_flows_before=`ovs-ofctl dump-flows br-int | grep "10.1.2.10" | wc -l`
    ovn-nbctl --wait=hv acl-add ls1 to-lport 200 \
            'outport=="lp2" && ip4 && ip4.src == $as1' allow-related
    n_flows_after=`ovs-ofctl dump-flows br-int | grep "10.1.2.10" | wc -l`
    AT_CHECK([test $(expr $n_flows_before \* 2) = $n_flows_after], [0], [ignore])

    # Trigger full recompute. Creating a chassis would trigger full recompute.
    ovn-sbctl chassis-add tst geneve 127.0.0.4
    ovn-sbctl chassis-del tst

    # Remove an ACL
    ovn-nbctl --wait=hv acl-del ls1 to-lport 200 \
            'outport=="lp2" && ip4 && ip4.src == $as1'
    n_flows_after=`ovs-ofctl dump-flows br-int | grep "10.1.2.10" | wc -l`
    AT_CHECK([test $n_flows_before = $n_flows_after], [0], [ignore])

    # Remove as1 while it is still used by an ACL, the lflows should be reparsed and
    # parsing should fail.
    echo "before del as1"
    ovn-nbctl list addr | grep as1
    ovn-nbctl --wait=hv destroy addr $as1_uuid
    echo "after del as1"
    ovn-nbctl list addr | grep as1
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.10"], [1], [ignore])
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.12"], [1], [ignore])

    # Recreate as1
    as1_uuid=`ovn-nbctl --wait=hv create addr name=as1`
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.12"], [0], [ignore])

    # Remove ACLs and address sets
    ovn-nbctl --wait=hv destroy addr $as1_uuid -- destroy addr $as2_uuid
    AT_CHECK([ovs-ofctl dump-flows br-int | grep "10.1.2.12"], [1], [ignore])

    ovn-nbctl --wait=hv acl-del ls1
done

# Gracefully terminate daemons
OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller restart])
ovn_start

# Logical network:
# One Logical Router: ro, with two logical switches sw1 and sw2.
# sw1 is for subnet 10.0.0.0/8
# sw2 is for subnet 20.0.0.0/8
# sw1 has a single port bound on hv1
# sw2 has a single port bound on hv2

ovn-nbctl lr-add ro
ovn-nbctl ls-add sw1
ovn-nbctl ls-add sw2

sw1_ro_mac=00:00:10:00:00:01
sw1_ro_ip=10.0.0.1
sw2_ro_mac=00:00:20:00:00:01
sw2_ro_ip=20.0.0.1
sw1_p1_mac=00:00:10:00:00:02
sw1_p1_ip=10.0.0.2
sw2_p1_mac=00:00:20:00:00:02
sw2_p1_ip=20.0.0.2

ovn-nbctl lrp-add ro ro-sw1 $sw1_ro_mac ${sw1_ro_ip}/8
ovn-nbctl lrp-add ro ro-sw2 $sw2_ro_mac ${sw2_ro_ip}/8
ovn-nbctl lsp-add sw1 sw1-ro -- set Logical_Switch_Port sw1-ro type=router \
  options:router-port=ro-sw1 addresses=\"$sw1_ro_mac\"
ovn-nbctl lsp-add sw2 sw2-ro -- set Logical_Switch_Port sw2-ro type=router \
  options:router-port=ro-sw2 addresses=\"$sw2_ro_mac\"

ovn-nbctl lsp-add sw1 sw1-p1 \
-- lsp-set-addresses sw1-p1 "$sw1_p1_mac $sw1_p1_ip"

ovn-nbctl lsp-add sw2 sw2-p1 \
-- lsp-set-addresses sw2-p1 "$sw2_p1_mac $sw2_p1_ip"

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw2-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

OVN_POPULATE_ARP

wait_for_ports_up
check ovn-nbctl --wait=hv sync

packet="inport==\"sw1-p1\" && eth.src==$sw1_p1_mac && eth.dst==$sw1_ro_mac &&
       ip4 && ip.ttl==64 && ip4.src==$sw1_p1_ip && ip4.dst==$sw2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"

# Start by Sending the packet and make sure it makes it there as expected
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Expected packet has TTL decreased by 1
expected="eth.src==$sw2_ro_mac && eth.dst==$sw2_p1_mac &&
       ip4 && ip.ttl==63 && ip4.src==$sw1_p1_ip && ip4.dst==$sw2_p1_ip &&
       udp && udp.src==53 && udp.dst==4369"
echo $expected | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Stop ovn-controller on hv2 with --restart flag
as hv2 ovs-appctl -t ovn-controller exit --restart

# Now send the packet again. This time, it should still arrive
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

cat expected expected > expected2

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected2])

# Start ovn-controller again just so OVN_CLEANUP doesn't complain
as hv2 start_daemon ovn-controller

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-nbctl duplicate addresses])
ovn_start

# Set up a switch with some switch ports of varying address types
ovn-nbctl ls-add sw1
ovn-nbctl set logical_switch sw1 other_config:subnet=192.168.0.0/24

ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-add sw1 sw1-p2
ovn-nbctl lsp-add sw1 sw1-p3
ovn-nbctl lsp-add sw1 sw1-p4
ovn-nbctl --wait=sb lsp-add sw1 sw1-p5

check ovn-nbctl --wait=sb lsp-set-addresses sw1-p1 "00:00:00:00:00:01 10.0.0.1 aef0::1" "00:00:00:00:00:02 10.0.0.2 aef0::2"
check ovn-nbctl --wait=sb lsp-set-addresses sw1-p2 "00:00:00:00:00:03 dynamic"
check ovn-nbctl --wait=sb lsp-set-addresses sw1-p3 "dynamic"
check ovn-nbctl --wait=sb lsp-set-addresses sw1-p4 "router"
check ovn-nbctl --wait=sb lsp-set-addresses sw1-p5 "unknown"

ovn-nbctl list logical_switch_port

# Now try to add duplicate addresses on a new port. These should all fail
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 10.0.0.1"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv4 address '10.0.0.1' found on logical switch port 'sw1-p1'
])
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 10.0.0.2"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv4 address '10.0.0.2' found on logical switch port 'sw1-p1'
])
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 aef0::1"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv6 address 'aef0::1' found on logical switch port 'sw1-p1'
])
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 aef0::2"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv6 address 'aef0::2' found on logical switch port 'sw1-p1'
])
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 192.168.0.2"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv4 address '192.168.0.2' found on logical switch port 'sw1-p2'
])
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p5 "00:00:00:00:00:04 192.168.0.3"], [1], [],
[ovn-nbctl: Error on switch sw1: duplicate IPv4 address '192.168.0.3' found on logical switch port 'sw1-p3'
])

# Now try re-setting sw1-p1. This should succeed
AT_CHECK([ovn-nbctl lsp-set-addresses sw1-p1 "00:00:00:00:00:01 10.0.0.1 aef0::1"])

# Now create a new switch and try setting IP addresses the same as the
# first switch. This should succeed.
ovn-nbctl ls-add sw2
ovn-nbctl lsp-add sw2 sw2-p1

AT_CHECK([ovn-nbctl lsp-set-addresses sw2-p1 "00:00:00:00:00:04 10.0.0.1"])
AT_CHECK([ovn-nbctl lsp-set-addresses sw2-p1 "00:00:00:00:00:04 192.168.0.2"])
AT_CHECK([ovn-nbctl lsp-set-addresses sw2-p1 "00:00:00:00:00:04 192.168.0.3"])
AT_CHECK([ovn-nbctl lsp-set-addresses sw2-p1 "00:00:00:00:00:04 aef0::1"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([router - check packet length - icmp defrag])
AT_KEYWORDS([check packet length])
AT_KEYWORDS([slowtest])
ovn_start

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-port1
ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 10.0.0.3 1000::3"
ovn-nbctl lsp-add sw0 sw0-port2
ovn-nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:02 10.0.0.4 1000::4"

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::1/64
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl ls-add public
ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24 2000::1/64
ovn-nbctl lsp-add public public-lr0
ovn-nbctl lsp-set-type public-lr0 router
ovn-nbctl lsp-set-addresses public-lr0 router
ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
ovn-nbctl lsp-add public ln-public
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-options ln-public network_name=phys

ovn-nbctl lrp-set-gateway-chassis lr0-public hv1 20
ovn-nbctl lr-nat-add lr0 snat 172.168.0.100 10.0.0.0/24
ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.168.0.110 10.0.0.4 sw0-port2 f0:00:00:01:02:04
ovn-nbctl lr-nat-add lr0 snat 2000::1 1000::/64
ovn-nbctl lr-nat-add lr0 dnat_and_snat 2000::2 1000::4 sw0-port2 f0:00:00:01:02:04

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-port1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-port2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1

# IPv4 outgoing traffic generated inside the cluster
test_ip_packet_larger() {
    local mtu=$1

    # Send ip packet from sw0-port1 to outside
    src_mac="505400000001" # sw-port1 mac
    dst_mac="00000000ff01" # sw0-lr0 mac (internal router leg)
    src_ip=`ip_to_hex 10 0 0 3`
    dst_ip=`ip_to_hex 172 168 0 3`
    # Set the packet length to 114.
    pkt_len=0072
    packet=${dst_mac}${src_mac}08004500${pkt_len}000000004001c3dd
    orig_packet_l3=${src_ip}${dst_ip}0800f7ff00000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}0000000000000000000000000000

    packet=${packet}${orig_packet_l3}

    gw_ip_garp=ffffffffffff00002020121308060001080006040001000020201213aca80064000000000000aca80064

    packet_bytes=$(expr ${#packet} / 2)
    mtu_needed=$(expr ${packet_bytes} - 14)

    # If icmp_pmtu_reply_expected is 0, it means the packet is lesser than
    # the gateway mtu and should be delivered to the provider bridge via the
    # localnet port.
    # If icmp_pmtu_reply_expected is 1, it means the packet is larger than
    # the gateway mtu and ovn-controller should drop the packet and instead
    # generate ICMPv4  Destination Unreachable message with pmtu set to 100.
    if test $mtu -ge $mtu_needed; then
        # Packet to expect at br-phys.
        src_mac="000020201213"
        dst_mac="00000012af11"
        src_ip=`ip_to_hex 172 168 0 100`
        dst_ip=`ip_to_hex 172 168 0 3`
        expected=${dst_mac}${src_mac}08004500${pkt_len}000000003f0121d4
        expected=${expected}${src_ip}${dst_ip}0800f7ff00000000
        expected=${expected}000000000000000000000000000000000000
        expected=${expected}000000000000000000000000000000000000
        expected=${expected}000000000000000000000000000000000000
        expected=${expected}000000000000000000000000000000000000
        expected=${expected}0000000000000000000000000000
        echo $expected > br_phys_n1.expected
    else
        src_ip=`ip_to_hex 172.168.0.100`
        dst_ip=`ip_to_hex 10 0 0 3`
        # pkt len should be 146 (28 (icmp packet) + 118 (orig ip + payload))
        reply_pkt_len=008e
        ip_csum=fc97
        icmp_reply=${src_mac}${dst_mac}08004500${reply_pkt_len}00004000fe01c55f
        icmp_reply=${icmp_reply}${src_ip}${dst_ip}0304${ip_csum}0000$(printf "%04x" $mtu)
        icmp_reply=${icmp_reply}4500${pkt_len}000000003f01c4dd
        icmp_reply=${icmp_reply}${orig_packet_l3}
        echo $icmp_reply > hv1-vif1.expected
    fi

    as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
    as hv1 reset_pcap_file hv1-vif1 hv1/vif1

    # Send packet from sw0-port1 to outside
    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

    if test $mtu -ge $mtu_needed; then
        # Ignore gratuitous ARPs; there is no guarantee to get them here as they might
        # already have been generated
        OVN_CHECK_PACKETS_CONTAIN([hv1/br-phys_n1-tx.pcap], [br_phys_n1.expected])
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap  > pkts
        # hv1/vif1-tx.pcap can receive the GARP packet generated by ovn-controller
        # for the gateway router port. So ignore this packet.
        cat pkts | grep -v $gw_ip_garp > packets
        AT_CHECK([cat packets], [0], [])
    else
        OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [hv1-vif1.expected])
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys_n1-tx.pcap  > \
        pkts
        # hv1/br-phys_n1-tx.pcap can receive the GARP packet generated by ovn-controller
        # for the gateway router port. So ignore this packet.
        cat pkts | grep -v $gw_ip_garp > packets
        AT_CHECK([cat packets], [0], [])
    fi
}

# IPv4 ingress traffic generated outside the cluster
test_ip_packet_larger_ext() {
    local idx=$1
    local checksum=$4
    local mtu=$5
    local reply_checksum=$6

    # Send ip packet from sw0-port1 to outside
    src_mac="00000012af11" # external mac
    dst_mac="$2" # lr0-public mac
    src_ip=`ip_to_hex 172 168 0 4`
    dst_ip="$3"
    # Set the packet length to 114.
    pkt_len=0072
    packet=${dst_mac}${src_mac}08004500${pkt_len}000000004001${checksum}
    orig_packet_l3=${src_ip}${dst_ip}0800f7ff00000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}000000000000000000000000000000000000
    orig_packet_l3=${orig_packet_l3}0000000000000000000000000000
    packet=${packet}${orig_packet_l3}

    # A Gratuitous ARP (as shown next line) might be transmitted, but
    # it is also possible that it was transmitted earlier, so do not wait for it.
    # optional_gw_ip_garp=ffffffffffff00002020121308060001080006040001000020201213aca80064000000000000aca80064
    ext_ip_garp=ffffffffffff00000012af110806000108000604000100000012af11aca80004000000000000aca80004

    src_ip="$3"
    dst_ip=`ip_to_hex 172 168 0 4`
    # pkt len should be 146 (28 (icmp packet) + 118 (orig ip + payload))
    reply_pkt_len=008e
    ip_csum=$7
    icmp_reply=${src_mac}${dst_mac}08004500${reply_pkt_len}00004000fe01${reply_checksum}
    icmp_reply=${icmp_reply}${src_ip}${dst_ip}0304${ip_csum}0000$(printf "%04x" $mtu)
    icmp_reply=${icmp_reply}4500${pkt_len}000000004001${checksum}
    icmp_reply=${icmp_reply}${orig_packet_l3}
    echo $icmp_reply > br-phys_n1.expected

    as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
    as hv1 reset_pcap_file hv1-vif${idx} hv1/vif${idx}

    check as hv1 ovs-appctl netdev-dummy/receive br-phys_n1 $ext_ip_garp
    sleep 1
    # Send packet from sw0-port1 to outside
    check as hv1 ovs-appctl netdev-dummy/receive br-phys_n1 $packet

    OVN_CHECK_PACKETS_CONTAIN([hv1/br-phys_n1-tx.pcap], [br-phys_n1.expected])
}

# IPv6 outgoing traffic generated inside the cluster
test_ip6_packet_larger() {
    local mtu=$1

    local eth_src=505400000001
    local eth_dst=00000000ff01

    local ipv6_src=10000000000000000000000000000003
    local ipv6_dst=20000000000000000000000000000002
    local ipv6_rt=20000000000000000000000000000001

    local payload=0000000000000000000000000000000000000000
    local payload=${payload}0000000000000000000000000000000000000000
    local payload=${payload}0000000000000000000000000000000000000000
    local payload=${payload}00000000000000000000000000000000

    local ip6_hdr=6000000000543afe${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}8000ec7a62f00001${payload}

    as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
    as hv1 reset_pcap_file hv1-vif1 hv1/vif1

    # Send packet from sw0-port1 to outside
    tcpdump_hex ">> sending packet:" $packet
    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
    AT_CHECK([as hv1 ovs-appctl ofproto/trace br-int in_port=hv1-vif1 $packet > trace-$mtu],
             [0], [ignore])
    AT_CAPTURE_FILE([trace-$mtu])

    packet_bytes=$(expr ${#packet} / 2)
    mtu_needed=$(expr ${packet_bytes} - 14)
    if test $mtu -lt $mtu_needed; then
        # First construct the inner IPv6 packet.
        inner_ip6=6000000000543afd${ipv6_src}${ipv6_dst}
        inner_icmp6=8000000062f00001
        inner_icmp6_and_payload=$(icmp6_csum_inplace ${inner_icmp6}${payload} ${inner_ip6})
        inner_packet=${inner_ip6}${inner_icmp6_and_payload}

        # Then the outer.
        outer_ip6=6000000000843afe${ipv6_rt}${ipv6_src}
        outer_icmp6_and_payload=$(icmp6_csum_inplace 020000000000$(printf "%04x" $mtu)${inner_packet} $outer_ip6)
        outer_packet=${outer_ip6}${outer_icmp6_and_payload}

        icmp6_reply=${eth_src}${eth_dst}86dd${outer_packet}

        echo
        tcpdump_hex ">> expecting reply packet" $icmp6_reply

        # The "trace" above sends a second packets as a side effect.
        (echo $icmp6_reply; echo $icmp6_reply) > hv1-vif1.expected

        OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [hv1-vif1.expected])
    fi
}

# IPv6 ingress traffic generated outside the cluster
test_ip6_packet_larger_ext() {
    local idx=$1
    local mtu=$4
    local icmp_checksum=$5

    local eth_src=00000012af11
    local eth_dst=$2

    local ipv6_src=20000000000000000000000000000004
    local ipv6_dst=$3

    local payload=0000000000000000000000000000000000000000
    local payload=${payload}0000000000000000000000000000000000000000
    local payload=${payload}0000000000000000000000000000000000000000
    local payload=${payload}00000000000000000000000000000000

    local ip6_hdr=6000000000543afe${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}9000${icmp_checksum}62f00001${payload}

    # Some ** ARP ** packets might still be received - ignore them
    as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
    as hv1 reset_pcap_file hv1-vif${idx} hv1/vif${idx}

    local na_ip6_hdr=6000000000203aff${ipv6_src}${ipv6_dst}
    local na=${eth_dst}${eth_src}86dd${na_ip6_hdr}8800d78440000000${ipv6_src}0201${eth_src}
    check as hv1 ovs-appctl netdev-dummy/receive br-phys_n1 $na
    sleep 1
    check as hv1 ovs-appctl netdev-dummy/receive br-phys_n1 $packet
    AT_CAPTURE_FILE([trace-$mtu])

    # First construct the inner IPv6 packet.
    inner_ip6=6000000000543afe${ipv6_src}${ipv6_dst}
    inner_icmp6=9000000062f00001
    inner_icmp6_and_payload=$(icmp6_csum_inplace ${inner_icmp6}${payload} ${inner_ip6})
    inner_packet=${inner_ip6}${inner_icmp6_and_payload}

    # Then the outer.
    outer_ip6=6000000000843afe${ipv6_dst}${ipv6_src}
    outer_icmp6_and_payload=$(icmp6_csum_inplace 020000000000$(printf "%04x" $mtu)${inner_packet} $outer_ip6)
    outer_packet=${outer_ip6}${outer_icmp6_and_payload}

    icmp6_reply=${eth_src}${eth_dst}86dd${outer_packet}
    echo $icmp6_reply > br-phys_n1.expected

    OVN_CHECK_PACKETS_CONTAIN([hv1/br-phys_n1-tx.pcap], [br-phys_n1.expected])
}

wait_for_ports_up
ovn-nbctl --wait=hv sync

ovn-nbctl show > nbdump
AT_CAPTURE_FILE([nbdump])

ovn-sbctl show > sbdump
AT_CAPTURE_FILE([sbdump])

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int  \
| grep "check_pkt_larger" | wc -l], [0], [[0
]])
dp_uuid=$(ovn-sbctl find datapath_binding | grep sw0 -B2 | grep _uuid | \
awk '{print $3}')
ovn-sbctl create MAC_Binding ip=172.168.0.3 datapath=$dp_uuid \
logical_port=lr0-public mac="00\:00\:00\:12\:af\:11"

# Try different gateway mtus and send a 142-byte packet (corresponding
# to a 124-byte MTU).  If the MTU is less than 124, ovn-controller
# should send icmp host not reachable with pmtu set to $mtu.
for mtu in 100 500 114; do
    AS_BOX([testing mtu $mtu])
    check ovn-nbctl --wait=hv set logical_router_port lr0-public options:gateway_mtu=$mtu
    ovn-sbctl dump-flows > sbflows-$mtu
    AT_CAPTURE_FILE([sbflows-$mtu])

    OVS_WAIT_FOR_OUTPUT([
        as hv1 ovs-ofctl dump-flows br-int > br-int-flows-$mtu
        AT_CAPTURE_FILE([br-int-flows-$mtu])
        grep "check_pkt_larger($(expr $mtu + 14))" br-int-flows-$mtu | wc -l], [0], [4
])

    AS_BOX([testing outgoing traffic mtu $mtu - IPv4])
    test_ip_packet_larger $mtu

    AS_BOX([testing outgoing traffic mtu $mtu - IPv6])
    test_ip6_packet_larger $mtu
done

AS_BOX([testing mtu 100])
check ovn-nbctl --wait=hv set logical_router_port lr0-public options:gateway_mtu=100
ovn-sbctl dump-flows > ext-sbflows-100
AT_CAPTURE_FILE([ext-sbflows-100])

OVS_WAIT_FOR_OUTPUT([
    as hv1 ovs-ofctl dump-flows br-int > ext-br-int-flows-100
    AT_CAPTURE_FILE([ext-br-int-flows-100])
    grep "check_pkt_larger(114)" ext-br-int-flows-100 | wc -l], [0], [4
])

AS_BOX([testing ingress traffic mtu 100 - IPv4])
test_ip_packet_larger_ext 1 000020201213 $(ip_to_hex 172 168 0 100) 20d3 100 22b6 fc97

AS_BOX([testing ingress traffic mtu 100 - IPv4 FIP])
test_ip_packet_larger_ext 2 f00000010204 $(ip_to_hex 172 168 0 110) 20c5 100 22ac fc9b

AS_BOX([testing ingress traffic mtu 100 - IPv6])
test_ip6_packet_larger_ext 1 000020201213 20000000000000000000000000000001 100 cc7a

AS_BOX([testing ingress traffic mtu 100 - IPv6 FIP])
test_ip6_packet_larger_ext 2 f00000010204 20000000000000000000000000000002 100 cc79

ovn-nbctl lsp-del sw0-lr0

ovn-nbctl lr-del lr0
ovn-nbctl create Logical_Router name=lr1 options:chassis="hv1"
ovn-nbctl lrp-add lr1 lr1-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::1/64
ovn-nbctl lsp-add sw0 sw0-lr1
ovn-nbctl lsp-set-type sw0-lr1 router
ovn-nbctl lsp-set-addresses sw0-lr1 router
ovn-nbctl lsp-set-options sw0-lr1 router-port=lr1-sw0

ovn-nbctl lrp-add lr1 lr1-public 00:00:20:20:12:13 172.168.0.100/24 2000::1/64
ovn-nbctl lsp-del public-lr0
ovn-nbctl lsp-add public public-lr1
ovn-nbctl lsp-set-type public-lr1 router
ovn-nbctl lsp-set-addresses public-lr1 router
ovn-nbctl lsp-set-options public-lr1 router-port=lr1-public

ovn-nbctl lr-nat-add lr1 snat 172.168.0.100 10.0.0.0/24
ovn-nbctl lr-nat-add lr1 snat 2000::1 1000::/64
ovn-nbctl --wait=sb sync

dp_uuid=$(ovn-sbctl find datapath_binding | grep sw0 -B2 | grep _uuid | \
awk '{print $3}')
ovn-sbctl create MAC_Binding ip=172.168.0.3 datapath=$dp_uuid \
logical_port=lr1-public mac="00\:00\:00\:12\:af\:11"

# Try different gateway mtus and send a 142-byte packet (corresponding
# to a 124-byte MTU).  If the MTU is less than 124, ovn-controller
# should send icmp host not reachable with pmtu set to $mtu.
for mtu in 100 500 114; do
    AS_BOX([testing gw mtu $mtu])
    check ovn-nbctl --wait=hv set logical_router_port lr1-public options:gateway_mtu=$mtu
    ovn-sbctl dump-flows > sbflows-gw-$mtu
    AT_CAPTURE_FILE([sbflows-gw-$mtu])

    OVS_WAIT_FOR_OUTPUT([
        as hv1 ovs-ofctl dump-flows br-int > br-int-gw-flows-$mtu
        AT_CAPTURE_FILE([br-int-gw-flows-$mtu])
        grep "check_pkt_larger($(expr $mtu + 14))" br-int-gw-flows-$mtu | wc -l], [0], [3
])

    AS_BOX([testing outgoing traffic mtu $mtu for gw router - IPv4])
    test_ip_packet_larger $mtu

    AS_BOX([testing outgoing traffic mtu $mtu for gw router - IPv6])
    test_ip6_packet_larger $mtu
done

AS_BOX([testing gw router mtu 100])
check ovn-nbctl --wait=hv set logical_router_port lr1-public options:gateway_mtu=100
ovn-sbctl dump-flows > ext-gw-sbflows-100
AT_CAPTURE_FILE([ext-gw-sbflows-100])

OVS_WAIT_FOR_OUTPUT([
    as hv1 ovs-ofctl dump-flows br-int > ext-br-int-gw-flows-100
    AT_CAPTURE_FILE([ext-br-int-gw-flows-100])
    grep "check_pkt_larger(114)" ext-br-int-gw-flows-100 | wc -l], [0], [3
])

AS_BOX([testing ingress traffic mtu 100 for gw router - IPv4])
test_ip_packet_larger_ext 1 000020201213 $(ip_to_hex 172 168 0 100) 20d3 100 22b6 fc97

AS_BOX([testing ingress traffic mtu 100 for gw router - IPv6])
test_ip6_packet_larger_ext 1 000020201213 20000000000000000000000000000001 100 cc7a fc9b

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IP packet buffering])
AT_KEYWORDS([ip-buffering])
ovn_start

# Logical network:
# One LR lr0 that has switches sw0 (192.168.1.0/24) and
# sw1 (172.16.1.0/24) connected to it.
#
# Physical network:
# Tw0 hypervisors hv[12].
# hv1 hosts vif sw0-p0.
# hv2 hosts vif sw1-p0 and sw0-p1

send_icmp_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7 data=$8
    shift 8

    local ip_ttl=ff
    local ip_len=001c
    local packet=${eth_dst}${eth_src}08004500${ip_len}00004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}${data}
    as hv$hv ovs-appctl netdev-dummy/receive hv$hv-vif$inport $packet
}

send_icmp6_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6 ipv6_router=$7 exp_icmp_chksum=$8
    shift 8

    local ip6_hdr=6000000000083aff${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}8000dcb662f00001

    as hv$hv ovs-appctl netdev-dummy/receive hv$hv-vif$inport $packet
}

get_arp_req() {
    local eth_src=$1 spa=$2 tpa=$3
    local request=ffffffffffff${eth_src}08060001080006040001${eth_src}${spa}000000000000${tpa}
    echo $request
}

send_arp_reply() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040002${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

send_na() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 src_ip=$5 dst_ip=$6
    local ip6_hdr=6000000000203aff${src_ip}${dst_ip}
    local request=${eth_dst}${eth_src}86dd${ip6_hdr}8800d78440000000${src_ip}0201${eth_src}

    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

get_nd() {
    local eth_src=$1 src_ip=$2 dst_ip=$3 ta=$4
    local ip6_hdr=6000000000203aff${src_ip}${dst_ip}
    request=3333ff000010${eth_src}86dd${ip6_hdr}870051f400000000${ta}0101${eth_src}

    echo $request
}

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p0 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p0 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=2
ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=3

ovn-nbctl create Logical_Router name=lr0
ovn-nbctl ls-add sw0
ovn-nbctl ls-add sw1

ovn-nbctl lrp-add lr0 sw0 00:00:01:01:02:03 192.168.1.1/24 2001:0:0:0:0:0:0:1/64
ovn-nbctl lsp-add sw0 rp-sw0 -- set Logical_Switch_Port rp-sw0 \
    type=router options:router-port=sw0 \
    -- lsp-set-addresses rp-sw0 router

ovn-nbctl lrp-add lr0 sw1 00:00:02:01:02:03 172.16.1.1/24 2002:0:0:0:0:0:0:1/64 \
    -- lrp-set-gateway-chassis sw1 hv2
ovn-nbctl lsp-add sw1 rp-sw1 -- set Logical_Switch_Port rp-sw1 \
    type=router options:router-port=sw1 \
    -- lsp-set-addresses rp-sw1 router

ovn-nbctl lsp-add sw0 sw0-p0 \
    -- lsp-set-addresses sw0-p0 "f0:00:00:01:02:03 192.168.1.2 2001::2"

ovn-nbctl lsp-add sw0 sw0-p1 \
    -- lsp-set-addresses sw0-p1 "f0:00:00:11:02:03 192.168.1.3 2001::3"

ovn-nbctl lsp-add sw1 sw1-p0 \
    -- lsp-set-addresses sw1-p0 unknown

ovn-nbctl lr-nat-add lr0 snat 172.16.1.1 192.168.1.0/24
ovn-nbctl lr-nat-add lr0 snat 2002::1 2001::/64

OVN_POPULATE_ARP
wait_for_ports_up
ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

src_mac=f00000010203
src_ip=$(ip_to_hex 192 168 1 2)
src_ip6=20010000000000000000000000000002

router_mac0=000001010203
router_mac1=000002010203
router_ip=$(ip_to_hex 172 16 1 1)
router_ip6=20020000000000000000000000000001

nd_src_ip6=fe80000000000000020002fffe010203

dst_mac=001122334455
dst_ip=$(ip_to_hex 172 16 1 10)
dst_ip6=20020000000000000000000000000010

data=0800bee4391a0001

send_icmp_packet 1 1 $src_mac $router_mac0 $src_ip $dst_ip 0d1c $data
send_arp_reply 2 1 $dst_mac $router_mac1 $dst_ip $router_ip
echo $(get_arp_req $router_mac1 $router_ip $dst_ip) > expected
echo "${dst_mac}${router_mac1}08004500001c00004000fe0122b5${router_ip}${dst_ip}${data}" >> expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

nd_ip=ff0200000000000000000001ff000010
ip6_hdr=6000000000083afe${router_ip6}${dst_ip6}

send_icmp6_packet 1 1 $src_mac $router_mac0 $src_ip6 $dst_ip6
echo $(get_nd $router_mac1 $nd_src_ip6 $nd_ip $dst_ip6) >> expected
echo "${dst_mac}${router_mac1}86dd${ip6_hdr}8000dcb662f00001" >> expected
send_na 2 1 $dst_mac $router_mac1 $dst_ip6 $router_ip6

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# Create FIP on sw0-p0, add a route on logical router pipeline and
# ARP request for a unkwon destination is sent using FIP MAC/IP
ovn-nbctl lr-nat-del lr0 snat
ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.16.1.2 192.168.1.3 sw0-p1 f0:00:00:01:02:04
ovn-nbctl lr-route-add lr0 172.16.2.0/24 172.16.1.11
ovn-nbctl --wait=hv sync
ovn-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

# create a route policy for pkt marking
check ovn-nbctl lr-policy-add lr0 2000 "ip4.src == 192.168.1.3" allow
policy=$(fetch_column nb:Logical_Router_Policy _uuid priority=2000)
check ovn-nbctl set logical_router_policy $policy options:pkt_mark=100
check ovn-nbctl --wait=hv sync
as hv2
# add a flow in egress pipeline to check pkt marking
ovs-ofctl --protocols=OpenFlow13 add-flow br-int "table=37,priority=200,ip,nw_src=172.16.1.2,pkt_mark=0x64 actions=resubmit(,38)"

dst_ip=$(ip_to_hex 172 16 2 10)
fip_ip=$(ip_to_hex 172 16 1 2)
src_ip=$(ip_to_hex 192 168 1 3)
gw_router_ip=$(ip_to_hex 172 16 1 11)
gw_router_mac=f00000010a0a
send_icmp_packet 2 2 f00000110203 $router_mac0 $src_ip $dst_ip 0c1b $data
echo $(get_arp_req f00000010204 $fip_ip $gw_router_ip) >> expected
send_arp_reply 2 1 $gw_router_mac f00000010204 $gw_router_ip $fip_ip
echo "${gw_router_mac}f0000001020408004500001c00004000fe0121b4${fip_ip}${dst_ip}${data}" >> expected

OVS_WAIT_UNTIL([test 1 = `as hv2 ovs-ofctl dump-flows br-int table=37 | grep pkt_mark=0x64 | grep -c n_packets=1`])

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([neighbor update on same HV])
ovn_start

# Logical network:
# A public switch (pub) with a localnet port connected to two LRs (lr0 and lr1)
# each with a distributed gateway port.
# Two VMs: lp0 on sw0 connected to lr0
#          lp1 on sw1 connected to lr1
#
# This test adds a floating IP to each VM so when they are bound to the same
# hypervisor, it checks that the GARP sent by ovn-controller causes the
# MAC_Binding entries to be updated properly on each logical router.
# It will also capture packets on the physical interface to make sure that the
# GARPs have been sent out to the external network as well.

# Create logical switches
check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add pub

# Created localnet port on public switch
check ovn-nbctl lsp-add pub ln-pub
check ovn-nbctl lsp-set-type ln-pub localnet
check ovn-nbctl lsp-set-addresses ln-pub unknown
check ovn-nbctl lsp-set-options ln-pub network_name=phys

# Create logical routers and connect them to public switch
AT_CHECK([(ovn-nbctl create Logical_Router name=lr0;
           ovn-nbctl create Logical_Router name=lr1) | uuidfilt], [0], [<0>
<1>
])

check ovn-nbctl lrp-add lr0 lr0-pub f0:00:00:00:00:01 172.24.4.220/24
check ovn-nbctl lsp-add pub pub-lr0 -- set Logical_Switch_Port pub-lr0 \
    type=router options:router-port=lr0-pub options:nat-addresses="router" addresses="router"
check ovn-nbctl lrp-add lr1 lr1-pub f0:00:00:00:01:01 172.24.4.221/24
check ovn-nbctl lsp-add pub pub-lr1 -- set Logical_Switch_Port pub-lr1 \
    type=router options:router-port=lr1-pub options:nat-addresses="router" addresses="router"

check ovn-nbctl lrp-set-gateway-chassis lr0-pub hv1 10
check ovn-nbctl lrp-set-gateway-chassis lr1-pub hv1 10

# Connect sw0 and sw1 to lr0 and lr1
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.254/24
check ovn-nbctl lsp-add sw0 sw0-lr0 -- set Logical_Switch_Port sw0-lr0 type=router \
    options:router-port=lr0-sw0 addresses="router"
check ovn-nbctl lrp-add lr1 lr1-sw1 00:00:00:00:ff:02 20.0.0.254/24
check ovn-nbctl lsp-add sw1 sw1-lr1 -- set Logical_Switch_Port sw1-lr1 type=router \
    options:router-port=lr1-sw1 addresses="router"


# Add SNAT rules
check ovn-nbctl lr-nat-add lr0 snat 172.24.4.220 10.0.0.0/24
check ovn-nbctl lr-nat-add lr1 snat 172.24.4.221 20.0.0.0/24

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 172.24.4.1
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

check ovs-vsctl add-port br-int vif0 -- set Interface vif0 external-ids:iface-id=lp0
check ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lp1

check ovn-nbctl lsp-add sw0 lp0
check ovn-nbctl lsp-add sw1 lp1
check ovn-nbctl lsp-set-addresses lp0 "50:54:00:00:00:01 10.0.0.10"
check ovn-nbctl lsp-set-addresses lp1 "50:54:00:00:00:02 20.0.0.10"

OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp0` = xup])
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp1` = xup])

# Create two floating IPs, one for each VIF
check ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.24.4.100 10.0.0.10
check ovn-nbctl lr-nat-add lr1 dnat_and_snat 172.24.4.200 20.0.0.10

# Check that the MAC_Binding entries have been properly created
wait_row_count MAC_Binding 1 logical_port=lr0-pub ip=172.24.4.200
wait_row_count MAC_Binding 1 logical_port=lr1-pub ip=172.24.4.100

# Check that the GARPs went also to the external physical network
# Wait until at least 4 packets have arrived and copy them to a separate file as
# more GARPs are expected in the capture in order to avoid race conditions.
#
# The expected output is:
# GARP for lp0 172.24.4.100 on lr0-pub MAC (f0:00:00:00:00:01)
# GARP for 172.24.4.220 on lr0-pub (f0:00:00:00:00:01)
# GARP for lp1 172.24.4.200 on lr1-pub MAC (f0:00:00:00:01:01)
# GARP for 172.24.4.221 on lr1-pub (f0:00:00:00:01:01)

OVS_WAIT_FOR_OUTPUT(
  [$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/br-phys-tx.pcap | sort | uniq],
  [0],
  [fffffffffffff0000000000108060001080006040001f00000000001ac180464000000000000ac180464
fffffffffffff0000000000108060001080006040001f00000000001ac1804dc000000000000ac1804dc
fffffffffffff0000000010108060001080006040001f00000000101ac1804c8000000000000ac1804c8
fffffffffffff0000000010108060001080006040001f00000000101ac1804dd000000000000ac1804dd
])

# Now make sure that always_learn_from_arp_request=false is also honored
# for locally injected mac bindings.
check ovn-nbctl set logical_router lr0 options:always_learn_from_arp_request=false
check ovn-nbctl set logical_router lr1 options:always_learn_from_arp_request=false
check ovn-nbctl --wait=hv sync

# Recreate two floating IPs, one for each VIF.
check ovn-nbctl lr-nat-del lr0 dnat_and_snat 172.24.4.100
check ovn-nbctl lr-nat-del lr1 dnat_and_snat 172.24.4.200
check ovn-nbctl --wait=hv sync

check ovn-sbctl --all destroy mac_binding

# Create a mac_binding entry on lr0-pub for 172.24.4.200 with a
# wrong mac, expecting it to be updated with the real mac.
lr0_dp=$(fetch_column Datapath_Binding _uuid external_ids:name=lr0)
ovn-sbctl create mac_binding datapath=$lr0_dp logical_port=lr0-pub \
    ip=172.24.4.200 mac=\"aa:aa:aa:aa:aa:aa\"

check ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.24.4.100 10.0.0.10
check ovn-nbctl lr-nat-add lr1 dnat_and_snat 172.24.4.200 20.0.0.10
check ovn-nbctl --wait=hv sync

check_row_count MAC_Binding 1 logical_port=lr0-pub ip=172.24.4.200
check_row_count MAC_Binding 0 logical_port=lr1-pub ip=172.24.4.100
check_column "f0:00:00:00:01:01" MAC_Binding mac logical_port=lr0-pub \
                                                 ip=172.24.4.200

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ipam to non-ipam])
ovn_start

check ovn-nbctl --wait=sb sync
ovn-nbctl --wait=hv set NB_Global . options:mac_prefix="0a:00:00:00:00:00"
ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 p0 -- lsp-set-addresses p0 dynamic
ovn-nbctl --wait=sb add Logical-Switch sw0 other_config subnet=192.168.1.0/24

AT_CHECK([ovn-nbctl get Logical-Switch-Port p0 dynamic_addresses], [0],
    ["0a:00:00:a8:01:03 192.168.1.2"
])

ovn-nbctl --wait=sb lsp-set-addresses p0 router

ovn-nbctl get Logical-Switch-Port p0 dynamic_addresses

AT_CHECK([ovn-nbctl get Logical-Switch-Port p0 dynamic_addresses], [0], [[[]]
])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ipam router ports])
ovn_start

ovn-nbctl ls-add sw
ovn-nbctl set logical_switch sw other-config:subnet=192.168.1.0/24

for i in 2 3 4; do
    ovn-nbctl lr-add ro$i
    ovn-nbctl lsp-add sw swp$i
    ovn-nbctl --wait=sb lsp-set-addresses swp$i "02:00:00:00:00:0$i dynamic"
    cidr=$(ovn-nbctl get logical_switch_port swp$i dynamic_addresses |cut -f2 -d' '|cut -f1 -d\")
    ovn-nbctl lrp-add ro$i rop$i 02:00:00:00:00:0$i $cidr/24 -- set logical_switch_port swp$i type=router options:router-port=rop$i addresses=router;
    AT_CHECK_UNQUOTED([ovn-nbctl get logical_router_port rop$i networks], [0], [[["192.168.1.$i/24"]]
])
done

ovn-nbctl list logical_switch_port
ovn-nbctl list logical_router_port

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([test transport zones])
ovn_start

net_add n1
for i in 1 2 3 4 5; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.$i.1
done

dnl Wait for the changes to be propagated
wait_for_ports_up
check ovn-nbctl --wait=hv sync

dnl Assert that each Chassis has a tunnel formed to every other Chassis
as hv1
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv2-0
ovn-hv3-0
ovn-hv4-0
ovn-hv5-0
]])

as hv2
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv3-0
ovn-hv4-0
ovn-hv5-0
]])

as hv3
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv4-0
ovn-hv5-0
]])

as hv4
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv3-0
ovn-hv5-0
]])

as hv5
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv3-0
ovn-hv4-0
]])

dnl Let's now add some Chassis to different transport zones
dnl * hv1: Will be part of two transport zones: tz1 and tz2 so it
dnl   should have tunnels formed between the other two Chassis (hv2 and hv3)
dnl
dnl * hv2: Will be part of one transport zone: tz1. It should have a tunnel
dnl   to hv1 but not to hv3
dnl
dnl * hv3: Will be part of one transport zone: tz2. It should have a tunnel
dnl   to hv1 but not to hv2
dnl
dnl * hv4 and hv5: Will not have any TZ set so they will keep the tunnels
dnl   between themselves and remove the tunnels to other Chassis which now
dnl   belongs to some TZs
dnl
as hv1
ovs-vsctl set open . external-ids:ovn-transport-zones=tz1,tz2

as hv2
ovs-vsctl set open . external-ids:ovn-transport-zones=tz1

as hv3
ovs-vsctl set open . external-ids:ovn-transport-zones=tz2

dnl Wait for the changes to be propagated
check ovn-nbctl --wait=hv sync

as hv1
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv2-0
ovn-hv3-0
]])

as hv2
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
]])

as hv3
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
]])

as hv4
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv5-0
]])

as hv5
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv4-0
]])

dnl Removing the transport zones should make all Chassis to create
dnl tunnels between every other Chassis again
for i in 1 2 3; do
    as hv$i
    ovs-vsctl remove open . external-ids ovn-transport-zones
done

dnl Wait for the changes to be propagated
check ovn-nbctl --wait=hv sync

as hv1
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv2-0
ovn-hv3-0
ovn-hv4-0
ovn-hv5-0
]])

as hv2
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv3-0
ovn-hv4-0
ovn-hv5-0
]])

as hv3
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv4-0
ovn-hv5-0
]])

as hv4
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv3-0
ovn-hv5-0
]])

as hv5
AT_CHECK([ovs-vsctl --bare --columns=name find interface type="geneve" | awk NF | sort], [0],
[[ovn-hv1-0
ovn-hv2-0
ovn-hv3-0
ovn-hv4-0
]])

OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 HVs, 2 lports/HV, localnet ports, DVR chassis mac])
ovn_start


# In this test cases we create 2 switches, all connected to same
# physical network (through br-phys on each HV). Each switch has
# 1 VIF. Each HV has 1 VIF port. The first digit
# of VIF port name indicates the hypervisor it is bound to, e.g.
# lp23 means VIF 3 on hv2.
#
# Each switch's VLAN tag and their logical switch ports are:
#   - ls1:
#       - tagged with VLAN 101
#       - ports: lp11
#   - ls2:
#       - tagged with VLAN 201
#       - ports: lp22
#
# Note: a localnet port is created for each switch to connect to
# physical network.

for i in 1 2; do
    ls_name=ls$i
    ovn-nbctl ls-add $ls_name
    ln_port_name=ln$i
    if test $i -eq 1; then
        ovn-nbctl lsp-add $ls_name $ln_port_name "" 101
    elif test $i -eq 2; then
        ovn-nbctl lsp-add $ls_name $ln_port_name "" 201
    fi
    ovn-nbctl lsp-set-addresses $ln_port_name unknown
    ovn-nbctl lsp-set-type $ln_port_name localnet
    ovn-nbctl lsp-set-options $ln_port_name network_name=phys
done

# lsp_to_ls LSP
#
# Prints the name of the logical switch that contains LSP.
lsp_to_ls () {
    case $1 in dnl (
        lp?[[11]]) echo ls1 ;; dnl (
        lp?[[12]]) echo ls2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_ls () {
    case $1 in dnl (
        vif?[[11]]) echo ls1 ;; dnl (
        vif?[[12]]) echo ls2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

hv_to_num () {
    case $1 in dnl (
        hv1) echo 1 ;; dnl (
        hv2) echo 2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_num () {
    case $1 in dnl (
        vif22) echo 22 ;; dnl (
        vif21) echo 21 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_hv () {
    case $1 in dnl (
        vif[[1]]?) echo hv1 ;; dnl (
        vif[[2]]?) echo hv2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_lrp () {
    echo router-to-`vif_to_ls $1`
}

hv_to_chassis_mac () {
     case $1 in dnl (
        hv[[1]]) echo aa:bb:cc:dd:ee:11 ;; dnl (
        hv[[2]]) echo aa:bb:cc:dd:ee:22 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

lrp_to_lrp_mac () {
     case $1 in dnl (
        router-to-ls[[1]]) echo 000001010203 ;; dnl (
        router-to-ls[[2]]) echo 000001010205 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:$i$i"
    ovn_attach n1 br-phys 192.168.0.$i

    ovs-vsctl add-port br-int vif$i$i -- \
        set Interface vif$i$i external-ids:iface-id=lp$i$i \
                              options:tx_pcap=hv$i/vif$i$i-tx.pcap \
                              options:rxq_pcap=hv$i/vif$i$i-rx.pcap \
                              ofport-request=$i$i

    lsp_name=lp$i$i
    ls_name=$(lsp_to_ls $lsp_name)

    ovn-nbctl lsp-add $ls_name $lsp_name
    ovn-nbctl lsp-set-addresses $lsp_name "f0:00:00:00:00:$i$i 192.168.$i.$i"
    ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:$i$i

    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])

done

ovn-nbctl lr-add router
ovn-nbctl lrp-add router router-to-ls1 00:00:01:01:02:03 192.168.1.3/24
ovn-nbctl lrp-add router router-to-ls2 00:00:01:01:02:05 192.168.2.3/24

ovn-nbctl lsp-add ls1 ls1-to-router -- set Logical_Switch_Port ls1-to-router type=router options:router-port=router-to-ls1 -- lsp-set-addresses ls1-to-router router
ovn-nbctl lsp-add ls2 ls2-to-router -- set Logical_Switch_Port ls2-to-router type=router options:router-port=router-to-ls2 -- lsp-set-addresses ls2-to-router router

wait_for_ports_up
ovn-nbctl --wait=sb sync
#ovn-sbctl dump-flows
for i in 1 2; do
    for j in 1 2; do
        OVN_WAIT_PATCH_PORT_FLOWS(["ln$j"], ["hv$i"])
    done
done

ovn-nbctl show
ovn-sbctl show

OVN_POPULATE_ARP

test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    hv=`vif_to_hv $inport`
    hv_num=`hv_to_num $hv`
    chassis_mac=`hv_to_chassis_mac $hv`
    as $hv ovs-appctl netdev-dummy/receive $inport $packet
    in_ls=`vif_to_ls $inport`
    in_lrp=`vif_to_lrp $inport`
    for outport; do
        out_ls=`vif_to_ls $outport`
        if test $in_ls = $out_ls; then
            # Ports on the same logical switch receive exactly the same packet.
            echo $packet
        else
            # Routing decrements TTL and updates source and dest MAC
            # (and checksum).
            outport_num=`vif_to_num $outport`
            out_lrp=`vif_to_lrp $outport`
            lrp_mac=`lrp_to_lrp_mac $out_lrp`
            echo f000000000${outport_num}${lrp_mac}08004500001c00000000"3f1101"00${src_ip}${dst_ip}0035111100080000

        fi >> $outport.expected
    done
}

# Dump a bunch of info helpful for debugging if there's a failure.

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-vsctl list Open_Vswitch

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-vsctl list Open_Vswitch

echo "Send traffic"
sip=`ip_to_hex 192 168 1 1`
dip=`ip_to_hex 192 168 2 2`
test_ip vif11 f00000000011  000001010203 $sip $dip vif22

echo "----------- Post Traffic hv1 dump -----------"
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int
as hv1 ovs-appctl fdb/show br-phys

echo "----------- Post Traffic hv2 dump -----------"
as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int
as hv2 ovs-appctl fdb/show br-phys

OVN_CHECK_PACKETS([hv2/vif22-tx.pcap], [vif22.expected])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([virtual ports])
AT_KEYWORDS([virtual ports])
ovn_start

send_nd_ns() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 ip6_src=$5 ip6_dst=$6 tgt_ip=$7
    local request=${eth_dst}${eth_src}86dd6000000000203aff${ip6_src}${ip6_dst}870005c900000000${tgt_ip}0101${eth_src}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}
send_garp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

send_arp_reply() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040002${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

send_icmp_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7 data=$8
    shift 8

    local ip_ttl=ff
    local ip_len=001c
    local packet=${eth_dst}${eth_src}08004500${ip_len}00004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}${data}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $packet
}

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p3 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2
ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

ovs-appctl -t ovn-controller vlog/set dbg

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=2

ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-vir
check ovn-nbctl lsp-set-addresses sw0-vir "50:54:00:00:00:10 10.0.0.10"
check ovn-nbctl lsp-set-port-security sw0-vir "50:54:00:00:00:10 10.0.0.10"
check ovn-nbctl lsp-set-type sw0-vir virtual
check ovn-nbctl set logical_switch_port sw0-vir options:virtual-ip=10.0.0.10
check ovn-nbctl set logical_switch_port sw0-vir options:virtual-parents=sw0-p1,sw0-p2,sw0-p3


check ovn-nbctl lsp-add sw0 sw0-vir6
check ovn-nbctl lsp-set-addresses sw0-vir6 "50:54:00:00:00:11 1000::61d1"
check ovn-nbctl lsp-set-port-security sw0-vir6 "50:54:00:00:00:11 1000::61d1"
check ovn-nbctl lsp-set-type sw0-vir6 virtual
check ovn-nbctl set logical_switch_port sw0-vir6 options:virtual-ip=1000::61d1
check ovn-nbctl set logical_switch_port sw0-vir6 options:virtual-parents=sw0-p1,sw0-p2,sw0-p3

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3 10.0.0.10 1000::3"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4 1000::4"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4 10.0.0.10 1000::4"

check ovn-nbctl lsp-add sw0 sw0-p3
check ovn-nbctl lsp-set-addresses sw0-p3 "50:54:00:00:00:05 10.0.0.5 1000::5"
check ovn-nbctl lsp-set-port-security sw0-p3 "50:54:00:00:00:05 10.0.0.5 10.0.0.10 1000::5"

# Create the second logical switch with one port
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1
check ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3 2000::3"
check ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3 2000::3"

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

# Add an ACL that matches on sw0-vir/sw0-vir6 being bound locally.
check ovn-nbctl acl-add sw0 to-lport 1000 'is_chassis_resident("sw0-vir") && ip4' allow
check ovn-nbctl acl-add sw0 to-lport 1000 'is_chassis_resident("sw0-vir6") && ip6' allow

check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24 2001:db8::1/64
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
check ovn-nbctl lsp-add public ln-public
check ovn-nbctl lsp-set-type ln-public localnet
check ovn-nbctl lsp-set-addresses ln-public unknown
check ovn-nbctl lsp-set-options ln-public network_name=public

# schedule the gw router port to a chassis. Change the name of the chassis
check ovn-nbctl --wait=hv lrp-set-gateway-chassis lr0-public hv1 20

check ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.168.0.50 10.0.0.10 sw0-vir 10:54:00:00:00:10
check ovn-nbctl lr-nat-add lr0 dnat_and_snat 2001:db8::61d1 1000::61d1 sw0-vir6 20:01:db:86:d1:10

OVN_POPULATE_ARP

wait_for_ports_up
ovn-nbctl --wait=hv sync

# Check that logical flows are added for sw0-vir/sw0vir6 in lsp_in_arp_rsp pipeline
# with bind_vport action.

ovn-sbctl dump-flows sw0 > sw0-flows
AT_CAPTURE_FILE([sw0-flows])

AT_CHECK([grep ls_in_arp_rsp sw0-flows | grep bind_vport | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p1" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p1" && ((nd_ns && ip6.dst == {1000::61d1, ff02::1:ff00:61d1} && nd.target == 1000::61d1) ||(nd_na && nd.target == 1000::61d1))), action=(bind_vport("sw0-vir6", inport); next;)
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p2" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p2" && ((nd_ns && ip6.dst == {1000::61d1, ff02::1:ff00:61d1} && nd.target == 1000::61d1) ||(nd_na && nd.target == 1000::61d1))), action=(bind_vport("sw0-vir6", inport); next;)
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p3" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p3" && ((nd_ns && ip6.dst == {1000::61d1, ff02::1:ff00:61d1} && nd.target == 1000::61d1) ||(nd_na && nd.target == 1000::61d1))), action=(bind_vport("sw0-vir6", inport); next;)
])

ovn-sbctl dump-flows lr0 > lr0-flows
AT_CAPTURE_FILE([lr0-flows])

hv1_ch_uuid=`ovn-sbctl --bare --columns _uuid find chassis name="hv1"`
hv2_ch_uuid=`ovn-sbctl --bare --columns _uuid find chassis name="hv2"`

AT_CHECK([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x], [0], [])

AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = x])
AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir6) = x])

# Try to bind sw0-vir directly to an OVS port. This should be ignored by
# ovn-controller.
as hv1
ovs-vsctl set interface hv1-vif3 external-ids:iface-id=sw0-vir

wait_column "" Port_Binding chassis logical_port=sw0-vir

# Cleanup hv1-vif3.
as hv1
ovs-vsctl del-port hv1-vif3

wait_column "" Port_Binding chassis logical_port=sw0-vir

check_virtual_offlows_present() {
    hv=$1

    sw0_dp_key=$(printf "%x" $(fetch_column Datapath_Binding tunnel_key external_ids:name=sw0))
    lr0_dp_key=$(printf "%x" $(fetch_column Datapath_Binding tunnel_key external_ids:name=lr0))
    lr0_public_dp_key=$(printf "%x" $(fetch_column Port_Binding tunnel_key logical_port=lr0-public))

    AT_CHECK_UNQUOTED([as $hv ovs-ofctl dump-flows br-int table=46,ip | ofctl_strip_all | grep "priority=2000"], [0], [dnl
 table=46, priority=2000,ip,metadata=0x$sw0_dp_key actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,47)
])

    AT_CHECK_UNQUOTED([as $hv ovs-ofctl dump-flows br-int table=11 | ofctl_strip_all | \
    grep "priority=92" | grep 172.168.0.50], [0], [dnl
 table=11, priority=92,arp,reg14=0x$lr0_public_dp_key,metadata=0x$lr0_dp_key,arp_tpa=172.168.0.50,arp_op=1 actions=move:NXM_OF_ETH_SRC[[]]->NXM_OF_ETH_DST[[]],mod_dl_src:10:54:00:00:00:10,load:0x2->NXM_OF_ARP_OP[[]],move:NXM_NX_ARP_SHA[[]]->NXM_NX_ARP_THA[[]],load:0x105400000010->NXM_NX_ARP_SHA[[]],push:NXM_OF_ARP_SPA[[]],push:NXM_OF_ARP_TPA[[]],pop:NXM_OF_ARP_SPA[[]],pop:NXM_OF_ARP_TPA[[]],move:NXM_NX_REG14[[]]->NXM_NX_REG15[[]],load:0x1->NXM_NX_REG10[[0]],resubmit(,37)
])
}

check_virtual_offlows_not_present() {
    hv=$1
    AT_CHECK([as $hv ovs-ofctl dump-flows br-int table=46,ip | ofctl_strip_all | grep "priority=2000"], [1], [dnl
])

    AT_CHECK([as $hv ovs-ofctl dump-flows br-int table=11 | ofctl_strip_all | \
    grep "priority=92" | grep 172.168.0.50], [1], [dnl
])
}

# From sw0-p0 send GARP for 10.0.0.10. hv1 should claim sw0-vir
# and sw0-p1 should be its virtual_parent.
eth_src=505400000003
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 10)
send_garp 1 1 $eth_src $eth_dst $spa $tpa

eth_dst=3333ff0061d1
ipv6_src=10000000000000000000000000000003
ipv6_dst=ff0200000000000000000001ff0061d1
ipv6_tgt=100000000000000000000000000061d1
send_nd_ns 1 1 $eth_src $eth_dst $ipv6_src $ipv6_dst $ipv6_tgt

wait_row_count Port_Binding 1 logical_port=sw0-vir chassis=$hv1_ch_uuid
check_row_count Port_Binding 1 logical_port=sw0-vir virtual_parent=sw0-p1
wait_for_ports_up sw0-vir
check ovn-nbctl --wait=hv sync
AT_CHECK([test 2 = `cat hv1/ovn-controller.log | grep "pinctrl received  packet-in" | \
grep opcode=BIND_VPORT | grep OF_Table_ID=29 | wc -l`])

wait_row_count Port_Binding 1 logical_port=sw0-vir6 chassis=$hv1_ch_uuid
check_row_count Port_Binding 1 logical_port=sw0-vir6 virtual_parent=sw0-p1
wait_for_ports_up sw0-vir6
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows lr0 > lr0-flows2
AT_CAPTURE_FILE([lr0-flows2])

# hv1 should add the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_present hv1

# hv2 should not have the above flows.
check_virtual_offlows_not_present hv2

# Forcibly clear virtual_parent. ovn-controller should release the binding
# gracefully.
pb_uuid=$(ovn-sbctl --bare --columns _uuid find port_binding logical_port=sw0-vir)
ovn-sbctl clear port_binding $pb_uuid virtual_parent

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x])

wait_row_count nb:Logical_Switch_Port 1 up=false name=sw0-vir

check ovn-nbctl --wait=hv sync

# verify the traffic from virtual port is discarded if the port is not claimed
AT_CHECK([grep lr_in_gw_redirect lr0-flows2 | grep "ip4.src == 10.0.0.10" | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_gw_redirect  ), priority=100  , match=(ip4.src == 10.0.0.10 && outport == "lr0-public" && is_chassis_resident("sw0-vir")), action=(eth.src = 10:54:00:00:00:10; reg1 = 172.168.0.50; next;)
  table=??(lr_in_gw_redirect  ), priority=80   , match=(ip4.src == 10.0.0.10 && outport == "lr0-public"), action=(drop;)
])

eth_src=505400000003
eth_dst=00000000ff01
ip_src=$(ip_to_hex 10 0 0 10)
ip_dst=$(ip_to_hex 172 168 0 101)
send_icmp_packet 1 1 $eth_src $eth_dst $ip_src $ip_dst c4c9 0000000000000000000000
AT_CHECK_UNQUOTED([as hv1 ovs-ofctl dump-flows br-int metadata=0x$lr0_dp_key | awk '/table=28, n_packets=1, n_bytes=45/{print $7" "$8}'],[0],[dnl
priority=80,ip,reg15=0x$lr0_public_dp_key,metadata=0x$lr0_dp_key,nw_src=10.0.0.10 actions=drop
])

# hv1 should remove the flow for the ACL with is_chassis_redirect check for sw0-vir.
check_virtual_offlows_not_present hv1

# hv2 should not have the flow for ACL.
check_virtual_offlows_not_present hv2

# From sw0-p0 resend GARP for 10.0.0.10. hv1 should reclaim sw0-vir
# and sw0-p1 should be its virtual_parent.
send_garp 1 1 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x$hv1_ch_uuid])

AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = xsw0-p1])

wait_for_ports_up sw0-vir

check ovn-nbctl --wait=hv sync
# hv1 should add the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_present hv1

# hv2 should not have the above flows.
check_virtual_offlows_not_present hv2

# Release sw0-p1.
as hv1 ovs-vsctl set interface hv1-vif1 external-ids:iface-id=sw0-px
wait_column "false" nb:Logical_Switch_Port up name=sw0-p1
wait_column "false" nb:Logical_Switch_Port up name=sw0-vir

check ovn-nbctl --wait=hv sync
# hv1 should remove the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_not_present hv1

# hv2 should not have the above flows.
check_virtual_offlows_not_present hv2

# Claim sw0-p1 again.
as hv1 ovs-vsctl set interface hv1-vif1 external-ids:iface-id=sw0-p1
wait_for_ports_up sw0-p1

# hv1 should not have the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_not_present hv1

# hv2 should not have the above flows.
check_virtual_offlows_not_present hv2

# From sw0-p0 send GARP for 10.0.0.10. hv1 should claim sw0-vir
# and sw0-p1 should be its virtual_parent.
eth_src=505400000003
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 10)
send_garp 1 1 $eth_src $eth_dst $spa $tpa

wait_row_count Port_Binding 1 logical_port=sw0-vir chassis=$hv1_ch_uuid
check_row_count Port_Binding 1 logical_port=sw0-vir virtual_parent=sw0-p1
wait_for_ports_up sw0-vir
check ovn-nbctl --wait=hv sync

# hv1 should add the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_present hv1

# hv2 should not have the above flows.
check_virtual_offlows_not_present hv2

# From sw0-p3 send GARP for 10.0.0.10. hv1 should claim sw0-vir
# and sw0-p3 should be its virtual_parent.
eth_src=505400000005
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 10)
send_garp 1 2 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x$hv1_ch_uuid])

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = xsw0-p3])

wait_for_ports_up sw0-vir

check ovn-nbctl --wait=hv sync
ovn-sbctl dump-flows lr0 > lr0-flows3
AT_CAPTURE_FILE([lr0-flows3])
cp ovn-sb/ovn-sb.db lr0-flows3.db

# hv1 should add the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_present hv1

# hv2 should not have the above flows.
check_virtual_offlows_not_present hv2

# send the garp from sw0-p2 (in hv2). hv2 should claim sw0-vir
# and sw0-p2 shpuld be its virtual_parent.
eth_src=505400000004
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 10)
send_garp 2 1 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x$hv2_ch_uuid])

AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = xsw0-p2])

wait_for_ports_up sw0-vir

check ovn-nbctl --wait=hv sync
ovn-sbctl dump-flows lr0 > lr0-flows4
AT_CAPTURE_FILE([lr0-flows4])

# hv2 should add the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_present hv2

# hv1 should not have the above flows.
check_virtual_offlows_not_present hv1

# Now send arp reply from sw0-p1. hv1 should claim sw0-vir
# and sw0-p1 shpuld be its virtual_parent.
eth_src=505400000003
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 4)
send_arp_reply 1 1 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x$hv1_ch_uuid])
sleep 1

AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = xsw0-p1])

wait_for_ports_up sw0-vir

check ovn-nbctl --wait=hv sync
ovn-sbctl dump-flows lr0 > lr0-flows5
AT_CAPTURE_FILE([lr0-flows5])

# hv1 should add the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_present hv1

# hv2 should not have the above flows.
check_virtual_offlows_not_present hv2

# Delete hv1-vif1 port. hv1 should release sw0-vir
as hv1 ovs-vsctl del-port hv1-vif1

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x])
sleep 1

AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = x])

wait_row_count nb:Logical_Switch_Port 1 up=false name=sw0-vir

check ovn-nbctl --wait=hv sync
ovn-sbctl dump-flows lr0 > lr0-flows6
AT_CAPTURE_FILE([lr0-flows6])

# hv1 should remove the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_not_present hv1

# hv2 should not have the above flows.
check_virtual_offlows_not_present hv2


# Now send arp reply from sw0-p2. hv2 should claim sw0-vir
# and sw0-p2 should be its virtual_parent.
eth_src=505400000004
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 3)
send_arp_reply 2 1 $eth_src $eth_dst $spa $tpa
sleep 1

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x$hv2_ch_uuid])
sleep 1
AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = xsw0-p2])

wait_for_ports_up sw0-vir

check ovn-nbctl --wait=hv sync
ovn-sbctl dump-flows lr0 > lr0-flows7
AT_CAPTURE_FILE([lr0-flows7])

# hv2 should add the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_present hv2

# hv1 should not have the above flows.
check_virtual_offlows_not_present hv1

# Delete sw0-p2 logical port
ovn-nbctl lsp-del sw0-p2

OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns chassis find port_binding \
logical_port=sw0-vir) = x])
AT_CHECK([test x$(ovn-sbctl --bare --columns virtual_parent find port_binding \
logical_port=sw0-vir) = x])

wait_row_count nb:Logical_Switch_Port 1 up=false name=sw0-vir

# Clear virtual_ip column of sw0-vir. There should be no bind_vport flows.
ovn-nbctl --wait=hv remove logical_switch_port sw0-vir options virtual-ip
ovn-nbctl --wait=hv remove logical_switch_port sw0-vir6 options virtual-ip

ovn-sbctl dump-flows sw0 > sw0-flows2
AT_CAPTURE_FILE([sw0-flows2])
AT_CHECK([grep ls_in_arp_rsp sw0-flows2 | grep bind_vport], [1])

# Add back virtual_ip and clear virtual_parents.
ovn-nbctl --wait=hv set logical_switch_port sw0-vir options:virtual-ip=10.0.0.10

check ovn-nbctl --wait=hv sync
ovn-sbctl dump-flows sw0 > sw0-flows3
AT_CAPTURE_FILE([sw0-flows3])
AT_CHECK([grep ls_in_arp_rsp sw0-flows3 | grep bind_vport | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p1" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p3" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
])

# hv2 should remove the flow for the ACL with is_chassis_redirect check for sw0-vir and
# arp responder flow in lr0 pipeline.
check_virtual_offlows_not_present hv2

# hv1 should not have the above flows.
check_virtual_offlows_not_present hv2

ovn-nbctl --wait=hv remove logical_switch_port sw0-vir options virtual-parents
ovn-sbctl dump-flows sw0 > sw0-flows4
AT_CAPTURE_FILE([sw0-flows4])
AT_CHECK([grep ls_in_arp_rsp sw0-flows4 | grep bind_vport], [1])

ovn-sbctl dump-flows lr0 > lr0-flows8
AT_CAPTURE_FILE([lr0-flows8])

# Delete sw0-vir and add again.
ovn-nbctl lsp-del sw0-vir

ovn-nbctl lsp-add sw0 sw0-vir
ovn-nbctl lsp-set-addresses sw0-vir "50:54:00:00:00:10 10.0.0.10"
ovn-nbctl lsp-set-port-security sw0-vir "50:54:00:00:00:10 10.0.0.10"
ovn-nbctl lsp-set-type sw0-vir virtual
ovn-nbctl set logical_switch_port sw0-vir options:virtual-ip=10.0.0.10
ovn-nbctl set logical_switch_port sw0-vir options:virtual-parents=sw0-p1,sw0-p2,sw0-p3

ovn-nbctl --wait=hv sync

# Check that logical flows are added for sw0-vir in lsp_in_arp_rsp pipeline
# with bind_vport action.

ovn-sbctl dump-flows sw0 > sw0-flows
AT_CAPTURE_FILE([sw0-flows])

AT_CHECK([grep ls_in_arp_rsp sw0-flows | grep bind_vport | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p1" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
  table=??(ls_in_arp_rsp      ), priority=100  , match=(inport == "sw0-p3" && ((arp.op == 1 && arp.spa == 10.0.0.10 && arp.tpa == 10.0.0.10) || (arp.op == 2 && arp.spa == 10.0.0.10))), action=(bind_vport("sw0-vir", inport); next;)
])

ovn-sbctl dump-flows lr0 > lr0-flows
AT_CAPTURE_FILE([lr0-flows])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# Run ovn-nbctl in daemon mode, change to a backup database and verify that
# an insert operation is not allowed.
AT_SETUP([can't write to a backup database server instance])
ovn_start
on_exit 'kill $(cat ovn-nbctl.pid)'
export OVN_NB_DAEMON=$(ovn-nbctl --pidfile --detach)

AT_CHECK([ovn-nbctl ls-add sw0])
as ovn-nb
AT_CHECK([ovs-appctl -t ovsdb-server ovsdb-server/sync-status | grep active | wc -l], [0], [1
])
ovs-appctl -t ovsdb-server ovsdb-server/set-active-ovsdb-server tcp:192.0.2.2:6641
ovs-appctl -t ovsdb-server ovsdb-server/connect-active-ovsdb-server
AT_CHECK([ovs-appctl -t ovsdb-server ovsdb-server/sync-status | grep -c backup], [0], [1
])
AT_CHECK([ovn-nbctl ls-add sw1], [1], [ignore],
[ovn-nbctl: transaction error: {"details":"insert operation not allowed when database server is in read only mode","error":"not allowed"}
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([controller event])
AT_KEYWORDS([ovn_controller_event])

ovn_start

# Create hypervisors hv[12].
# Add vif1[12] to hv1, vif2[12] to hv2
# Add all of the vifs to a single logical switch sw0.
# Create logical router lr0

net_add n1

ovn-nbctl create Logical_Router name=lr0 options:chassis=hv1
for i in 0 1; do
    idx=$((i+1))
    ovn-nbctl ls-add sw$i
    ovn-nbctl lrp-add lr0 lrp$i 00:00:00:00:ff:0$idx 192.168.$idx.254/24 200$idx::a/64
    ovn-nbctl \
        -- lsp-add sw$i lrp$i-attachment \
        -- set Logical_Switch_Port lrp$i-attachment type=router \
                         options:router-port=lrp$i \
                         addresses='"00:00:00:00:ff:'0$idx'"'
done

for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    for j in 1 2; do
        ovn-nbctl lsp-add sw0 sw0-p$i$j -- \
                lsp-set-addresses sw0-p$i$j "00:00:00:00:00:$i$j 192.168.1.$i$j 2001::$i$j"

        ovs-vsctl -- add-port br-int vif$i$j -- \
                set interface vif$i$j \
                external-ids:iface-id=sw0-p$i$j \
                options:tx_pcap=hv$i/vif$i$j-tx.pcap \
                options:rxq_pcap=hv$i/vif$i$j-rx.pcap \
                ofport-request=$i$j
    done
done

as hv1
ovn-nbctl lsp-add sw1 sw1-p0 \
    -- lsp-set-addresses sw1-p0 "00:00:00:00:00:33 192.168.2.11 2002::1"
ovs-vsctl -- add-port br-int vif33 -- \
        set interface vif33 \
        external-ids:iface-id=sw1-p0 \
        options:tx_pcap=hv$i/vif33-tx.pcap \
        options:rxq_pcap=hv$i/vif33-rx.pcap \
        ofport-request=33

ovn-nbctl --event lb-add lb0 192.168.1.100:80 ""
ovn-nbctl ls-lb-add sw0 lb0
uuid_lb0=$(ovn-nbctl --bare --columns=_uuid find load_balancer name=lb0)

ovn-nbctl --event lb-add lb1 192.168.2.100:80 ""
ovn-nbctl lr-lb-add lr0 lb1
uuid_lb1=$(ovn-nbctl --bare --columns=_uuid find load_balancer name=lb1)

ovn-nbctl --event lb-add lb2 [[2001::10]]:50051 ""
ovn-nbctl ls-lb-add sw0 lb2
uuid_lb2=$(ovn-nbctl --bare --columns=_uuid find load_balancer name=lb2)

ovn-nbctl --wait=hv meter-add event-elb drop 100 pktps 10
ovn-nbctl --wait=hv copp-add copp0 event-elb event-elb
ovn-nbctl --wait=hv ls-copp-add copp0 sw0

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync
ovn-sbctl lflow-list > sbflows
AT_CAPTURE_FILE([sbflows])
as hv1 ovs-ofctl dump-flows br-int > offlows
AT_CAPTURE_FILE([offlows])

packet0="inport==\"sw0-p11\" && eth.src==00:00:00:00:00:11 && eth.dst==00:00:00:00:00:21 &&
         ip4 && ip.ttl==64 && ip4.src==192.168.1.11 && ip4.dst==192.168.1.100 &&
         tcp && tcp.src==10000 && tcp.dst==80"
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet0"])
ovn-nbctl --wait=hv

ovn-sbctl list controller_event > events
AT_CAPTURE_FILE([events])
uuid=$(awk '/_uuid/{print $3}' < events)
echo uuid=$uuid
AT_CHECK([test -n "$uuid"])
AT_CHECK([ovn-sbctl get controller_event $uuid event_type], [0], [dnl
empty_lb_backends
])
AT_CHECK([ovn-sbctl get controller_event $uuid event_info:vip], [0], [dnl
"192.168.1.100:80"
])
AT_CHECK([ovn-sbctl get controller_event $uuid event_info:protocol], [0], [dnl
tcp
])
AT_CHECK_UNQUOTED([ovn-sbctl get controller_event $uuid event_info:load_balancer], [0], [dnl
"$uuid_lb0"
])
AT_CHECK([ovn-sbctl get controller_event $uuid seq_num], [0], [dnl
1
])

ovn-sbctl destroy controller_event $uuid
packet1="inport==\"sw1-p0\" && eth.src==00:00:00:00:00:33 && eth.dst==00:00:00:00:ff:02 &&
         ip4 && ip.ttl==64 && ip4.src==192.168.2.11 && ip4.dst==192.168.2.100 &&
         tcp && tcp.src==10000 && tcp.dst==80"

OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet1"])
ovn-nbctl --wait=hv
ovn-sbctl list controller_event
uuid=$(ovn-sbctl list controller_event | awk '/_uuid/{print $3}')
AT_CHECK([ovn-sbctl get controller_event $uuid event_type], [0], [dnl
empty_lb_backends
])
AT_CHECK([ovn-sbctl get controller_event $uuid event_info:vip], [0], [dnl
"192.168.2.100:80"
])
ovn-sbctl destroy controller_event $uuid

packet2="inport==\"sw0-p11\" && eth.src==00:00:00:00:00:11 && eth.dst==00:00:00:00:00:21 &&
         ip6 && ip.ttl==64 && ip6.src==2001::11 && ip6.dst==2001::10 &&
         tcp && tcp.src==10000 && tcp.dst==50051"

OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet2"])
ovn-nbctl --wait=hv
ovn-sbctl list controller_event
uuid=$(ovn-sbctl list controller_event | awk '/_uuid/{print $3}')

AT_CHECK([ovn-sbctl get controller_event $uuid event_type], [0], [dnl
empty_lb_backends
])
AT_CHECK([ovn-sbctl get controller_event $uuid event_info:vip], [0], [dnl
"[[2001::10]]:50051"
])
AT_CHECK_UNQUOTED([ovn-sbctl get controller_event $uuid event_info:load_balancer], [0], [dnl
"$uuid_lb2"
])

AT_CHECK_UNQUOTED([ovn_trace sw0 'inport == "sw0-p11" && eth.src == 00:00:00:00:00:11 && ip4.dst == 192.168.1.100 && tcp && tcp.dst == 80' | grep -q 'event = "empty_lb_backends"'], [0])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IGMP snoop/querier/relay])
AT_KEYWORDS([IP-multicast snoop query querier relay])
AT_KEYWORDS([slowtest])

ovn_start

# Logical network:
# Three logical switches (sw1-sw3) connected to a logical router (rtr).
# sw1:
#   - subnet 10.0.0.0/8
#   - 2 ports bound on hv1 (sw1-p11, sw1-p12)
#   - 2 ports bound on hv2 (sw1-p21, sw1-p22)
# sw2:
#   - subnet 20.0.0.0/8
#   - 1 port bound on hv1 (sw2-p1)
#   - 1 port bound on hv2 (sw2-p2)
#   - IGMP Querier from 20.0.0.254
# sw3:
#   - subnet 30.0.0.0/8
#   - 1 port bound on hv1 (sw3-p1)
#   - 1 port bound on hv2 (sw3-p2)
#   - 1 localnet port (sw3-ln)

ovn-nbctl ls-add sw1
ovn-nbctl ls-add sw2
ovn-nbctl ls-add sw3

ovn-nbctl lsp-add sw1 sw1-p11
ovn-nbctl lsp-add sw1 sw1-p12
ovn-nbctl lsp-add sw1 sw1-p21
ovn-nbctl lsp-add sw1 sw1-p22
ovn-nbctl lsp-add sw2 sw2-p1
ovn-nbctl lsp-add sw2 sw2-p2
ovn-nbctl lsp-add sw3 sw3-p1
ovn-nbctl lsp-add sw3 sw3-p2
ovn-nbctl lsp-add sw3 sw3-ln                    \
    -- lsp-set-type sw3-ln localnet             \
    -- lsp-set-options sw3-ln network_name=phys

ovn-nbctl lr-add rtr
ovn-nbctl lrp-add rtr rtr-sw1 00:00:00:00:01:00 10.0.0.254/24
ovn-nbctl lrp-add rtr rtr-sw2 00:00:00:00:02:00 20.0.0.254/24
ovn-nbctl lrp-add rtr rtr-sw3 00:00:00:00:03:00 30.0.0.254/24

ovn-nbctl lsp-add sw1 sw1-rtr                      \
    -- lsp-set-type sw1-rtr router                 \
    -- lsp-set-addresses sw1-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw1-rtr router-port=rtr-sw1
check ovn-nbctl lsp-add sw2 sw2-rtr                \
    -- lsp-set-type sw2-rtr router                 \
    -- lsp-set-addresses sw2-rtr 00:00:00:00:02:00 \
    -- lsp-set-options sw2-rtr router-port=rtr-sw2
check ovn-nbctl lsp-add sw3 sw3-rtr                \
    -- lsp-set-type sw3-rtr router                 \
    -- lsp-set-addresses sw3-rtr 00:00:00:00:03:00 \
    -- lsp-set-options sw3-rtr router-port=rtr-sw3

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p11 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p12 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=sw2-p1 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif4 -- \
    set interface hv1-vif4 external-ids:iface-id=sw3-p1 \
    options:tx_pcap=hv1/vif4-tx.pcap \
    options:rxq_pcap=hv1/vif4-rx.pcap \
    ofport-request=1
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p21 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw1-p22 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif3 -- \
    set interface hv2-vif3 external-ids:iface-id=sw2-p2 \
    options:tx_pcap=hv2/vif3-tx.pcap \
    options:rxq_pcap=hv2/vif3-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif4 -- \
    set interface hv2-vif4 external-ids:iface-id=sw3-p2 \
    options:tx_pcap=hv2/vif4-tx.pcap \
    options:rxq_pcap=hv2/vif4-rx.pcap \
    ofport-request=1
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    if test "$1" = --uniq; then
        sort="sort -u"; shift
    else
        sort=sort
    fi
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        $sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | $sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

OVN_POPULATE_ARP

# Enable IGMP snooping on sw1.
check ovn-nbctl --wait=hv set Logical_Switch sw1       \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"

AT_CAPTURE_FILE([sbflows])
cp ovn-sb/ovn-sb.db ovn-sb.db
ovn-sbctl dump-flows > sbflows

# No IGMP query should be generated by sw1 (mcast_querier="false").
# (Therefore everything is expected to be empty.)
AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
> expected
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv2/vif2-tx.pcap expected'],
  [$at_diff -F'^---' exp rcv])

check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([sbflows2])
ovn-sbctl dump-flows > sbflows2

# Inject IGMP Join for 239.0.1.68 on sw1-p11.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null
# Inject IGMP Join for 239.0.1.68 on sw1-p21.
send_igmp_v3_report hv2-vif1 hv2 000000000002 $(ip_to_hex 10 0 0 2) f9f9 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Check that the IGMP Group is learned on both hv.
wait_row_count IGMP_Group 2 address=239.0.1.68
check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([sbflows3])
ovn-sbctl dump-flows > sbflows3

AS_BOX([IGMP traffic test 1])
# Send traffic and make sure it gets forwarded only on the two ports that
# joined.
> expected
> expected_empty
send_ip_multicast_pkt hv1-vif2 hv1 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000 expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Inject IGMP Leave for 239.0.1.68 on sw1-p11.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 03 eab9 \
    /dev/null

# Check IGMP_Group table on both HV.
wait_row_count IGMP_Group 1 address=239.0.1.68
check ovn-nbctl --wait=hv sync

AS_BOX([IGMP traffic test 2])
# Send traffic and make sure it gets forwarded only on the port that joined.
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
> expected
> expected_empty
send_ip_multicast_pkt hv1-vif2 hv1 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000 expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Flush IGMP groups.
check ovn-sbctl ip-multicast-flush sw1
wait_row_count IGMP_Group 0 address=239.0.1.68
check ovn-nbctl --wait=hv sync

# Check that traffic for 224.0.0.X is flooded even if some hosts register for
# it.
# Inject IGMP Join for 224.0.0.42 on sw1-p11.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 224 0 0 42) 04 f9d3 \
    /dev/null

# Check that the IGMP Group is learned.
wait_row_count IGMP_Group 1 address=224.0.0.42

AS_BOX([IGMP traffic test 3])
# Send traffic and make sure it gets flooded to all ports.
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
> expected
send_ip_multicast_pkt hv1-vif2 hv1 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 224 0 0 42) 1e 01 f989 11 \
    e518e518000a4b540000
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 224 0 0 42) 1e 01 f989 11 \
    e518e518000a4b540000 expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv2/vif2-tx.pcap expected'],
  [$at_diff -F'^---' exp rcv])

# Enable IGMP snooping and querier on sw2 and set query interval to minimum.
check ovn-nbctl set Logical_Switch sw2 \
    other_config:mcast_snoop="true" \
    other_config:mcast_querier="true" \
    other_config:mcast_query_interval=1 \
    other_config:mcast_eth_src="00:00:00:00:02:fe" \
    other_config:mcast_ip4_src="20.0.0.254"

AS_BOX([IGMP traffic test 4])
# Check that multiple queries are generated over time.
> expected
store_igmp_v3_query 0000000002fe $(ip_to_hex 20 0 0 254) 84dd expected
store_igmp_v3_query 0000000002fe $(ip_to_hex 20 0 0 254) 84dd expected

for count in 1 2 3; do
    as hv1 reset_pcap_file hv1-vif1 hv1/vif1
    as hv1 reset_pcap_file hv1-vif2 hv1/vif2
    as hv1 reset_pcap_file hv1-vif3 hv1/vif3
    as hv1 reset_pcap_file hv1-vif4 hv1/vif4
    as hv2 reset_pcap_file hv2-vif1 hv2/vif1
    as hv2 reset_pcap_file hv2-vif2 hv2/vif2
    as hv2 reset_pcap_file hv2-vif3 hv2/vif3
    as hv2 reset_pcap_file hv2-vif4 hv2/vif4
    OVS_WAIT_UNTIL(
      [check_packets --uniq \
                     'hv1/vif3-tx.pcap expected' \
                     'hv2/vif3-tx.pcap expected'],
      [$at_diff -F'^---' exp rcv])
done

# Disable IGMP querier on sw2.
check ovn-nbctl set Logical_Switch sw2 \
    other_config:mcast_querier="false"

# Enable IGMP snooping on sw3.
check ovn-nbctl set Logical_Switch sw3       \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"

check ovn-nbctl --wait=hv sync

AS_BOX([IGMP traffic test 5])
# Send traffic from sw3 and make sure rtr doesn't relay it.
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip_multicast_pkt hv2-vif4 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000

# Sleep a bit to make sure no traffic is received and then check.
sleep 1
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_empty' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Enable IGMP relay on rtr
check ovn-nbctl set logical_router rtr \
    options:mcast_relay="true"

# Inject IGMP Join for 239.0.1.68 on sw1-p11.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null
# Inject IGMP Join for 239.0.1.68 on sw2-p2.
send_igmp_v3_report hv2-vif3 hv2 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Check that the IGMP Group is learned by all switches.
wait_row_count IGMP_Group 2 address=239.0.1.68
check ovn-nbctl --wait=hv sync

AS_BOX([IGMP traffic test 6])
# Send traffic from sw3 and make sure it is relayed by rtr.
# to ports that joined.
> expected_routed_sw1
> expected_routed_sw2
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip_multicast_pkt hv2-vif4 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000100 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw1
store_ip_multicast_pkt \
    000000000200 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_routed_sw1' \
                 'hv2/vif3-tx.pcap expected_routed_sw2' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Inject IGMP Join for 239.0.1.68 on sw3-p1.
send_igmp_v3_report hv1-vif4 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Check that the IGMP Group is learned by all switches.
wait_row_count IGMP_Group 3 address=239.0.1.68
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows4
AT_CAPTURE_FILE([sbflows4])

ovn-sbctl -f csv --columns=datapath,name,ports,tunnel_key list Multicast_Group > mcgroups4
AT_CAPTURE_FILE([mcgroups4])

AS_BOX([IGMP traffic test 7])
# Send traffic from sw3 and make sure it is relayed by rtr
# to ports that joined.
> expected_routed_sw1
> expected_routed_sw2
> expected_switched
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip_multicast_pkt hv2-vif4 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000100 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw1
store_ip_multicast_pkt \
    000000000200 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw2
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000 expected_switched

# TODO: IGMP Relay duplicates IP multicast packets in some conditions, for
# more details see TODO.rst, section "IP Multicast Relay". Once that issue is
# fixed the duplicated packets should not appear anymore.
store_ip_multicast_pkt \
    000000000100 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw1
store_ip_multicast_pkt \
    000000000200 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed_sw2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_routed_sw1' \
                 'hv2/vif3-tx.pcap expected_routed_sw2' \
                 'hv1/vif4-tx.pcap expected_switched' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Flush IGMP groups.
ovn-sbctl ip-multicast-flush sw1
ovn-sbctl ip-multicast-flush sw2
ovn-sbctl ip-multicast-flush sw3
wait_row_count IGMP_Group 0 address=239.0.1.68
check ovn-nbctl --wait=hv sync

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

> expected_empty
> expected_switched
> expected_routed
> expected_reports

# Enable mcast_flood on sw1-p11
ovn-nbctl set Logical_Switch_Port sw1-p11 options:mcast_flood='true'

# Enable mcast_flood_reports on sw1-p21
ovn-nbctl set Logical_Switch_Port sw1-p21 options:mcast_flood_reports='true'
# Enable mcast_flood on rtr-sw2
ovn-nbctl set Logical_Router_Port rtr-sw2 options:mcast_flood='true'
# Enable mcast_flood on sw2-p1
ovn-nbctl set Logical_Switch_Port sw2-p1 options:mcast_flood='true'

ovn-nbctl --wait=hv sync

# Inject IGMP Join for 239.0.1.68 on sw1-p12.
send_igmp_v3_report hv1-vif2 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    expected_reports

# Check that the IGMP Group is learned (on sw1-p12 and on sw2-rtr).
wait_row_count IGMP_Group 2 address=239.0.1.68
check ovn-nbctl --wait=hv sync

AS_BOX([IGMP traffic test 8])
# Send traffic from sw1-p21
send_ip_multicast_pkt hv2-vif1 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000 expected_switched
store_ip_multicast_pkt \
    000000000200 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed


# Check that traffic is switched to sw1-p11 and sw1-p12
# Check that IGMP join is flooded on sw1-p21
# Check that traffic is routed by rtr to rtr-sw2 and then switched to sw2-p1
AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_switched' \
                 'hv1/vif2-tx.pcap expected_switched' \
                 'hv1/vif3-tx.pcap expected_routed' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_reports' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# With ovn-monitor-all=true, make sure ovn-controllers don't delete each
# other's IGMP_Group records.

# Add a new chassis with no local datapaths.
net_add n3
sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n3 br-phys 192.168.0.3

# Enable ovn-monitor-all on all chassis.
as hv1 ovs-vsctl set open . external_ids:ovn-monitor-all=true
as hv2 ovs-vsctl set open . external_ids:ovn-monitor-all=true
as hv3 ovs-vsctl set open . external_ids:ovn-monitor-all=true

# Wait until ovn-monitor-all is processed by ovn-controller.
wait_row_count Chassis 1 name=hv1 other_config:ovn-monitor-all='"true"'
wait_row_count Chassis 1 name=hv2 other_config:ovn-monitor-all='"true"'
wait_row_count Chassis 1 name=hv3 other_config:ovn-monitor-all='"true"'

# Inject a fake IGMP_Group entry.
dp=$(fetch_column Datapath_Binding _uuid external_ids:name=sw2)
ch=$(fetch_column Chassis _uuid name=hv3)
ovn-sbctl create IGMP_Group address=239.0.1.42 datapath=$dp chassis=$ch

ovn-nbctl --wait=hv sync
wait_row_count IGMP_Group 2 address=239.0.1.68
wait_row_count IGMP_Group 1 address=239.0.1.42

OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IGMP relay - distributed gateway port])
AT_KEYWORDS([IP-multicast snoop relay])

ovn_start

# Logical network:
# Two logical switches (sw1-sw2) connected to a logical router (rtr).
# sw1:
#   - subnet 10.0.0.0/8
#   - 1 ports bound on hv1 (sw1-p1)
# sw2:
#   - subnet 20.0.0.0/8
#   - 1 port bound on hv2 (sw2-p2)
#   - IGMP Querier from 20.0.0.254

check ovn-nbctl ls-add sw1 \
    -- lsp-add sw1 sw1-p1

check ovn-nbctl ls-add sw2 \
    -- lsp-add sw2 sw2-p2

check ovn-nbctl lr-add rtr                                 \
    -- lrp-add rtr rtr-sw1 00:00:00:00:01:00 10.0.0.254/24 \
    -- lrp-add rtr rtr-sw2 00:00:00:00:02:00 20.0.0.254/24

ovn-nbctl lsp-add sw1 sw1-rtr                      \
    -- lsp-set-type sw1-rtr router                 \
    -- lsp-set-addresses sw1-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw1-rtr router-port=rtr-sw1
check ovn-nbctl lsp-add sw2 sw2-rtr                \
    -- lsp-set-type sw2-rtr router                 \
    -- lsp-set-addresses sw2-rtr 00:00:00:00:02:00 \
    -- lsp-set-options sw2-rtr router-port=rtr-sw2
check ovn-nbctl lrp-set-gateway-chassis rtr-sw1 hv1 10
check ovn-nbctl lrp-set-gateway-chassis rtr-sw2 hv2 10

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw2-p2 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap

wait_for_ports_up

AS_BOX([Wait until cr-rtr-sw1 is claimed by hv1])
hv1_chassis=$(fetch_column Chassis _uuid name=hv1)
AS_BOX([check that the chassis redirect port has been claimed by the hv1 chassis])
wait_row_count Port_Binding 1 logical_port=cr-rtr-sw1 chassis=$hv1_chassis

AS_BOX([Wait until cr-rtr-sw2 is claimed by hv2])
hv2_chassis=$(fetch_column Chassis _uuid name=hv2)
AS_BOX([check that the chassis redirect port has been claimed by the hv2 chassis])
wait_row_count Port_Binding 1 logical_port=cr-rtr-sw2 chassis=$hv2_chassis

check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    if test "$1" = --uniq; then
        sort="sort -u"; shift
    else
        sort=sort
    fi
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        $sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | $sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

OVN_POPULATE_ARP

# Enable IGMP snooping on sw1 and sw2 and relay on rtr.
check ovn-nbctl --wait=hv set Logical_Switch sw1 \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"
check ovn-nbctl --wait=hv set Logical_Switch sw2 \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"
check ovn-nbctl set logical_router rtr \
    options:mcast_relay="true"
check ovn-nbctl --wait=hv sync

# Inject IGMP Join for 239.0.1.68 on sw2-p2.
send_igmp_v3_report hv2-vif2 hv2 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Check that the IGMP Group is learned by all switches.
wait_row_count IGMP_Group 1 address=239.0.1.68
check ovn-nbctl --wait=hv sync

# Send traffic from sw1 and make sure it is relayed by rtr.
> expected_routed
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2

send_ip_multicast_pkt hv1-vif1 hv1 \
    000000000001 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 20 ca70 11 \
    e518e518000a3b3a0000
store_ip_multicast_pkt \
    000000000200 01005e000144 \
    $(ip_to_hex 10 0 0 42) $(ip_to_hex 239 0 1 68) 1e 1f cb70 11 \
    e518e518000a3b3a0000 expected_routed

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_routed'],
  [$at_diff -F'^---' exp rcv])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([MLD snoop/querier/relay])
AT_KEYWORDS([IP-multicast snoop query querier relay])
AT_KEYWORDS([slowtest])

ovn_start

# Logical network:
# Three logical switches (sw1-sw3) connected to a logical router (rtr).
# sw1:
#   - subnet 10::/64
#   - 2 ports bound on hv1 (sw1-p11, sw1-p12)
#   - 2 ports bound on hv2 (sw1-p21, sw1-p22)
# sw2:
#   - subnet 20::/64
#   - 1 port bound on hv1 (sw2-p1)
#   - 1 port bound on hv2 (sw2-p2)
#   - MLD Querier from 20::fe
# sw3:
#   - subnet 30::/64
#   - 1 port bound on hv1 (sw3-p1)
#   - 1 port bound on hv2 (sw3-p2)
#   - 1 localnet port (sw3-ln)

check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add sw2
check ovn-nbctl ls-add sw3

check ovn-nbctl lsp-add sw1 sw1-p11
check ovn-nbctl lsp-add sw1 sw1-p12
check ovn-nbctl lsp-add sw1 sw1-p21
check ovn-nbctl lsp-add sw1 sw1-p22
check ovn-nbctl lsp-add sw2 sw2-p1
check ovn-nbctl lsp-add sw2 sw2-p2
check ovn-nbctl lsp-add sw3 sw3-p1
check ovn-nbctl lsp-add sw3 sw3-p2
check ovn-nbctl lsp-add sw3 sw3-ln              \
    -- lsp-set-type sw3-ln localnet             \
    -- lsp-set-options sw3-ln network_name=phys

check ovn-nbctl lr-add rtr
check ovn-nbctl lrp-add rtr rtr-sw1 00:00:00:00:01:00 10::fe/64
check ovn-nbctl lrp-add rtr rtr-sw2 00:00:00:00:02:00 20::fe/64
check ovn-nbctl lrp-add rtr rtr-sw3 00:00:00:00:03:00 30::fe/64

check ovn-nbctl lsp-add sw1 sw1-rtr                \
    -- lsp-set-type sw1-rtr router                 \
    -- lsp-set-addresses sw1-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw1-rtr router-port=rtr-sw1
check ovn-nbctl lsp-add sw2 sw2-rtr                \
    -- lsp-set-type sw2-rtr router                 \
    -- lsp-set-addresses sw2-rtr 00:00:00:00:02:00 \
    -- lsp-set-options sw2-rtr router-port=rtr-sw2
check ovn-nbctl lsp-add sw3 sw3-rtr                \
    -- lsp-set-type sw3-rtr router                 \
    -- lsp-set-addresses sw3-rtr 00:00:00:00:03:00 \
    -- lsp-set-options sw3-rtr router-port=rtr-sw3

# Conntrack marks all IPv6 Neighbor Discovery and MLD packets as invalid,
# make sure to test that conntrack is bypassed for MLD by adding an empty
# allow-related ACL and an empty load balancer.
check ovn-nbctl acl-add sw1 from-lport 1 "1" allow-related
check ovn-nbctl acl-add sw2 from-lport 1 "1" allow-related
check ovn-nbctl acl-add sw3 from-lport 1 "1" allow-related
check ovn-nbctl acl-add sw1 to-lport 1 "1" allow-related
check ovn-nbctl acl-add sw2 to-lport 1 "1" allow-related
check ovn-nbctl acl-add sw3 to-lport 1 "1" allow-related

check ovn-nbctl lb-add lb0 [[4242::1]]:80 "[[4242::2]]:80"
check ovn-nbctl ls-lb-add sw1 lb0
check ovn-nbctl ls-lb-add sw2 lb0
check ovn-nbctl ls-lb-add sw3 lb0

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p11 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p12 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=sw2-p1 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif4 -- \
    set interface hv1-vif4 external-ids:iface-id=sw3-p1 \
    options:tx_pcap=hv1/vif4-tx.pcap \
    options:rxq_pcap=hv1/vif4-rx.pcap \
    ofport-request=1
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p21 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw1-p22 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif3 -- \
    set interface hv2-vif3 external-ids:iface-id=sw2-p2 \
    options:tx_pcap=hv2/vif3-tx.pcap \
    options:rxq_pcap=hv2/vif3-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv2-vif4 -- \
    set interface hv2-vif4 external-ids:iface-id=sw3-p2 \
    options:tx_pcap=hv2/vif4-tx.pcap \
    options:rxq_pcap=hv2/vif4-rx.pcap \
    ofport-request=1
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

wait_for_ports_up
check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([sbflows])
ovn-sbctl dump-flows > sbflows

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    if test "$1" = --uniq; then
        sort="sort -u"; shift
    else
        sort=sort
    fi
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        $sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | $sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

OVN_POPULATE_ARP

# Enable multicast snooping on sw1.
check ovn-nbctl --wait=hv set Logical_Switch sw1 \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"

# No IGMP/MLD query should be generated by sw1 (mcast_querier="false").
> expected
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv2/vif2-tx.pcap expected'],
  [$at_diff -F'^---' exp rcv])

check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([sbflows2])
ovn-sbctl dump-flows > sbflows2

# Inject MLD Join for ff0a:dead:beef::1 on sw1-p11.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null
# Inject MLD Join for ff0a:dead:beef::1 on sw1-p21.
send_mld_v2_report hv2-vif1 hv2 \
    000000000002 10000000000000000000000000000002 \
    ff0adeadbeef00000000000000000001 04 c0e3 \
    /dev/null

# Check that the IP multicast group is learned on both hv.
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'

# This gives the ovn-controller nodes a chance to see the new IGMP_Group.
check ovn-nbctl --wait=hv sync

AT_CAPTURE_FILE([sbflows3])
ovn-sbctl dump-flows > sbflows3

# Send traffic and make sure it gets forwarded only on the two ports that
# joined.
> expected
> expected_empty
send_ip6_multicast_pkt hv1-vif2 hv1 \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a

store_ip6_multicast_pkt \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Inject MLD Leave for ff0a:dead:beef::1 on sw1-p11.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 03 c1e4 \
    /dev/null

# Check IGMP_Group table on both HV.
wait_row_count IGMP_Group 1 address='"ff0a:dead:beef::1"'

# This gives the ovn-controller nodes a chance to see the updated IGMP_Group.
check ovn-nbctl --wait=hv sync

# Send traffic and make sure it gets forwarded only on the port that joined.
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
> expected
> expected_empty
send_ip6_multicast_pkt hv1-vif2 hv1 \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a

store_ip6_multicast_pkt \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Flush IP multicast groups.
check ovn-sbctl ip-multicast-flush sw1
wait_row_count IGMP_Group 0 address='"ff0a:dead:beef::1"'

# This gives the ovn-controller nodes a chance to see the updated IGMP_Group.
check ovn-nbctl --wait=hv sync

# Check that traffic for "all-hosts" is flooded even if some hosts register
# for it.
# Inject MLD Join for ff02::1 on sw1-p11.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff020000000000000000000000000001 04 5e8a \
    /dev/null

# Check that the Multicast Group is learned.
wait_row_count IGMP_Group 1 address='"ff02::1"'

# Send traffic and make sure it gets flooded to all ports.
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
> expected
send_ip6_multicast_pkt hv1-vif2 hv1 \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff020000000000000000000000000001 \
    000e 01 11 \
    93407a69000eb90361736461640a
store_ip6_multicast_pkt \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff020000000000000000000000000001 \
    000e 01 11 \
    93407a69000eb90361736461640a \
    expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv2/vif2-tx.pcap expected'],
  [$at_diff -F'^---' exp rcv])

# Enable multicast snooping and querier on sw2 and set query interval to
# minimum.
check ovn-nbctl --wait=hv set Logical_Switch sw2 \
    other_config:mcast_snoop="true" \
    other_config:mcast_querier="true" \
    other_config:mcast_query_interval=1 \
    other_config:mcast_eth_src="00:00:00:00:02:fe" \
    other_config:mcast_ip6_src="fe80::fe"

AT_CAPTURE_FILE([sbflows4])
ovn-sbctl dump-flows > sbflows4

# Check that multiple queries are generated over time.
> expected
store_mld_query 0000000002fe fe8000000000000000000000000000fe expected
store_mld_query 0000000002fe fe8000000000000000000000000000fe expected
for count in 1 2 3; do
    as hv1 reset_pcap_file hv1-vif1 hv1/vif1
    as hv1 reset_pcap_file hv1-vif2 hv1/vif2
    as hv1 reset_pcap_file hv1-vif3 hv1/vif3
    as hv1 reset_pcap_file hv1-vif4 hv1/vif4
    as hv2 reset_pcap_file hv2-vif1 hv2/vif1
    as hv2 reset_pcap_file hv2-vif2 hv2/vif2
    as hv2 reset_pcap_file hv2-vif3 hv2/vif3
    as hv2 reset_pcap_file hv2-vif4 hv2/vif4
    OVS_WAIT_UNTIL(
      [check_packets --uniq \
                     'hv1/vif3-tx.pcap expected' \
                     'hv2/vif3-tx.pcap expected'],
      [$at_diff -F'^---' exp rcv])
done

# Disable multicast querier on sw2.
check ovn-nbctl set Logical_Switch sw2 \
    other_config:mcast_querier="false"

# Enable multicast snooping on sw3.
check ovn-nbctl --wait=hv set Logical_Switch sw3       \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"

AT_CAPTURE_FILE([sbflows5])
ovn-sbctl dump-flows > sbflows5

# Send traffic from sw3 and make sure rtr doesn't relay it.
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip6_multicast_pkt hv2-vif4 hv2 \
    000000000001 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e2b4e61736461640a

# Sleep a bit to make sure no traffic is received and then check.
sleep 1
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_empty' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Enable multicast relay on rtr
check ovn-nbctl --wait=hv set logical_router rtr options:mcast_relay="true"

AT_CAPTURE_FILE([sbflows6])
ovn-sbctl dump-flows > sbflows6

# Inject MLD Join for ff0a:dead:beef::1 on sw1-p11.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Inject MLD Join for ff0a:dead:beef::1 on sw2-p2.
send_mld_v2_report hv2-vif3 hv2 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Check that the IGMP Group is learned by all switches.
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'

# Send traffic from sw3 and make sure it is relayed by rtr.
# to ports that joined.
> expected_routed_sw1
> expected_routed_sw2
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip6_multicast_pkt hv2-vif4 hv2 \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e1b5e61736461640a
store_ip6_multicast_pkt \
    000000000100 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw1
store_ip6_multicast_pkt \
    000000000200 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_routed_sw1' \
                 'hv2/vif3-tx.pcap expected_routed_sw2' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Inject MLD Join for 239.0.1.68 on sw3-p1.
send_mld_v2_report hv1-vif4 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Check that the Multicast Group is learned by all switches.
wait_row_count IGMP_Group 3 address='"ff0a:dead:beef::1"'
check ovn-nbctl --wait=hv sync

# Send traffic from sw3 and make sure it is relayed by rtr
# to ports that joined.
> expected_routed_sw1
> expected_routed_sw2
> expected_switched
> expected_empty

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

send_ip6_multicast_pkt hv2-vif4 hv2 \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e1b5e61736461640a
store_ip6_multicast_pkt \
    000000000100 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw1
store_ip6_multicast_pkt \
    000000000200 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw2
store_ip6_multicast_pkt \
    000000000001 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e1b5e61736461640a \
    expected_switched

# TODO: MLD Relay duplicates IP multicast packets in some conditions, for
# more details see TODO.rst, section "IP Multicast Relay". Once that issue is
# fixed the duplicated packets should not appear anymore.
store_ip6_multicast_pkt \
    000000000100 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw1
store_ip6_multicast_pkt \
    000000000200 333300000001 \
    10000000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e1b5e61736461640a \
    expected_routed_sw2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_routed_sw1' \
                 'hv2/vif3-tx.pcap expected_routed_sw2' \
                 'hv1/vif4-tx.pcap expected_switched' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/vif3-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

# Flush multicast groups.
check ovn-sbctl ip-multicast-flush sw1
check ovn-sbctl ip-multicast-flush sw2
check ovn-sbctl ip-multicast-flush sw3
wait_row_count IGMP_Group 0 address='"ff0a:dead:beef::1"'

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file hv1-vif3 hv1/vif3
as hv1 reset_pcap_file hv1-vif4 hv1/vif4
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
as hv2 reset_pcap_file hv2-vif4 hv2/vif4

> expected_empty
> expected_switched
> expected_routed
> expected_reports

# Enable mcast_flood on sw1-p11
check ovn-nbctl set Logical_Switch_Port sw1-p11 options:mcast_flood='true'

# Enable mcast_flood_reports on sw1-p21
check ovn-nbctl set Logical_Switch_Port sw1-p21 options:mcast_flood_reports='true'
# Enable mcast_flood on rtr-sw2
check ovn-nbctl set Logical_Router_Port rtr-sw2 options:mcast_flood='true'
# Enable mcast_flood on sw2-p1
check ovn-nbctl set Logical_Switch_Port sw2-p1 options:mcast_flood='true'

check ovn-nbctl --wait=hv sync

# Inject MLD Join for ff0a:dead:beef::1 on sw1-p12.
send_mld_v2_report hv1-vif2 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    expected_reports

# Check that the IP multicast group is learned (on sw1-p12 and on sw2-rtr).
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'
check ovn-nbctl --wait=hv sync

# Send traffic from sw1-p21
send_ip6_multicast_pkt hv2-vif1 hv2 \
    000000000001 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e2b4e61736461640a
store_ip6_multicast_pkt \
    000000000001 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 02 11 \
    93407a69000e2b4e61736461640a \
    expected_switched
store_ip6_multicast_pkt \
    000000000200 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 01 11 \
    93407a69000e2b4e61736461640a \
    expected_routed

# Sleep a bit to make sure no duplicate traffic is received
sleep 1

AT_CAPTURE_FILE([sbflows7])
ovn-sbctl dump-flows > sbflows7

# Check that traffic is switched to sw1-p11 and sw1-p12
# Check that MLD join is flooded on sw1-p21
# Check that traffic is routed by rtr to rtr-sw2 and then switched to sw2-p1
OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_switched' \
                 'hv1/vif2-tx.pcap expected_switched' \
                 'hv1/vif3-tx.pcap expected_routed' \
                 'hv1/vif4-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected_reports' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/vif3-tx.pcap expected_empty' \
                 'hv2/vif4-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IGMP external querier])
AT_KEYWORDS([IP-multicast])

ovn_start

# Logical network:
# A logical switch (mcast snoop enabled) connected to a provider (localnet)
# network.
# One external multicast querier, connected to the switch via the localnet
# port.

check ovn-nbctl                                                  \
    -- ls-add sw1                                                \
      -- lsp-add sw1 sw1-ln                                      \
        -- lsp-set-type sw1-ln localnet                          \
        -- lsp-set-options sw1-ln network_name=phys-1            \
      -- lsp-add sw1 sw1-p1                                      \
      -- lsp-add sw1 sw1-p2                                      \
      -- lsp-add sw1 sw1-p3                                      \
      -- lsp-add sw1 sw1-p4                                      \
      -- set logical_switch sw1 other_config:mcast_snoop=true    \
      -- set logical_switch sw1 other_config:mcast_querier=false

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys-1
ovn_attach n1 br-phys-1 192.168.1.1
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-1:br-phys-1

check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap


sim_add hv2
as hv2
check ovs-vsctl add-br br-phys-1
ovn_attach n1 br-phys-1 192.168.1.2
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys-1:br-phys-1

check ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p3 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap
check ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw1-p4 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Wait for pinctrl thread to be connected
OVS_WAIT_UNTIL([grep pinctrl hv1/ovn-controller.log | grep -c connected])
OVS_WAIT_UNTIL([grep pinctrl hv2/ovn-controller.log | grep -c connected])

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    if test "$1" = --uniq; then
        sort="sort -u"; shift
    else
        sort=sort
    fi
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        $sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | $sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

OVN_POPULATE_ARP

sw1=$(fetch_column Datapath_Binding _uuid external_ids:name=sw1)

dnl Send IGMP query from localnet1 (send on both hypervisors to simulate
dnl the multicast query packet in the fabric).
send_igmp_v3_query br-phys-1_n1 hv1 000000000142 $(ip_to_hex 10 0 0 42) 8fb1
send_igmp_v3_query br-phys-1_n1 hv2 000000000142 $(ip_to_hex 10 0 0 42) 8fb1 expected

dnl Wait for the mrouter to be learned by both chassis.
wait_row_count IGMP_Group 2 address=mrouters datapath=$sw1

dnl The query should have been flooded in the broadcast domain.
: > expected_empty

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected' \
                 'hv1/br-phys-1_n1-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv2/vif2-tx.pcap expected' \
                 'hv2/br-phys-1_n1-tx.pcap expected_empty'],
  [$at_diff -F'^---' exp rcv])

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file br-phys-1_n1 hv1/br-phys-1_n1
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file br-phys-1_n1 hv2/br-phys-1_n1

: > expected

dnl Send IGMP query from sw1-p4.
send_igmp_v3_query hv2-vif2 hv2 000000000002 $(ip_to_hex 10 0 0 2) 8fb1 expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected' \
                 'hv1/vif2-tx.pcap expected' \
                 'hv1/br-phys-1_n1-tx.pcap expected_empty' \
                 'hv2/vif1-tx.pcap expected' \
                 'hv2/vif2-tx.pcap expected_empty' \
                 'hv2/br-phys-1_n1-tx.pcap expected'],
  [$at_diff -F'^---' exp rcv])

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif2 hv1/vif2
as hv1 reset_pcap_file br-phys-1_n1 hv1/br-phys-1_n1
as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file br-phys-1_n1 hv2/br-phys-1_n1

: > expected

dnl Send a join from sw1-p1: should be forwarded to sw1-ln and sw1-p4.
send_igmp_v3_report hv1-vif1 hv1 \
   000000000001 $(ip_to_hex 10 0 0 2) f9f7 \
   $(ip_to_hex 239 0 1 68) 04 e9b9 \
   expected

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_empty' \
                 'hv1/vif2-tx.pcap expected_empty' \
                 'hv1/br-phys-1_n1-tx.pcap expected' \
                 'hv2/vif1-tx.pcap expected_empty' \
                 'hv2/vif2-tx.pcap expected' \
                 'hv2/br-phys-1_n1-tx.pcap expected_empty' ],
  [$at_diff -F'^---' exp rcv])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([unixctl socket])
ovn_start

sockfile="$at_group_dir/my_sock.ctl"

# Specifying -u should fail since we have no daemon running
AT_CHECK([ovn-nbctl -u $sockfile show], [1], [ignore], [ignore])

AT_CHECK_UNQUOTED([ovn-nbctl --detach -u $sockfile --pidfile], [0], [$sockfile
])
AT_CHECK([if test -f "$sockfile" ; then exit 99 ; fi])
on_exit 'kill $(cat ovn-nbctl.pid)'

# We can't confirm that the nbctl client is actually using the sockfile,
# but we can still ensure that the command is successful.
AT_CHECK([ovn-nbctl -u $sockfile show])

AT_CLEANUP
])

m4_define([DVR_N_S_ARP_HANDLING],
  [OVN_FOR_EACH_NORTHD([
   AT_SETUP([2 HVs, 2 lports/HV, localnet ports, DVR N-S ARP handling, encap $1])
   set -x
   encap=$1
   ovn_start

   # In this test cases we create 3 switches, all connected to same
   # physical network (through br-phys on each HV). LS1 and LS2 have
   # 1 VIF each. Each HV has 1 VIF port. The first digit
   # of VIF port name indicates the hypervisor it is bound to, e.g.
   # lp23 means VIF 3 on hv2.
   #
   # All the switches are connected to a logical router "router".
   #
   # Each switch's VLAN tag and their logical switch ports are:
   #   - ls1:
   #       - tagged with VLAN 101
   #       - ports: lp11
   #   - ls2:
   #       - tagged with VLAN 201
   #       - ports: lp22
   #   - ls-underlay:
   #       - tagged with VLAN 1000
   # Note: a localnet port is created for each switch to connect to
   # physical network.

   for i in 1 2; do
       ls_name=ls$i
       ovn-nbctl ls-add $ls_name
       ln_port_name=ln$i
       if test $i -eq 1; then
           ovn-nbctl lsp-add $ls_name $ln_port_name "" 101
       elif test $i -eq 2; then
           ovn-nbctl lsp-add $ls_name $ln_port_name "" 201
       fi
       ovn-nbctl lsp-set-addresses $ln_port_name unknown
       ovn-nbctl lsp-set-type $ln_port_name localnet
       ovn-nbctl lsp-set-options $ln_port_name network_name=phys
   done

   # lsp_to_ls LSP
   #
   # Prints the name of the logical switch that contains LSP.
   lsp_to_ls () {
       case ${1} in dnl (
           lp?[[11]]) echo ls1 ;; dnl (
           lp?[[12]]) echo ls2 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_hv () {
       case $1 in dnl (
           vif[[1]]?) echo hv1 ;; dnl (
           vif[[2]]?) echo hv2 ;; dnl (
           vif?[[north]]?) echo hv4 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   net_add n1
   for i in 1 2; do
       sim_add hv$i
       as hv$i
       ovs-vsctl add-br br-phys
       ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
       ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:$i$i"
       ovn_attach n1 br-phys 192.168.0.$i 24 $encap

       ovs-vsctl add-port br-int vif$i$i -- \
           set Interface vif$i$i external-ids:iface-id=lp$i$i \
                                 options:tx_pcap=hv$i/vif$i$i-tx.pcap \
                                 options:rxq_pcap=hv$i/vif$i$i-rx.pcap \
                                 ofport-request=$i$i

       lsp_name=lp$i$i
       ls_name=$(lsp_to_ls $lsp_name)

       ovn-nbctl lsp-add $ls_name $lsp_name
       ovn-nbctl lsp-set-addresses $lsp_name "f0:00:00:00:00:$i$i 192.168.$i.$i"
       ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:$i$i

       OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])

   done

   ovn-nbctl ls-add ls-underlay
   ovn-nbctl lsp-add ls-underlay ln3 "" 1000
   ovn-nbctl lsp-set-addresses ln3 unknown
   ovn-nbctl lsp-set-type ln3 localnet
   ovn-nbctl lsp-set-options ln3 network_name=phys

   ovn-nbctl ls-add ls-north
   ovn-nbctl lsp-add ls-north ln4 "" 1000
   ovn-nbctl lsp-set-addresses ln4 unknown
   ovn-nbctl lsp-set-type ln4 localnet
   ovn-nbctl lsp-set-options ln4 network_name=phys

   # Add a VM on ls-north
   ovn-nbctl lsp-add ls-north lp-north
   ovn-nbctl lsp-set-addresses lp-north "f0:f0:00:00:00:11 172.31.0.10"
   ovn-nbctl lsp-set-port-security lp-north f0:f0:00:00:00:11

   # Add 3rd hypervisor
   sim_add hv3
   as hv3 ovs-vsctl add-br br-phys
   as hv3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
   as hv3 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:33"
   as hv3 ovn_attach n1 br-phys 192.168.0.3 24 $encap

   # Add 4th hypervisor
   sim_add hv4
   as hv4 ovs-vsctl add-br br-phys
   as hv4 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
   as hv4 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:44"
   as hv4 ovn_attach n1 br-phys 192.168.0.4 24 $encap

   as hv4 ovs-vsctl add-port br-int vif-north -- \
           set Interface vif-north external-ids:iface-id=lp-north \
                                 options:tx_pcap=hv4/vif-north-tx.pcap \
                                 options:rxq_pcap=hv4/vif-north-rx.pcap \
                                 ofport-request=44

   ovn-nbctl lr-add router
   ovn-nbctl lrp-add router router-to-ls1 00:00:01:01:02:03 192.168.1.3/24
   ovn-nbctl lrp-add router router-to-ls2 00:00:01:01:02:05 192.168.2.3/24
   ovn-nbctl lrp-add router router-to-underlay 00:00:01:01:02:07 172.31.0.1/24

   ovn-nbctl lsp-add ls1 ls1-to-router -- set Logical_Switch_Port ls1-to-router type=router \
             options:router-port=router-to-ls1 -- lsp-set-addresses ls1-to-router router
   ovn-nbctl lsp-add ls2 ls2-to-router -- set Logical_Switch_Port ls2-to-router type=router \
             options:router-port=router-to-ls2 -- lsp-set-addresses ls2-to-router router
   ovn-nbctl lsp-add ls-underlay underlay-to-router -- set Logical_Switch_Port \
                                 underlay-to-router type=router \
                                 options:router-port=router-to-underlay \
                                 -- lsp-set-addresses underlay-to-router router


   OVN_POPULATE_ARP

   vif_to_hv () {
       case ${1} in dnl (
           vif[[1]]?) echo hv1 ;; dnl (
           vif[[2]]?) echo hv2 ;; dnl (
           vif-north) echo hv4 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   # test_arp INPORT SHA SPA TPA [REPLY_HA]
   #
   # Causes a packet to be received on INPORT.  The packet is an ARP
   # request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
   # it should be the hardware address of the target to expect to receive in an
   # ARP reply; otherwise no reply is expected.
   #
   # INPORT is an logical switch port number, e.g. 11 for vif11.
   # SHA and REPLY_HA are each 12 hex digits.
   # SPA and TPA are each 8 hex digits.
   test_arp() {
       local inport=${1} sha=${2} spa=${3} tpa=${4} reply_ha=${5}
       local request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
       hv=`vif_to_hv $inport`
       as $hv ovs-appctl netdev-dummy/receive $inport $request

       if test X$reply_ha = X; then
           # Expect to receive the broadcast ARP on the other logical switch ports
           # if no reply is expected.
           local i j
           for i in 1 2 3; do
               for j in 1 2 3; do
                   if test $i$j != $inport; then
                       echo $request >> $i$j.expected
                   fi
               done
           done
       else
           # Expect to receive the reply, if any.
           local reply=${sha}${reply_ha}08060001080006040002${reply_ha}${tpa}${sha}${spa}
           local reply_vid=${sha}${reply_ha}810003e808060001080006040002${reply_ha}${tpa}${sha}${spa}
           echo $reply_vid >> ${inport}_vid.expected
           echo $reply >> $inport.expected
       fi
   }

   sip=`printf "%02x%02x%02x%02x" 172 31 0 10`
   tip=`printf "%02x%02x%02x%02x" 172 31 0 1`

   # Set a hypervisor as gateway chassis, for router port 172.31.0.1
   ovn-nbctl lrp-set-gateway-chassis router-to-underlay hv3
   wait_for_ports_up
   ovn-nbctl --wait=sb sync
   OVN_WAIT_PATCH_PORT_FLOWS(["ln1"] ["ln2"], ["hv1"] ["hv2"] ["hv3"])
   OVN_WAIT_PATCH_PORT_FLOWS(["ln4"], ["hv4"])

   wait_row_count Port_Binding 1 logical_port=cr-router-to-underlay

   # Dump a bunch of info helpful for debugging if there's a failure.

   ovn-sbctl dump-flows > sbflows
   AT_CAPTURE_FILE([sbflows])

   (ovn-nbctl show
    ovn-sbctl show
    ovn-sbctl list port_binding
    ovn-sbctl list mac_binding) > ovndump
   AT_CAPTURE_FILE([ovndump])

   (as hv1 ovs-vsctl show; as hv1 ovs-vsctl list Open_Vswitch) > hv1dump
   AT_CAPTURE_FILE([hv1dump])

   (as hv2 ovs-vsctl show; as hv2 ovs-vsctl list Open_Vswitch) > hv2dump
   AT_CAPTURE_FILE([hv2dump])

   (as hv3 ovs-vsctl show; as hv3 ovs-vsctl list Open_Vswitch) > hv3dump
   AT_CAPTURE_FILE([hv3dump])

   (as hv4 ovs-vsctl show; as hv4 ovs-vsctl list Open_Vswitch) > hv4dump
   AT_CAPTURE_FILE([hv4dump])

   test_arp vif-north f0f000000011 $sip $tip 000001010207

   # Confirm that vif-north gets a single ARP reply
   OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv4/vif-north-tx.pcap], [vif-north.expected])

   # Confirm that only redirect chassis allowed arp resolution.
   OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv3/br-phys_n1-tx.pcap], [vif-north_vid.expected])

   # Confirm that other OVN chassis did not generate ARP reply.
   $PYTHON "$ovs_srcdir//utilities/ovs-pcap.in" hv1/br-phys_n1-tx.pcap > hv1/br-phys_n1-tx.packets
   $PYTHON "$ovs_srcdir//utilities/ovs-pcap.in" hv2/br-phys_n1-tx.pcap > hv2/br-phys_n1-tx.packets

   AT_CHECK([grep 000001010207 hv1/br-phys_n1-tx.packets | wc -l], [0], [[0
]])
   AT_CHECK([grep 000001010207 hv2/br-phys_n1-tx.packets | wc -l], [0], [[0
]])

   # validate max_tunid reflects the type of encapsulation used
   max_tunid=`ovn-nbctl get NB_Global . options:max_tunid | sed s/":"//g | sed s/\"//g`
   if [[ $encap = vxlan ]]; then
       max_tunid_expected=4095
   else
       max_tunid_expected=16711680
   fi
   echo max_tunid=$max_tunid max_tunid_expected=$max_tunid_expected
   AT_CHECK([test -n "$max_tunid"])
   AT_CHECK([test "$max_tunid" -eq "$max_tunid_expected"])

   echo "----------- Post Traffic hv1 dump -----------"
   as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int
   as hv1 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv2 dump -----------"
   as hv2 ovs-ofctl -O OpenFlow13 dump-flows br-int
   as hv2 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv3 dump -----------"
   as hv3 ovs-ofctl -O OpenFlow13 dump-flows br-int
   as hv3 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv4 dump -----------"
   as hv4 ovs-ofctl -O OpenFlow13 dump-flows br-int
   as hv4 ovs-appctl fdb/show br-phys

   OVN_CLEANUP([hv1],[hv2],[hv3],[hv4])

   AT_CLEANUP])])

DVR_N_S_ARP_HANDLING([geneve])
DVR_N_S_ARP_HANDLING([vxlan])

m4_define([DVR_N_S_PING],
  [OVN_FOR_EACH_NORTHD([
   AT_SETUP([2 HVs, 2 lports/HV, localnet ports, DVR N-S Ping, encap $1])
   AT_KEYWORDS([$1])
   encap=$1
   ovn_start

   # In this test cases we create 3 switches, all connected to same
   # physical network (through br-phys on each HV). LS1 and LS2 have
   # 1 VIF each. Each HV has 1 VIF port. The first digit
   # of VIF port name indicates the hypervisor it is bound to, e.g.
   # lp23 means VIF 3 on hv2.
   #
   # All the switches are connected to a logical router "router".
   #
   # Each switch's VLAN tag and their logical switch ports are:
   #   - ls1:
   #       - tagged with VLAN 101
   #       - ports: lp11
   #   - ls2:
   #       - tagged with VLAN 201
   #       - ports: lp22
   #   - ls-underlay:
   #       - tagged with VLAN 1000
   # Note: a localnet port is created for each switch to connect to
   # physical network.

   for i in 1 2; do
       ls_name=ls$i
       ovn-nbctl ls-add $ls_name
       ln_port_name=ln$i
       if test $i -eq 1; then
           ovn-nbctl lsp-add $ls_name $ln_port_name "" 101
       elif test $i -eq 2; then
           ovn-nbctl lsp-add $ls_name $ln_port_name "" 201
       fi
       ovn-nbctl lsp-set-addresses $ln_port_name unknown
       ovn-nbctl lsp-set-type $ln_port_name localnet
       ovn-nbctl lsp-set-options $ln_port_name network_name=phys
   done

   # lsp_to_ls LSP
   #
   # Prints the name of the logical switch that contains LSP.
   lsp_to_ls () {
       case ${1} in dnl (
           lp?[[11]]) echo ls1 ;; dnl (
           lp?[[12]]) echo ls2 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_hv () {
       case ${1} in dnl (
           vif[[1]]?) echo hv1 ;; dnl (
           vif[[2]]?) echo hv2 ;; dnl (
           vif?[[north]]?) echo hv4 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   net_add n1
   for i in 1 2; do
       sim_add hv$i
       as hv$i
       ovs-vsctl add-br br-phys
       ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
       ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:$i$i"
       ovn_attach n1 br-phys 192.168.0.$i 24 $encap

       ovs-vsctl add-port br-int vif$i$i -- \
           set Interface vif$i$i external-ids:iface-id=lp$i$i \
                                 options:tx_pcap=hv$i/vif$i$i-tx.pcap \
                                 options:rxq_pcap=hv$i/vif$i$i-rx.pcap \
                                 ofport-request=$i$i

       lsp_name=lp$i$i
       ls_name=$(lsp_to_ls $lsp_name)

       ovn-nbctl lsp-add $ls_name $lsp_name
       ovn-nbctl lsp-set-addresses $lsp_name "f0:00:00:00:00:$i$i 192.168.$i.$i"
       ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:$i$i

       OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])

   done

   ovn-nbctl ls-add ls-underlay
   ovn-nbctl lsp-add ls-underlay ln3 "" 1000
   ovn-nbctl lsp-set-addresses ln3 unknown
   ovn-nbctl lsp-set-type ln3 localnet
   ovn-nbctl lsp-set-options ln3 network_name=phys

   ovn-nbctl ls-add ls-north
   ovn-nbctl lsp-add ls-north ln4 "" 1000
   ovn-nbctl lsp-set-addresses ln4 unknown
   ovn-nbctl lsp-set-type ln4 localnet
   ovn-nbctl lsp-set-options ln4 network_name=phys

   # Add a VM on ls-north
   ovn-nbctl lsp-add ls-north lp-north
   ovn-nbctl lsp-set-addresses lp-north "f0:f0:00:00:00:11 172.31.0.10"
   ovn-nbctl lsp-set-port-security lp-north f0:f0:00:00:00:11

   # Add 3rd hypervisor
   sim_add hv3
   as hv3 ovs-vsctl add-br br-phys
   as hv3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
   as hv3 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:33"
   as hv3 ovn_attach n1 br-phys 192.168.0.3 24 $encap

   # Add 4th hypervisor
   sim_add hv4
   as hv4 ovs-vsctl add-br br-phys
   as hv4 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
   as hv4 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:44"
   as hv4 ovn_attach n1 br-phys 192.168.0.4 24 $encap

   as hv4 ovs-vsctl add-port br-int vif-north -- \
           set Interface vif-north external-ids:iface-id=lp-north \
                                 options:tx_pcap=hv4/vif-north-tx.pcap \
                                 options:rxq_pcap=hv4/vif-north-rx.pcap \
                                 ofport-request=44

   ovn-nbctl lr-add router
   ovn-nbctl lrp-add router router-to-ls1 00:00:01:01:02:03 192.168.1.3/24
   ovn-nbctl lrp-add router router-to-ls2 00:00:01:01:02:05 192.168.2.3/24
   ovn-nbctl lrp-add router router-to-underlay 00:00:01:01:02:07 172.31.0.1/24

   ovn-nbctl lsp-add ls1 ls1-to-router -- set Logical_Switch_Port ls1-to-router type=router \
             options:router-port=router-to-ls1 -- lsp-set-addresses ls1-to-router router
   ovn-nbctl lsp-add ls2 ls2-to-router -- set Logical_Switch_Port ls2-to-router type=router \
             options:router-port=router-to-ls2 -- lsp-set-addresses ls2-to-router router
   ovn-nbctl lsp-add ls-underlay underlay-to-router -- set Logical_Switch_Port \
                                 underlay-to-router type=router \
                                 options:router-port=router-to-underlay \
                                 -- lsp-set-addresses underlay-to-router router

   ovn-nbctl lrp-set-gateway-chassis router-to-underlay hv3
   ovn-nbctl lrp-set-redirect-type router-to-underlay bridged

   wait_for_ports_up
   ovn-nbctl --wait=sb sync
   OVN_WAIT_PATCH_PORT_FLOWS(["ln1"] ["ln2"], ["hv1"] ["hv2"] ["hv3"])
   OVN_WAIT_PATCH_PORT_FLOWS(["ln4"], ["hv4"])

   OVN_POPULATE_ARP

   # lsp_to_ls LSP
   #
   # Prints the name of the logical switch that contains LSP.
   lsp_to_ls () {
       case ${1} in dnl (
           lp?[[11]]) echo ls1 ;; dnl (
           lp?[[12]]) echo ls2 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_ls () {
       case ${1} in dnl (
           vif?[[11]]) echo ls1 ;; dnl (
           vif?[[12]]) echo ls2 ;; dnl (
           vif-north) echo ls-north ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   hv_to_num () {
       case ${1} in dnl (
           hv1) echo 1 ;; dnl (
           hv2) echo 2 ;; dnl (
           hv3) echo 3 ;; dnl (
           hv4) echo 4 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_num () {
       case ${1} in dnl (
           vif22) echo 22 ;; dnl (
           vif21) echo 21 ;; dnl (
           vif11) echo 11 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_hv () {
       case ${1} in dnl (
           vif[[1]]?) echo hv1 ;; dnl (
           vif[[2]]?) echo hv2 ;; dnl (
           vif-north) echo hv4 ;; dnl (
           *) AT_FAIL_IF([:]) ;;
       esac
   }

   vif_to_lrp () {
       echo router-to-`vif_to_ls ${1}`
   }

   test_ip() {
           # This packet has bad checksums but logical L3 routing doesn't check.
           local inport=${1} src_mac=${2} dst_mac=${3} src_ip=${4} dst_ip=${5} outport=${6}
           local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
           shift; shift; shift; shift; shift
           hv=`vif_to_hv $inport`
           as $hv ovs-appctl netdev-dummy/receive $inport $packet
           in_ls=`vif_to_ls $inport`
           for outport; do
               out_ls=`vif_to_ls $outport`
               if test $in_ls = $out_ls; then
                   # Ports on the same logical switch receive exactly the same packet.
                   echo $packet
               else
                   # Routing decrements TTL and updates source and dest MAC
                   # (and checksum).
                   out_lrp=`vif_to_lrp $outport`
                   # For North-South, packet will come via gateway chassis, i.e hv3
                   if test $inport = vif-north; then
                       echo f0000000001100000101020308004500001c000000003f110100${src_ip}${dst_ip}0035111100080000 >> $outport.expected
                   fi
                   if test $outport = vif-north; then
                       echo f0f00000001100000101020708004500001c000000003e110200${src_ip}${dst_ip}0035111100080000 >> $outport.expected
                   fi
               fi >> $outport.expected
           done
   }

   # Dump a bunch of info helpful for debugging if there's a failure.

   echo "------ OVN dump ------"
   ovn-nbctl show
   ovn-sbctl show
   ovn-sbctl list port_binding
   ovn-sbctl list mac_binding

   echo "------ hv1 dump ------"
   as hv1 ovs-vsctl show
   as hv1 ovs-vsctl list Open_Vswitch

   echo "------ hv2 dump ------"
   as hv2 ovs-vsctl show
   as hv2 ovs-vsctl list Open_Vswitch

   echo "------ hv3 dump ------"
   as hv3 ovs-vsctl show
   as hv3 ovs-vsctl list Open_Vswitch

   echo "------ hv4 dump ------"
   as hv4 ovs-vsctl show
   as hv4 ovs-vsctl list Open_Vswitch

   echo "Send traffic North to South"

   sip=`ip_to_hex 172 31 0 10`
   dip=`ip_to_hex 192 168 1 1`
   test_ip vif-north f0f000000011 000001010207 $sip $dip vif11

   # Confirm that North to south traffic works fine.
   OVN_CHECK_PACKETS([hv1/vif11-tx.pcap], [vif11.expected])

   echo "Send traffic South to Nouth"
   sip=`ip_to_hex 192 168 1 1`
   dip=`ip_to_hex 172 31 0 10`
   test_ip vif11 f00000000011 000001010203 $sip $dip vif-north

   # Confirm that South to North traffic works fine.
   OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv4/vif-north-tx.pcap], [vif-north.expected])

   # Confirm that packets did not go out via tunnel port.
   AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep table=39 | grep NXM_NX_TUN_METADATA0 | grep n_packets=0 | wc -l], [0], [[0
]])

   # Confirm that packet went out via localnet port
   AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep table=65 | grep priority=150 | grep src=00:00:01:01:02:07 | grep n_packets=1 | wc -l], [0], [[1
]])

   echo "----------- Post Traffic hv1 dump -----------"
   as hv1 ovs-ofctl dump-flows br-int
   as hv1 ovs-ofctl show br-phys
   as hv1 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv2 dump -----------"
   as hv2 ovs-ofctl dump-flows br-int
   as hv2 ovs-ofctl show br-phys
   as hv2 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv3 dump -----------"
   as hv3 ovs-ofctl dump-flows br-int
   as hv3 ovs-ofctl show br-phys
   as hv3 ovs-appctl fdb/show br-phys

   echo "----------- Post Traffic hv4 dump -----------"
   as hv4 ovs-ofctl dump-flows br-int
   as hv4 ovs-ofctl show br-phys
   as hv4 ovs-appctl fdb/show br-phys

   OVN_CLEANUP([hv1],[hv2],[hv3],[hv4])

   AT_CLEANUP])])

DVR_N_S_PING([geneve])
DVR_N_S_PING([vxlan])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ARP lookup before learning])
AT_KEYWORDS([virtual ports])
ovn_start

send_garp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

send_arp_reply() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040002${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p3 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03"

# Create the second logical switch with one port
ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create a logical router and attach both logical switches
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

OVN_POPULATE_ARP
wait_for_ports_up
ovn-nbctl --wait=hv sync

as hv1 ovs-appctl -t ovn-controller vlog/set dbg

# From sw0-p1 send GARP for 10.0.0.30.
# ovn-controller should learn the
#   mac_binding entry
#     port - lr0-sw0
#     ip - 10.0.0.30
#     mac - 50:54:00:00:00:03

check_row_count MAC_Binding 0
eth_src=505400000003
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 30)
tpa=$(ip_to_hex 10 0 0 30)
send_garp 1 1 $eth_src $eth_dst $spa $tpa

wait_row_count MAC_Binding 1

OVS_WAIT_FOR_OUTPUT([ovn-sbctl --format=csv --bare --columns logical_port,ip,mac \
list mac_binding], [0], [lr0-sw0
10.0.0.30
50:54:00:00:00:03
])

AT_CHECK([test 1 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

AT_CHECK([test 1 = `cat hv1/ovn-controller.log | grep "pinctrl received  packet-in" | \
grep opcode=PUT_ARP | grep OF_Table_ID=10 | wc -l`])

AT_CHECK([test 1 = `as hv1 ovs-ofctl dump-flows br-int table=10 | grep arp | \
grep controller | grep -v n_packets=0 | wc -l`])

# Wait for an entry in table=67
OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep n_packets=0 \
| wc -l`]
)

# Send garp again. This time the packet should not be sent to ovn-controller.
send_garp 1 1 $eth_src $eth_dst $spa $tpa
# Wait for an entry in table=67
OVS_WAIT_UNTIL([test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep n_packets=1 | wc -l`])

# The packet should not be sent to ovn-controller. The packet
# count should be 1 only.
AT_CHECK([test 1 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])
AT_CHECK([test 1 = `as hv1 ovs-ofctl dump-flows br-int table=10 | grep arp | \
grep controller | grep -v n_packets=0 | wc -l`])

# Now send garp packet with different mac.
eth_src=505400000013
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 30)
tpa=$(ip_to_hex 10 0 0 30)
send_garp 1 1 $eth_src $eth_dst $spa $tpa

# The garp packet should be sent to ovn-controller and the mac_binding entry
# should be updated.
OVS_WAIT_UNTIL([test 2 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

check_row_count MAC_Binding 1

OVS_WAIT_FOR_OUTPUT([ovn-sbctl --format=csv --bare --columns logical_port,ip,mac \
list mac_binding], [0], [lr0-sw0
10.0.0.30
50:54:00:00:00:13
])

# Send ARP request to lrp - lr0-sw1 (20.0.0.1) using src mac 50:54:00:00:00:33
# and src ip - 10.0.0.50.from sw0-p1.
# ovn-controller should add the mac_binding entry
#   logical_port - lr0
#   IP           - 10.0.0.50
#   MAC          - 50:54:00:00:00:33
eth_src=505400000033
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 50)
tpa=$(ip_to_hex 20 0 0 1)

send_garp 1 1 $eth_src $eth_dst $spa $tpa

# The garp packet should be sent to ovn-controller and the mac_binding entry
# should be updated.
OVS_WAIT_UNTIL([test 3 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=50:54:00:00:00:33 \
| wc -l`]
)

OVS_WAIT_FOR_OUTPUT([ovn-sbctl --format=csv --bare --columns logical_port,ip,mac \
find mac_binding ip=10.0.0.50], [0], [lr0-sw0
10.0.0.50
50:54:00:00:00:33
])

# Send the same packet again.
send_garp 1 1 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=50:54:00:00:00:33 \
| grep n_packets=1 | wc -l`]
)

AT_CHECK([test 3 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

# Now send ARP reply packet with IP - 10.0.0.40 and mac 505400000023
eth_src=505400000023
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 40)
tpa=$(ip_to_hex 10 0 0 50)
send_arp_reply 1 1 $eth_src $eth_dst $spa $tpa

# ovn-controller should add the
#   mac_binding entry
#     port - lr0-sw0
#     ip - 10.0.0.40
#     mac - 50:54:00:00:00:23

# The garp packet should be sent to ovn-controller and the mac_binding entry
# should be updated.
OVS_WAIT_UNTIL([test 4 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

# Wait for an entry in table=67 for the learnt mac_binding entry.

OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=50:54:00:00:00:23 \
| wc -l`]
)

# Send the same garp reply. This time it should not be sent to ovn-controller.
send_arp_reply 1 1 $eth_src $eth_dst $spa $tpa
OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=50:54:00:00:00:23 \
| grep n_packets=1 | wc -l`]
)

AT_CHECK([test 4 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

send_arp_reply 1 1 $eth_src $eth_dst $spa $tpa
OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=50:54:00:00:00:23 \
| grep n_packets=2 | wc -l`]
)

AT_CHECK([test 4 = `cat hv1/ovn-controller.log | grep NXT_PACKET_IN2 | \
grep table_id=10 | wc -l`])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([1 HVs, 1 lport/HV, localnet ports, RARP])
ovn_start

# In this test case we create 1 switch and bring up a VIF on it.
# Logical switch will have a localnet port also.
# This VIF will be assigned a MAC address only (i.e. no ip).

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 ln1 "" 101
ovn-nbctl lsp-set-addresses ln1 unknown
ovn-nbctl lsp-set-type ln1 localnet
ovn-nbctl lsp-set-options ln1 network_name=phys

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.1

ovs-vsctl add-port br-int vif11 -- \
    set Interface vif11 external-ids:iface-id=lp11 \
                          options:tx_pcap=hv1/vif11-tx.pcap \
                          options:rxq_pcap=hv1/vif11-rx.pcap \
                          ofport-request=11

lsp_name=lp11

ovn-nbctl lsp-add ls1 lp11
ovn-nbctl lsp-set-addresses lp11 "f0:00:00:00:00:11"
ovn-nbctl lsp-set-port-security lp11 f0:00:00:00:00:11

wait_for_ports_up
ovn-nbctl --wait=sb sync

ovn-nbctl show
ovn-sbctl show

# Dump a bunch of info helpful for debugging if there's a failure.

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-vsctl list Open_Vswitch

echo "----------- Post Traffic hv1 dump -----------"
as hv1 ovs-ofctl -O OpenFlow13 dump-flows br-int
as hv1 ovs-appctl fdb/show br-phys

OVS_WAIT_UNTIL(
    [test 1 = `ovs-appctl fdb/show br-phys | grep f0:00:00:00:00:11 | \
grep 101 | wc -l`])

OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Stateless Floating IP])
ovn_start

# In this test cases we create 3 switches, all connected to same
# physical network (through br-phys on each HV). LS1 and LS2 have
# 1 VIF each. Each HV has 1 VIF port. The first digit
# of VIF port name indicates the hypervisor it is bound to, e.g.
# lp23 means VIF 3 on hv2.
#
# All the switches are connected to a logical router "router".
#
# There is an external logical switch, ls-north.
# This test validates the stateless floating ip implementation.
#
# Each switch's VLAN tag and their logical switch ports are:
#   - ls1:
#       - tagged with VLAN 101
#       - ports: lp11
#   - ls2:
#       - tagged with VLAN 201
#       - ports: lp22
#   - ls-north:
#       - tagged with VLAN 1000
# Note: a localnet port is created for each switch to connect to
# physical network.

for i in 1 2; do
    ls_name=ls$i
    ovn-nbctl ls-add $ls_name
    ln_port_name=ln$i
    if test $i -eq 1; then
        ovn-nbctl lsp-add $ls_name $ln_port_name "" 101
    elif test $i -eq 2; then
        ovn-nbctl lsp-add $ls_name $ln_port_name "" 201
    fi
    ovn-nbctl lsp-set-addresses $ln_port_name unknown
    ovn-nbctl lsp-set-type $ln_port_name localnet
    ovn-nbctl lsp-set-options $ln_port_name network_name=phys
done

# lsp_to_ls LSP
#
# Prints the name of the logical switch that contains LSP.
lsp_to_ls () {
    case $1 in dnl (
        lp?[[11]]) echo ls1 ;; dnl (
        lp?[[12]]) echo ls2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_hv () {
    case $1 in dnl (
        vif[[1]]?) echo hv1 ;; dnl (
        vif[[2]]?) echo hv2 ;; dnl (
        vif?[[north]]?) echo hv4 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

net_add n1
for i in 1 2; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:$i$i"
    ovn_attach n1 br-phys 192.168.0.$i

    ovs-vsctl add-port br-int vif$i$i -- \
        set Interface vif$i$i external-ids:iface-id=lp$i$i \
                              options:tx_pcap=hv$i/vif$i$i-tx.pcap \
                              options:rxq_pcap=hv$i/vif$i$i-rx.pcap \
                              ofport-request=$i$i

    lsp_name=lp$i$i
    ls_name=$(lsp_to_ls $lsp_name)

    ovn-nbctl lsp-add $ls_name $lsp_name
    ovn-nbctl lsp-set-addresses $lsp_name "f0:00:00:00:00:$i$i 192.168.$i.$i"
    ovn-nbctl lsp-set-port-security $lsp_name f0:00:00:00:00:$i$i

    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up $lsp_name` = xup])

done

ovn-nbctl ls-add ls-underlay
ovn-nbctl lsp-add ls-underlay ln3 "" 1000
ovn-nbctl lsp-set-addresses ln3 unknown
ovn-nbctl lsp-set-type ln3 localnet
ovn-nbctl lsp-set-options ln3 network_name=phys

ovn-nbctl ls-add ls-north
ovn-nbctl lsp-add ls-north ln4 "" 1000
ovn-nbctl lsp-set-addresses ln4 unknown
ovn-nbctl lsp-set-type ln4 localnet
ovn-nbctl lsp-set-options ln4 network_name=phys

# Add a VM on ls-north
ovn-nbctl lsp-add ls-north lp-north
ovn-nbctl lsp-set-addresses lp-north "f0:f0:00:00:00:11 172.31.0.10"
ovn-nbctl lsp-set-port-security lp-north f0:f0:00:00:00:11

# Add 3rd hypervisor
sim_add hv3
as hv3 ovs-vsctl add-br br-phys
as hv3 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
as hv3 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:33"
as hv3 ovn_attach n1 br-phys 192.168.0.3

# Add 4th hypervisor
sim_add hv4
as hv4 ovs-vsctl add-br br-phys
as hv4 ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
as hv4 ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:aa:bb:cc:dd:ee:44"
as hv4 ovn_attach n1 br-phys 192.168.0.4

as hv4 ovs-vsctl add-port br-int vif-north -- \
        set Interface vif-north external-ids:iface-id=lp-north \
                              options:tx_pcap=hv4/vif-north-tx.pcap \
                              options:rxq_pcap=hv4/vif-north-rx.pcap \
                              ofport-request=44

ovn-nbctl lr-add router
ovn-nbctl lrp-add router router-to-ls1 00:00:01:01:02:03 192.168.1.3/24
ovn-nbctl lrp-add router router-to-ls2 00:00:01:01:02:05 192.168.2.3/24
ovn-nbctl lrp-add router router-to-underlay 00:00:01:01:02:07 172.31.0.1/24

ovn-nbctl lsp-add ls1 ls1-to-router -- set Logical_Switch_Port ls1-to-router type=router \
          options:router-port=router-to-ls1 -- lsp-set-addresses ls1-to-router router
ovn-nbctl lsp-add ls2 ls2-to-router -- set Logical_Switch_Port ls2-to-router type=router \
          options:router-port=router-to-ls2 -- lsp-set-addresses ls2-to-router router
ovn-nbctl lsp-add ls-underlay underlay-to-router -- set Logical_Switch_Port \
                              underlay-to-router type=router \
                              options:router-port=router-to-underlay \
                              -- lsp-set-addresses underlay-to-router router

ovn-nbctl lrp-set-gateway-chassis router-to-underlay hv3
ovn-nbctl --stateless lr-nat-add router dnat_and_snat 172.31.0.100 192.168.1.1
ovn-nbctl lrp-set-redirect-type router-to-underlay bridged

wait_for_ports_up
ovn-nbctl --wait=sb sync

OVN_WAIT_PATCH_PORT_FLOWS(["ln1"] ["ln2"] ["ln3"], ["hv1"] ["hv2"] ["hv3"])
OVN_WAIT_PATCH_PORT_FLOWS(["ln4"], ["hv4"])

OVN_POPULATE_ARP

# lsp_to_ls LSP
#
# Prints the name of the logical switch that contains LSP.
lsp_to_ls () {
    case $1 in dnl (
        lp?[[11]]) echo ls1 ;; dnl (
        lp?[[12]]) echo ls2 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_ls () {
    case $1 in dnl (
        vif?[[11]]) echo ls1 ;; dnl (
        vif?[[12]]) echo ls2 ;; dnl (
        vif-north) echo ls-north ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

hv_to_num () {
    case $1 in dnl (
        hv1) echo 1 ;; dnl (
        hv2) echo 2 ;; dnl (
        hv3) echo 3 ;; dnl (
        hv4) echo 4 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_num () {
    case $1 in dnl (
        vif22) echo 22 ;; dnl (
        vif21) echo 21 ;; dnl (
        vif11) echo 11 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_hv () {
    case $1 in dnl (
        vif[[1]]?) echo hv1 ;; dnl (
        vif[[2]]?) echo hv2 ;; dnl (
        vif-north) echo hv4 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_lrp () {
    echo router-to-`vif_to_ls $1`
}

test_ip() {
        # This packet has bad checksums but logical L3 routing doesn't check.
        local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5 outport=$6
        local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
        shift; shift; shift; shift; shift
        hv=`vif_to_hv $inport`
        as $hv ovs-appctl netdev-dummy/receive $inport $packet
        in_ls=`vif_to_ls $inport`
        for outport; do
            out_ls=`vif_to_ls $outport`
            if test $in_ls = $out_ls; then
                # Ports on the same logical switch receive exactly the same packet.
                echo $packet
            else
                # Routing decrements TTL and updates source and dest MAC
                # (and checksum).
                out_lrp=`vif_to_lrp $outport`
                # For North-South, packet will come via gateway chassis, i.e hv3
                if test $inport = vif-north; then
                    echo f0000000001100000101020308004500001c000000003f110100${src_ip}${dst_ip}0035111100080000 >> $outport.expected
                fi
                if test $outport = vif-north; then
                    echo f0f00000001100000101020708004500001c000000003e111726ac1f0064${dst_ip}0035111100080000 >> $outport.expected
                fi
            fi >> $outport.expected
        done
}

# Dump a bunch of info helpful for debugging if there's a failure.

echo "------ OVN dump ------"
ovn-nbctl show
ovn-nbctl lr-nat-list router
ovn-sbctl show
ovn-sbctl list port_binding
ovn-sbctl list mac_binding
ovn-sbctl dump-flows

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-vsctl list Open_Vswitch

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-vsctl list Open_Vswitch

echo "------ hv3 dump ------"
as hv3 ovs-vsctl show
as hv3 ovs-vsctl list Open_Vswitch

echo "------ hv4 dump ------"
as hv4 ovs-vsctl show
as hv4 ovs-vsctl list Open_Vswitch

echo "Send traffic South to Nouth"
sip=`ip_to_hex 192 168 1 1`
dip=`ip_to_hex 172 31 0 10`
test_ip vif11 f00000000011 000001010203 $sip $dip vif-north

# Confirm that South to North traffic works fine.
OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv4/vif-north-tx.pcap], [vif-north.expected])

# Confirm that NATing happened without connection tracker
ovn-sbctl dump-flows router > sbflows
AT_CAPTURE_FILE([sbflows])
AT_CHECK([for regex in ct_snat ct_dnat ip4.dst= ip4.src=; do
  grep -c "$regex" sbflows;
done], [0], [0
0
1
1
])

echo "----------- Post Traffic hv1 dump -----------"
as hv1 ovs-ofctl dump-flows br-int
as hv1 ovs-ofctl show br-phys
as hv1 ovs-appctl fdb/show br-phys
as hv1 ovs-dpctl dump-flows

echo "----------- Post Traffic hv2 dump -----------"
as hv2 ovs-ofctl dump-flows br-int
as hv2 ovs-ofctl show br-phys
as hv2 ovs-appctl fdb/show br-phys

echo "----------- Post Traffic hv3 dump -----------"
as hv3 ovs-ofctl dump-flows br-int
as hv3 ovs-ofctl show br-phys
as hv3 ovs-appctl dpctl/dump-conntrack
as hv3 ovs-appctl fdb/show br-phys
as hv3 ovs-dpctl dump-flows
as hv3 ovs-ofctl dump-flows br-int

echo "----------- Post Traffic hv4 dump -----------"
as hv4 ovs-ofctl dump-flows br-int
as hv4 ovs-ofctl show br-phys
as hv4 ovs-appctl fdb/show br-phys

OVN_CLEANUP([hv1],[hv2],[hv3],[hv4])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load balancer health checks - IPv4])
AT_KEYWORDS([lb])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

# Create port group and ACLs for sw0 ports.
check ovn-nbctl pg-add pg0_drop sw0-p1
check ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
check ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

# Create the second logical switch with one port
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1
check ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
check ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create port group and ACLs for sw1 ports.
check ovn-nbctl pg-add pg1_drop sw1-p1
check ovn-nbctl acl-add pg1_drop from-lport 1001 "inport == @pg1_drop && ip" drop
check ovn-nbctl acl-add pg1_drop to-lport 1001 "outport == @pg1_drop && ip" drop

check ovn-nbctl pg-add pg1 sw1-p1
check ovn-nbctl acl-add pg1 from-lport 1002 "inport == @pg1 && ip4" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 router
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

check ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80
OVN_LB_ID=$(ovn-nbctl --bare --column _uuid find load_balancer name=lb1)
check ovn-nbctl set load_balancer ${OVN_LB_ID} selection_fields="ip_dst,ip_src,tp_dst,tp_src"

check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2

AT_CHECK([ovn-nbctl --wait=sb \
          -- --id=@hc create Load_Balancer_Health_Check vip="10.0.0.10\:80" \
             options:failure_count=100 \
          -- add Load_Balancer . health_check @hc | uuidfilt], [0], [<0>
])

check ovn-nbctl --wait=sb ls-lb-add sw0 lb1
check ovn-nbctl --wait=sb ls-lb-add sw1 lb1
check ovn-nbctl --wait=sb lr-lb-add lr0 lb1

check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
check ovn-nbctl lsp-add public ln-public
check ovn-nbctl lsp-set-type ln-public localnet
check ovn-nbctl lsp-set-addresses ln-public unknown
check ovn-nbctl lsp-set-options ln-public network_name=public

# schedule the gw router port to a chassis. Change the name of the chassis
check ovn-nbctl --wait=hv lrp-set-gateway-chassis lr0-public hv1 20

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync

wait_row_count Service_Monitor 2

AT_CAPTURE_FILE([sbflows])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows > sbflows
   ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | sed 's/table=..//'], 0,
  [dnl
  (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg1 = 10.0.0.10; reg2[[0..15]] = 80; ct_lb_mark;)
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80; hash_fields="ip_dst,ip_src,tcp_dst,tcp_src");)
])

AT_CAPTURE_FILE([sbflows2])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows > sbflows2
   ovn-sbctl dump-flows lr0 | grep ct_lb_mark | grep priority=120 | sed 's/table=..//'], 0,
  [  (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80 && is_chassis_resident("cr-lr0-public")), action=(ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80; hash_fields="ip_dst,ip_src,tcp_dst,tcp_src");)
])

# get the svc monitor mac.
svc_mon_src_mac=`ovn-nbctl get NB_Global . options:svc_monitor_mac | \
sed s/":"//g | sed s/\"//g`

# If the system is overloaded and the test runs slowly, we might get multiple similar packets (just varying by src port)
OVS_WAIT_UNTIL(
    [test 1 -le `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap | \
grep "505400000003${svc_mon_src_mac}" | wc -l`]
)

OVS_WAIT_UNTIL(
    [test 1 -le `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/vif1-tx.pcap | \
grep "405400000003${svc_mon_src_mac}" | wc -l`]
)

check ovn-nbctl set load_balancer_health_check 10.0.0.10:80 options:failure_count=1
wait_row_count Service_Monitor 2 status=offline

OVS_WAIT_UNTIL(
    [test 2 -le `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap | \
grep "505400000003${svc_mon_src_mac}" | wc -l`]
)

OVS_WAIT_UNTIL(
    [test 2 -le `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/vif1-tx.pcap | \
grep "405400000003${svc_mon_src_mac}" | wc -l`]
)

AT_CAPTURE_FILE([sbflows3])
ovn-sbctl dump-flows sw0 > sbflows3
AT_CHECK(
  [grep "ip4.dst == 10.0.0.10 && tcp.dst == 80" sbflows3 | grep priority=120 |\
   sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg1 = 10.0.0.10; reg2[[0..15]] = 80; ct_lb_mark;)
  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(drop;)
])

AT_CAPTURE_FILE([sbflows4])
ovn-sbctl dump-flows lr0 > sbflows4
AT_CHECK([grep lr_in_dnat sbflows4 | grep priority=120 | sed 's/table=..//' | sort], [0], [dnl
  (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80 && is_chassis_resident("cr-lr0-public")), action=(drop;)
])

# Delete sw0-p1
check ovn-nbctl lsp-del sw0-p1

wait_row_count Service_Monitor 1

# Add back sw0-p1 but without any IP address.
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03" -- \
    lsp-set-port-security sw0-p1 "50:54:00:00:00:03"

wait_row_count Service_Monitor 2 status=offline

check ovn-nbctl lsp-del sw0-p1
check ovn-nbctl lsp-del sw1-p1
wait_row_count Service_Monitor 0

# Add back sw0-p1 but without any address set.
check ovn-nbctl lsp-add sw0 sw0-p1

wait_row_count Service_Monitor 1
wait_row_count Service_Monitor 0 status=offline
wait_row_count Service_Monitor 0 status=online

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load balancer health checks - IPv6])
AT_KEYWORDS([lb])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 2001::3"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 2001::3"

# Create port group and ACLs for sw0 ports.
check ovn-nbctl pg-add pg0_drop sw0-p1
check ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
check ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

# Create the second logical switch with one port
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1
check ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 2002::3"
check ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 2002::3"

# Create port group and ACLs for sw1 ports.
check ovn-nbctl pg-add pg1_drop sw1-p1
check ovn-nbctl acl-add pg1_drop from-lport 1001 "inport == @pg1_drop && ip" drop
check ovn-nbctl acl-add pg1_drop to-lport 1001 "outport == @pg1_drop && ip" drop

check ovn-nbctl pg-add pg1 sw1-p1
check ovn-nbctl acl-add pg1 from-lport 1002 "inport == @pg1 && ip6" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip6 && ip6.src == ::/0 && icmp6" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip6 && ip6.src == ::/0 && tcp && tcp.dst == 80" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip6 && ip6.src == ::/0 && udp && udp.dst == 80" allow-related

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 2001::1/64
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 2001::a/64
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 router
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

check ovn-nbctl lb-add lb1 [[2001::a]]:80 [[2001::3]]:80,[[2002::3]]:80
OVN_LB_ID=$(ovn-nbctl --bare --column _uuid find load_balancer name=lb1)
check ovn-nbctl set load_balancer ${OVN_LB_ID} selection_fields="ip_dst,ip_src,tp_dst,tp_src"
#
check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:\"[[2001::3]]\"=\"sw0-p1:[[2001::2]]\"
check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:\"[[2002::3]]\"=\"sw1-p1:[[2002::2]]\"

AT_CHECK([ovn-nbctl --wait=sb \
          -- --id=@hc create Load_Balancer_Health_Check vip="\[\[2001\:\:a\]\]\:80" \
             options:failure_count=100 \
          -- add Load_Balancer . health_check @hc | uuidfilt], [0], [<0>
])

check ovn-nbctl --wait=sb ls-lb-add sw0 lb1
check ovn-nbctl --wait=sb ls-lb-add sw1 lb1
check ovn-nbctl --wait=sb lr-lb-add lr0 lb1

check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 2003::1/64
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
check ovn-nbctl lsp-add public ln-public
check ovn-nbctl lsp-set-type ln-public localnet
check ovn-nbctl lsp-set-addresses ln-public unknown
check ovn-nbctl lsp-set-options ln-public network_name=public

# schedule the gw router port to a chassis. Change the name of the chassis
check ovn-nbctl --wait=hv lrp-set-gateway-chassis lr0-public hv1 20

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync

wait_row_count Service_Monitor 2

AT_CAPTURE_FILE([sbflows])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows > sbflows
   ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | sed 's/table=..//'], 0,
  [dnl
  (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip6.dst == 2001::a && tcp.dst == 80), action=(xxreg1 = 2001::a; reg2[[0..15]] = 80; ct_lb_mark;)
  (ls_in_lb           ), priority=120  , match=(ct.new && ip6.dst == 2001::a && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=[[2001::3]]:80,[[2002::3]]:80; hash_fields="ip_dst,ip_src,tcp_dst,tcp_src");)
])

AT_CAPTURE_FILE([sbflows2])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows > sbflows2
   ovn-sbctl dump-flows lr0 | grep ct_lb_mark | grep priority=120 | sed 's/table=..//'], 0,
  [  (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip6 && ip6.dst == 2001::a && tcp && tcp.dst == 80 && is_chassis_resident("cr-lr0-public")), action=(ct_lb_mark(backends=[[2001::3]]:80,[[2002::3]]:80; hash_fields="ip_dst,ip_src,tcp_dst,tcp_src");)
])

# get the svc monitor mac.
svc_mon_src_mac=`ovn-nbctl get NB_Global . options:svc_monitor_mac | \
sed s/":"//g | sed s/\"//g`

OVS_WAIT_UNTIL(
    [test 1 -le `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap | \
grep "505400000003${svc_mon_src_mac}" | wc -l`]
)

OVS_WAIT_UNTIL(
    [test 1 -le `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/vif1-tx.pcap | \
grep "405400000003${svc_mon_src_mac}" | wc -l`]
)

check ovn-nbctl set load_balancer_health_check [[2001::a]]:80 options:failure_count=1
wait_row_count Service_Monitor 2 status=offline

OVS_WAIT_UNTIL(
    [test 2 -le `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap | \
grep "505400000003${svc_mon_src_mac}" | wc -l`]
)

OVS_WAIT_UNTIL(
    [test 2 -le `$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv2/vif1-tx.pcap | \
grep "405400000003${svc_mon_src_mac}" | wc -l`]
)

AT_CAPTURE_FILE([sbflows3])
ovn-sbctl dump-flows sw0 > sbflows3
AT_CHECK(
  [grep "ip6.dst == 2001::a && tcp.dst == 80" sbflows3 | grep priority=120 |\
   sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip6.dst == 2001::a && tcp.dst == 80), action=(xxreg1 = 2001::a; reg2[[0..15]] = 80; ct_lb_mark;)
  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip6.dst == 2001::a && tcp.dst == 80), action=(drop;)
])

AT_CAPTURE_FILE([sbflows4])
ovn-sbctl dump-flows lr0 > sbflows4
AT_CHECK([grep lr_in_dnat sbflows4 | grep priority=120 | sed 's/table=..//' | sort], [0], [dnl
  (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip6 && ip6.dst == 2001::a && tcp && tcp.dst == 80 && is_chassis_resident("cr-lr0-public")), action=(drop;)
])

# Delete sw0-p1
check ovn-nbctl lsp-del sw0-p1

wait_row_count Service_Monitor 1

# Add back sw0-p1 but without any IP address.
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03" -- \
    lsp-set-port-security sw0-p1 "50:54:00:00:00:03"

wait_row_count Service_Monitor 2 status=offline

check ovn-nbctl lsp-del sw0-p1
check ovn-nbctl lsp-del sw1-p1
wait_row_count Service_Monitor 0

# Add back sw0-p1 but without any address set.
check ovn-nbctl lsp-add sw0 sw0-p1

wait_row_count Service_Monitor 1
wait_row_count Service_Monitor 0 status=offline
wait_row_count Service_Monitor 0 status=online

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([SCTP Load balancer health checks])
AT_KEYWORDS([lb sctp])

# Currently this test just ensures that no service monitors get created when
# An SCTP load balancer is configured to use health checks. Once SCTP load
# balancers are modified to allow health checks, this test should be altered
# to ensure the health check succeeds.

ovn_start

# Set up same network as previous health check test. As long as health checks
# aren't allowed for SCTP load balancers, the network will not be used for
# much. However, having the network in place will make it easy to alter when
# health checks are allowed.

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

# Create the second logical switch with one port
ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create a logical router and attach both logical switches
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 router
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80 sctp

ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:10.0.0.2

ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer . \
health_check @hc

ovn-nbctl --wait=sb ls-lb-add sw0 lb1
ovn-nbctl --wait=sb ls-lb-add sw1 lb1
ovn-nbctl --wait=sb lr-lb-add lr0 lb1

ovn-nbctl ls-add public
ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24
ovn-nbctl lsp-add public public-lr0
ovn-nbctl lsp-set-type public-lr0 router
ovn-nbctl lsp-set-addresses public-lr0 router
ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
ovn-nbctl lsp-add public ln-public
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-options ln-public network_name=public

# schedule the gw router port to a chassis. Change the name of the chassis
ovn-nbctl --wait=hv lrp-set-gateway-chassis lr0-public hv1 20

OVN_POPULATE_ARP
wait_for_ports_up
ovn-nbctl --wait=hv sync

# And now for the anticlimax. We need to ensure that there is no
# service monitor in the southbound db.
check_row_count Service_Monitor 0

# Let's also be sure the warning message about SCTP load balancers is
# is in the ovn-northd log

AT_CHECK([test 1 = `grep -c "SCTP load balancers do not currently support health checks" northd/NORTHD_TYPE.log`])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ARP/ND request broadcast limiting])
ovn_start

send_arp_request() {
    local hv=$1 inport=$2 eth_src=$3 spa=$4 tpa=$5
    local eth_dst=ffffffffffff
    local eth_type=0806
    local eth=${eth_dst}${eth_src}${eth_type}

    local arp=0001080006040001${eth_src}${spa}${eth_dst}${tpa}

    local request=${eth}${arp}
    check as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

send_nd_ns() {
    local hv=$1 inport=$2 eth_src=$3 spa=$4 tpa=$5 cksum=$6

    local eth_dst=ffffffffffff
    local eth_type=86dd
    local eth=${eth_dst}${eth_src}${eth_type}

    local ip_vhlen=60000000
    local ip_plen=0020
    local ip_next=3a
    local ip_ttl=ff
    local ip=${ip_vhlen}${ip_plen}${ip_next}${ip_ttl}${spa}${tpa}

    # Neighbor Solicitation
    local icmp6_type=87
    local icmp6_code=00
    local icmp6_rsvd=00000000
    # ICMPv6 source lla option
    local icmp6_opt=01
    local icmp6_optlen=01
    local icmp6=${icmp6_type}${icmp6_code}${cksum}${icmp6_rsvd}${tpa}${icmp6_opt}${icmp6_optlen}${eth_src}

    local request=${eth}${ip}${icmp6}

    check as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

src_mac=000000000001

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.1

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.2

# One Aggregation Switch connected to two Logical networks (routers).
check ovn-nbctl ls-add sw-agg
check ovn-nbctl lsp-add sw-agg sw-agg-ext \
    -- lsp-set-addresses sw-agg-ext 00:00:00:00:00:01

check ovn-nbctl lsp-add sw-agg sw-rtr1             \
    -- lsp-set-type sw-rtr1 router                 \
    -- lsp-set-addresses sw-rtr1 00:00:00:00:01:00 \
    -- lsp-set-options sw-rtr1 router-port=rtr1-sw
check ovn-nbctl lsp-add sw-agg sw-rtr2             \
    -- lsp-set-type sw-rtr2 router                 \
    -- lsp-set-addresses sw-rtr2 00:00:00:00:02:00 \
    -- lsp-set-options sw-rtr2 router-port=rtr2-sw

# Localnet port on the Aggregation Switch.
check ovn-nbctl lsp-add sw-agg sw-agg-ln
check ovn-nbctl lsp-set-addresses sw-agg-ln unknown
check ovn-nbctl lsp-set-type sw-agg-ln localnet
check ovn-nbctl lsp-set-options sw-agg-ln network_name=phys

# Configure L3 interface IPv4 & IPv6 on both routers.
check ovn-nbctl lr-add rtr1
check ovn-nbctl lrp-add rtr1 rtr1-sw 00:00:00:00:01:00 10.0.0.1/24 10::1/64

check ovn-nbctl lrp-add rtr1 rtr1-sw1 00:00:01:00:00:00 20.0.0.1/24 20::1/64

check ovn-nbctl lr-add rtr2
check ovn-nbctl lrp-add rtr2 rtr2-sw 00:00:00:00:02:00 10.0.0.2/24 10::2/64

# Configure router gateway ports.
check ovn-nbctl lrp-set-gateway-chassis rtr1-sw hv1 20
check ovn-nbctl lrp-set-gateway-chassis rtr2-sw hv1 20

# One private network behind rtr1 with two VMs.
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1 \
    -- lsp-set-addresses sw1-p1 00:00:00:01:00:00
check ovn-nbctl lsp-add sw1 sw1-p2 \
    -- lsp-set-addresses sw1-p2 00:00:00:02:00:00
check ovn-nbctl lsp-add sw1 sw1-rtr1                 \
    -- lsp-set-type sw1-rtr1 router                  \
    -- lsp-set-addresses sw1-rtr1 00:00:01:00:00:00  \
    -- lsp-set-options sw1-rtr1 router-port=rtr1-sw1

# Bind a "VM" connected to sw-agg on hv1.
as hv1
check ovs-vsctl -- add-port br-int hv1-vif0 -- \
    set interface hv1-vif0 external-ids:iface-id=sw-agg-ext \
    options:tx_pcap=hv1/vif0-tx.pcap \
    options:rxq_pcap=hv1/vif0-rx.pcap \
    ofport-request=1

# Bind a "VM" connected to sw1 on hv1.
as hv1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=2

# Bind a "VM" connected to sw1 on hv2.
as hv2
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=3

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

sw_dp_uuid=$(ovn-sbctl --bare --columns _uuid list datapath_binding sw-agg)
sw_dp_key=$(ovn-sbctl --bare --columns tunnel_key list datapath_binding sw-agg)
sw1_dp_key=$(ovn-sbctl --bare --columns tunnel_key list datapath_binding sw1)
r1_dp_key=$(ovn-sbctl --bare --columns tunnel_key list datapath_binding rtr1)

r1_tnl_key=$(ovn-sbctl --bare --columns tunnel_key list port_binding sw-rtr1)
r2_tnl_key=$(ovn-sbctl --bare --columns tunnel_key list port_binding sw-rtr2)

match_sw_metadata="metadata=0x${sw_dp_key}"
match_sw1_metadata="metadata=0x${sw1_dp_key}"
match_r1_metadata="metadata=0x${r1_dp_key}"

# Inject ARP request for first router owned IP address.
send_arp_request 1 0 ${src_mac} $(ip_to_hex 10 0 0 254) $(ip_to_hex 10 0 0 1)

# Verify that the ARP request is sent only to rtr1.
match_arp_req="priority=80.*${match_sw_metadata}.*arp_tpa=10.0.0.1,arp_op=1"
match_send_rtr1="load:0x${r1_tnl_key}->NXM_NX_REG15"
match_send_rtr2="load:0x${r2_tnl_key}->NXM_NX_REG15"

for var in sw_dp_uuid sw_dp_key sw1_dp_key r1_dp_key r1_tnl_key r2_tnl_key \
           match_arp_req match_send_rtr1 match_send_rtr2; do
   AS_VAR_COPY([value], [$var])
   echo "$var=$value"
done

as hv1
AT_CAPTURE_FILE([offlows])
OVS_WAIT_FOR_OUTPUT([
    ovs-ofctl dump-flows br-int > offlows
    for match in "$match_send_rtr1" "$match_send_rtr2"; do
        grep -E "$match_arp_req.*$match" offlows | grep -c 'n_packets=[[1-9]]'
    done
    :
], [0], [1
0
])

# Inject ND_NS for ofirst router owned IP address.
src_ipv6=00100000000000000000000000000254
dst_ipv6=00100000000000000000000000000001
send_nd_ns 1 0 ${src_mac} ${src_ipv6} ${dst_ipv6} 751d

# Verify that the ND_NS is sent only to rtr1.
match_nd_ns="priority=80.*${match_sw_metadata}.*icmp_type=135.*nd_target=10::1"

as hv1
OVS_WAIT_FOR_OUTPUT([
    ovs-ofctl dump-flows br-int > offlows
    for match in "$match_send_rtr1" "$match_send_rtr2"; do
        grep -E "$match_nd_ns.*$match" offlows | grep -c 'n_packets=[[1-9]]'
    done
    :
], [0], [1
0
])

# Configure load balancing on both routers.
check ovn-nbctl lb-add lb1-v4 10.0.0.11 42.42.42.1
check ovn-nbctl lb-add lb1-v6 10::11 42::1
check ovn-nbctl lr-lb-add rtr1 lb1-v4
check ovn-nbctl lr-lb-add rtr1 lb1-v6

check ovn-nbctl lb-add lb2-v4 10.0.0.22 42.42.42.2
check ovn-nbctl lb-add lb2-v6 10::22 42::2
check ovn-nbctl lr-lb-add rtr2 lb2-v4
check ovn-nbctl lr-lb-add rtr2 lb2-v6
check ovn-nbctl --wait=hv sync

# Inject ARP request for first router owned VIP address.
send_arp_request 1 0 ${src_mac} $(ip_to_hex 10 0 0 254) $(ip_to_hex 10 0 0 11)

# Verify that the ARP request is sent only to rtr1.
match_arp_req="priority=80.*${match_sw_metadata}.*arp_tpa=10.0.0.11,arp_op=1"
match_send_rtr1="load:0x${r1_tnl_key}->NXM_NX_REG15"
match_send_rtr2="load:0x${r2_tnl_key}->NXM_NX_REG15"

as hv1
OVS_WAIT_UNTIL([
    pkts_to_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep "${match_send_rtr1}" | \
    grep n_packets=1 -c)
    test "1" = "${pkts_to_rtr1}"
])
OVS_WAIT_UNTIL([
    pkts_to_rtr2=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep "${match_send_rtr2}" | \
    grep n_packets=1 -c)
    test "0" = "${pkts_to_rtr2}"
])

# Inject ND_NS for first router owned VIP address.
src_ipv6=00100000000000000000000000000254
dst_ipv6=00100000000000000000000000000011
send_nd_ns 1 0 ${src_mac} ${src_ipv6} ${dst_ipv6} 751d

# Verify that the ND_NS is sent only to rtr1.
match_nd_ns="priority=80.*${match_sw_metadata}.*icmp_type=135.*nd_target=10::11"

as hv1
OVS_WAIT_UNTIL([
    pkts_to_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep "${match_send_rtr1}" | \
    grep n_packets=1 -c)
    test "1" = "${pkts_to_rtr1}"
])
OVS_WAIT_UNTIL([
    pkts_to_rtr2=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep "${match_send_rtr2}" | \
    grep n_packets=1 -c)
    test "0" = "${pkts_to_rtr2}"
])

# Configure NAT on both routers.
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10.0.0.111 42.42.42.1
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10::111 42::1
check ovn-nbctl lr-nat-add rtr2 dnat_and_snat 10.0.0.222 42.42.42.2
check ovn-nbctl lr-nat-add rtr2 dnat_and_snat 10::222 42::2
check ovn-nbctl --wait=hv sync

# Configure FIP1 and FIP2 on rtr1 for sw1-p1 and sw1-p2.
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10.0.0.121 20.0.0.11 sw1-p1 00:00:00:01:00:00
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10::121 20::11 sw1-p1 00:00:00:01:00:00
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10.0.0.122 20.0.0.12 sw1-p2 00:00:00:02:00:00
check ovn-nbctl lr-nat-add rtr1 dnat_and_snat 10::122 20::12 sw1-p2 00:00:00:02:00:00
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

# Check that broadcast domain limiting flows match only on IPs that are
# directly reachable via the router port.
# For sw-rtr1:
# - 10.0.0.1, 10::1, fe80::200:ff:fe00:100 - interface IPs.
# - 10.0.0.11, 10::11 - LB VIPs.
# - 10.0.0.111, 10.0.0.121, 10.0.0.122, 10::111, 10::121, 10::122 - DNAT IPs.
# For sw-rtr2:
# - 10.0.0.2, 10::2, fe80::200:ff:fe00:200 - interface IPs.
# - 10.0.0.22, 10::22 - LB VIPs.
# - 10.0.0.222, 10::222 - DNAT IPs.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=80,.*${match_sw_metadata}" | grep -oE "arp_tpa=[[0-9.]]+" | sort], [0], [dnl
arp_tpa=10.0.0.1
arp_tpa=10.0.0.11
arp_tpa=10.0.0.111
arp_tpa=10.0.0.121
arp_tpa=10.0.0.122
arp_tpa=10.0.0.2
arp_tpa=10.0.0.22
arp_tpa=10.0.0.222
])
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=80,.*${match_sw_metadata}" | grep -oE "nd_target=[[0-9a-f:]]+" | sort], [0], [dnl
nd_target=10::1
nd_target=10::11
nd_target=10::111
nd_target=10::121
nd_target=10::122
nd_target=10::2
nd_target=10::22
nd_target=10::222
nd_target=fe80::200:ff:fe00:100
nd_target=fe80::200:ff:fe00:200
])

# For sw1-rtr1:
# - 20.0.0.1, 20::1, fe80::200:1ff:fe00:0 - interface IPs.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=80,.*${match_sw1_metadata}" | grep -oE "arp_tpa=[[0-9.]]+" | sort], [0], [dnl
arp_tpa=10.0.0.111
arp_tpa=10.0.0.121
arp_tpa=10.0.0.122
arp_tpa=20.0.0.1
])
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=80,.*${match_sw1_metadata}" | grep -oE "nd_target=[[0-9a-f:]]+" | sort], [0], [dnl
nd_target=10::111
nd_target=10::121
nd_target=10::122
nd_target=20::1
nd_target=fe80::200:1ff:fe00:0
])

# Self originated ARP/NS with SMACs owned by rtr1-sw and rtr2-sw should be
# flooded:
# - 00:00:00:00:01:00 - interface MAC (rtr1-sw).
# - 00:00:00:00:02:00 - interface MAC (rtr2-sw).
# - 00:00:00:01:00:00 - dnat_and_snat external MAC.
# - 00:00:00:02:00:00 - dnat_and_snat external MAC.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=75,arp.*${match_sw_metadata}.*arp_op=1" | grep -oE "dl_src=[[0-9a-f:]]+" | sort], [0], [dnl
dl_src=00:00:00:00:01:00
dl_src=00:00:00:00:02:00
dl_src=00:00:00:01:00:00
dl_src=00:00:00:02:00:00
])
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=75,rarp.*${match_sw_metadata}.*arp_op=3" | grep -oE "dl_src=[[0-9a-f:]]+" | sort], [0], [dnl
dl_src=00:00:00:00:01:00
dl_src=00:00:00:00:02:00
dl_src=00:00:00:01:00:00
dl_src=00:00:00:02:00:00
])
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=75,.*${match_sw_metadata}.*icmp_type=135" | grep -oE "dl_src=[[0-9a-f:]]+" | sort], [0], [dnl
dl_src=00:00:00:00:01:00
dl_src=00:00:00:00:02:00
dl_src=00:00:00:01:00:00
dl_src=00:00:00:02:00:00
])

# Self originated ARP/NS with SMACs owned by rtr1-sw1 should be flooded:
# - 00:00:01:00:00:00 - interface MAC.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep -E "priority=75,.*${match_sw1_metadata}.*arp_op=1" | grep -oE "dl_src=[[0-9a-f:]]+" | sort], [0], [dnl
dl_src=00:00:00:01:00:00
dl_src=00:00:00:02:00:00
dl_src=00:00:01:00:00:00
])

# Inject ARP request for first router owned NAT address.
send_arp_request 1 0 ${src_mac} $(ip_to_hex 10 0 0 254) $(ip_to_hex 10 0 0 111)

# Verify that the ARP request is sent only to rtr1.
match_arp_req="priority=80.*${match_sw_metadata}.*arp_tpa=10.0.0.111,arp_op=1"
match_send_rtr1="load:0x${r1_tnl_key}->NXM_NX_REG15"
match_send_rtr2="load:0x${r2_tnl_key}->NXM_NX_REG15"

as hv1
OVS_WAIT_UNTIL([
    pkts_to_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep "${match_send_rtr1}" | \
    grep n_packets=1 -c)
    test "1" = "${pkts_to_rtr1}"
])
OVS_WAIT_UNTIL([
    pkts_to_rtr2=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep "${match_send_rtr2}" | \
    grep n_packets=1 -c)
    test "0" = "${pkts_to_rtr2}"
])

# Inject ARP request for FIP1.
send_arp_request 1 0 ${src_mac} $(ip_to_hex 10 0 0 254) $(ip_to_hex 10 0 0 121)

# Verify that the ARP request is replied to from hv1 and not hv2.
match_arp_req="priority=92.*${match_r1_metadata}.*arp_tpa=10.0.0.121,arp_op=1"

as hv1
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep n_packets=1 -c)
    test "1" = "${pkts_on_rtr1}"
])

as hv2
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep n_packets=1 -c)
    test "0" = "${pkts_on_rtr1}"
])

# Inject ARP request for FIP2.
send_arp_request 1 0 ${src_mac} $(ip_to_hex 10 0 0 254) $(ip_to_hex 10 0 0 122)

# Verify that the ARP request is replied to from hv2 and not hv1.
match_arp_req="priority=92.*${match_r1_metadata}.*arp_tpa=10.0.0.122,arp_op=1"

as hv2
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep n_packets=1 -c)
    test "1" = "${pkts_on_rtr1}"
])

as hv1
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_arp_req}" | grep n_packets=1 -c)
    test "0" = "${pkts_on_rtr1}"
])

# Inject ND_NS for first router owned IP address.
src_ipv6=00100000000000000000000000000254
dst_ipv6=00100000000000000000000000000111
send_nd_ns 1 0 ${src_mac} ${src_ipv6} ${dst_ipv6} 751d

# Verify that the ND_NS is sent only to rtr1.
match_nd_ns="priority=80.*${match_sw_metadata}.*icmp_type=135.*nd_target=10::111"

as hv1
OVS_WAIT_UNTIL([
    pkts_to_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep "${match_send_rtr1}" | \
    grep n_packets=1 -c)
    test "1" = "${pkts_to_rtr1}"
])
OVS_WAIT_UNTIL([
    pkts_to_rtr2=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep "${match_send_rtr2}" | \
    grep n_packets=1 -c)
    test "0" = "${pkts_to_rtr2}"
])

# Inject ND_NS for FIP1.
src_ipv6=00100000000000000000000000000254
dst_ipv6=00100000000000000000000000000121
send_nd_ns 1 0 ${src_mac} ${src_ipv6} ${dst_ipv6} 72dd

# Verify that the ND_NS is replied to from hv1 and not hv2.
match_nd_ns="priority=92.*${match_r1_metadata}.*icmp_type=135.*nd_target=10::121"

as hv1
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep n_packets=1 -c)
    test "1" = "${pkts_on_rtr1}"
])

as hv2
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep n_packets=1 -c)
    test "0" = "${pkts_on_rtr1}"
])

# Inject ND_NS for FIP2.
src_ipv6=00100000000000000000000000000254
dst_ipv6=00100000000000000000000000000122
send_nd_ns 1 0 ${src_mac} ${src_ipv6} ${dst_ipv6} 72db

# Verify that the ND_NS is replied to from hv2 and not hv1.
match_nd_ns="priority=92.*${match_r1_metadata}.*icmp_type=135.*nd_target=10::122"

as hv2
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep n_packets=1 -c)
    test "1" = "${pkts_on_rtr1}"
])

as hv1
OVS_WAIT_UNTIL([
    pkts_on_rtr1=$(ovs-ofctl dump-flows br-int | \
    grep -E "${match_nd_ns}" | grep n_packets=1 -c)
    test "0" = "${pkts_on_rtr1}"
])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([trace when flow cookie updated])
AT_KEYWORDS([cookie])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=lp1 ofport-request=1

ovn-nbctl ls-add lsw0
ovn-nbctl lsp-add lsw0 lp1
ovn-nbctl lsp-set-addresses lp1 "f0:00:00:00:00:01 10.0.0.1"
ovn-nbctl acl-add lsw0 from-lport 1000 'eth.type == 0x1234' drop

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Trace with --ovs should see ovs flow related to the ACL
AT_CHECK([ovn_trace --ovs lsw0 'inport == "lp1" && eth.type == 0x1234' | grep "dl_type=0x1234" | grep "cookie"], [0], [ignore])

# Replace the ACL with same match but different action.
ovn-nbctl acl-del lsw0 -- \
    acl-add lsw0 from-lport 1000 'eth.type == 0x1234' allow

check ovn-nbctl --wait=hv sync

# Trace with --ovs should still see the ovs flow related to the ACL, which
# means the OVS flow is updated with new cookie corresponding to the new lflow.
AT_CHECK([ovn_trace --ovs lsw0 'inport == "lp1" && eth.type == 0x1234' | grep "dl_type=0x1234 actions="], [0], [ignore])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([interconnection])
AT_KEYWORDS([slowtest])

ovn_init_ic_db
# The number needs to stay relatively low due to high memory consumption
# with address sanitizers enabled.
n_az=3
n_ts=3
for i in `seq 1 $n_az`; do
    ovn_start az$i
done

net_add n1

# 1 HV and 1 GW per AZ
for az in `seq 1 $n_az`; do
    sim_add hv$az
    as hv$az
    check ovs-vsctl add-br br-phys
    ovn_az_attach az$az n1 br-phys 192.168.$az.1 16
    for p in `seq 1 $n_ts`; do
        check ovs-vsctl -- add-port br-int vif$p -- \
            set interface vif$p external-ids:iface-id=lsp$az-$p \
            options:tx_pcap=hv$az/vif$p-tx.pcap \
            options:rxq_pcap=hv$az/vif$p-rx.pcap \
            ofport-request=$p
    done

    sim_add gw$az
    as gw$az
    check ovs-vsctl add-br br-phys
    ovn_az_attach az$az n1 br-phys 192.168.$az.2 16
    check ovs-vsctl set open . external-ids:ovn-is-interconn=true
done

for ts in `seq 1 $n_ts`; do
    AT_CHECK([ovn-ic-nbctl create Transit_Switch name=ts$ts], [0], [ignore])
    for az in `seq 1 $n_az`; do
        echo "az$az: wait for ts$ts..."
        check ovn_as az$az ovn-nbctl wait-until logical_switch ts$ts
    done
done

for az in `seq 1 $n_az`; do
    ovn_as az$az
    check ovn-nbctl set nb_global . options:ic-route-learn=true
    check ovn-nbctl set nb_global . options:ic-route-adv=true

    # Each AZ has n_ts LSPi->LSi->LRi connecting to each TSi
    echo
    echo "az$az"
    for i in `seq 1 $n_ts`; do
        lsp_mac=00:00:00:0$az:0$i:00
        lrp_ls_mac=00:00:00:0$az:0$i:01
        lrp_ts_mac=00:00:00:0$az:0$i:02
        lsp_ip=10.$az.$i.123
        lrp_ls_ip=10.$az.$i.1
        lrp_ts_ip=169.254.$i.$az

        check ovn-nbctl ls-add ls$az-$i
        check ovn-nbctl lsp-add ls$az-$i lsp$az-$i
        check ovn-nbctl lsp-set-addresses lsp$az-$i "$lsp_mac $lsp_ip"

        check ovn-nbctl lr-add lr$az-$i

        check ovn-nbctl lrp-add lr$az-$i lrp-lr$az-$i-ls$az-$i $lrp_ls_mac $lrp_ls_ip/24
        check ovn-nbctl lsp-add ls$az-$i lsp-ls$az-$i-lr$az-$i
        check ovn-nbctl lsp-set-addresses lsp-ls$az-$i-lr$az-$i router
        check ovn-nbctl lsp-set-type lsp-ls$az-$i-lr$az-$i router
        check ovn-nbctl lsp-set-options lsp-ls$az-$i-lr$az-$i router-port=lrp-lr$az-$i-ls$az-$i

        check ovn-nbctl lrp-add lr$az-$i lrp-lr$az-$i-ts$i $lrp_ts_mac $lrp_ts_ip/24
        check ovn-nbctl lsp-add ts$i lsp-ts$i-lr$az-$i
        check ovn-nbctl lsp-set-addresses lsp-ts$i-lr$az-$i router
        check ovn-nbctl lsp-set-type lsp-ts$i-lr$az-$i router
        check ovn-nbctl lsp-set-options lsp-ts$i-lr$az-$i router-port=lrp-lr$az-$i-ts$i
        check ovn-nbctl lrp-set-gateway-chassis lrp-lr$az-$i-ts$i gw$az
    done
    check ovn-nbctl --wait=hv sync
    ovn-sbctl list Port_Binding > az$az.ports
    wait_for_ports_up
done

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

for i in `seq 1 $n_az`; do
    check ovn_as az$i ovn-nbctl --wait=hv sync
    ovn_as az$i ovn-sbctl dump-flows > az$i/sbflows
done

# Allow some time for ovn-northd and ovn-controller to catch up.
# XXX This should be more systematic.
sleep 2

# Populate requested-chassis options for remote lsps
for az in $(seq 1 $n_az); do
    ovn_as az${az}
    for ts in $(seq 1 $n_ts); do
        for i in $(seq 1 $n_ts); do
            if [[ $i -eq ${az} ]]; then
                continue
            fi
            check ovn-nbctl lsp-set-options lsp-ts${ts}-lr${i}-${ts} requested-chassis=gw$i
        done
    done
done

ovn-ic-nbctl show > ic-nbctl.dump
AT_CAPTURE_FILE([ic-nbctl.dump])

(echo "---------ISB dump-----"
 ovn-ic-sbctl show
 echo "---------------------"
 ovn-ic-sbctl list gateway
 echo "---------------------"
 ovn-ic-sbctl list datapath_binding
 echo "---------------------"
 ovn-ic-sbctl list port_binding
 echo "---------------------"
 ovn-ic-sbctl list route
 echo "---------------------") > ic-sbctl.dump
AT_CAPTURE_FILE([ic-sbctl.dump])

AT_CAPTURE_FILE([expected])
AT_CAPTURE_FILE([received])
check_packets() {
    > expected
    > received
    for az in `seq 1 $n_az`; do
        for i in `seq 1 $n_ts`; do
            pcap=hv$az/vif$i-tx.pcap
            echo "--- $pcap" | tee -a expected >> received
            if test -e $az-$i.expected; then
                sort $az-$i.expected >> expected
            fi
            if test -e $pcap; then
                $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | sort >> received
            fi
            echo | tee -a expected >> received
        done
    done

    $at_diff expected received >/dev/null
}

# Send packets between AZs on each TS
for s_az in $(seq 1 $n_az); do
    ovn_as az${s_az}
    as hv${s_az}
    for d_az in $(seq 1 $n_az); do
        if test $s_az = $d_az; then
            continue
        fi

        for i in $(seq 1 $n_ts); do
            echo
            AS_BOX([packet from az$s_az to az$d_az via ts$i])
            lsp_smac=00:00:00:0${s_az}:0$i:00
            lsp_dmac=00:00:00:0${d_az}:0$i:00
            lrp_ls_smac=00:00:00:0${s_az}:0$i:01
            lrp_ls_dmac=00:00:00:0${d_az}:0$i:01
            lsp_sip=10.${s_az}.$i.123
            lsp_dip=10.${d_az}.$i.123

            ovn_inport=lsp${s_az}-$i
            packet="inport==\"$ovn_inport\" && eth.src==$lsp_smac && eth.dst==$lrp_ls_smac &&
                    ip4 && ip.ttl==64 && ip4.src==$lsp_sip && ip4.dst==$lsp_dip &&
                    udp && udp.src==53 && udp.dst==4369"
            echo "sending: $packet"
            AT_CHECK([ovn_trace --ovs "$packet" > ${s_az}-${d_az}-$i.ovn-trace])
            OVS_WAIT_UNTIL([ovs-appctl -t ovn-controller inject-pkt "$packet"])
            ovs_inport=$(ovs-vsctl --bare --columns=ofport find Interface external-ids:iface-id="$ovn_inport")

            ovs_packet=$(echo $packet | ovstest test-ovn expr-to-packets)
            echo ovs_inport=$ovs_inport ovs_packet=$ovs_packet
            AT_CHECK([ovs-appctl ofproto/trace br-int in_port="$ovs_inport" "$ovs_packet" > ${s_az}-${d_az}-$i.ovs-trace])

            # Packet to Expect
            # The TTL should be decremented by 2.
            packet="eth.src==$lrp_ls_dmac && eth.dst==$lsp_dmac &&
                    ip4 && ip.ttl==62 && ip4.src==$lsp_sip && ip4.dst==$lsp_dip &&
                    udp && udp.src==53 && udp.dst==4369"
            echo $packet | ovstest test-ovn expr-to-packets >> ${d_az}-$i.expected
        done
    done
done
OVS_WAIT_UNTIL([check_packets], [$at_diff -F'^---' expected received])

for az in `seq 1 $n_az`; do
    OVN_CLEANUP_SBOX([hv$az])
    OVN_CLEANUP_SBOX([gw$az])
    OVN_CLEANUP_AZ([az$az])
done

OVN_CLEANUP_IC

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([interconnection - static multicast])

# Logical network:
#
#       AZ1                     |                     AZ2
#   ---------------------------------------------------------------------
#                               |
#                               |     +-- LR2 --- LS2 --- LSP2 (sender)
#                               |     |            |
#                               |     |            +----- LSP4 (receiver)
#                               |    /
#     LSP1  --- LS1 --- LR1 --- TS ---
#   (receiver)                  |    \
#                               |     +-- LR3 --- LS3 --- LSP3 (receiver)
#
# LS1, LS2, LS3 configured to flood unregistered IP multicast.
# LR1, LR2, LR3 configured to relay IP multicast.
# LR1-LS1 configured to flood IP multicast traffic unconditionally.
# LR3-LS3 configured to flood IP multicast traffic unconditionally.

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    if test "$1" = --uniq; then
        sort="sort -u"; shift
    else
        sort=sort
    fi
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        $sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | $sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

ovn_init_ic_db
ovn_start az1
ovn_start az2

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_az_attach az1 n1 br-phys 192.168.1.1 16
check ovs-vsctl -- add-port br-int hv1-vif1 \
    -- set interface hv1-vif1 external-ids:iface-id=lsp1 \
       options:tx_pcap=hv1/vif1-tx.pcap \
       options:rxq_pcap=hv1/vif1-rx.pcap
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_az_attach az2 n1 br-phys 192.168.2.1 16
check ovs-vsctl -- add-port br-int hv2-vif1 \
    -- set interface hv2-vif1 external-ids:iface-id=lsp2 \
       options:tx_pcap=hv2/vif1-tx.pcap \
       options:rxq_pcap=hv2/vif1-rx.pcap
check ovs-vsctl -- add-port br-int hv2-vif2 \
    -- set interface hv2-vif2 external-ids:iface-id=lsp3 \
       options:tx_pcap=hv2/vif2-tx.pcap \
       options:rxq_pcap=hv2/vif2-rx.pcap
check ovs-vsctl -- add-port br-int hv2-vif3 \
    -- set interface hv2-vif3 external-ids:iface-id=lsp4 \
       options:tx_pcap=hv2/vif3-tx.pcap \
       options:rxq_pcap=hv2/vif3-rx.pcap
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

AT_CHECK([ovn-ic-nbctl create Transit_Switch name=ts], [0], [ignore])
check ovn_as az1 ovn-nbctl wait-until logical_switch ts
check ovn_as az2 ovn-nbctl wait-until logical_switch ts

ovn_as az1
check ovn-nbctl lr-add lr1 \
    -- lrp-add lr1 lr1-ts 00:00:00:01:00:01 42.42.42.1/24 \
    -- lrp-add lr1 lr1-ls1 00:00:00:01:01:00 43.43.43.1/24 \
    -- lrp-set-gateway-chassis lr1-ts hv1
check ovn-nbctl ls-add ls1 \
    -- lsp-add ls1 ls1-lr1 \
    -- lsp-set-addresses ls1-lr1 router \
    -- lsp-set-type ls1-lr1 router \
    -- lsp-set-options ls1-lr1 router-port=lr1-ls1 \
    -- lsp-add ls1 lsp1
check ovn-nbctl lsp-add ts ts-lr1 \
    -- lsp-set-addresses ts-lr1 router \
    -- lsp-set-type ts-lr1 router \
    -- lsp-set-options ts-lr1 router-port=lr1-ts
wait_for_ports_up

ovn_as az2
check ovn-nbctl lr-add lr2 \
    -- lrp-add lr2 lr2-ts 00:00:00:02:00:01 42.42.42.2/24 \
    -- lrp-add lr2 lr2-ls2 00:00:00:02:01:00 44.44.44.1/24 \
    -- lrp-set-gateway-chassis lr2-ts hv2
check ovn-nbctl ls-add ls2 \
    -- lsp-add ls2 ls2-lr2 \
    -- lsp-set-addresses ls2-lr2 router \
    -- lsp-set-type ls2-lr2 router \
    -- lsp-set-options ls2-lr2 router-port=lr2-ls2 \
    -- lsp-add ls2 lsp2 \
    -- lsp-add ls2 lsp4
check ovn-nbctl lsp-add ts ts-lr2 \
    -- lsp-set-addresses ts-lr2 router \
    -- lsp-set-type ts-lr2 router \
    -- lsp-set-options ts-lr2 router-port=lr2-ts

check ovn-nbctl lr-add lr3 \
    -- lrp-add lr3 lr3-ts 00:00:00:02:00:02 42.42.42.3/24 \
    -- lrp-add lr3 lr3-ls3 00:00:00:02:02:00 44.44.45.1/24 \
    -- lrp-set-gateway-chassis lr3-ts hv2
check ovn-nbctl ls-add ls3 \
    -- lsp-add ls3 ls3-lr3 \
    -- lsp-set-addresses ls3-lr3 router \
    -- lsp-set-type ls3-lr3 router \
    -- lsp-set-options ls3-lr3 router-port=lr3-ls3 \
    -- lsp-add ls3 lsp3
check ovn-nbctl lsp-add ts ts-lr3 \
    -- lsp-set-addresses ts-lr3 router \
    -- lsp-set-type ts-lr3 router \
    -- lsp-set-options ts-lr3 router-port=lr3-ts

wait_for_ports_up

ovn_as az1
OVS_WAIT_UNTIL([ovn-nbctl show | grep ts-lr2])
check ovn-nbctl lsp-set-options ts-lr2 requested-chassis=hv2
OVS_WAIT_UNTIL([ovn-nbctl show | grep ts-lr3])
check ovn-nbctl lsp-set-options ts-lr3 requested-chassis=hv2

ovn_as az2
OVS_WAIT_UNTIL([ovn-nbctl show | grep ts-lr1])
check ovn-nbctl lsp-set-options ts-lr1 requested-chassis=hv1

dnl Enable unregistered IP multicast flooding and IP multicast relay.
ovn_as az1
check ovn-nbctl set logical_switch ls1 other_config:mcast_snoop="true" \
    other_config:mcast_flood_unregistered="true"
check ovn-nbctl set logical_router lr1 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr1-ls1 options:mcast_flood="true"

ovn_as az2
check ovn-nbctl set logical_switch ls2 other_config:mcast_snoop="true" \
    other_config:mcast_flood_unregistered="true"
check ovn-nbctl set logical_router lr2 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr2-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ls3 other_config:mcast_snoop="true" \
    other_config:mcast_flood_unregistered="true"
check ovn-nbctl set logical_router lr3 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr3-ls3 options:mcast_flood="true"

check ovn_as az1 ovn-nbctl --wait=hv sync
check ovn_as az2 ovn-nbctl --wait=hv sync

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Send an IP multicast packet from lsp2, it should be forwarded
# statically to lsp1, lsp3 and lsp4.
> expected_az1
> expected_az2
> expected_az2_switched
send_ip_multicast_pkt hv2-vif1 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 20 7c6b 11 \
    e518e518000aed350000
store_ip_multicast_pkt \
    000000010100 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 1e 7e6b 11 \
    e518e518000aed350000 expected_az1
store_ip_multicast_pkt \
    000000020200 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 1e 7e6b 11 \
    e518e518000aed350000 expected_az2
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 20 7c6b 11 \
    e518e518000aed350000 expected_az2_switched

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_az1' \
                 'hv2/vif2-tx.pcap expected_az2' \
                 'hv2/vif3-tx.pcap expected_az2_switched'],
  [$at_diff -F'^---' exp rcv])

# Send an IP multicast packet from lsp2 towards 224.0.0.x, it should be
# forwarded statically only to lsp3.
as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file hv2-vif2 hv2/vif2
as hv2 reset_pcap_file hv2-vif3 hv2/vif3
> expected_az1
> expected_az2
> expected_az2_switched
send_ip_multicast_pkt hv2-vif1 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 224 0 0 1) 1e 20 8cae 11 \
    e518e518000aed350000
store_ip_multicast_pkt \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 224 0 0 1) 1e 20 8cae 11 \
    e518e518000aed350000 expected_az2_switched

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_az1' \
                 'hv2/vif2-tx.pcap expected_az2' \
                 'hv2/vif3-tx.pcap expected_az2_switched'],
  [$at_diff -F'^---' exp rcv])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([interconnection - IGMP/MLD multicast])
AT_KEYWORDS([IP-multicast])

# Logical network:
#
#       AZ1                     |                     AZ2
#   ---------------------------------------------------------------------
#                               |
#                               |     +-- LR2 --- LS2 --- LSP2 (sender)
#                               |    /
#     LSP1  --- LS1 --- LR1 --- TS ---
#   (receiver)                  |    \
#                               |     +-- LR3 --- LS3 --- LSP3 (receiver)
#
# LS1, LS2, LS3, TS configured to snoop IP multicast.
# LR1, LR2, LR3 configured to relay IP multicast.
# LR1-TS configured to flood IP multicast traffic unconditionally.
# LR2-TS configured to flood IP multicast traffic unconditionally.
# LR3-TS configured to flood IP multicast traffic unconditionally.

AT_CAPTURE_FILE([exp])
AT_CAPTURE_FILE([rcv])
check_packets() {
    > exp
    > rcv
    if test "$1" = --uniq; then
        sort="sort -u"; shift
    else
        sort=sort
    fi
    for tuple in "$@"; do
        set $tuple; pcap=$1 type=$2
        echo "--- $pcap" | tee -a exp >> rcv
        $sort "$type" >> exp
        $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $pcap | $sort >> rcv
        echo | tee -a exp >> rcv
    done

    $at_diff exp rcv >/dev/null
}

ovn_init_ic_db
ovn_start az1
ovn_start az2

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_az_attach az1 n1 br-phys 192.168.1.1 16
check ovs-vsctl -- add-port br-int hv1-vif1 \
    -- set interface hv1-vif1 external-ids:iface-id=lsp1 \
       options:tx_pcap=hv1/vif1-tx.pcap \
       options:rxq_pcap=hv1/vif1-rx.pcap
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_az_attach az2 n1 br-phys 192.168.2.1 16
check ovs-vsctl -- add-port br-int hv2-vif1 \
    -- set interface hv2-vif1 external-ids:iface-id=lsp2 \
       options:tx_pcap=hv2/vif1-tx.pcap \
       options:rxq_pcap=hv2/vif1-rx.pcap
check ovs-vsctl -- add-port br-int hv2-vif2 \
    -- set interface hv2-vif2 external-ids:iface-id=lsp3 \
       options:tx_pcap=hv2/vif2-tx.pcap \
       options:rxq_pcap=hv2/vif2-rx.pcap
check ovs-vsctl set open . external-ids:ovn-is-interconn=true

AT_CHECK([ovn-ic-nbctl create Transit_Switch name=ts], [0], [ignore])
check ovn_as az1 ovn-nbctl wait-until logical_switch ts
check ovn_as az2 ovn-nbctl wait-until logical_switch ts

ovn_as az1
check ovn-nbctl lr-add lr1 \
    -- lrp-add lr1 lr1-ts 00:00:00:01:00:01 42.42.42.1/24 4242::1/64 \
    -- lrp-add lr1 lr1-ls1 00:00:00:01:01:00 43.43.43.1/24 4343::1/64\
    -- lrp-set-gateway-chassis lr1-ts hv1
check ovn-nbctl ls-add ls1 \
    -- lsp-add ls1 ls1-lr1 \
    -- lsp-set-addresses ls1-lr1 router \
    -- lsp-set-type ls1-lr1 router \
    -- lsp-set-options ls1-lr1 router-port=lr1-ls1 \
    -- lsp-add ls1 lsp1
check ovn-nbctl lsp-add ts ts-lr1 \
    -- lsp-set-addresses ts-lr1 router \
    -- lsp-set-type ts-lr1 router \
    -- lsp-set-options ts-lr1 router-port=lr1-ts
wait_for_ports_up

ovn_as az2
check ovn-nbctl lr-add lr2 \
    -- lrp-add lr2 lr2-ts 00:00:00:02:00:01 42.42.42.2/24 4242::2/64 \
    -- lrp-add lr2 lr2-ls2 00:00:00:02:01:00 44.44.44.1/24 4444::1/64 \
    -- lrp-set-gateway-chassis lr2-ts hv2
check ovn-nbctl ls-add ls2 \
    -- lsp-add ls2 ls2-lr2 \
    -- lsp-set-addresses ls2-lr2 router \
    -- lsp-set-type ls2-lr2 router \
    -- lsp-set-options ls2-lr2 router-port=lr2-ls2 \
    -- lsp-add ls2 lsp2
check ovn-nbctl lsp-add ts ts-lr2 \
    -- lsp-set-addresses ts-lr2 router \
    -- lsp-set-type ts-lr2 router \
    -- lsp-set-options ts-lr2 router-port=lr2-ts

check ovn-nbctl lr-add lr3 \
    -- lrp-add lr3 lr3-ts 00:00:00:02:00:02 42.42.42.3/24 4242::3/64 \
    -- lrp-add lr3 lr3-ls3 00:00:00:02:02:00 44.44.45.1/24 4445::1/64 \
    -- lrp-set-gateway-chassis lr3-ts hv2
check ovn-nbctl ls-add ls3 \
    -- lsp-add ls3 ls3-lr3 \
    -- lsp-set-addresses ls3-lr3 router \
    -- lsp-set-type ls3-lr3 router \
    -- lsp-set-options ls3-lr3 router-port=lr3-ls3 \
    -- lsp-add ls3 lsp3
check ovn-nbctl lsp-add ts ts-lr3 \
    -- lsp-set-addresses ts-lr3 router \
    -- lsp-set-type ts-lr3 router \
    -- lsp-set-options ts-lr3 router-port=lr3-ts

wait_for_ports_up

ovn_as az1
OVS_WAIT_UNTIL([ovn-nbctl show | grep ts-lr2])
check ovn-nbctl lsp-set-options ts-lr2 requested-chassis=hv2
OVS_WAIT_UNTIL([ovn-nbctl show | grep ts-lr3])
check ovn-nbctl lsp-set-options ts-lr3 requested-chassis=hv2

ovn_as az2
OVS_WAIT_UNTIL([ovn-nbctl show | grep ts-lr1])
check ovn-nbctl lsp-set-options ts-lr1 requested-chassis=hv1

dnl Enable IP multicast snooping and IP multicast relay.  Reports are
dnl forwarded statically.
ovn_as az1
check ovn-nbctl set logical_switch ls1 other_config:mcast_snoop="true"
check ovn-nbctl set Logical_Switch_Port ls1-lr1 options:mcast_flood_reports="true"
check ovn-nbctl set logical_router lr1 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr1-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ts other_config:mcast_snoop="true"
check ovn-nbctl set logical_switch_port ts-lr1 options:mcast_flood_reports="true"
check ovn-nbctl set logical_switch_port ts-lr2 options:mcast_flood_reports="true"
check ovn-nbctl set logical_switch_port ts-lr3 options:mcast_flood_reports="true"

ovn_as az2
check ovn-nbctl set logical_switch ls2 other_config:mcast_snoop="true"
check ovn-nbctl set Logical_Switch_Port ls2-lr2 options:mcast_flood_reports="true"
check ovn-nbctl set logical_router lr2 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr2-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ls3 other_config:mcast_snoop="true"
check ovn-nbctl set Logical_Switch_Port ls3-lr3 options:mcast_flood_reports="true"
check ovn-nbctl set logical_router lr3 options:mcast_relay="true"
check ovn-nbctl set logical_router_port lr3-ts options:mcast_flood="true"
check ovn-nbctl set logical_switch ts other_config:mcast_snoop="true"
check ovn-nbctl set logical_switch_port ts-lr1 options:mcast_flood_reports="true"
check ovn-nbctl set logical_switch_port ts-lr2 options:mcast_flood_reports="true"
check ovn-nbctl set logical_switch_port ts-lr3 options:mcast_flood_reports="true"

check ovn_as az1 ovn-nbctl --wait=hv sync
check ovn_as az2 ovn-nbctl --wait=hv sync

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

# Inject IGMP Join for 239.0.1.68 on LSP1.
send_igmp_v3_report hv1-vif1 hv1 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Inject MLD Join for ff0a:dead:beef::1 on LSP1.
send_mld_v2_report hv1-vif1 hv1 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Inject IGMP Join for 239.0.1.68 on LSP3.
send_igmp_v3_report hv2-vif2 hv2 \
    000000000001 $(ip_to_hex 10 0 0 1) f9f8 \
    $(ip_to_hex 239 0 1 68) 04 e9b9 \
    /dev/null

# Inject MLD Join for ff0a:dead:beef::1 on LSP3.
send_mld_v2_report hv2-vif2 hv2 \
    000000000001 10000000000000000000000000000001 \
    ff0adeadbeef00000000000000000001 04 c0e4 \
    /dev/null

# Check that the IGMP and MLD groups are learned on both AZs (on the LS
# and TS).
ovn_as az1
wait_row_count IGMP_Group 2 address=239.0.1.68
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'
check ovn-nbctl --wait=hv sync

ovn_as az2
wait_row_count IGMP_Group 2 address=239.0.1.68
wait_row_count IGMP_Group 2 address='"ff0a:dead:beef::1"'
check ovn-nbctl --wait=hv sync

# Send an IP multicast packet from LSP2, it should be forwarded
# to lsp1 and lsp3.
> expected_az1
> expected_az2
send_ip_multicast_pkt hv2-vif1 hv2 \
    000000000001 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 20 7c6b 11 \
    e518e518000aed350000
store_ip_multicast_pkt \
    000000010100 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 1e 7e6b 11 \
    e518e518000aed350000 expected_az1
store_ip_multicast_pkt \
    000000020200 01005e000144 \
    $(ip_to_hex 44 44 44 2) $(ip_to_hex 239 0 1 68) 1e 1e 7e6b 11 \
    e518e518000aed350000 expected_az2

send_ip6_multicast_pkt hv2-vif1 hv2 \
    000000000001 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 40 11 \
    93407a69000e2b4e61736461640a
store_ip6_multicast_pkt \
    000000010100 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 3e 11 \
    93407a69000e2b4e61736461640a \
    expected_az1
store_ip6_multicast_pkt \
    000000020200 333300000001 \
    00100000000000000000000000000042 ff0adeadbeef00000000000000000001 \
    000e 3e 11 \
    93407a69000e2b4e61736461640a \
    expected_az2

OVS_WAIT_UNTIL(
  [check_packets 'hv1/vif1-tx.pcap expected_az1' \
                 'hv2/vif2-tx.pcap expected_az2'],
  [$at_diff -F'^---' exp rcv])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ECMP static routes])
ovn_start

# Logical network:
# ls1 (192.168.1.0/24) - lr1 - ls2 (192.168.2.0/24)
# lsl has lsp11 (192.168.1.11) and ls2 has lsp21 (192.168.2.21) and lsp22
# (192.168.2.22)
#
# Static routes on lr1:
# 10.0.0.0/24 nexthop 192.168.2.21
# 10.0.0.0/24 nexthop 192.168.2.22
#
# Test:
# lsp11 send packets to 10.0.0.*
#
# Expected result:
# Both lsp21 and lsp22 should received some of the packets.

ovn-nbctl lr-add lr1

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

for i in 1 2; do
    ovn-nbctl lrp-add lr1 lrp-lr1-ls${i} 00:00:00:01:0${i}:01 192.168.${i}.1/24
    ovn-nbctl lsp-add ls${i} lsp-ls${i}-lr1 -- lsp-set-type lsp-ls${i}-lr1 router \
        -- lsp-set-options lsp-ls${i}-lr1 router-port=lrp-lr1-ls${i} \
        -- lsp-set-addresses lsp-ls${i}-lr1 router
done

#install static routes
ovn-nbctl lr-route-add lr1 10.0.0.0/24 192.168.2.21
ovn-nbctl --ecmp lr-route-add lr1 10.0.0.0/24 192.168.2.22

# Create logical ports
ovn-nbctl lsp-add ls1 lsp11 -- \
    lsp-set-addresses lsp11 "f0:00:00:00:01:11 192.168.1.11"
ovn-nbctl lsp-add ls2 lsp21 -- \
    lsp-set-addresses lsp21 "f0:00:00:00:02:21 192.168.2.21"
ovn-nbctl lsp-add ls2 lsp22 -- \
    lsp-set-addresses lsp22 "f0:00:00:00:02:22 192.168.2.22"

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp11 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=lsp21 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=lsp22 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

# wait for earlier changes to take effect
check ovn-nbctl --wait=hv sync
wait_for_ports_up

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

for i in $(seq 5001 5010); do
    packet="inport==\"lsp11\" && eth.src==f0:00:00:00:01:11 && eth.dst==00:00:00:01:01:01 &&
            ip4 && ip.ttl==64 && ip4.src==192.168.1.11 && ip4.dst==10.0.0.123 &&
            tcp && tcp.src==$i && tcp.dst==80"
    OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

    for j in 1 2; do
        # Assume all packets go to lsp2${j}.
        exp_packet="eth.src==00:00:00:01:02:01 && eth.dst==f0:00:00:00:02:2${j} &&
                ip4 && ip.ttl==63 && ip4.src==192.168.1.11 && ip4.dst==10.0.0.123 &&
                tcp && tcp.src==$i && tcp.dst==80"
        echo $exp_packet | ovstest test-ovn expr-to-packets >> expected_lsp2${j}
    done
done

# Each port should receive some packets and the total number should be 10
OVS_WAIT_UNTIL([
    rcv_n1=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > lsp21.packets && cat lsp21.packets | wc -l`
    rcv_n2=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif3-tx.pcap > lsp22.packets && cat lsp22.packets | wc -l`
    echo $rcv_n1 $rcv_n2
    test $rcv_n1 -ge 1 -a $rcv_n2 -ge 1 -a $(($rcv_n1 + $rcv_n2)) -ge 10])

# Each port should receive a subset of expected packets
for i in 1 2; do
    sort expected_lsp2$i > expout
    AT_CHECK([cat lsp2${i}.packets expected_lsp2$i | sort | uniq], [0], [expout])
done

OVN_CLEANUP([hv1])

AT_CLEANUP
])


OVN_FOR_EACH_NORTHD([
AT_SETUP([route tables -- <main> route table routes])
ovn_start

# Logical network:
# ls1 (192.168.1.0/24) - lrp-lr1-ls1 - lr1 - lrp-lr1-ls2 - ls2 (192.168.2.0/24)
#
# ls1 has lsp11 (192.168.1.11) and
# ls2 has lsp21 (192.168.2.21) and lsp22 (192.168.2.22)
#
# lrp-lr1-ls1 set options:route_table=rtb-1
#
# Static routes on lr1:
# 0.0.0.0/0 nexthop 192.168.2.21
# 1.1.1.1/32 nexthop 192.168.2.22 route_table=rtb-1
#
# Test 1:
# lsp11 send packet to 2.2.2.2
#
# Expected result:
# each port should receive no traffic
#
# Test 2:
# lsp11 send packet to 1.1.1.1
#
# Expected result:
# lsp22 should receive traffic, lsp21 should not
#
# Test 3:
# lsp21 send packet to 1.1.1.1
#
# Expected result:
# lsp11 should receive traffic, lsp21 should not receive any traffic

ovn-nbctl lr-add lr1

for i in 1 2; do
    ovn-nbctl ls-add ls${i}
    ovn-nbctl lrp-add lr1 lrp-lr1-ls${i} 00:00:00:01:0${i}:01 192.168.${i}.1/24
    ovn-nbctl lsp-add ls${i} lsp-ls${i}-lr1 -- lsp-set-type lsp-ls${i}-lr1 router \
        -- lsp-set-options lsp-ls${i}-lr1 router-port=lrp-lr1-ls${i} \
        -- lsp-set-addresses lsp-ls${i}-lr1 router
done

# install static routes
ovn-nbctl lr-route-add lr1 0.0.0.0/0 192.168.2.21
ovn-nbctl --route-table=rtb-1 lr-route-add lr1 1.1.1.1/32 192.168.2.22

# set lrp-lr1-ls1 route table
ovn-nbctl lrp-set-options lrp-lr1-ls1 route_table=rtb-1

# Create logical ports
ovn-nbctl lsp-add ls1 lsp11 -- \
    lsp-set-addresses lsp11 "f0:00:00:00:01:11 192.168.1.11"
ovn-nbctl lsp-add ls2 lsp21 -- \
    lsp-set-addresses lsp21 "f0:00:00:00:02:21 192.168.2.21"
ovn-nbctl lsp-add ls2 lsp22 -- \
    lsp-set-addresses lsp22 "f0:00:00:00:02:22 192.168.2.22"

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp11 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=lsp21 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=lsp22 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

# wait for earlier changes to take effect
check ovn-nbctl --wait=hv sync
wait_for_ports_up

# Test 1
packet="inport==\"lsp11\" && eth.src==f0:00:00:00:01:11 && eth.dst==00:00:00:01:01:01 &&
        ip4 && ip.ttl==64 && ip4.src==192.168.1.11 && ip4.dst==2.2.2.2 && icmp"
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Assume no packets go neither to lsp21 nor to lsp22.
> expected_lsp21
> expected_lsp22

ovn-sbctl dump-flows lr1


OVS_WAIT_UNTIL([
    rcv_n1=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > lsp21.packets && cat lsp21.packets | wc -l`
    rcv_n2=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif3-tx.pcap > lsp22.packets && cat lsp22.packets | wc -l`
    echo $rcv_n1 $rcv_n2
    test $rcv_n1 -eq 0 -a $rcv_n2 -eq 0])

for i in 1 2; do
    sort expected_lsp2$i > expout
    AT_CHECK([cat lsp2${i}.packets | sort], [0], [expout])
done

# cleanup pcap
for i in 2 3; do
    ovs-vsctl remove interface hv1-vif$i options tx_pcap
    > hv1/vif$i-tx.pcap
    ovs-vsctl set interface hv1-vif$i options:tx_pcap=hv1/vif$i-tx.pcap
done

# Test 2
packet="inport==\"lsp11\" && eth.src==f0:00:00:00:01:11 && eth.dst==00:00:00:01:01:01 &&
        ip4 && ip.ttl==64 && ip4.src==192.168.1.11 && ip4.dst==1.1.1.1 && icmp"
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Assume all packets go to lsp22.
exp_packet="eth.src==00:00:00:01:02:01 && eth.dst==f0:00:00:00:02:22 &&
        ip4 && ip.ttl==63 && ip4.src==192.168.1.11 && ip4.dst==1.1.1.1 && icmp"
echo $exp_packet | ovstest test-ovn expr-to-packets > expected_lsp22
> expected_lsp21

# lsp21 should recieve 1 packet and lsp22 should recieve no packets
OVS_WAIT_UNTIL([
    rcv_n1=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > lsp21.packets && cat lsp21.packets | wc -l`
    rcv_n2=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif3-tx.pcap > lsp22.packets && cat lsp22.packets | wc -l`
    echo $rcv_n1 $rcv_n2
    test $rcv_n1 -eq 0 -a $rcv_n2 -eq 1])

for i in 1 2; do
    sort expected_lsp2$i > expout
    AT_CHECK([cat lsp2${i}.packets | sort], [0], [expout])
done

# cleanup pcap
for i in 2 3; do
    ovs-vsctl remove interface hv1-vif$i options tx_pcap
    > hv1/vif$i-tx.pcap
    ovs-vsctl set interface hv1-vif$i options:tx_pcap=hv1/vif$i-tx.pcap
done

# Test 3
packet="inport==\"lsp21\" && eth.src==f0:00:00:00:02:21 && eth.dst==00:00:00:01:02:01 &&
        ip4 && ip.ttl==64 && ip4.src==192.168.2.21 && ip4.dst==2.2.2.2 && icmp"
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Assume all packets go to lsp21.
exp_packet="eth.src==00:00:00:01:02:01 && eth.dst==f0:00:00:00:02:21 &&
        ip4 && ip.ttl==63 && ip4.src==192.168.2.21 && ip4.dst==2.2.2.2 && icmp"
echo $exp_packet | ovstest test-ovn expr-to-packets > expected_lsp21
> expected_lsp22

# lsp21 should recieve 1 packet and lsp22 should recieve no packets
OVS_WAIT_UNTIL([
    rcv_n1=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > lsp21.packets && cat lsp21.packets | wc -l`
    rcv_n2=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif3-tx.pcap > lsp22.packets && cat lsp22.packets | wc -l`
    echo $rcv_n1 $rcv_n2
    test $rcv_n1 -eq 1 -a $rcv_n2 -eq 0])

for i in 1 2; do
    sort expected_lsp2$i > expout
    AT_CHECK([cat lsp2${i}.packets | sort], [0], [expout])
done

OVN_CLEANUP([hv1])
AT_CLEANUP
])


OVN_FOR_EACH_NORTHD([
AT_SETUP([route tables -- directly connected routes])
ovn_start

# Logical network:
# ls1 (192.168.1.0/24) - lrp-lr1-ls1 - lr1 - lrp-lr1-ls2 - ls2 (192.168.2.0/24)
#
# ls1 has lsp11 (192.168.1.11) and ls2 has lsp21 (192.168.2.21)
#
# lrp-lr1-ls1 set options:route_table=rtb-1
#
# Static routes on lr1:
# 192.168.2.128/25 nexthop 192.168.1.11 route_table=rtb-1
#
# Test 1:
# lsp11 send packet to 192.168.2.21
#
# Expected result:
# lsp21 should receive traffic, lsp11 should not receive any traffic
#
# Test 2:
# lsp11 send packet to 192.168.2.200
#
# Expected result:
# lsp11 should receive traffic, lsp21 should not receive any traffic

ovn-nbctl lr-add lr1

for i in 1 2; do
    ovn-nbctl ls-add ls${i}
    ovn-nbctl lrp-add lr1 lrp-lr1-ls${i} 00:00:00:01:0${i}:01 192.168.${i}.1/24
    ovn-nbctl lsp-add ls${i} lsp-ls${i}-lr1 -- lsp-set-type lsp-ls${i}-lr1 router \
        -- lsp-set-options lsp-ls${i}-lr1 router-port=lrp-lr1-ls${i} \
        -- lsp-set-addresses lsp-ls${i}-lr1 router
done

# install static route, which is more specific than directly-connected route
ovn-nbctl --route-table=rtb-1 lr-route-add lr1 192.168.2.128/25 192.168.1.11

# set lrp-lr1-ls1 route table
ovn-nbctl lrp-set-options lrp-lr1-ls1 route_table=rtb-1

# Create logical ports
ovn-nbctl lsp-add ls1 lsp11 -- \
    lsp-set-addresses lsp11 "f0:00:00:00:01:11 192.168.1.11"
ovn-nbctl lsp-add ls2 lsp21 -- \
    lsp-set-addresses lsp21 "f0:00:00:00:02:21 192.168.2.21"

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp11 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=lsp21 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

# wait for earlier changes to take effect
check ovn-nbctl --wait=hv sync
wait_for_ports_up

# test 1
packet="inport==\"lsp11\" && eth.src==f0:00:00:00:01:11 && eth.dst==00:00:00:01:01:01 &&
        ip4 && ip.ttl==64 && ip4.src==192.168.1.11 && ip4.dst==192.168.2.21 && icmp"
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Assume all packets go to lsp21.
exp_packet="eth.src==00:00:00:01:02:01 && eth.dst==f0:00:00:00:02:21 && ip4 &&
            ip.ttl==63 && ip4.src==192.168.1.11 && ip4.dst==192.168.2.21 && icmp"
echo $exp_packet | ovstest test-ovn expr-to-packets > expected_lsp21
> expected_lsp11

# lsp21 should recieve 1 icmp packet and lsp11 should recieve no packets
OVS_WAIT_UNTIL([
    rcv_n11=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap > lsp11.packets && cat lsp11.packets | wc -l`
    rcv_n21=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > lsp21.packets && cat lsp21.packets | wc -l`
    echo $rcv_n11 $rcv_n21
    test $rcv_n11 -eq 0 -a $rcv_n21 -eq 1])

for i in 11 21; do
    sort expected_lsp$i > expout
    AT_CHECK([cat lsp${i}.packets | sort], [0], [expout])
done

for i in 11 21; do
    > lsp${i}.packets
done

# flush tx pcaps:
ovs-vsctl remove interface hv1-vif1 options tx_pcap
ovs-vsctl remove interface hv1-vif2 options tx_pcap
rm -f hv1/vif1-tx.pcap hv1/vif2-tx.pcap
ovs-vsctl set interface hv1-vif1 options:tx_pcap=hv1/vif1-tx.pcap
ovs-vsctl set interface hv1-vif2 options:tx_pcap=hv1/vif2-tx.pcap

# test 2
packet="inport==\"lsp11\" && eth.src==f0:00:00:00:01:11 && eth.dst==00:00:00:01:01:01 &&
        ip4 && ip.ttl==64 && ip4.src==192.168.1.11 && ip4.dst==192.168.2.200 && icmp"
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Assume all packets go to lsp11.
exp_packet="eth.src==00:00:00:01:01:01 && eth.dst==f0:00:00:00:01:11 && ip4 &&
            ip.ttl==63 && ip4.src==192.168.1.11 && ip4.dst==192.168.2.200 && icmp"
echo $exp_packet | ovstest test-ovn expr-to-packets > expected_lsp11
> expected_lsp21

# lsp11 should recieve 1 icmp packet and lsp21 should recieve no packets
OVS_WAIT_UNTIL([
    rcv_n11=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap > lsp11.packets && cat lsp11.packets | wc -l`
    rcv_n21=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap > lsp21.packets && cat lsp21.packets | wc -l`
    echo $rcv_n11 $rcv_n21
    test $rcv_n11 -eq 1 -a $rcv_n21 -eq 0])

for i in 11 21; do
    echo I=$i
    sort expected_lsp$i > expout
    AT_CHECK([cat lsp${i}.packets | sort], [0], [expout])
done

OVN_CLEANUP([hv1])
AT_CLEANUP
])


OVN_FOR_EACH_NORTHD([
AT_SETUP([route tables -- overlapping subnets])
ovn_start

# Logical network:
#
# ls1 (192.168.1.0/24) - lrp-lr1-ls1 -\   /- lrp-lr1-ls2 - ls2 (192.168.2.0/24)
#                                      lr1
# ls3 (192.168.3.0/24) - lrp-lr1-ls3 -/   \- lrp-lr1-ls4 - ls4 (192.168.4.0/24)
#
# ls1 has lsp11 (192.168.1.11)
# ls2 has lsp21 (192.168.2.21)
# ls3 has lsp31 (192.168.3.31)
# ls4 has lsp41 (192.168.4.41)
#
# lrp-lr1-ls1 set options:route_table=rtb-1
#
# Static routes on lr1:
# 10.0.0.0/24 nexthop 192.168.3.31 route_table=rtb-1
# 10.0.0.0/24 nexthop 192.168.4.41 (<main> route table)
#
# Test 1:
# lsp11 send packet to 10.0.0.1
#
# Expected result:
# lsp31 should receive traffic, lsp41 should not receive any traffic
#
# Test 2:
# lsp21 send packet to 10.0.0.1
#
# Expected result:
# lsp41 should receive traffic, lsp31 should not receive any traffic

ovn-nbctl lr-add lr1

# Create logical topology
for i in $(seq 1 4); do
    ovn-nbctl ls-add ls${i}
    ovn-nbctl lrp-add lr1 lrp-lr1-ls${i} 00:00:00:01:0${i}:01 192.168.${i}.1/24
    ovn-nbctl lsp-add ls${i} lsp-ls${i}-lr1 -- lsp-set-type lsp-ls${i}-lr1 router \
        -- lsp-set-options lsp-ls${i}-lr1 router-port=lrp-lr1-ls${i} \
        -- lsp-set-addresses lsp-ls${i}-lr1 router
    ovn-nbctl lsp-add ls$i lsp${i}1 -- \
        lsp-set-addresses lsp${i}1 "f0:00:00:00:0${i}:1${i} 192.168.${i}.${i}1"
done

# install static routes
ovn-nbctl --route-table=rtb-1 lr-route-add lr1 10.0.0.0/24 192.168.3.31
ovn-nbctl lr-route-add lr1 10.0.0.0/24 192.168.4.41

# set lrp-lr1-ls1 route table
ovn-nbctl lrp-set-options lrp-lr1-ls1 route_table=rtb-1

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

for i in $(seq 1 4); do
    ovs-vsctl -- add-port br-int hv1-vif${i} -- \
        set interface hv1-vif${i} external-ids:iface-id=lsp${i}1 \
        options:tx_pcap=hv1/vif${i}-tx.pcap \
        options:rxq_pcap=hv1/vif${i}-rx.pcap \
        ofport-request=${i}
done

# wait for earlier changes to take effect
check ovn-nbctl --wait=hv sync
wait_for_ports_up

# lsp31 should recieve packet coming from lsp11
# lsp41 should recieve packet coming from lsp21
for i in $(seq 1 2); do
    di=$(( i + 2))  # dst index
    ri=$(( 5 - i))  # reverse index
    packet="inport==\"lsp${i}1\" && eth.src==f0:00:00:00:0${i}:1${i} &&
            eth.dst==00:00:00:01:0${i}:01 && ip4 && ip.ttl==64 &&
            ip4.src==192.168.${i}.${i}1 && ip4.dst==10.0.0.1 && icmp"
    OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

    # Assume all packets go to lsp${di}1.
    exp_packet="eth.src==00:00:00:01:0${di}:01 && eth.dst==f0:00:00:00:0${di}:1${di} &&
            ip4 && ip.ttl==63 && ip4.src==192.168.${i}.${i}1 && ip4.dst==10.0.0.1 && icmp"
    echo $exp_packet | ovstest test-ovn expr-to-packets >> expected_lsp${di}1
    > expected_lsp${ri}1

    OVS_WAIT_UNTIL([
        rcv_n1=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif${di}-tx.pcap > lsp${di}1.packets && cat lsp${di}1.packets | wc -l`
        rcv_n2=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif${ri}-tx.pcap > lsp${ri}1.packets && cat lsp${ri}1.packets | wc -l`
        echo $rcv_n1 $rcv_n2
        test $rcv_n1 -eq 1 -a $rcv_n2 -eq 0])

    for j in "${di}1" "${ri}1"; do
        sort expected_lsp${j} > expout
        AT_CHECK([cat lsp${j}.packets | sort], [0], [expout])
    done

    # cleanup tx pcap files
    for j in "${di}1" "${ri}1"; do
        ovs-vsctl -- remove interface hv1-vif${di} options tx_pcap
        > hv1/vif${di}-tx.pcap
        ovs-vsctl -- set interface hv1-vif${di} external-ids:iface-id=lsp${di}1 \
            options:tx_pcap=hv1/vif${di}-tx.pcap
    done
done

OVN_CLEANUP([hv1])
AT_CLEANUP
])


OVN_FOR_EACH_NORTHD([
AT_SETUP([route tables IPv6 -- overlapping subnets])
ovn_start

# Logical network:
#
# ls1 (2001:db8:1::/64) - lrp-lr1-ls1 -\   /- lrp-lr1-ls2 - ls2 (2001:db8:2::/64)
#                                       lr1
# ls3 (2001:db8:3::/64) - lrp-lr1-ls3 -/   \- lrp-lr1-ls4 - ls4 (2001:db8:4::/64)
#
# ls1 has lsp11 (2001:db8:1::11)
# ls2 has lsp21 (2001:db8:2::21)
# ls3 has lsp31 (2001:db8:3::31)
# ls4 has lsp41 (2001:db8:4::41)
#
# lrp-lr1-ls1 set options:route_table=rtb-1
# lrp-lr1-ls2 set options:route_table=rtb-2
#
# Static routes on lr1:
# 2001:db8:2000::/64 nexthop 2001:db8:3::31 route_table=rtb-1
# 2001:db8:2000::/64 nexthop 2001:db8:3::41 route_table=rtb-2
#
# Test 1:
# lsp11 send packet to 2001:db8:2000::1
#
# Expected result:
# lsp31 should receive traffic, lsp41 should not receive any traffic
#
# Test 2:
# lsp21 send packet to 2001:db8:2000::1
#
# Expected result:
# lsp41 should receive traffic, lsp31 should not receive any traffic

ovn-nbctl lr-add lr1

# Create logical topology
for i in $(seq 1 4); do
    ovn-nbctl ls-add ls${i}
    ovn-nbctl lrp-add lr1 lrp-lr1-ls${i} 00:00:00:01:0${i}:01 2001:db8:${i}::1/64
    ovn-nbctl lsp-add ls${i} lsp-ls${i}-lr1 -- lsp-set-type lsp-ls${i}-lr1 router \
        -- lsp-set-options lsp-ls${i}-lr1 router-port=lrp-lr1-ls${i} \
        -- lsp-set-addresses lsp-ls${i}-lr1 router
    ovn-nbctl lsp-add ls$i lsp${i}1 -- \
        lsp-set-addresses lsp${i}1 "f0:00:00:00:0${i}:1${i} 2001:db8:${i}::${i}1"
done

# install static routes
ovn-nbctl --route-table=rtb-1 lr-route-add lr1 2001:db8:2000::/64 2001:db8:3::31
ovn-nbctl --route-table=rtb-2 lr-route-add lr1 2001:db8:2000::/64 2001:db8:4::41

# set lrp-lr1-ls{1,2} route tables
ovn-nbctl lrp-set-options lrp-lr1-ls1 route_table=rtb-1
ovn-nbctl lrp-set-options lrp-lr1-ls2 route_table=rtb-2

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

for i in $(seq 1 4); do
    ovs-vsctl -- add-port br-int hv1-vif${i} -- \
        set interface hv1-vif${i} external-ids:iface-id=lsp${i}1 \
        options:tx_pcap=hv1/vif${i}-tx.pcap \
        options:rxq_pcap=hv1/vif${i}-rx.pcap \
        ofport-request=${i}
done

wait_for_ports_up

# wait for earlier changes to take effect
AT_CHECK([ovn-nbctl --timeout=3 --wait=hv sync], [0], [ignore])

# lsp31 should recieve packet coming from lsp11
# lsp41 should recieve packet coming from lsp21
for i in $(seq 1 2); do
    di=$(( i + 2))  # dst index
    ri=$(( 5 - i))  # reverse index
    packet="inport==\"lsp${i}1\" && eth.src==f0:00:00:00:0${i}:1${i} &&
            eth.dst==00:00:00:01:0${i}:01 && ip6 && ip.ttl==64 &&
            ip6.src==2001:db8:${i}::${i}1 && ip6.dst==2001:db8:2000::1 && icmp6"
    OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

    # Assume all packets go to lsp${di}1.
    exp_packet="eth.src==00:00:00:01:0${di}:01 && eth.dst==f0:00:00:00:0${di}:1${di} && ip6 &&
                ip.ttl==63 && ip6.src==2001:db8:${i}::${i}1 && ip6.dst==2001:db8:2000::1 && icmp6"
    echo $exp_packet | ovstest test-ovn expr-to-packets >> expected_lsp${di}1
    > expected_lsp${ri}1

    OVS_WAIT_UNTIL([
        rcv_n1=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif${di}-tx.pcap > lsp${di}1.packets && cat lsp${di}1.packets | wc -l`
        rcv_n2=`$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif${ri}-tx.pcap > lsp${ri}1.packets && cat lsp${ri}1.packets | wc -l`
        echo $rcv_n1 $rcv_n2
        test $rcv_n1 -eq 1 -a $rcv_n2 -eq 0])

    for j in "${di}1" "${ri}1"; do
        sort expected_lsp${j} > expout
        AT_CHECK([cat lsp${j}.packets | sort], [0], [expout])
    done

    # cleanup tx pcap files
    for j in "${di}1" "${ri}1"; do
        ovs-vsctl -- remove interface hv1-vif${di} options tx_pcap
        > hv1/vif${di}-tx.pcap
        ovs-vsctl -- set interface hv1-vif${di} external-ids:iface-id=lsp${di}1 \
            options:tx_pcap=hv1/vif${di}-tx.pcap
    done
done

OVN_CLEANUP([hv1])
AT_CLEANUP
])


OVN_FOR_EACH_NORTHD([
AT_SETUP([forwarding group: 3 HVs, 1 LR, 2 LS])
AT_KEYWORDS([forwarding-group])
ovn_start

# Logical network:
# One LR - R1 has a logical switch ls1 and ls2 connected to it.
# Logical switch ls1 has one port while ls2 has two logical switch ports as
# child ports.
check ovn-nbctl lr-add R1
check ovn-nbctl ls-add ls1
check ovn-nbctl ls-add ls2

# Logical switch ls1 to R1 connectivity
check ovn-nbctl lrp-add R1 R1-ls1 00:00:00:01:02:f1 192.168.1.1/24
check ovn-nbctl lsp-add ls1 ls1-R1 -- set Logical_Switch_Port ls1-R1 \
    type=router options:router-port=R1-ls1 -- lsp-set-addresses ls1-R1 router
check ovn-nbctl lsp-add ls1 lsp11 \
    -- lsp-set-addresses lsp11 "00:00:00:01:02:01 192.168.1.2"

# Logical switch ls2 to R1 connectivity
check ovn-nbctl lrp-add R1 R1-ls2 00:00:00:01:02:f2 172.16.1.1/24
check ovn-nbctl lsp-add ls2 ls2-R1 -- set Logical_Switch_Port ls2-R1 \
    type=router options:router-port=R1-ls2 -- lsp-set-addresses ls2-R1 router
check ovn-nbctl lsp-add ls2 lsp21 \
    -- lsp-set-addresses lsp21 "00:00:00:01:02:01 172.16.1.2"
check ovn-nbctl lsp-add ls2 lsp22 \
    -- lsp-set-addresses lsp22 "00:00:00:01:02:02 172.16.1.3"

# Create a network
net_add n1

# Create hypervisor hv1 connected to n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl add-port br-int vif1 -- set Interface vif1 external-ids:iface-id=lsp11 options:tx_pcap=hv1/vif1-tx.pcap options:rxq_pcap=hv1/vif1-rx.pcap ofport-request=1

# Create hypervisor hv2 connected to n1
sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
check ovs-vsctl add-port br-int vif2 -- set Interface vif2 external-ids:iface-id=lsp21 options:tx_pcap=hv2/vif2-tx.pcap options:rxq_pcap=hv2/vif2-rx.pcap ofport-request=1

# Create hypervisor hv3 connected to n1
sim_add hv3
as hv3
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
check ovs-vsctl add-port br-int vif3 -- set Interface vif3 external-ids:iface-id=lsp22 options:tx_pcap=hv3/vif3-tx.pcap options:rxq_pcap=hv3/vif3-rx.pcap ofport-request=1

# Add a forwarding group on ls2 with lsp21 and lsp22 as child ports
# virtual IP - 172.16.1.11, virtual MAC - 00:11:de:ad:be:ef
check ovn-nbctl --wait=hv fwd-group-add fwd_grp1 ls2 172.16.1.11 00:11:de:ad:be:ef lsp21 lsp22

# Check logical flow
AT_CAPTURE_FILE([sbflows])
ovn-sbctl dump-flows > sbflows
AT_CHECK([grep ls_in_l2_lkup sbflows | grep fwd_group | wc -l], [0], [1
])

# Check openflow rule with "group" on hypervisor
AT_CAPTURE_FILE([offlows])
as hv1 ovs-ofctl dump-flows br-int > offlows
AT_CHECK([grep -c "dl_dst=00:11:de:ad:be:ef actions=group" offlows], [0], [1
])

# Verify openflow group members
 # Verify openflow group members
AT_CAPTURE_FILE([ofgroups])
as hv1 ovs-ofctl -O OpenFlow13 dump-groups br-int > ofgroups
for child_port in lsp21 lsp22; do
    tunnel_key=`ovn-sbctl get Port_Binding $child_port tunnel_key`
    AT_CHECK([grep -c "bucket=actions=load:0x"$tunnel_key ofgroups], [0], [1
])
done

# Send a packet to virtual IP
src_mac=00:00:00:01:02:01
dst_mac=00:00:00:01:02:f1
src_ip=192.168.1.2
dst_ip=172.16.1.11
packet="inport==\"lsp11\" && eth.src==$src_mac && eth.dst==$dst_mac &&
        ip4 && ip.ttl==64 && ip4.src==$src_ip && ip4.dst==$dst_ip &&
        udp && udp.src==53 && udp.dst==4369"
OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Check if the packet hit the forwarding group policy
AT_CAPTURE_FILE([offlows2])
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int > offlows2
    grep "dl_dst=00:11:de:ad:be:ef actions=group" offlows2 | \
    grep "n_packets=1" | wc -l], [0], [1
])

# Delete the forwarding group
check ovn-nbctl fwd-group-del fwd_grp1

# Add a forwarding group with liveness on ls2 with lsp21 and lsp22 as child
# ports virtual IP - 172.16.1.11, virtual MAC - 00:11:de:ad:be:ef
check ovn-nbctl --wait=hv --liveness fwd-group-add fwd_grp1 ls2 172.16.1.11 00:11:de:ad:be:ef lsp21 lsp22

# Verify openflow group members
ofport_lsp21=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-hv2-0)
tunnel_key=`ovn-sbctl --bare --column tunnel_key find port_binding logical_port=lsp21`
AT_CHECK([as hv1 ovs-ofctl -O OpenFlow13 dump-groups br-int | \
    grep "bucket=watch_port:$ofport_lsp21,actions=load:0x"$tunnel_key | wc -l], [0], [dnl
1
])

ofport_lsp22=$(as hv1 ovs-vsctl --bare --columns ofport find Interface name=ovn-hv3-0)
tunnel_key=`ovn-sbctl --bare --column tunnel_key find port_binding logical_port=lsp22`
AT_CHECK([as hv1 ovs-ofctl -O OpenFlow13 dump-groups br-int | \
    grep "bucket=watch_port:$ofport_lsp22,actions=load:0x"$tunnel_key | wc -l], [0], [dnl
1
])

OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load Balancer LS hairpin])
ovn_start

build_udp() {
    local sport=$1 dport=$2 chksum=$3
    local len=000a
    echo ${sport}${dport}${len}${chksum}0000
}

build_tcp_syn() {
    local sport=$1 dport=$2 chksum=$3
    local seq=00000001
    local ack=00000000
    local hlen_flags=5002
    local win=00ff
    local urg=0000
    echo ${sport}${dport}${seq}${ack}${hlen_flags}${win}${chksum}${urg}
}

send_ipv4_pkt() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4
    local ip_src=$5 ip_dst=$6 ip_proto=$7 ip_len=$8
    local l4_payload=$9
    local hp_ip_src=${10}
    local hp_l4_payload=${11}
    local outfile=${12}

    local ip_ttl=40

    local eth=${eth_dst}${eth_src}0800
    local hp_eth=${eth_src}${eth_dst}0800
    local ip=4500${ip_len}00004000${ip_ttl}${ip_proto}0000${ip_src}${ip_dst}
    ip=$(ip4_csum_inplace $ip)
    local hp_ip=4500${ip_len}00004000${ip_ttl}${ip_proto}0000${hp_ip_src}${ip_src}
    hp_ip=$(ip4_csum_inplace ${hp_ip})
    local packet=${eth}${ip}${l4_payload}
    local hp_packet=${hp_eth}${hp_ip}${hp_l4_payload}

    echo ${hp_packet} >> ${outfile}
    as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

send_ipv6_pkt() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4
    local ip_src=$5 ip_dst=$6 ip_proto=$7 ip_len=$8
    local l4_payload=$9
    local hp_ip_src=${10}
    local hp_l4_payload=${11}
    local outfile=${12}

    local ip_ttl=40

    local eth=${eth_dst}${eth_src}86dd
    local hp_eth=${eth_src}${eth_dst}86dd
    local ip=60000000${ip_len}${ip_proto}${ip_ttl}${ip_src}${ip_dst}
    local hp_ip=60000000${ip_len}${ip_proto}${ip_ttl}${hp_ip_src}${ip_src}
    local packet=${eth}${ip}${l4_payload}
    local hp_packet=${hp_eth}${hp_ip}${hp_l4_payload}

    echo ${hp_packet} >> ${outfile}
    as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

# One logical switch with IPv4 and IPv6 load balancers that hairpin the
# traffic.
# Also create "duplicate" load balancers, i.e., different VIPs using the same
# backends.
ovn-nbctl ls-add sw
ovn-nbctl lsp-add sw lsp -- lsp-set-addresses lsp 00:00:00:00:00:01
ovn-nbctl lb-add lb-ipv4-tcp     88.88.88.88:8080 42.42.42.1:4041 tcp
ovn-nbctl lb-add lb-ipv4-tcp-dup 88.88.88.89:8080 42.42.42.1:4041 tcp
ovn-nbctl lb-add lb-ipv4-udp     88.88.88.88:4040 42.42.42.1:2021 udp
ovn-nbctl lb-add lb-ipv4-udp-dup 88.88.88.89:4040 42.42.42.1:2021 udp
ovn-nbctl lb-add lb-ipv6-tcp     [[8800::0088]]:8080 [[4200::1]]:4041 tcp
ovn-nbctl lb-add lb-ipv6-tcp-dup [[8800::0089]]:8080 [[4200::1]]:4041 tcp
ovn-nbctl lb-add lb-ipv6-udp     [[8800::0088]]:4040 [[4200::1]]:2021 udp
ovn-nbctl lb-add lb-ipv6-udp-dup [[8800::0089]]:4040 [[4200::1]]:2021 udp
ovn-nbctl ls-lb-add sw lb-ipv4-tcp
ovn-nbctl ls-lb-add sw lb-ipv4-tcp-dup
ovn-nbctl ls-lb-add sw lb-ipv4-udp
ovn-nbctl ls-lb-add sw lb-ipv4-udp-dup
ovn-nbctl ls-lb-add sw lb-ipv6-tcp
ovn-nbctl ls-lb-add sw lb-ipv6-tcp-dup
ovn-nbctl ls-lb-add sw lb-ipv6-udp
ovn-nbctl ls-lb-add sw lb-ipv6-udp-dup

ovn-nbctl lr-add rtr
ovn-nbctl lrp-add rtr rtr-sw 00:00:00:00:01:00 42.42.42.254/24 4200::00ff/64
ovn-nbctl lsp-add sw sw-rtr                       \
    -- lsp-set-type sw-rtr router                 \
    -- lsp-set-addresses sw-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw-rtr router-port=rtr-sw

ovn-nbctl --wait=hv sync
wait_for_ports_up

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])
> expected

AS_BOX([IPv4 TCP Hairpin])

# Inject IPv4 TCP packets from lsp.
tcp_payload=$(build_tcp_syn 84d0 1f90 05a7)
hp_tcp_payload=$(build_tcp_syn 84d0 0fc9 156e)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 88) \
    06 0028 \
    ${tcp_payload} \
    $(ip_to_hex 88 88 88 88) ${hp_tcp_payload} \
    expected

tcp_payload=$(build_tcp_syn 84d1 1f90 05a5)
hp_tcp_payload=$(build_tcp_syn 84d1 0fc9 156c)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 89) \
    06 0028 \
    ${tcp_payload} \
    $(ip_to_hex 88 88 88 89) ${hp_tcp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.88,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
])

# Change LB Hairpin SNAT IP.
# Also flush conntrack to avoid reusing an existing entry.
as hv1 ovs-appctl dpctl/flush-conntrack

ovn-nbctl --wait=hv set load_balancer lb-ipv4-tcp options:hairpin_snat_ip="88.88.88.87"
# Inject IPv4 TCP packets from lsp.
tcp_payload=$(build_tcp_syn 84d0 1f90 05a7)
hp_tcp_payload=$(build_tcp_syn 84d0 0fc9 156f)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 88) \
    06 0028 \
    ${tcp_payload} \
    $(ip_to_hex 88 88 88 87) ${hp_tcp_payload} \
    expected

tcp_payload=$(build_tcp_syn 84d1 1f90 05a5)
hp_tcp_payload=$(build_tcp_syn 84d1 0fc9 156c)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 89) \
    06 0028 \
    ${tcp_payload} \
    $(ip_to_hex 88 88 88 89) ${hp_tcp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
])

AS_BOX([IPv4 UDP Hairpin])

# Inject IPv4 UDP packets from lsp.
udp_payload=$(build_udp 84d0 0fc8 6666)
hp_udp_payload=$(build_udp 84d0 07e5 6e49)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 88) \
    11 001e \
    ${udp_payload} \
    $(ip_to_hex 88 88 88 88) ${hp_udp_payload} \
    expected

udp_payload=$(build_udp 84d1 0fc8 6664)
hp_udp_payload=$(build_udp 84d1 07e5 6e47)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 89) \
    11 001e \
    ${udp_payload} \
    $(ip_to_hex 88 88 88 89) ${hp_udp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.88,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

# Change LB Hairpin SNAT IP.
# Also flush conntrack to avoid reusing an existing entry.
as hv1 ovs-appctl dpctl/flush-conntrack
ovn-nbctl --wait=hv set load_balancer lb-ipv4-udp options:hairpin_snat_ip="88.88.88.87"
# Inject IPv4 UDP packets from lsp.
udp_payload=$(build_udp 84d0 0fc8 6666)
hp_udp_payload=$(build_udp 84d0 07e5 6e4a)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 88) \
    11 001e \
    ${udp_payload} \
    $(ip_to_hex 88 88 88 87) ${hp_udp_payload} \
    expected

udp_payload=$(build_udp 84d1 0fc8 6664)
hp_udp_payload=$(build_udp 84d1 07e5 6e47)
send_ipv4_pkt hv1 hv1-vif1 000000000001 000000000100 \
    $(ip_to_hex 42 42 42 1) $(ip_to_hex 88 88 88 89) \
    11 001e \
    ${udp_payload} \
    $(ip_to_hex 88 88 88 89) ${hp_udp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

AS_BOX([IPv6 TCP Hairpin])

# Inject IPv6 TCP packets from lsp.
tcp_payload=$(build_tcp_syn 84d0 1f90 3ff9)
hp_tcp_payload=$(build_tcp_syn 84d0 0fc9 4fc0)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000088 \
    06 0014 \
    ${tcp_payload} \
    88000000000000000000000000000088 ${hp_tcp_payload} \
    expected

tcp_payload=$(build_tcp_syn 84d1 1f90 3ff7)
hp_tcp_payload=$(build_tcp_syn 84d1 0fc9 4fbe)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000089 \
    06 0014 \
    ${tcp_payload} \
    88000000000000000000000000000089 ${hp_tcp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::88,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

# Change LB Hairpin SNAT IP.
# Also flush conntrack to avoid reusing an existing entry.
as hv1 ovs-appctl dpctl/flush-conntrack
ovn-nbctl --wait=hv set load_balancer lb-ipv6-tcp options:hairpin_snat_ip="8800::0087"

# Inject IPv6 TCP packets from lsp.
tcp_payload=$(build_tcp_syn 84d0 1f90 3ff9)
hp_tcp_payload=$(build_tcp_syn 84d0 0fc9 4fc1)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000088 \
    06 0014 \
    ${tcp_payload} \
    88000000000000000000000000000087 ${hp_tcp_payload} \
    expected

tcp_payload=$(build_tcp_syn 84d1 1f90 3ff7)
hp_tcp_payload=$(build_tcp_syn 84d1 0fc9 4fbe)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000089 \
    06 0014 \
    ${tcp_payload} \
    88000000000000000000000000000089 ${hp_tcp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

AS_BOX([IPv6 UDP Hairpin])

# Inject IPv6 UDP packets from lsp.
udp_payload=$(build_udp 84d0 0fc8 a0b8)
hp_udp_payload=$(build_udp 84d0 07e5 a89b)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000088 \
    11 000a \
    ${udp_payload} \
    88000000000000000000000000000088 ${hp_udp_payload} \
    expected

udp_payload=$(build_udp 84d1 0fc8 a0b6)
hp_udp_payload=$(build_udp 84d1 07e5 a899)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000089 \
    11 000a \
    ${udp_payload} \
    88000000000000000000000000000089 ${hp_udp_payload} \
    expected

# Check that traffic is hairpinned.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::88,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

# Change LB Hairpin SNAT IP.
# Also flush conntrack to avoid reusing an existing entry.
as hv1 ovs-appctl dpctl/flush-conntrack
ovn-nbctl --wait=hv set load_balancer lb-ipv6-udp options:hairpin_snat_ip="8800::0087"

# Inject IPv6 UDP packets from lsp.
udp_payload=$(build_udp 84d0 0fc8 a0b8)
hp_udp_payload=$(build_udp 84d0 07e5 a89b)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000088 \
    11 000a \
    ${udp_payload} \
    88000000000000000000000000000087 ${hp_udp_payload} \
    expected

udp_payload=$(build_udp 84d1 0fc8 a0b6)
hp_udp_payload=$(build_udp 84d1 07e5 a899)
send_ipv6_pkt hv1 hv1-vif1 000000000001 000000000100 \
    42000000000000000000000000000001 88000000000000000000000000000089 \
    11 000a \
    ${udp_payload} \
    88000000000000000000000000000089 ${hp_udp_payload} \
    expected

# Check learned hairpin reply flows.
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

AS_BOX([Delete VIP])
check ovn-nbctl --wait=hv set Load_Balancer lb-ipv4-tcp vips='"88.88.88.88:8080"=""'
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp,metadata=0x1,nw_src=42.42.42.1,nw_dst=88.88.88.89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

AS_BOX([Delete LB])
check ovn-nbctl --wait=hv     \
    -- lb-del lb-ipv4-tcp     \
    -- lb-del lb-ipv4-tcp-dup \
    -- lb-del lb-ipv4-udp     \
    -- lb-del lb-ipv4-udp-dup

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, tcp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=4041 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

check ovn-nbctl --wait=hv     \
    -- lb-del lb-ipv6-tcp     \
    -- lb-del lb-ipv6-tcp-dup
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::87,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
 table=69, udp6,metadata=0x1,ipv6_src=4200::1,ipv6_dst=8800::89,tp_src=2021 actions=load:0x1->NXM_NX_REG10[[7]]
])

check ovn-nbctl --wait=hv     \
    -- lb-del lb-ipv6-udp     \
    -- lb-del lb-ipv6-udp-dup
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=69 | ofctl_strip_all | grep -v NXST], [1], [dnl
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Big Load Balancer])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 lsp1

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl add-port br-int p1 -- set Interface p1 external-ids:iface-id=lsp1

IPS=192.169.0.1:80
for i in `seq 1 9` ; do
    for j in `seq 1 254` ; do
        IPS=${IPS},192.169.$i.$j:80
    done
done

ovn-nbctl lb-add lb0 172.172.0.1:8080 "${IPS}"
ovn-nbctl --wait=hv ls-lb-add ls1 lb0

AT_CHECK([test 2287 = `ovs-ofctl dump-group-stats br-int | grep -o bucket | wc -l`])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Bind existing VIF])
net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-int
ovs-vsctl add-port br-int p1 \
    -- set Interface p1 external-ids:iface-id=lsp1 \
    -- set Interface p1 ofport-request=1
OVS_WAIT_UNTIL([ovs-vsctl list Interface p1])

ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl --wait=sb lsp-add ls1 lsp1

# Simulate the fact that lsp1 had been previously bound on hv1.
ovn-sbctl --id=@e1 create encap chassis_name=hv1 ip="192.168.0.1" type="geneve" \
    --id=@e2 create encap chassis_name=hv1 ip="192.168.0.1" type="vxlan" \
    -- --id=@c create chassis name=hv1 encaps=@e1,@e2 \
    -- set Port_Binding lsp1 chassis=@c

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Chassis hv1 should add flows for the ls1 datapath in table 8 (ls_in_port_sec_l2).
dp_key=$(ovn-sbctl --bare --columns tunnel_key list Datapath_Binding ls1)
OVS_WAIT_UNTIL([as hv1 ovs-ofctl dump-flows br-int | grep -E "table=8.*metadata=0x${dp_key}"])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Release stale port binding])
net_add n1
sim_add hv1

ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl --wait=sb lsp-add ls1 lsp1

# Simulate the fact that lsp1 had been previously bound on hv1.
ovn-sbctl --id=@e1 create encap chassis_name=hv1 ip="192.168.0.1" type="geneve" \
    --id=@e2 create encap chassis_name=hv1 ip="192.168.0.1" type="vxlan" \
    -- --id=@c create chassis name=hv1 encaps=@e1,@e2 \
    -- set Port_Binding lsp1 chassis=@c

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Port_Binding should be released.
OVS_WAIT_UNTIL([test 0 = $(ovn-sbctl show | grep Port_Binding -c)])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Logical router policy packet marking])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-port1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-port2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

as hv1 check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=public:br-phys

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3 10.0.0.5"
check ovn-nbctl lsp-set-port-security sw0-port1 "50:54:00:00:00:03 10.0.0.3 10.0.0.5"

check ovn-nbctl lsp-add sw0 sw0-port2
check ovn-nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:04 10.0.0.4 aef0::4"

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 aef0::1/64
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24 bef0::1/64
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
check ovn-nbctl lsp-add public ln-public
check ovn-nbctl lsp-set-type ln-public localnet
check ovn-nbctl lsp-set-addresses ln-public unknown
check ovn-nbctl lsp-set-options ln-public network_name=public

check ovn-nbctl lrp-set-gateway-chassis lr0-public hv1 20
check ovn-nbctl lr-nat-add lr0 snat 172.168.0.100 10.0.0.0/24
check ovn-nbctl --wait=hv sync
wait_for_ports_up

wait_row_count datapath_binding 1 external-ids:name=lr0
lr0_dp_uuid=$(ovn-sbctl --bare --columns _uuid list datapath_binding lr0)

AT_CHECK(
  [ovn-sbctl create mac_binding datapath=$lr0_dp_uuid ip=172.168.0.120 \
       logical_port=lr0-public mac="10\:54\:00\:00\:00\:03"
   ovn-sbctl create mac_binding datapath=$lr0_dp_uuid ip=172.168.0.200 \
       logical_port=lr0-public mac="10\:54\:00\:00\:00\:04"
   ovn-sbctl create mac_binding datapath=$lr0_dp_uuid ip="bef0\:\:4" \
       logical_port=lr0-public mac="10\:54\:00\:00\:00\:05"
   ovn-sbctl create mac_binding datapath=$lr0_dp_uuid ip="bef0\:\:5" \
       logical_port=lr0-public mac="10\:54\:00\:00\:00\:06"
   ovn-sbctl create mac_binding datapath=$lr0_dp_uuid ip="bef0\:\:6" \
       logical_port=lr0-public mac="10\:54\:00\:00\:00\:07"
   ovn-nbctl -- --id=@lrt create Logical_Router_Static_Route \
       ip_prefix="\:\:/64" nexthop="bef0\:\:4" -- add Logical_Router lr0 \
       static_routes @lrt],
  [0], [stdout])
AT_CHECK([uuidfilt stdout], [0],
  [<0>
<1>
<2>
<3>
<4>
<5>
])

check ovn-nbctl --wait=hv sync

# Add logical router policy and set pkt_mark on it.
check ovn-nbctl lr-policy-add lr0 2000 "ip4.src == 10.0.0.3" allow pkt_mark=100
check ovn-nbctl lr-policy-add lr0 1000 "ip4.src == 10.0.0.4" allow
check ovn-nbctl lr-policy-add lr0 900 "ip4.src == 10.0.0.5" reroute 172.168.0.200 pkt_mark=3
check ovn-nbctl lr-policy-add lr0 2001 "ip6.dst == bef0::5" reroute bef0::6
check ovn-nbctl lr-policy-add lr0 1001 "ip6" allow

pol1=$(ovn-nbctl --bare --columns _uuid find logical_router_policy priority=2000)
pol4=$(ovn-nbctl --bare --columns _uuid find logical_router_policy priority=2001)
pol5=$(ovn-nbctl --bare --columns _uuid find logical_router_policy priority=1001)

check ovn-nbctl set logical_router_policy $pol4 options:pkt_mark=4
check ovn-nbctl set logical_router_policy $pol5 options:pkt_mark=4294967295
check ovn-nbctl --wait=hv sync

ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])
AT_CAPTURE_FILE([offlows])
OVS_WAIT_UNTIL([
    as hv1 ovs-ofctl dump-flows br-int table=23 > offlows
    test $(grep -c "load:0x64->NXM_NX_PKT_MARK" offlows) = 1 && \
    test $(grep -c "load:0x3->NXM_NX_PKT_MARK" offlows) = 1 && \
    test $(grep -c "load:0x4->NXM_NX_PKT_MARK" offlows) = 1 && \
    test $(grep -c "load:0xffffffff->NXM_NX_PKT_MARK" offlows) = 1
])

as hv1 check ovs-ofctl del-flows br-phys

AT_DATA([flows.txt], [dnl
table=0, priority=200 arp,actions=drop
table=0, priority=0 actions=NORMAL
table=0, priority=100, pkt_mark=0x64 actions=drop
table=0, priority=100, pkt_mark=0x2 actions=drop
table=0, priority=100, pkt_mark=0x3 actions=drop
table=0, priority=100, pkt_mark=0x4 actions=drop
table=0, priority=100, pkt_mark=0xffffffff actions=drop
])

as hv1 check ovs-ofctl --protocols=OpenFlow13 add-flows br-phys flows.txt
sleep 5

send_ipv4_pkt() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4
    local ip_src=$5 ip_dst=$6
    local ip_cksum=$7 tcp_cksum=$8
    packet=${eth_dst}${eth_src}080045000028000000004006${ip_cksum}${ip_src}${ip_dst}0035111112345678000000005002faf0${tcp_cksum}0000
    tcpdump_hex $packet
    as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

send_icmp6_packet() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 ipv6_src=$5 ipv6_dst=$6 tcp_cksum=$7

    local ip6_hdr=60000000001406ff${ipv6_src}${ipv6_dst}
    local packet=${eth_dst}${eth_src}86dd${ip6_hdr}0035111112345678000000005002faf0${tcp_cksum}0000

    as $hv ovs-appctl netdev-dummy/receive ${inport} ${packet}
}

send_ipv4_pkt hv1 hv1-vif1 505400000003 00000000ff01 \
    $(ip_to_hex 10 0 0 3) $(ip_to_hex 172 168 0 120) \
    c3ad 83dc

AT_CAPTURE_FILE([offlows2])
OVS_WAIT_UNTIL([
    as hv1 ovs-ofctl dump-flows br-phys table=0 > offlows2
    test 1 -eq $(grep "priority=100,pkt_mark=0x64" offlows2 | \
                 grep -c "n_packets=1")
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep priority=0 | \
    grep "n_packets=0" -c)
])

# Send the pkt from sw0-port2. Packet should not be marked.
send_ipv4_pkt hv1 hv1-vif2 505400000004 00000000ff01 \
    $(ip_to_hex 10 0 0 4) $(ip_to_hex 172 168 0 120) \
    c3ac 83db

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep priority=0 | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x64" | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x3" | \
    grep "n_packets=0" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x4" | \
    grep "n_packets=0" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0xffffffff" | \
    grep "n_packets=0" -c)
])

ovn-nbctl --wait=hv set logical_router_policy $pol1 options:pkt_mark=2
send_ipv4_pkt hv1 hv1-vif1 505400000003 00000000ff01 \
    $(ip_to_hex 10 0 0 3) $(ip_to_hex 172 168 0 120) \
    c3ad 83dc

OVS_WAIT_UNTIL([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-int table=23 | \
    grep "load:0x2->NXM_NX_PKT_MARK" -c)
])

AT_CHECK([
    test 0 -eq $(as hv1 ovs-ofctl dump-flows br-int table=23 | \
    grep "load:0x64->NXM_NX_PKT_MARK" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x2" | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep priority=0 | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x3" | \
    grep "n_packets=0" -c)
])

# Send with src ip 10.0.0.5. The reroute policy should be hit
# and the packet should be marked with 5.
send_ipv4_pkt hv1 hv1-vif1 505400000003 00000000ff01 \
    $(ip_to_hex 10 0 0 5) $(ip_to_hex 172 168 0 120) \
    c3ab 83da

OVS_WAIT_UNTIL([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x3" | \
    grep "n_packets=1" -c)
])

# Send IPv6 traffic.
src_ip6=aef00000000000000000000000000004
dst_ip6=bef00000000000000000000000000004

send_icmp6_packet hv1 hv1-vif2 505400000004 00000000ff01 ${src_ip6} ${dst_ip6} cd16

OVS_WAIT_UNTIL([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0xffffffff" | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x4" | \
    grep "n_packets=0" -c)
])

# Send IPv6 packet which hits the reroute policy. Packet should be marked
# with 4.

src_ip6=aef00000000000000000000000000004
dst_ip6=bef00000000000000000000000000005

send_icmp6_packet hv1 hv1-vif2 505400000004 00000000ff01 ${src_ip6} ${dst_ip6} cd15

OVS_WAIT_UNTIL([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0x4" | \
    grep "n_packets=1" -c)
])

AT_CHECK([
    test 1 -eq $(as hv1 ovs-ofctl dump-flows br-phys table=0 | \
    grep "priority=100,pkt_mark=0xffffffff" | \
    grep "n_packets=1" -c)
])

AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_policy.*priority=1001" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=1001 , dnl
match=(ip6), action=(pkt.mark = 4294967295; reg8[[0..15]] = 0; next;)
])

ovn-nbctl --wait=hv set logical_router_policy $pol5 options:pkt_mark=-1
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_policy.*priority=1001" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=1001 , dnl
match=(ip6), action=(reg8[[0..15]] = 0; next;)
])

ovn-nbctl --wait=hv set logical_router_policy $pol5 options:pkt_mark=2147483648
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_policy.*priority=1001" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=1001 , dnl
match=(ip6), action=(pkt.mark = 2147483648; reg8[[0..15]] = 0; next;)
])

ovn-nbctl --wait=hv set logical_router_policy $pol5 options:pkt_mark=foo
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_policy.*priority=1001" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=1001 , dnl
match=(ip6), action=(reg8[[0..15]] = 0; next;)
])

ovn-nbctl --wait=hv set logical_router_policy $pol5 options:pkt_mark=4294967296
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_policy.*priority=1001" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=1001 , dnl
match=(ip6), action=(reg8[[0..15]] = 0; next;)
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([normalized lrp-add])
ovn_start

ovn-nbctl lr-add r1
ovn-nbctl lrp-add r1 rp1 CC:DD:EE:EE:DD:CC AEF0::1/64 BEF0::1/64

AT_CHECK([ovn-nbctl --may-exist lrp-add r1 rp1 cc:dd:ee:ee:dd:cc bef0:0000:0000:0000::1/64 aef0::1/64])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([normalized lr-nat-add])
ovn_start

ovn-nbctl lr-add r1
ovn-nbctl lr-nat-add r1 snat AEF0::1 BEEF::/64
ovn-nbctl lr-nat-add r1 dnat AEF0::1 BEEF::1

AT_CHECK([ovn-nbctl --may-exist lr-nat-add r1 snat aef0:0000::1 beef:0000::/ffff:ffff:ffff:ffff::0])
AT_CHECK([ovn-nbctl --may-exist lr-nat-add r1 dnat aef0:0000:00::1 beef::0001])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([normalized lr-nat-del])
ovn_start

ovn-nbctl lr-add r1
ovn-nbctl lr-nat-add r1 snat AEF0::1 BEEF::/64
ovn-nbctl lr-nat-add r1 dnat AEF0::1 BEEF::1

AT_CHECK([ovn-nbctl --if-exists lr-nat-del r1 snat beef:0000::0/ffff:ffff:ffff:ffff::0])
AT_CHECK([ovn-nbctl --if-exists lr-nat-del r1 dnat aef0:0000:00::1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load balancer selection fields])
AT_KEYWORDS([lb])
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

# Create port group and ACLs for sw0 ports.
ovn-nbctl pg-add pg0_drop sw0-p1 sw0-p2
ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

ovn-nbctl pg-add pg0 sw0-p1 sw0-p2
ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip4" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create the second logical switch with one port
ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create port group and ACLs for sw1 ports.
ovn-nbctl pg-add pg1_drop sw1-p1
ovn-nbctl acl-add pg1_drop from-lport 1001 "inport == @pg1_drop && ip" drop
ovn-nbctl acl-add pg1_drop to-lport 1001 "outport == @pg1_drop && ip" drop

ovn-nbctl pg-add pg1 sw1-p1
ovn-nbctl acl-add pg1 from-lport 1002 "inport == @pg1 && ip4" allow-related
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create a logical router and attach both logical switches.
# Make the logical router a GW router for load balancing to be supported.
ovn-nbctl lr-add lr0
ovn-nbctl set logical_router lr0 options:chassis=hv1
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 router
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80
lb1_uuid=$(ovn-nbctl --bare --columns _uuid list load_balancer)
ovn-nbctl ls-lb-add sw0 lb1
ovn-nbctl ls-lb-add sw1 lb1
ovn-nbctl lr-lb-add lr0 lb1

OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-groups br-int | \
    grep "selection_method=dp_hash" -c) -eq 2
])

OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-groups br-int | \
    grep "selection_method=dp_hash" -c) -eq 1
])

echo "lb1_uuid = $lb1_uuid"

ovn-nbctl set load_balancer $lb1_uuid selection_fields="ip_src,ip_dst,tp_src,tp_dst"

OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)" -c) -eq 2
])

OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)" -c) -eq 1
])

# Change the protocol to udp.
ovn-nbctl set load_balancer $lb1_uuid protocol=udp
OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,udp_src,udp_dst)" -c) -eq 2
])

OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,udp_src,udp_dst)" -c) -eq 1
])

# Change the protocol to udp.
ovn-nbctl set load_balancer $lb1_uuid protocol=sctp
OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,sctp_src,sctp_dst)" -c) -eq 2
])

OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,sctp_src,sctp_dst)" -c) -eq 1
])

ovn-nbctl set load_balancer $lb1_uuid selection_fields="ip_src,ip_dst,tp_dst"
OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,sctp_dst)" -c) -eq 2
])

OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,sctp_dst)" -c) -eq 1
])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([controller I-P handling with monitoring disabled])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1


sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

wait_for_ports_up sw0-p1

# Wait for arp flow to be installed
OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-flows br-int | \
    grep "arp_tpa=10.0.0.3,arp_op=1" -c) -eq 2
])

# Get the number of OF flows in hv1 and hv2
hv1_offlows=$(as hv1 ovs-ofctl dump-flows br-int | wc -l)
echo "hv1 flows : $hv1_offlows"
AT_CHECK([test $hv1_offlows -gt 0])

as hv2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

wait_for_ports_up sw0-p2

# Wait for arp flow to be installed
OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-flows br-int | \
    grep "arp_tpa=10.0.0.4,arp_op=1" -c) -eq 2
])

hv2_offlows=$(as hv2 ovs-ofctl dump-flows br-int | wc -l)
echo "hv2 flows : $hv2_offlows"
AT_CHECK([test $hv2_offlows -gt 0])

ovn-nbctl ls-del sw0
as hv1 ovs-vsctl del-port hv1-vif1
as hv2 ovs-vsctl del-port hv2-vif1

as hv1 ovs-vsctl set open . external_ids:ovn-monitor-all=true
as hv2 ovs-vsctl set open . external_ids:ovn-monitor-all=true

# Wait until ovn-monitor-all is processed by ovn-controller.
wait_row_count Chassis 1 name=hv1 other_config:ovn-monitor-all=true
wait_row_count Chassis 1 name=hv2 other_config:ovn-monitor-all=true

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows > sbflows2
AT_CAPTURE_FILE([sbflows2])

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

wait_for_ports_up sw0-p1

# Wait for arp flow to be installed
OVS_WAIT_UNTIL([
    test $(as hv1 ovs-ofctl dump-flows br-int | \
    grep "arp_tpa=10.0.0.3,arp_op=1" -c) -eq 2
])

# Get the number of OF flows in hv1 and hv2
hv1_offlows_mon=$(as hv1 ovs-ofctl dump-flows br-int | wc -l)
echo "hv1 flows after monitor-all=true : $hv1_offlows_mon"
AT_CHECK([test "$hv1_offlows" = "$hv1_offlows_mon"])

as hv2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1

wait_for_ports_up sw0-p2

# Wait for arp flow to be installed
OVS_WAIT_UNTIL([
    test $(as hv2 ovs-ofctl dump-flows br-int | \
    grep "arp_tpa=10.0.0.4,arp_op=1" -c) -eq 2
])

hv2_offlows_mon=$(as hv2 ovs-ofctl dump-flows br-int | wc -l)
echo "hv2 flows after monitor-all=true : $hv2_offlows_mon"
AT_CHECK([test "$hv2_offlows" = "$hv2_offlows_mon"])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([controller I-P handling when lrp added last])

ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Step 1. Add OVS interface with external_ids:iface-id set.
# Step 2. Create the logical switch and logical port.
# Step 3. Create logical switch port of type router and set the peer.
# Step 4. Create logical router and the logical router port (peer to logical switch)
# Step 5. Check that all the flows are added and logical port gets arp reply for
#         router IP.

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "00:00:00:01:01:02 192.168.1.2"

ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0
ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:00:01

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:00:01 192.168.1.1/24 aef0:0:0:0:0:0:0:1/64

wait_for_ports_up sw0-p1
ovn-nbctl --wait=sb sync

sw0_dpkey=$(ovn-sbctl  --bare --columns tunnel_key list datapath_binding sw0)
lr0_dpkey=$(ovn-sbctl  --bare --columns tunnel_key list datapath_binding lr0)

AT_CHECK([test $(as hv1 ovs-ofctl dump-flows br-int metadata=0x${sw0_dpkey} | wc -l) -gt 80])
AT_CHECK([test $(as hv1 ovs-ofctl dump-flows br-int metadata=0x${lr0_dpkey} | wc -l) -gt 80])

# test_arp INPORT SHA SPA TPA [REPLY_HA]
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.  If REPLY_HA is provided, then
# it should be the hardware address of the target to expect to receive in an
# ARP reply; otherwise no reply is expected.
#
# INPORT is an logical switch port number, e.g. 11 for vif11.
# SHA and REPLY_HA are each 12 hex digits.
# SPA and TPA are each 8 hex digits.
test_arp() {
    local hv=$1 inport=$2 sha=$3 spa=$4 tpa=$5 reply_ha=$6
    local request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request

    if test X$reply_ha != X; then
        # Expect to receive the reply, if any.
        local reply=${sha}${reply_ha}08060001080006040002${reply_ha}${tpa}${sha}${spa}
        echo $reply >> hv${hv}-vif$inport.expected
    fi
}

sw0p1_ip=$(ip_to_hex 192 168 1 2)
rtr_ip=$(ip_to_hex 192 168 1 1)
test_arp 1 1 000000010102 $sw0p1_ip $rtr_ip 000000000001

# Now check the packets actually received against the ones expected.
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [hv1-vif1.expected])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# When a lport is released on a chassis, ovn-controller was
# not clearing some of the flowss in the table 33.
# Make sure that those flows are cleared properly.
AT_SETUP([Test clear flows in physical tables])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

as hv1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1) = xup])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2) = xup])

sw0_dpkey=$(ovn-sbctl  --bare --columns tunnel_key list datapath_binding sw0)
p1_dpkey=$(ovn-sbctl  --bare --columns tunnel_key list port_binding sw0-p1)
p2_dpkey=$(ovn-sbctl  --bare --columns tunnel_key list port_binding sw0-p2)

p1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p1 | sed 's/"//g')
AT_CHECK([test ! -z $p1_zoneid])

p2_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p2 | sed 's/"//g')
AT_CHECK([test ! -z $p2_zoneid])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=40,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep REG13 | wc -l) -eq 1])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=40,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep "load:0x${p1_zoneid}->NXM_NX_REG13" | wc -l) -eq 1])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=40,metadata=${sw1_dpkey},\
reg15=0x${p2_dpkey} | grep REG13 | wc -l) -eq 1])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=40,metadata=${sw1_dpkey},\
reg15=0x${p2_dpkey} | grep "load:0x${p2_zoneid}->NXM_NX_REG13" | wc -l) -eq 1])

ovs-vsctl set interface hv1-vif1 external_ids:iface-id=foo
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1) = xdown])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=40,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep REG13 | wc -l) -eq 0])

p1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p1 | sed 's/"//g')
AT_CHECK([test -z $p1_zoneid])

ovs-vsctl set interface hv1-vif1 external_ids:iface-id=sw0-p1
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1) = xup])

p1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p1 | sed 's/"//g')
AT_CHECK([test ! -z $p1_zoneid])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=40,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep REG13 | wc -l) -eq 1])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=40,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep "load:0x${p1_zoneid}->NXM_NX_REG13" | wc -l) -eq 1])

ovs-vsctl del-port hv1-vif2
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2) = xdown])

AT_CHECK([test $(ovs-ofctl dump-flows br-int table=40,metadata=${sw0_dpkey},\
reg15=0x${p2_dpkey} | grep REG13 | wc -l) -eq 0])

p2_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p2 | sed 's/"//g')
AT_CHECK([test -z $p2_zoneid])

ovn-nbctl lsp-del sw0-p1

OVS_WAIT_UNTIL([test $(ovs-ofctl dump-flows br-int table=40,metadata=${sw0_dpkey},\
reg15=0x${p1_dpkey} | grep REG13 | wc -l) -eq 0])

p1_zoneid=$(as hv1 ovs-vsctl get bridge br-int external_ids:ct-zone-sw0-p1 | sed 's/"//g')
AT_CHECK([test -z $p1_zoneid])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Symmetric ECMP reply flows])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

# Logical network
#
#   ls1 \
#        \
#         DR -- join -- GW -- ext
#        /
#   ls2 /
#
#  ls1 and ls2 are internal switches connected to distributed router
#  DR. DR is then connected via a join switch to gateway router GW.
#  GW is then connected to external switch ext. In real life, this
#  would likely have a localnet port, but for the purposes of this test
#  it is unnecessary.

ovn-nbctl create Logical_Router name=DR
gw_uuid=$(ovn-nbctl create Logical_Router name=GW)

check ovn-nbctl ls-add ls1
check ovn-nbctl ls-add ls2
check ovn-nbctl ls-add join
check ovn-nbctl ls-add ext

# Connect ls1 to DR
check ovn-nbctl lrp-add DR dr-ls1 00:00:01:01:02:03 10.0.0.1/24
check ovn-nbctl lsp-add ls1 ls1-dr -- set Logical_Switch_Port ls1-dr \
    type=router options:router-port=dr-ls1 addresses='"00:00:01:01:02:03"'

# Connect ls2 to DR
check ovn-nbctl lrp-add DR dr-ls2 00:00:01:01:02:04 10.0.0.2/24
check ovn-nbctl lsp-add ls2 ls2-dr -- set Logical_Switch_Port ls2-dr \
    type=router options:router-port=dr-ls2 addresses='"00:00:01:01:02:04"'

# Connect join to DR
check ovn-nbctl lrp-add DR dr-join 00:00:02:01:02:03 20.0.0.1/24
check ovn-nbctl lsp-add join join-dr -- set Logical_Switch_Port join-dr \
    type=router options:router-port=dr-join addresses='"00:00:02:01:02:03"'

# Connect join to GW
check ovn-nbctl lrp-add GW gw-join 00:00:02:01:02:04 20.0.0.2/24
check ovn-nbctl lsp-add join join-gw -- set Logical_Switch_Port join-gw \
    type=router options:router-port=gw-join addresses='"00:00:02:01:02:04"'

# Connect ext to GW
check ovn-nbctl lrp-add GW gw-ext 00:00:03:01:02:03 172.16.0.1/16
check ovn-nbctl lsp-add ext ext-gw -- set Logical_Switch_Port ext-gw \
    type=router options:router-port=gw-ext addresses='"00:00:03:01:02:03"'

check ovn-nbctl lr-route-add GW 10.0.0.0/24 20.0.0.1
check ovn-nbctl --policy="src-ip" lr-route-add DR 10.0.0.0/24 20.0.0.2

# Now add some ECMP routes to the GW router.
check ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add GW 10.0.0.0/24 172.16.0.2
check ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add GW 10.0.0.0/24 172.16.0.3

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Ensure ECMP symmetric reply flows are not present on any hypervisor.
AT_CHECK([
    test 0 -eq $(as hv1 ovs-ofctl dump-flows br-int table=17 | \
    grep "priority=100" | \
    grep "ct(commit,zone=NXM_NX_REG11\\[[0..15\\]],exec(move:NXM_OF_ETH_SRC\\[[\\]]->NXM_NX_CT_LABEL\\[[32..79\\]],load:0x[[0-9]]->NXM_NX_CT_LABEL\\[[80..95\\]]))" -c)
])
AT_CHECK([
    test 0 -eq $(as hv1 ovs-ofctl dump-flows br-int table=25 | \
    grep "priority=200" | \
    grep "actions=move:NXM_NX_CT_LABEL\\[[32..79\\]]->NXM_OF_ETH_DST\\[[\\]]" -c)
])

AT_CHECK([
    test 0 -eq $(as hv2 ovs-ofctl dump-flows br-int table=17 | \
    grep "priority=100" | \
    grep "ct(commit,zone=NXM_NX_REG11\\[[0..15\\]],exec(move:NXM_OF_ETH_SRC\\[[\\]]->NXM_NX_CT_LABEL\\[[32..79\\]],load:0x[[0-9]]->NXM_NX_CT_LABEL\\[[80..95\\]]))" -c)
])
AT_CHECK([
    test 0 -eq $(as hv2 ovs-ofctl dump-flows br-int table=25 | \
    grep "priority=200" | \
    grep "actions=move:NXM_NX_CT_LABEL\\[[32..79\\]]->NXM_OF_ETH_DST\\[[\\]]" -c)
])

# Now make GW a gateway router on hv1
ovn-nbctl set Logical_Router $gw_uuid options:chassis=hv1
ovn-nbctl --wait=hv sync

ovn-sbctl list logical_flow > lflows
# And ensure that ECMP symmetric reply flows are present only on hv1
as hv1 ovs-ofctl dump-flows br-int > hv1flows
AT_CAPTURE_FILE([hv1flows])
as hv2 ovs-ofctl dump-flows br-int > hv2flows
AT_CAPTURE_FILE([hv2flows])

AT_CHECK([
    for hv in 1 2; do
        grep table=17 hv${hv}flows | \
        grep "priority=100" | \
        grep -c "ct(commit,zone=NXM_NX_REG11\\[[0..15\\]],.*exec(move:NXM_OF_ETH_SRC\\[[\\]]->NXM_NX_CT_LABEL\\[[32..79\\]],load:0x[[0-9]]->NXM_NX_CT_MARK\\[[16..31\\]]))"

        grep table=25 hv${hv}flows | \
        grep "priority=200" | \
        grep -c "move:NXM_NX_CT_LABEL\\[[\\]]->NXM_NX_XXREG1\\[[\\]],move:NXM_NX_XXREG1\\[[32..79\\]]->NXM_OF_ETH_DST"
    done; :], [0], [dnl
6
1
0
0
])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Symmetric IPv6 ECMP reply flows])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

# Logical network
#
#   ls1 \
#        \
#         DR -- join -- GW -- ext
#        /
#   ls2 /
#
#  ls1 and ls2 are internal switches connected to distributed router
#  DR. DR is then connected via a join switch to gateway router GW.
#  GW is then connected to external switch ext. In real life, this
#  would likely have a localnet port, but for the purposes of this test
#  it is unnecessary.

ovn-nbctl create Logical_Router name=DR
gw_uuid=$(ovn-nbctl create Logical_Router name=GW)

check ovn-nbctl ls-add ls1
check ovn-nbctl ls-add ls2
check ovn-nbctl ls-add join
check ovn-nbctl ls-add ext

# Connect ls1 to DR
check ovn-nbctl lrp-add DR dr-ls1 00:00:01:01:02:03 1001::1/64
check ovn-nbctl lsp-add ls1 ls1-dr -- set Logical_Switch_Port ls1-dr \
    type=router options:router-port=dr-ls1 addresses='"00:00:01:01:02:03"'

# Connect ls2 to DR
check ovn-nbctl lrp-add DR dr-ls2 00:00:01:01:02:04 1001::2/64
check ovn-nbctl lsp-add ls2 ls2-dr -- set Logical_Switch_Port ls2-dr \
    type=router options:router-port=dr-ls2 addresses='"00:00:01:01:02:04"'

# Connect join to DR
check ovn-nbctl lrp-add DR dr-join 00:00:02:01:02:03 2001::1/64
check ovn-nbctl lsp-add join join-dr -- set Logical_Switch_Port join-dr \
    type=router options:router-port=dr-join addresses='"00:00:02:01:02:03"'

# Connect join to GW
check ovn-nbctl lrp-add GW gw-join 00:00:02:01:02:04 2001::2/64
check ovn-nbctl lsp-add join join-gw -- set Logical_Switch_Port join-gw \
    type=router options:router-port=gw-join addresses='"00:00:02:01:02:04"'

# Connect ext to GW
check ovn-nbctl lrp-add GW gw-ext 00:00:03:01:02:03 7001::1/64
check ovn-nbctl lsp-add ext ext-gw -- set Logical_Switch_Port ext-gw \
    type=router options:router-port=gw-ext addresses='"00:00:03:01:02:03"'

check ovn-nbctl lr-route-add GW 1001::/64 2001::1
check ovn-nbctl --policy="src-ip" lr-route-add DR 1001::0/64 2001::2

# Now add some ECMP routes to the GW router.
check ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add GW 1001::/64 7001::2
check ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add GW 1001::/64 7001::3

wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Ensure ECMP symmetric reply flows are not present on any hypervisor.
AT_CHECK([
    test 0 -eq $(as hv1 ovs-ofctl dump-flows br-int table=17 | \
    grep "priority=100" | \
    grep "ct(commit,zone=NXM_NX_REG11\\[[0..15\\]],exec(move:NXM_OF_ETH_SRC\\[[\\]]->NXM_NX_CT_LABEL\\[[32..79\\]],load:0x[[0-9]]->NXM_NX_CT_LABEL\\[[80..95\\]]))" -c)
])
AT_CHECK([
    test 0 -eq $(as hv1 ovs-ofctl dump-flows br-int table=25 | \
    grep "priority=200" | \
    grep "actions=move:NXM_NX_CT_LABEL\\[[32..79\\]]->NXM_OF_ETH_DST\\[[\\]]" -c)
])

AT_CHECK([
    test 0 -eq $(as hv2 ovs-ofctl dump-flows br-int table=17 | \
    grep "priority=100" | \
    grep "ct(commit,zone=NXM_NX_REG11\\[[0..15\\]],exec(move:NXM_OF_ETH_SRC\\[[\\]]->NXM_NX_CT_LABEL\\[[32..79\\]],load:0x[[0-9]]->NXM_NX_CT_MARK\\[[16..31\\]]))" -c)
])
AT_CHECK([
    test 0 -eq $(as hv2 ovs-ofctl dump-flows br-int table=25 | \
    grep "priority=200" | \
    grep "actions=move:NXM_NX_CT_LABEL\\[[\\]]->NXM_OF_ETH_DST\\[[\\]]" -c)
])

# Now make GW a gateway router on hv1
ovn-nbctl set Logical_Router $gw_uuid options:chassis=hv1
ovn-nbctl --wait=hv sync

# And ensure that ECMP symmetric reply flows are present only on hv1
as hv1 ovs-ofctl dump-flows br-int > hv1flows
AT_CAPTURE_FILE([hv1flows])
as hv2 ovs-ofctl dump-flows br-int > hv2flows
AT_CAPTURE_FILE([hv2flows])

AT_CHECK([
    for hv in 1 2; do
        grep table=17 hv${hv}flows | \
        grep "priority=100" | \
        grep -c "ct(commit,zone=NXM_NX_REG11\\[[0..15\\]],.*exec(move:NXM_OF_ETH_SRC\\[[\\]]->NXM_NX_CT_LABEL\\[[32..79\\]],load:0x[[0-9]]->NXM_NX_CT_MARK\\[[16..31\\]]))"

        grep table=25 hv${hv}flows | \
        grep "priority=200" | \
        grep -c "move:NXM_NX_CT_LABEL\\[[\\]]->NXM_NX_XXREG1\\[[\\]],move:NXM_NX_XXREG1\\[[32..79\\]]->NXM_OF_ETH_DST"
    done; :], [0], [dnl
6
1
0
0
])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])



OVN_FOR_EACH_NORTHD([
# Test option:dynamic_neigh_routers. No static neighbor flows when enabled, and
# traffic should still work, with the help of dynamic mac_bindings.
AT_SETUP([Dynamic neighbor between LRs])
ovn_start

# Logical network:
# 2 LRs - R1 and R2 that are connected to each other via LS "join"
# in 10.0.0.0/24 network.
# R1 is connected to S1 (10.0.1.0/24), R2 is connected to S2 (10.0.2.0/24)

ovn-nbctl lr-add r1 -- set logical_router r1 option:dynamic_neigh_routers=true
ovn-nbctl lr-add r2 -- set logical_router r2 option:dynamic_neigh_routers=true

ovn-nbctl ls-add s1
ovn-nbctl ls-add s2
ovn-nbctl ls-add join

# Connnect r1 to s1.
ovn-nbctl lrp-add r1 lrp-r1-s1 00:00:00:00:01:01 10.0.1.1/24
ovn-nbctl lsp-add s1 lsp-s1-r1 -- set Logical_Switch_Port lsp-s1-r1 type=router \
    options:router-port=lrp-r1-s1 addresses=router

# Connnect r2 to s2.
ovn-nbctl lrp-add r2 lrp-r2-s2 00:00:00:00:02:01 10.0.2.1/24
ovn-nbctl lsp-add s2 lsp-s2-r2 -- set Logical_Switch_Port lsp-s2-r2 type=router \
    options:router-port=lrp-r2-s2 addresses=router

# Connect r1 to join
ovn-nbctl lrp-add r1 lrp-r1-join 00:00:00:00:03:01 10.0.0.1/24
ovn-nbctl lsp-add join lsp-join-r1 -- set Logical_Switch_Port lsp-join-r1 \
    type=router options:router-port=lrp-r1-join addresses=router

# Connect r2 to join
ovn-nbctl lrp-add r2 lrp-r2-join 00:00:00:00:03:02 10.0.0.2/24
ovn-nbctl lsp-add join lsp-join-r2 -- set Logical_Switch_Port lsp-join-r2 \
    type=router options:router-port=lrp-r2-join addresses=router

#install static routes
ovn-nbctl lr-route-add r1 10.0.2.0/24 10.0.0.2
ovn-nbctl lr-route-add r2 10.0.1.0/24 10.0.0.1

# Create logical port p1 in s1
ovn-nbctl lsp-add s1 p1 \
-- lsp-set-addresses p1 "f0:00:00:00:01:02 10.0.1.2"

# Create logical port p2 in s2
ovn-nbctl lsp-add s2 p2 \
-- lsp-set-addresses p2 "f0:00:00:00:02:02 10.0.2.2"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

wait_for_ports_up
ovn-nbctl --wait=hv sync

AT_CHECK([ovn-sbctl lflow-list | grep lr_in_arp_resolve | grep 10.0.0.1], [1], [])
AT_CHECK([ovn-sbctl lflow-list | grep lr_in_arp_resolve | grep 10.0.0.2], [1], [])

# Send ip packets from p1 to p2
src_mac="f00000000102"
dst_mac="000000000101"
src_ip=`ip_to_hex 10 0 1 2`
dst_ip=`ip_to_hex 10 0 2 2`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Packet to Expect at p2
src_mac="000000000201"
dst_mac="f00000000202"
src_ip=`ip_to_hex 10 0 1 2`
dst_ip=`ip_to_hex 10 0 2 2`
echo "${dst_mac}${src_mac}08004500001c000000003e110200${src_ip}${dst_ip}0035111100080000" > expected

OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])
as hv1 ovs-appctl ofproto/trace br-int in_port=1 $packet

# MAC binding entry should have generated
AT_CHECK([ovn-sbctl find mac ip=10.0.0.2 mac='"00:00:00:00:03:02"' logical_port=lrp-r1-join | grep 10\.0\.0\.2], [0], [ignore], [])

OVN_CLEANUP([hv1],[hv2])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([lflow cache operations])
ovn_start
net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

as hv1
ovs-vsctl -- add-port br-int hv1-vif1 \
    -- set interface hv1-vif1 external-ids:iface-id=lsp1 \
    -- add-port br-int hv1-vif2 \
    -- set interface hv1-vif2 external-ids:iface-id=lsp2

ovn-nbctl ls-add ls1 \
    -- lsp-add ls1 lsp1 \
    -- lsp-add ls1 lsp2 \
    -- pg-add pg1 lsp1 lsp2 \
    -- create Address_Set name=as1 addresses=\"10.0.0.1\",\"10.0.0.2\"
check ovn-nbctl --wait=hv sync
wait_for_ports_up lsp1 lsp2

get_cache_count () {
    local cache_name=$1
    as hv1 ovn-appctl -t ovn-controller lflow-cache/show-stats | grep ${cache_name} | awk '{ print $3 }'
}

AS_BOX([Check matches caching])
expr_cnt=$(get_cache_count cache-expr)
matches_cnt=$(get_cache_count cache-matches)

check ovn-nbctl acl-add ls1 from-lport 1 '1' drop
check ovn-nbctl --wait=hv sync

AT_CHECK([test "$expr_cnt" = "$(get_cache_count cache-expr)"], [0], [])
# Changing from having no ACLs to having ACLs adds 9 logical flows, 3 in each
# of ls_in_acl_action, ls_in_acl_after_lb_action, and ls_out_acl_action, plus the
# logical flow representing the ACL itself. This is where the 10 comes from in
# the calculation below.
AT_CHECK([test "$(($matches_cnt + 10))" = "$(get_cache_count cache-matches)"], [0], [])

AS_BOX([Check expr caching for is_chassis_resident() matches])
expr_cnt=$(get_cache_count cache-expr)
matches_cnt=$(get_cache_count cache-matches)

check ovn-nbctl acl-add ls1 from-lport 1 'is_chassis_resident("lsp1")' drop
check ovn-nbctl --wait=hv sync

AT_CHECK([test "$(($expr_cnt + 1))" = "$(get_cache_count cache-expr)"], [0], [])
AT_CHECK([test "$matches_cnt" = "$(get_cache_count cache-matches)"], [0], [])

AS_BOX([Check conj-id caching for conjunctive port group/address set matches])
expr_cnt=$(get_cache_count cache-expr)
matches_cnt=$(get_cache_count cache-matches)

check ovn-nbctl acl-add ls1 from-lport 1 'inport == @pg1 && outport == @pg1 && is_chassis_resident("lsp1")' drop
check ovn-nbctl acl-add ls1 from-lport 1 'ip4.src == $as1 && ip4.dst == $as1 && is_chassis_resident("lsp1")' drop
check ovn-nbctl --wait=hv sync

AT_CHECK([test "$expr_cnt" = "$(get_cache_count cache-expr)"], [0], [])
AT_CHECK([test "$matches_cnt" = "$(get_cache_count cache-matches)"], [0], [])

AS_BOX([Check no caching for non-conjunctive port group/address set matches])
expr_cnt=$(get_cache_count cache-expr)
matches_cnt=$(get_cache_count cache-matches)

check ovn-nbctl acl-add ls1 from-lport 1 'inport == @pg2 && outport == @pg2 && is_chassis_resident("lsp1")' drop
check ovn-nbctl --wait=hv sync

AT_CHECK([test "$expr_cnt" = "$(get_cache_count cache-expr)"], [0], [])
AT_CHECK([test "$matches_cnt" = "$(get_cache_count cache-matches)"], [0], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Delete Port_Binding and OVS port Incremental Processing])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

ovn-nbctl ls-add ls
ovn-nbctl lsp-add ls lsp

as hv1 ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp

# Wait for port to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=lsp chassis=$ch

# Pause ovn-controller.
as hv1 ovn-appctl -t ovn-controller debug/pause

# Delete port binding and OVS port. The updates will be processed in the same
# loop in ovn-controller when it resumes.
ovn-nbctl --wait=sb lsp-del lsp
as hv1 ovs-vsctl del-port vif1

# Resume ovn-controller.
as hv1 ovn-appctl -t ovn-controller debug/resume

# Make sure ovn-controller runs fine.
OVS_WAIT_UNTIL([test x$(as hv1 ovn-appctl -t ovn-controller debug/status) = "xrunning"])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

AT_SETUP([Multiple OVS port changes Incremental Processing])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw lsp1
check ovn-nbctl lsp-add sw lsp2

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1 \
    ofport-request=1
ovs-vsctl \
    -- add-port br-int vif2 \
    -- set Interface vif2 external_ids:iface-id=lsp2 \
    ofport-request=2

# Wait for ports to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch
wait_row_count Port_Binding 1 logical_port=lsp2 chassis=$ch

AS_BOX([check output flows for initial interfaces])
as hv1 ovs-ofctl dump-flows br-int table=65 > offlows_table65.txt
AT_CAPTURE_FILE([offlows_table65.txt])
AT_CHECK_UNQUOTED([grep -c "output:1" offlows_table65.txt], [0], [dnl
1
])
AT_CHECK_UNQUOTED([grep -c "output:2" offlows_table65.txt], [0], [dnl
1
])

AS_BOX([delete and add OVS interfaces and force batch of updates])
as hv1 ovn-appctl -t ovn-controller debug/pause

as hv1
ovs-vsctl \
    -- del-port vif1 \
    -- del-port vif2

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1 \
    ofport-request=3 \
    -- add-port br-int vif2 \
    -- set Interface vif2 external_ids:iface-id=lsp2 \
    ofport-request=4

as hv1 ovn-appctl -t ovn-controller debug/resume
check ovn-nbctl --wait=hv sync

AS_BOX([check output flows for new interfaces])
as hv1 ovs-ofctl dump-flows br-int table=65 > offlows_table65_2.txt
AT_CAPTURE_FILE([offlows_table65_2.txt])
AT_CHECK_UNQUOTED([grep -c "output:3" offlows_table65_2.txt], [0], [dnl
1
])
AT_CHECK_UNQUOTED([grep -c "output:4" offlows_table65_2.txt], [0], [dnl
1
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([Container port Incremental Processing])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1 \
    ofport-request=1

check ovn-nbctl ls-add ls1 \
    -- ls-add ls2 \
    -- lsp-add ls1 lsp1 \
    -- lsp-add ls2 lsp-cont1 lsp1 1
check ovn-nbctl --wait=hv sync

# Wait for ports to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch
wait_row_count Port_Binding 1 logical_port=lsp-cont1 chassis=$ch

AS_BOX([delete OVS VIF and OVN container port])
as hv1 ovn-appctl -t ovn-controller debug/pause
as hv1 ovs-vsctl del-port vif1

check ovn-nbctl --wait=sb lsp-del lsp-cont1
as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync
check_row_count Port_Binding 1 logical_port=lsp1 chassis="[[]]"

AS_BOX([readd OVS VIF])
as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1 \
    ofport-request=1
wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch

AS_BOX([readd OVN container port])
check ovn-nbctl lsp-add ls2 lsp-cont1 lsp1 1
check ovn-nbctl --wait=hv sync
check_row_count Port_Binding 1 logical_port=lsp-cont1 chassis=$ch

AS_BOX([delete both OVN VIF and OVN container port])
as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-del lsp1 \
    -- lsp-del lsp-cont1
check ovn-nbctl --wait=sb sync
as hv1 ovn-appctl -t ovn-controller debug/resume

AS_BOX([readd both OVN VIF and OVN container port])
as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl lsp-add ls1 lsp1 \
    -- lsp-add ls2 lsp-cont1 lsp1 1
check ovn-nbctl --wait=sb sync
as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync
wait_row_count Port_Binding 1 logical_port=lsp1 chassis=$ch
wait_row_count Port_Binding 1 logical_port=lsp-cont1 chassis=$ch

OVN_CLEANUP([hv1])
AT_CLEANUP

# TEST_LR_DROP_TRAFFIC_FOR_OWN_IPS [ DGP | GR ]
# Test dropping traffic destined to router owned IPs.
m4_define([TEST_LR_DROP_TRAFFIC_FOR_OWN_IPS], [
ovn_start

ovn-nbctl lr-add r1 # Gateway router or LR with DGP on the ext side
ovn-nbctl ls-add ext # simulate external LS
ovn-nbctl ls-add s2 # simulate internal LS

# Connnect r1 to ext.
ovn-nbctl lrp-add r1 lrp-r1-ext 00:00:00:00:01:01 10.0.1.1/24
if test X"$1" = X"DGP"; then
    ovn-nbctl lrp-set-gateway-chassis lrp-r1-ext hv1 1
else
    ovn-nbctl set logical_router r1 options:chassis=hv1
fi
ovn-nbctl lsp-add ext lsp-ext-r1 -- set Logical_Switch_Port lsp-ext-r1 type=router \
    options:router-port=lrp-r1-ext addresses=router

# Connnect r1 to s2.
ovn-nbctl lrp-add r1 lrp-r1-s2 00:00:00:00:02:01 10.0.2.1/24
ovn-nbctl lsp-add s2 lsp-s2-r1 -- set Logical_Switch_Port lsp-s2-r1 type=router \
    options:router-port=lrp-r1-s2 addresses=router

# Create logical port p1 in ext
ovn-nbctl lsp-add ext p1 \
-- lsp-set-addresses p1 "f0:00:00:00:01:02 10.0.1.2" \
-- lsp-set-port-security p1 "f0:00:00:00:01:02 10.0.1.2"

# Create logical port p2 in s2
ovn-nbctl lsp-add s2 p2 \
-- lsp-set-addresses p2 "f0:00:00:00:02:02 10.0.2.2"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

# Pre-populate the hypervisors' ARP tables so that we don't lose any
# packets for ARP resolution (native tunneling doesn't queue packets
# for ARP resolution).
OVN_POPULATE_ARP

wait_for_ports_up
ovn-nbctl --wait=hv sync

sw_key=$(ovn-sbctl --bare --columns tunnel_key list datapath_binding r1)

echo sw_key: $sw_key
AT_CHECK([ovn-sbctl lflow-list | grep lr_in_arp_resolve | grep 10.0.1.1], [1], [])

# Send ip packets from p1 to lrp-r1-ext
src_mac="f00000000102"
dst_mac="000000000101"
src_ip=`ip_to_hex 10 0 1 2`
dst_ip=`ip_to_hex 10 0 1 1`
packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# No packet-ins should reach ovn-controller.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep "actions=controller" | grep -v n_packets=0 -c], [1], [dnl
0
])

# The packet should have been dropped in the lr_in_ip_input stage.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep -E "table=11, n_packets=1,.* priority=60,ip,metadata=0x${sw_key},nw_dst=10.0.1.1 actions=drop" -c], [0], [dnl
1
])

# Use the router IP as SNAT IP.
ovn-nbctl lr-nat-add r1 snat 10.0.1.1 10.8.8.0/24
ovn-nbctl --wait=hv sync

# Send ip packets from p1 to lrp-r1-ext
src_mac="f00000000102"
dst_mac="000000000101"
src_ip=`ip_to_hex 10 0 1 2`
dst_ip=`ip_to_hex 10 0 1 1`
packet=${dst_mac}${src_mac}08004500001c00000000401164cf${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet

# Even after configuring a router owned IP for SNAT, no packet-ins should
# reach ovn-controller.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep "actions=controller" | grep -v n_packets=0 -c], [1], [dnl
0
])

# The packet should've been dropped in the lr_in_arp_resolve stage.
if test X"$1" = X"DGP"; then
    prio=150
    inport=reg14
    outport=reg15
else
    prio=2
fi
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep -E "table=25, n_packets=1,.* priority=$prio,ip,$inport.*$outport.*metadata=0x${sw_key},nw_dst=10.0.1.1 actions=drop" -c], [0], [dnl
1
])

# Send ip packets from p2 to lrp-r1-ext
src_mac="f00000000202"
dst_mac="000000000201"
src_ip=`ip_to_hex 10 0 2 2`
dst_ip=`ip_to_hex 10 0 1 1`
packet=${dst_mac}${src_mac}08004500001c00000000401163cf${src_ip}${dst_ip}0035111100080000
as hv1 ovs-appctl netdev-dummy/receive hv1-vif2 $packet

# Still no packet-ins should reach ovn-controller.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep "actions=controller" | grep -v n_packets=0 -c], [1], [dnl
0
])

if test X"$1" = X"DGP"; then
    # The packet dst should be resolved once for E/W centralized NAT purpose.
    AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep -E "table=25, n_packets=1,.* priority=100,reg0=0xa000101,reg15=.*metadata=0x${sw_key} actions=mod_dl_dst:00:00:00:00:01:01,resubmit" -c], [0], [dnl
1
])
fi

# The packet should've been finally dropped in the lr_in_arp_resolve stage.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep -E "table=25, n_packets=2,.* priority=$prio,ip,$inport.*$outport.*metadata=0x${sw_key},nw_dst=10.0.1.1 actions=drop" -c], [0], [dnl
1
])
OVN_CLEANUP([hv1])
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([gateway router drop traffic for own IPs])
TEST_LR_DROP_TRAFFIC_FOR_OWN_IPS(GR)
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([distributed gateway port drop traffic for own IPs])
TEST_LR_DROP_TRAFFIC_FOR_OWN_IPS(DGP)
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([nb_cfg timestamp])
TAG_UNSTABLE
ovn_start

check ovn-nbctl ls-add s2
check ovn-nbctl ls-add join

net_add n1

n=10
for i in $(seq 1 $n); do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i
done

wait_row_count Chassis $n

# get_cfg IDX
#
# Fetches data fields into shell variables:
# - nb_cfg into nbs$IDX
# - nb_cfg_timestamp into nbt$IDX
# - sb_cfg into sbs$IDX
# - sb_cfg_timestamp into sbt$IDX
# - hv_cfg into hvs$IDX
# - hv_cfg_timestamp into hvt$IDX
get_cfg() {
    local i=$1
    set -- $(ovn-nbctl get nb_global . nb_cfg nb_cfg_timestamp sb_cfg sb_cfg_timestamp hv_cfg hv_cfg_timestamp)
    AS_VAR_SET([nbs$i], [$1])
    AS_VAR_SET([nbt$i], [$2])
    AS_VAR_SET([sbs$i], [$3])
    AS_VAR_SET([sbt$i], [$4])
    AS_VAR_SET([hvs$i], [$5])
    AS_VAR_SET([hvt$i], [$6])
    if test "$i" = 1; then
        printf '\n-- %s\n' "$i. *_cfg(*_cfg_timestamp): nb=$1($2) sb=$3($4) hv=$5($6)"
    else
        AS_VAR_ARITH([p], [$i - 1])
        AS_VAR_COPY([nbtp], [nbt$p])
        AS_VAR_COPY([sbtp], [sbt$p])
        AS_VAR_COPY([hvtp], [hvt$p])
        AS_VAR_ARITH([nbtdelta], [$2 - $nbtp])
        AS_VAR_ARITH([sbtdelta], [$4 - $sbtp])
        AS_VAR_ARITH([hvtdelta], [$6 - $hvtp])
        printf "\n-- $i. *_cfg(*_cfg_timestamp): nb=$1(%+d) sb=$3(%+d) hv=$5(%+d)\n" $nbtdelta $sbtdelta $hvtdelta
    fi
}

# Check initial timestamps
get_cfg 1
check test "$nbs1" = 0
check test "$sbs1" = 0
check test "$hvs1" = 0

# Force a sequence number change and check the new timestamps
ovn-nbctl --wait=hv ls-add s1
get_cfg 2
check test "$nbs2" = 1
check test "$nbt2" -gt 0
check test "$sbt2" -gt 0
check test "$hvt2" -gt 0

# Kill ovn-controller on chassis hv3, so that it won't update nb_cfg.
# Then wait for 9 out of 10
sleep 1
check as hv3 ovn-appctl -t ovn-controller exit --restart
wait_for_ports_up
ovn-nbctl --wait=sb sync
wait_row_count Chassis_Private 9 name!=hv3 nb_cfg=2
check_row_count Chassis_Private 1 name=hv3 nb_cfg=1

get_cfg 3
check test "$nbs3" = 2
check test "$nbt3" -gt "$nbt2"
check test "$sbt3" -gt "$sbt2"
check test "$hvt3" -gt 0

# start ovn-controller on hv3 again, so that it will update nb_cfg with latest
# timestamp (hv3 will be the slowest one).
as hv3 start_daemon ovn-controller
wait_row_count Chassis_Private 1 name=hv3 nb_cfg=2

get_cfg 4
hv3_ts=$(ovn-sbctl --bare --columns=nb_cfg_timestamp find chassis_private name=hv3)
echo hv3_ts=$hv3_ts
wait_column $hv3_ts nb:nb_global hv_cfg_timestamp

AT_CHECK([test x$(ovn-nbctl --print-wait-time --wait=sb sync | grep ms | wc -l) = x2])
AT_CHECK([test x$(ovn-nbctl --print-wait-time --wait=hv sync | grep ms | wc -l) = x3])

for i in $(seq 2 $n); do
    OVN_CLEANUP_SBOX([hv$i])
done
OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ARP replies for SNAT external ips])
AT_KEYWORDS([slowtest])
TAG_UNSTABLE
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-port1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw3-port1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])
ovs-vsctl set open . external_ids:ovn-enable-lflow-cache=false

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-port2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])
ovs-vsctl set open . external_ids:ovn-enable-lflow-cache=false

sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=sw1-port1 \
    options:tx_pcap=hv3/vif1-tx.pcap \
    options:rxq_pcap=hv3/vif1-rx.pcap \
    ofport-request=1
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-phys])
ovs-vsctl set open . external_ids:ovn-enable-lflow-cache=false

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-port1
ovn-nbctl lsp-set-addresses sw0-port1 "10:54:00:00:00:03 10.0.0.3 1000::3"
ovn-nbctl lsp-add sw0 sw0-port2
ovn-nbctl lsp-set-addresses sw0-port2 "10:54:00:00:00:04 10.0.0.4 1000::4"

ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-port1
ovn-nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3 2000::3"

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 router
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

ovn-nbctl ls-add public
ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.16.0.100/24 3000::a/64
ovn-nbctl lsp-add public public-lr0
ovn-nbctl lsp-set-type public-lr0 router
ovn-nbctl lsp-set-addresses public-lr0 router
ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

# localnet port
ovn-nbctl lsp-add public ln-public
ovn-nbctl lsp-set-type ln-public localnet
ovn-nbctl lsp-set-addresses ln-public unknown
ovn-nbctl lsp-set-options ln-public network_name=physnet1

# schedule the gw router port to a chassis.
ovn-nbctl lrp-set-gateway-chassis lr0-public hv1 20

# Create NAT entries for the ports

# sw0-port1
ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.16.0.110 10.0.0.3 sw0-port1 30:54:00:00:00:03
ovn-nbctl lr-nat-add lr0 dnat_and_snat 3000::c 1000::3 sw0-port1 40:54:00:00:00:03
# sw1-port1
ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.16.0.120 20.0.0.3 sw1-port1 30:54:00:00:00:04
ovn-nbctl lr-nat-add lr0 dnat_and_snat 3000::d 2000::3 sw1-port1 40:54:00:00:00:04

# Add snat entriess
ovn-nbctl lr-nat-add lr0 snat 172.16.0.100 10.0.0.0/24
ovn-nbctl lr-nat-add lr0 snat 172.16.0.101 10.0.0.10
ovn-nbctl lr-nat-add lr0 snat 172.16.0.102 10.0.0.11
ovn-nbctl lr-nat-add lr0 snat 172.16.0.100 20.0.0.0/24

ovn-nbctl ls-add sw3
ovn-nbctl lsp-add sw3 sw3-port1
ovn-nbctl lsp-set-addresses sw3-port1 "20:14:00:00:00:03 30.0.0.3 3000::3"

ovn-nbctl lr-add lr1
ovn-nbctl lrp-add lr1 lr1-sw3 00:00:00:10:ff:03 30.0.0.1/24 3000::a/64
ovn-nbctl lsp-add sw3 sw3-lr1
ovn-nbctl lsp-set-type sw3-lr1 router
ovn-nbctl lsp-set-addresses sw3-lr1 router
ovn-nbctl lsp-set-options sw3-lr1 router-port=lr1-sw3

ovn-nbctl ls-add join

# Connect lr1 to join
ovn-nbctl lrp-add lr1 lr1-join 00:00:04:01:02:03 170.0.0.1/24
ovn-nbctl lsp-add join join-lr1
ovn-nbctl lsp-set-type join-lr1 router
ovn-nbctl lsp-set-addresses join-lr1 router
ovn-nbctl lsp-set-options join-lr1 router-port=lr1-join

# Create GW router
ovn-nbctl lr-add gw_router
# connect gw_router to join
ovn-nbctl lrp-add gw_router gw_router-join 00:00:03:11:12:13 170.0.0.2/24
ovn-nbctl lsp-add join join-gw_router
ovn-nbctl lsp-set-type join-gw_router router
ovn-nbctl lsp-set-addresses join-gw_router router
ovn-nbctl lsp-set-options join-gw_router router-port=gw_router-join

# Connect gw_router to public
ovn-nbctl lrp-add gw_router gw_router-public 00:00:30:30:32:33 172.16.0.200/24 3000::b/64
ovn-nbctl lsp-add public public-gw_router
ovn-nbctl lsp-set-type public-gw_router router
ovn-nbctl lsp-set-addresses public-gw_router router
ovn-nbctl lsp-set-options public-gw_router router-port=gw_router-public

# Pin gw_router to hv3
ovn-nbctl set logical_router gw_router options:chassis=hv3

# Add snat entries on gw_router
ovn-nbctl lr-nat-add gw_router snat 172.16.0.200 30.0.0.0/24
ovn-nbctl lr-nat-add gw_router snat 172.16.0.201 30.0.0.3

wait_for_ports_up
ovn-nbctl --wait=hv sync

# Create an interface in br-phys in hv2 and send ARP request for 172.16.0.100
as hv2
ovs-vsctl -- add-port br-phys hv2-phys1 -- \
    set interface hv2-phys1 options:tx_pcap=hv2/phys1-tx.pcap \
    options:rxq_pcap=hv2/phys1-rx.pcap \
    ofport-request=1

send_arp_request() {
    local eth_src=$1 spa=$2 tpa=$3
    local eth_dst=ffffffffffff
    local eth_type=0806
    local eth=${eth_dst}${eth_src}${eth_type}

    local arp=0001080006040001${eth_src}${spa}${eth_dst}${tpa}

    local request=${eth}${arp}
    as hv2 ovs-appctl netdev-dummy/receive hv2-phys1 $request
}

test_arp_response () {
    local router_mac=$1 router_ip=$2 gw=$3 nongw1=$4 nongw2=$5

    echo "Checking arp reply for IP - $router_ip"
    as hv1 reset_pcap_file br-phys_n1 hv1/br-phys_n1
    as hv2 reset_pcap_file br-phys_n1 hv2/br-phys_n1
    as hv3 reset_pcap_file br-phys_n1 hv3/br-phys_n1
    as hv2 reset_pcap_file hv2-phys1 hv2/phys1

    local src_mac=000200100011
    src_ip=$(ip_to_hex 172 16 0 40)
    send_arp_request ${src_mac} ${src_ip} ${router_ip}
    arp_reply=${src_mac}${router_mac}08060001080006040002${router_mac}
    arp_reply=${arp_reply}${router_ip}${src_mac}${src_ip}

    # there is a small race where gw-router-port can be running on both
    # hvs and both of them can reply to the arp request ending up with
    # two arp replies in the pcap file. This is transitory not significant
    # in a real deployment that can trigger a fail here. Let's check that
    # we received the expected arp_reply, ignoring other packets such as
    # duplicates and garps.
    echo $arp_reply > expected_out
    OVN_CHECK_PACKETS_CONTAIN([hv2/phys1-tx.pcap], [expected_out])

    # $gw phys1-n1 should see the response because $gw ovn-controller responds
    # to arp request.
    OVN_CHECK_PACKETS_CONTAIN([$gw/br-phys_n1-tx.pcap], [expected_out])

    # $nongw1 and $nongw1 phys1-n1 should not see the response.
    $PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $nongw1/br-phys_n1-tx.pcap
    AT_CHECK([$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $nongw1/br-phys_n1-tx.pcap | \
    grep -c $arp_reply], [1], [0
])

    AT_CHECK([$PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" $nongw2/br-phys_n1-tx.pcap | \
    grep -c $arp_reply], [1], [0
])
}

# Send ARP request for the IPs which belongs to lr0 having
# distributed gw router port - lr0-public.
test_arp_response 000020201213 $(ip_to_hex 172 16 0 100) hv1 hv2 hv3
test_arp_response 000020201213 $(ip_to_hex 172 16 0 101) hv1 hv2 hv3
test_arp_response 000020201213 $(ip_to_hex 172 16 0 102) hv1 hv2 hv3

# Send ARP request for the IP which belongs to gw_router
test_arp_response 000030303233 $(ip_to_hex 172 16 0 200) hv3 hv1 hv2
test_arp_response 000030303233 $(ip_to_hex 172 16 0 201) hv3 hv1 hv2

# Make hv3 claim the cr-lr0-public
ovn-nbctl lrp-set-gateway-chassis lr0-public hv1 20
ovn-nbctl lrp-set-gateway-chassis lr0-public hv2 30
ovn-nbctl lrp-set-gateway-chassis lr0-public hv3 40

hv3_uuid=$(ovn-sbctl --bare --columns _uuid list chassis hv3)

OVS_WAIT_UNTIL([
    cr_lr0_public_ch=$(ovn-sbctl --bare --columns chassis list port_binding cr-lr0-public)
    test "$cr_lr0_public_ch" = $hv3_uuid
])

test_arp_response 000020201213 $(ip_to_hex 172 16 0 100) hv3 hv1 hv2
test_arp_response 000020201213 $(ip_to_hex 172 16 0 101) hv3 hv1 hv2
test_arp_response 000020201213 $(ip_to_hex 172 16 0 102) hv3 hv1 hv2

# Schedule gw_router on hv1.
ovn-nbctl set logical_router gw_router options:chassis=hv1
hv1_uuid=$(ovn-sbctl --bare --columns _uuid list chassis hv1)

OVS_WAIT_UNTIL([
    gw_router_ch=$(ovn-sbctl --bare --columns chassis list port_binding gw_router-public)
    test "$gw_router_ch" = $hv1_uuid
])

# Send ARP request for the IP which belongs to gw_router
test_arp_response 000030303233 $(ip_to_hex 172 16 0 200) hv1 hv2 hv3
test_arp_response 000030303233 $(ip_to_hex 172 16 0 201) hv1 hv2 hv3

OVN_CLEANUP([hv1],[hv2],[hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# Duplicate ACLs (same match with same action) should work as expected.
# Conflict ACLs (same match with different actions) behavior is unpredictable
# (only one of them would work).
# This test covers both situation and also makes sure adding/deleting in
# different order is handled properly (duplicated flow handling in ofctrl_put()
# of ovn-controller)
AT_SETUP([conflict or duplicate ACLs resulting in same OVS match])
ovn_start

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 lsp1 \
    -- lsp-set-addresses lsp1 "f0:00:00:00:00:01 10.0.0.1"

check ovn-nbctl lsp-add ls1 lsp2 \
    -- lsp-set-addresses lsp2 "f0:00:00:00:00:02 10.0.0.2"

net_add n1
sim_add hv1

as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

check ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=lsp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

# Default drop
check ovn-nbctl acl-add ls1 to-lport 1000 \
    'outport == "lsp1" && ip4' drop

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes an ip packet to be received on INPORT.
# The packet's content has Ethernet destination DST and source SRC
# (each exactly 12 hex digits) and Ethernet type ETHTYPE (4 hex digits).
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 11 for vif11.
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}\
${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Create overlapping ACLs resulting in duplicated desired OVS flows
check ovn-nbctl acl-add ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == 10.0.0.2' allow
check ovn-nbctl acl-add ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == {10.0.0.2, 10.0.0.3}' allow

wait_for_ports_up
check ovn-nbctl --wait=hv sync

sip=`ip_to_hex 10 0 0 2`
dip=`ip_to_hex 10 0 0 1`
test_ip 2 f00000000002 f00000000001 $sip $dip 1
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# Delete one of the ACLs.
check ovn-nbctl acl-del ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == {10.0.0.2, 10.0.0.3}'
check ovn-nbctl --wait=hv sync

test_ip 2 f00000000002 f00000000001 $sip $dip 1
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# Add a conflict ACL with drop action.
check ovn-nbctl acl-add ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == {10.0.0.2, 10.0.0.3}' drop
# Don't test because it is unpredicatable which rule will take effect.

# Delete the ACL that has "allow" action
check ovn-nbctl acl-del ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == 10.0.0.2'
check ovn-nbctl --wait=hv sync

# Packet should be dropped
test_ip 2 f00000000002 f00000000001 $sip $dip
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# Add the ACL back and delete the "drop" ACL
check ovn-nbctl acl-add ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == 10.0.0.2' allow
check ovn-nbctl acl-del ls1 to-lport 1001 \
    'outport == "lsp1" && ip4 && ip4.src == {10.0.0.2, 10.0.0.3}'
check ovn-nbctl --wait=hv sync

# Packet should be received
test_ip 2 f00000000002 f00000000001 $sip $dip 1
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# This test cases tests a scenario of ACL confliction with address set update.
# It is to cover a corner case when flows are re-processed in the I-P
# iteration, combined with the scenario of conflicting ACLs.
AT_SETUP([conflict ACLs with address set])
TAG_UNSTABLE
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 lsp1 \
-- lsp-set-addresses lsp1 "f0:00:00:00:00:01 10.0.0.1"

ovn-nbctl lsp-add ls1 lsp2 \
-- lsp-set-addresses lsp2 "f0:00:00:00:00:02 10.0.0.2"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=lsp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

# Default drop
ovn-nbctl acl-add ls1 to-lport 1000 \
'outport == "lsp1" && ip4' drop

# test_ip INPORT SRC_MAC DST_MAC SRC_IP DST_IP OUTPORT...
#
# This shell function causes an ip packet to be received on INPORT.
# The packet's content has Ethernet destination DST and source SRC
# (each exactly 12 hex digits) and Ethernet type ETHTYPE (4 hex digits).
# The OUTPORTs (zero or more) list the VIFs on which the packet should
# be received.  INPORT and the OUTPORTs are specified as logical switch
# port numbers, e.g. 11 for vif11.
test_ip() {
    # This packet has bad checksums but logical L3 routing doesn't check.
    local inport=$1 src_mac=$2 dst_mac=$3 src_ip=$4 dst_ip=$5
    local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}\
${dst_ip}0035111100080000
    shift; shift; shift; shift; shift
    as hv1 ovs-appctl netdev-dummy/receive hv1-vif$inport $packet
    for outport; do
        echo $packet >> $outport.expected
    done
}

# Create an address set
ovn-nbctl create Address_Set name=as1 \
addresses=\"10.0.0.2\",\"10.0.0.3\"

# Create overlapping ACLs resulting in conflict desired OVS flows
# Add ACL1 uses the address set
ovn-nbctl --wait=hv acl-add ls1 to-lport 1001 \
'outport == "lsp1" && ip4 && ip4.src == $as1' allow

# Add ACL2 which uses a single IP, which shouldn't take effect because
# when it is added incrementally there is already a conflict one installed.
ovn-nbctl --wait=hv acl-add ls1 to-lport 1001 \
'outport == "lsp1" && ip4 && ip4.src == 10.0.0.2' drop


sip=`ip_to_hex 10 0 0 2`
dip=`ip_to_hex 10 0 0 1`
test_ip 2 f00000000002 f00000000001 $sip $dip 1
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# Update the address set which causes flow reprocessing but the OVS flow
# for allowing 10.0.0.2 should keep unchanged
ovn-nbctl --wait=hv set Address_Set as1 addresses=\"10.0.0.2\"

test_ip 2 f00000000002 f00000000001 $sip $dip 1
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

# Delete the ACL1 that has "allow" action
ovn-nbctl --wait=hv acl-del ls1 to-lport 1001 \
'outport == "lsp1" && ip4 && ip4.src == $as1'

# ACL2 should take effect and packet should be dropped
test_ip 2 f00000000002 f00000000001 $sip $dip
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [1.expected])

OVN_CLEANUP([hv1])
AT_CLEANUP

OVN_FOR_EACH_NORTHD([
AT_SETUP([port bind/unbind change handling with conj flows - IPv6])
ovn_start

ovn-nbctl ls-add ls1

ovn-nbctl lsp-add ls1 lsp1 \
    -- lsp-set-addresses lsp1 "f0:00:00:00:00:01 2001::1" \
    -- lsp-set-port-security lsp1 "f0:00:00:00:00:01 2001::1"

net_add n1
sim_add hv1

as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

wait_for_ports_up
ovn-nbctl --wait=hv sync

# Expected conjunction flows: None
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])

# unbind the port
ovs-vsctl set interface hv1-vif1 external_ids:iface-id=foo
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])

# bind the port again
ovs-vsctl set interface hv1-vif1 external_ids:iface-id=lsp1
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])

# unbind the port again
ovs-vsctl set interface hv1-vif1 external_ids:iface-id=foo
OVS_WAIT_UNTIL([test 0 = `as hv1 ovs-ofctl dump-flows br-int | \
grep conjunction | wc -l`])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([I-P of OVS interface changes which belong to non integration bridge])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-add sw0 sw0-p2

as hv1 ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=sw0-p1

# Wait for port to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=sw0-p1 chassis=$ch

as hv1 ovs-vsctl add-br br-temp
as hv1 ovs-vsctl \
    -- add-port br-temp t1 \
    -- set Interface t1 external_ids:iface-id=sw0-p2

ovn-nbctl --wait=hv sync

# hv1 ovn-controller should not bind sw0-p2.
wait_for_ports_up sw0-p1
check_row_count Port_Binding 0 logical_port=sw0-p2 chassis=$c

# Trigger recompute and sw0-p2 should not be claimed.
as hv1 ovn-appctl -t ovn-controller recompute
ovn-nbctl --wait=hv sync

check_row_count Port_Binding 0 logical_port=sw0-p2 chassis=$ch

ovn-sbctl --columns chassis --bare list port_binding sw0-p2

OVN_CLEANUP([hv1])
AT_CLEANUP
])

#
# When multiple encap-ips are configued, make sure the
# ovn-controller doesn't get into a state of constantly
# updating the SB Chassis's encap information. The test
# configures multiple vteps and waits for a couple
# of seconds to makes sure the SB encap info remains
# unchanged.
#
#
OVN_FOR_EACH_NORTHD([
AT_SETUP([multi-vtep SB Chassis encap updates])
TAG_UNSTABLE
ovn_start

net_add n1
sim_add hv1
as hv1

ovs-vsctl add-br br-phys
# Just set the encap type to be geneve for this test.
ovn_attach n1 br-phys 192.168.0.1 24 geneve

# Get the encap rec, should be just one - with geneve/192.168.0.1
# Skip initial null encap
OVS_WAIT_UNTIL(
  [encap_rec=$(ovn-sbctl --bare --no-heading --columns encaps list chassis hv1)
  echo "encap_rec = $encap_rec"
  test $encap_rec])

# Set multiple IPs
as hv1
ovs-vsctl \
    -- set Open_vSwitch . external-ids:ovn-encap-ip="192.168.0.1,192.168.1.1"

# Check if the encap_rec changed - should have, no need to
# compare the exact values.
OVS_WAIT_UNTIL(
  [encap_rec_mvtep=$(ovn-sbctl --bare --no-heading --columns encaps list chassis hv1)
  echo "encap_rec_mvtep = $encap_rec_mvtep"
  test "$encap_rec" != "$encap_rec_mvtep"])

# now, wait for a couple of secs -  should be enough time, I suppose.
sleep 2

# Check if the encap_rec changed (it should not have)
encap_rec_mvtep1=$(ovn-sbctl --data=bare --no-heading --column encaps list chassis hv1)

AT_CHECK([test "$encap_rec_mvtep" = "$encap_rec_mvtep1"], [0], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load Balancer LS hairpin OF flows])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external_ids:ovn-check-ct-label-for-lb-hairpin=false

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2

check ovn-nbctl --wait=hv ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 00:00:00:00:00:01

check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1 -- lsp-set-addresses sw1-p1 00:00:00:00:01:01

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1) = xup])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw1-p1) = xup])

check ovn-nbctl lb-add lb-ipv4-tcp 88.88.88.88:8080 42.42.42.1:4041 tcp
check ovn-nbctl lb-add lb-ipv4-udp 88.88.88.88:4040 42.42.42.1:2021 udp
check ovn-nbctl lb-add lb-ipv4 88.88.88.89 42.42.42.2
check ovn-nbctl lb-add lb-ipv6-tcp [[8800::0088]]:8080 [[4200::1]]:4041 tcp
check ovn-nbctl lb-add lb-ipv6 8800::0089 4200::2
check ovn-nbctl --wait=hv lb-add lb-ipv6-udp [[8800::0088]]:4040 [[4200::1]]:2021 udp

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | grep -v NXST], [1], [dnl
])

check ovn-nbctl --wait=hv ls-lb-add sw0 lb-ipv4-tcp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 1]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69], [0], [dnl
NXST_FLOW reply (xid=0x8):
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | grep -v NXST], [1], [dnl
])

check ovn-nbctl lb-add lb-ipv4-tcp 88.88.88.90:8080 42.42.42.42:4041,52.52.52.52:4042 tcp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 3]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69], [0], [dnl
NXST_FLOW reply (xid=0x8):
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | grep -v NXST], [1], [dnl
])


check ovn-nbctl lsp-add sw0 sw0-p2
# hv2 should bind sw0-p2 and it should install the LB hairpin flows.
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2) = xup])

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 3]
)

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
])

check ovn-nbctl --wait=hv ls-lb-add sw0 lb-ipv4-udp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 4]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 4]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
])

check ovn-nbctl --wait=hv ls-lb-add sw0 lb-ipv6-tcp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 5]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 5]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
])

check ovn-nbctl --wait=hv ls-lb-add sw0 lb-ipv6-udp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 6]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 6]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
])

check ovn-nbctl --wait=hv ls-lb-add sw1 lb-ipv6-udp

# Number of hairpin flows shouldn't change as it doesn't depend on how many
# datapaths the LB is applied.
OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 6]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 6]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
])

check ovn-nbctl --wait=hv ls-lb-add sw0 lb-ipv4
OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 7]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 7]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,ip,reg1=0x58585859,nw_src=42.42.42.2,nw_dst=42.42.42.2 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.89,NXM_OF_IP_PROTO[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=90,ip,reg1=0x58585859 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.89))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,ip,reg1=0x58585859,nw_src=42.42.42.2,nw_dst=42.42.42.2 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.89,NXM_OF_IP_PROTO[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=90,ip,reg1=0x58585859 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.89))
])

check ovn-nbctl --wait=hv ls-lb-add sw0 lb-ipv6
OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 8]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 8]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,ip,reg1=0x58585859,nw_src=42.42.42.2,nw_dst=42.42.42.2 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.89,NXM_OF_IP_PROTO[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,ipv6,reg4=0x88000000,reg5=0,reg6=0,reg7=0x89,ipv6_src=4200::2,ipv6_dst=4200::2 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::89,NXM_OF_IP_PROTO[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=90,ip,reg1=0x58585859 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.89))
 table=70, priority=90,ipv6,reg4=0x88000000,reg5=0,reg6=0,reg7=0x89 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::89))
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,ip,reg1=0x58585859,nw_src=42.42.42.2,nw_dst=42.42.42.2 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.89,NXM_OF_IP_PROTO[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,ipv6,reg4=0x88000000,reg5=0,reg6=0,reg7=0x89,ipv6_src=4200::2,ipv6_dst=4200::2 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::89,NXM_OF_IP_PROTO[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x58585858,reg2=0x1f90/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp,reg1=0x58585858,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,tcp,reg1=0x5858585a,reg2=0x1f90/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=90,ip,reg1=0x58585859 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.89))
 table=70, priority=90,ipv6,reg4=0x88000000,reg5=0,reg6=0,reg7=0x89 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::89))
])

check ovn-nbctl --wait=hv ls-lb-del sw0 lb-ipv4
check ovn-nbctl --wait=hv ls-lb-del sw0 lb-ipv6

# Check backwards compatibility with ovn-northd versions that don't store the
# original destination tuple.
#
# ovn-controller should fall back to matching on ct_nw_dst()/ct_tp_dst().
as northd ovn-appctl -t NORTHD_TYPE pause

check ovn-sbctl \
    -- remove load_balancer lb-ipv4-tcp options hairpin_orig_tuple \
    -- remove load_balancer lb-ipv6-tcp options hairpin_orig_tuple \
    -- remove load_balancer lb-ipv4-udp options hairpin_orig_tuple \
    -- remove load_balancer lb-ipv6-udp options hairpin_orig_tuple

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_ipv6_dst=8800::88,ct_nw_proto=17,ct_tp_dst=4040,udp6,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_ipv6_dst=8800::88,ct_nw_proto=6,ct_tp_dst=8080,tcp6,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_nw_dst=88.88.88.88,ct_nw_proto=17,ct_tp_dst=4040,udp,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_nw_dst=88.88.88.88,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,ct_state=+trk+dnat,ct_ipv6_dst=8800::88,ct_nw_proto=17,ct_tp_dst=4040,udp6 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,ct_state=+trk+dnat,ct_ipv6_dst=8800::88,ct_nw_proto=6,ct_tp_dst=8080,tcp6 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.88,ct_nw_proto=17,ct_tp_dst=4040,udp actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.88,ct_nw_proto=6,ct_tp_dst=8080,tcp actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
])

OVS_WAIT_FOR_OUTPUT([as hv2 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_ipv6_dst=8800::88,ct_nw_proto=17,ct_tp_dst=4040,udp6,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_ipv6_dst=8800::88,ct_nw_proto=6,ct_tp_dst=8080,tcp6,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_nw_dst=88.88.88.88,ct_nw_proto=17,ct_tp_dst=4040,udp,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_nw_dst=88.88.88.88,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=42.42.42.42,nw_dst=42.42.42.42,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_state=+trk+dnat,ct_mark=0x2/0x2,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp,nw_src=52.52.52.52,nw_dst=52.52.52.52,tp_dst=4042 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.90,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69 | grep -v NXST], [1], [dnl
])

OVS_WAIT_FOR_OUTPUT([as hv2 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,ct_state=+trk+dnat,ct_ipv6_dst=8800::88,ct_nw_proto=17,ct_tp_dst=4040,udp6 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,ct_state=+trk+dnat,ct_ipv6_dst=8800::88,ct_nw_proto=6,ct_tp_dst=8080,tcp6 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.88,ct_nw_proto=17,ct_tp_dst=4040,udp actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.88,ct_nw_proto=6,ct_tp_dst=8080,tcp actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,ct_state=+trk+dnat,ct_nw_dst=88.88.88.90,ct_nw_proto=6,ct_tp_dst=8080,tcp actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.90))
])

# Resume ovn-northd.
as northd ovn-appctl -t NORTHD_TYPE resume
check ovn-nbctl --wait=hv sync

as hv2 ovs-vsctl del-port hv2-vif1
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2) = xdown])

# Trigger recompute on hv2 as sw0 will not be cleared from local_datapaths.
as hv2 ovn-appctl -t ovn-controller recompute

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=69 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=70 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 6]
)

check ovn-nbctl --wait=hv lb-del lb-ipv4-tcp

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 3]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 0]
)

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=68 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=4041 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp,reg1=0x58585858,reg2=0xfc8/0xffff,nw_src=42.42.42.1,nw_dst=42.42.42.1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=88.88.88.88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88,ipv6_src=4200::1,ipv6_dst=4200::1,tp_dst=2021 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x86dd,NXM_NX_IPV6_SRC[[]],ipv6_dst=8800::88,nw_proto=17,NXM_OF_UDP_SRC[[]]=NXM_OF_UDP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=69], [0], [dnl
NXST_FLOW reply (xid=0x8):
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=70 | ofctl_strip_all | grep -v NXST], [0], [dnl
 table=70, priority=100,tcp6,reg2=0x1f90/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
 table=70, priority=100,udp,reg1=0x58585858,reg2=0xfc8/0xffff actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=88.88.88.88))
 table=70, priority=100,udp6,reg2=0xfc8/0xffff,reg4=0x88000000,reg5=0,reg6=0,reg7=0x88 actions=ct(commit,zone=NXM_NX_REG12[[0..15]],nat(src=8800::88))
])

check ovn-nbctl --wait=hv ls-del sw0
check ovn-nbctl --wait=hv ls-del sw1

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=69 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv1 ovs-ofctl dump-flows br-int table=70 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=68 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=69 | grep -c -v NXST) -eq 0]
)

OVS_WAIT_UNTIL(
    [test $(as hv2 ovs-ofctl dump-flows br-int table=70 | grep -c -v NXST) -eq 0]
)

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([check ovn-northd and ovn-controller version pinning])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-add sw0 sw0-p2

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=sw0-p1 \
    ofport-request=1
ovs-vsctl \
    -- add-port br-int vif2 \
    -- set Interface vif2 external_ids:iface-id=sw0-p2 \
    ofport-request=2

# Wait for port to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=sw0-p1 chassis=$ch
wait_row_count Port_Binding 1 logical_port=sw0-p2 chassis=$ch

northd_version=$(ovn-sbctl get SB_Global . options:northd_internal_version | sed s/\"//g)
echo "northd version = $northd_version"
AT_CHECK([grep -c $northd_version hv1/ovn-controller.log], [0], [1
])

# Stop ovn-northd so that we can modify the northd_version.
as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

check ovn-sbctl set SB_Global . options:northd_internal_version=foo

as hv1
check ovs-vsctl set interface vif2 external_ids:iface-id=foo

# ovn-controller should release the lport sw0-p2 since ovn-match-northd-version
# is not true.
wait_row_count Port_Binding 1 logical_port=sw0-p2 'chassis=[[]]'

as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [1], [dnl
0
])

echo
echo "__file__:__line__: Pin ovn-controller to ovn-northd version."

as hv1
check ovs-vsctl set open . external_ids:ovn-match-northd-version=true

OVS_WAIT_UNTIL(
    [test 1 = $(grep -c "controller version - $northd_version mismatch with northd version - foo" hv1/ovn-controller.log)
])

as hv1
check ovs-vsctl set interface vif2 external_ids:iface-id=sw0-p2

# ovn-controller should not claim sw0-p2 since there is version mismatch
as hv1 ovn-appctl -t ovn-controller recompute
wait_row_count Port_Binding 1 logical_port=sw0-p2 'chassis=[[]]'

as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [1], [dnl
0
])

check ovn-sbctl set SB_Global . options:northd_internal_version=$northd_version

# It should claim sw0-p2
wait_row_count Port_Binding 1 logical_port=sw0-p2 chassis=$ch

as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [0], [dnl
1
])

as hv1
ovn_remote=$(ovs-vsctl get open . external_ids:ovn-remote | sed s/\"//g)
ovs-vsctl set open . external_ids:ovn-remote=unix:foo
check ovs-vsctl set interface vif2 external_ids:iface-id=foo

# ovn-controller is not connected to the SB DB. Even though it
# releases sw0-p2, it will not delete the OF flows.
as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [0], [dnl
1
])

# Change the version to incorrect one and reconnect to the SB DB.
check ovn-sbctl set SB_Global . options:northd_internal_version=bar

as hv1
check ovs-vsctl set open . external_ids:ovn-remote=$ovn_remote

sleep 1

as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [0], [dnl
1
])

wait_row_count Port_Binding 1 logical_port=sw0-p2 chassis=$ch

# Change the ovn-remote to incorrect and set the correct northd version
# and then change back to the correct ovn-remote
as hv1
check ovs-vsctl set open . external_ids:ovn-remote=unix:foo

check ovn-sbctl set SB_Global . options:northd_internal_version=$northd_version

as hv1
check ovs-vsctl set open . external_ids:ovn-remote=$ovn_remote

wait_row_count Port_Binding 1 logical_port=sw0-p2 'chassis=[[]]'
as hv1 ovs-ofctl dump-flows br-int table=0 > offlows_table0.txt
AT_CAPTURE_FILE([offlows_table0.txt])
AT_CHECK_UNQUOTED([grep -c "in_port=2" offlows_table0.txt], [1], [dnl
0
])

as hv1
OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([propagate Port_Binding.up to NB and OVS])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl ls-add ls

AS_BOX([add OVS port for existing LSP])
check ovn-nbctl lsp-add ls lsp1
check ovn-nbctl --wait=hv sync
check_column "false" Port_Binding up logical_port=lsp1

check ovs-vsctl add-port br-int lsp1 -- set Interface lsp1 external-ids:iface-id=lsp1
wait_column "true" Port_Binding up logical_port=lsp1
wait_column "true" nb:Logical_Switch_Port up name=lsp1
OVS_WAIT_UNTIL([test `ovs-vsctl get Interface lsp1 external_ids:ovn-installed` = '"true"'])

AS_BOX([add LSP for existing OVS port])
check ovs-vsctl add-port br-int lsp2 -- set Interface lsp2 external-ids:iface-id=lsp2
check ovn-nbctl lsp-add ls lsp2
check ovn-nbctl --wait=hv sync
check_column "true" Port_Binding up logical_port=lsp2
wait_column "true" nb:Logical_Switch_Port up name=lsp2
OVS_WAIT_UNTIL([test `ovs-vsctl get Interface lsp2 external_ids:ovn-installed` = '"true"'])

AS_BOX([ovn-controller should not reset Port_Binding.up without northd])
# Pause northd and clear the "up" field to simulate older ovn-northd
# versions writing to the Southbound DB.
as northd ovn-appctl -t NORTHD_TYPE pause

as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-sbctl clear Port_Binding lsp1 up
as hv1 ovn-appctl -t ovn-controller debug/resume

# Forcefully release the Port_Binding so ovn-controller reclaims it.
# Make sure the Port_Binding.up field is not updated though.
check ovn-sbctl clear Port_Binding lsp1 chassis
hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
wait_column "$hv1_uuid" Port_Binding chassis logical_port=lsp1
check_column "" Port_Binding up logical_port=lsp1

# Once northd should explicitly set the Port_Binding.up field to 'false' and
# ovn-controller sets it to 'true' as soon as the update is processed.
as northd ovn-appctl -t NORTHD_TYPE resume
wait_column "true" Port_Binding up logical_port=lsp1
wait_column "true" nb:Logical_Switch_Port up name=lsp1

AS_BOX([ovn-controller should reset Port_Binding.up - from NULL])
# If Port_Binding.up is cleared externally, ovn-northd resets it to 'false'
# and ovn-controller finally sets it to 'true' once the update is processed.
as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-sbctl clear Port_Binding lsp1 up
check ovn-nbctl --wait=sb sync
wait_column "false" nb:Logical_Switch_Port up name=lsp1
as hv1 ovn-appctl -t ovn-controller debug/resume
wait_column "true" Port_Binding up logical_port=lsp1
wait_column "true" nb:Logical_Switch_Port up name=lsp1

AS_BOX([ovn-controller should reset Port_Binding.up - from false])
# If Port_Binding.up is externally set to 'false', ovn-controller should sets
# it to 'true' once the update is processed.
as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-sbctl set Port_Binding lsp1 up=false
check ovn-nbctl --wait=sb sync
wait_column "false" nb:Logical_Switch_Port up name=lsp1
as hv1 ovn-appctl -t ovn-controller debug/resume
wait_column "true" Port_Binding up logical_port=lsp1
wait_column "true" nb:Logical_Switch_Port up name=lsp1

AS_BOX([ovn-controller should set Port_Binding.up - to false when OVS port is released])
check ovs-vsctl remove Interface lsp1 external_ids iface-id
check ovs-vsctl remove Interface lsp2 external_ids iface-id
wait_column "false" Port_Binding up logical_port=lsp1
wait_column "false" Port_Binding up logical_port=lsp2
wait_column "false" Port_Binding up logical_port=lsp1
wait_column "false" nb:Logical_Switch_Port up name=lsp1

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
# Test case to check that ovn-controller doesn't assert when
# handling port group updates.
AT_SETUP([No ovn-controller assert for port group updates])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

as hv1
ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=sw0-port1 \
    ofport-request=1

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "10:14:00:00:00:01 192.168.0.2"

check ovn-nbctl lsp-add sw0 sw0-port2
check ovn-nbctl lsp-add sw0 sw0-port3
check ovn-nbctl lsp-add sw0 sw0-port4
check ovn-nbctl lsp-add sw0 sw0-port5
check ovn-nbctl lsp-add sw0 sw0-port6
check ovn-nbctl lsp-add sw0 sw0-port7

ovn-nbctl create address_set name=as1
ovn-nbctl set address_set . addresses="10.0.0.10,10.0.0.11,10.0.0.12"

ovn-nbctl pg-add pg1 sw0-port1 sw0-port2 sw0-port3
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4.dst == \$as1 && icmp4" drop
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4.dst == \$as1 && tcp && tcp.dst >=10000 && tcp.dst <= 20000" drop
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4.dst == \$as1 && udp && udp.dst >=10000 && udp.dst <= 20000" drop

ovn-nbctl pg-add pg2 sw0-port2 sw0-port3 sw0-port4 sw0-port5
ovn-nbctl acl-add pg2 to-lport 1002 "outport == @pg2 && ip4.dst == \$as1 && icmp4" allow-related
ovn-nbctl acl-add pg2 to-lport 1002 "outport == @pg2 && ip4.dst == \$as1 && tcp && tcp.dst >=30000 && tcp.dst <= 40000" drop
ovn-nbctl acl-add pg2 to-lport 1002 "outport == @pg2 && ip4.dst == \$as1 && udp && udp.dst >=30000 && udp.dst <= 40000" drop

ovn-nbctl pg-add pg3 sw0-port1 sw0-port5
ovn-nbctl acl-add pg3 to-lport 1002 "outport == @pg3 && ip4.dst == \$as1 && icmp4" allow-related
ovn-nbctl acl-add pg3 to-lport 1002 "outport == @pg3 && ip4.dst == \$as1 && tcp && tcp.dst >=20000 && tcp.dst <= 30000" allow-related
ovn-nbctl acl-add pg3 to-lport 1002 "outport == @pg3 && ip4.dst == \$as1 && udp && udp.dst >=20000 && udp.dst <= 30000" allow-related

AS_BOX([Delete and add the port groups multiple times])

for i in $(seq 1 10)
do
    check ovn-nbctl --wait=hv clear port_Group pg1 ports
    check ovn-nbctl --wait=hv clear port_Group pg2 ports
    check ovn-nbctl --wait=hv clear port_Group pg3 ports
    check ovn-nbctl --wait=hv pg-set-ports pg1 sw0-port1
    check ovn-nbctl --wait=hv pg-set-ports pg1 sw0-port1 sw0-port4
    check ovn-nbctl --wait=hv pg-set-ports pg1 sw0-port1 sw0-port4 sw0-port5

    check ovn-nbctl --wait=hv pg-set-ports pg2 sw0-port2
    check ovn-nbctl --wait=hv pg-set-ports pg2 sw0-port2 sw0-port6
    check ovn-nbctl --wait=hv pg-set-ports pg2 sw0-port2 sw0-port6 sw0-port7

    check ovn-nbctl --wait=hv pg-set-ports pg3 sw0-port1
    check ovn-nbctl --wait=hv pg-set-ports pg3 sw0-port1 sw0-port3
    check ovn-nbctl --wait=hv pg-set-ports pg3 sw0-port1 sw0-port3 sw0-port6

    # Make sure that ovn-controller has not asserted.
    AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])
done

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# Test case to check that ovn-controller doesn't assert when
# handling conjunction flows.  When ovn-controller claims
# the first port of a logical switch datapath, it programs the flows
# for this datapath incrementally (without full recompute).  If
# suppose, in the same SB update from ovsdb-server, a logical flow is added
# which results in conjunction action, then this logical flow is also
# handled incrementally.  The newly added logical flow is processed
# twice which results in wrong oflows and it results in an assertion
# in ovn-controller.  Test this ovn-controller handles this scenario
# properly and doesn't assert.
OVN_FOR_EACH_NORTHD([
AT_SETUP([No ovn-controller assert when generating conjunction flows])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

as hv1
for i in 1 2; do
    ovs-vsctl \
        -- add-port br-int vif$i \
        -- set Interface vif$i external_ids:iface-id=sw0-p$i \
        ofport-request=$i
done

check as hv1
ovs-vsctl set open . external_ids:ovn-monitor-all=true

check ovn-nbctl ls-add sw0
check ovn-nbctl pg-add pg1
check ovn-nbctl pg-add pg2
check ovn-nbctl lsp-add sw0 sw0-p3
check ovn-nbctl lsp-set-addresses sw0-p3 "00:00:00:00:00:03 192.168.47.3"
check ovn-nbctl lsp-add sw0 sw0-p4
check ovn-nbctl lsp-set-addresses sw0-p4 "00:00:00:00:00:04 192.168.47.4"

# Pause ovn-northd. When it is resumed, all the below NB updates
# will be sent in one transaction.

check as northd ovn-appctl -t NORTHD_TYPE pause

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "00:00:00:00:00:01 192.168.47.1"
check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "00:00:00:00:00:02 192.168.47.2"
check ovn-nbctl pg-set-ports pg1 sw0-p1 sw0-p2 sw0-p3
check ovn-nbctl pg-set-ports pg2 sw0-p4
check ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == \$pg2_ip4 && udp && udp.dst >= 1 && udp.dst <= 65535" allow-related

# resume ovn-northd now. This should result in a single update message
# from SB ovsdb-server to ovn-controller for all the above NB updates.
check as northd ovn-appctl -t NORTHD_TYPE resume

AS_BOX([Wait for sw0-p1 and sw0-p2 to be up])
wait_for_ports_up sw0-p1 sw0-p2

# When the port group pg1 is updated, it should not result in
# any assert in ovn-controller.
ovn-nbctl --wait=hv pg-set-ports pg1 sw0-p1 sw0-p2 sw0-p3 sw0-p4
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])
check ovn-nbctl --wait=hv sync

# Check OVS flows are installed properly.
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=46 | ofctl_strip_all | \
    grep "priority=2002" | grep conjunction | \
    sed 's/conjunction([[^)]]*)/conjunction()/g' | \
    sed 's/reg15=0x[[1-9]]/reg15=0xN/g' | sort], [0], [dnl
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x10/0xfff0 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x100/0xff00 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x1000/0xf000 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x2/0xfffe actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x20/0xffe0 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x200/0xfe00 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x2000/0xe000 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x4/0xfffc actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x40/0xffc0 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x400/0xfc00 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x4000/0xc000 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x8/0xfff8 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x80/0xff80 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x800/0xf800 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x8000/0x8000 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,metadata=0x1,nw_src=192.168.47.4,tp_dst=1 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,reg15=0xN,metadata=0x1,nw_src=192.168.47.4 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x100/0x100,reg15=0xN,metadata=0x1,nw_src=192.168.47.4 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x10/0xfff0 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x100/0xff00 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x1000/0xf000 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x2/0xfffe actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x20/0xffe0 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x200/0xfe00 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x2000/0xe000 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x4/0xfffc actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x40/0xffc0 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x400/0xfc00 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x4000/0xc000 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x8/0xfff8 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x80/0xff80 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x800/0xf800 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=0x8000/0x8000 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,metadata=0x1,nw_src=192.168.47.4,tp_dst=1 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,reg15=0xN,metadata=0x1,nw_src=192.168.47.4 actions=conjunction()
 table=46, priority=2002,udp,reg0=0x80/0x80,reg15=0xN,metadata=0x1,nw_src=192.168.47.4 actions=conjunction()
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

AT_SETUP([OVN FDB (MAC learning) - 3 HVs, 2 LS, 1 LR ])
ovn_start

# Create the first logical switch with one port
check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3" unknown

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
# Port security is set for sw0-p2
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

# sw0-p1 and sw0-p3 have unknown address and no port security.
# FDB should be enabled for these lports.
check ovn-nbctl lsp-add sw0 sw0-p3
check ovn-nbctl lsp-set-addresses sw0-p3 unknown

# Create the second logical switch with one port
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1
check ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 11.0.0.3" unknown

check ovn-nbctl lsp-add sw1 sw1-p2
check ovn-nbctl lsp-set-addresses sw1-p2 "40:54:00:00:00:04 11.0.0.4"
check ovn-nbctl lsp-set-port-security sw1-p2 "40:54:00:00:00:04 11.0.0.4"

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 11.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 router
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1
ovn-nbctl --wait=hv sync

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif2 -- \
    set interface hv1-vif2 external-ids:iface-id=sw1-p2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=2
ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 external-ids:iface-id=sw0-p3 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw0-p2 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw1-p1 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=2

sim_add hv3
as hv3
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.3
ovs-vsctl -- add-port br-int hv3-vif1 -- \
    set interface hv3-vif1 external-ids:iface-id=sw0-p4 \
    options:tx_pcap=hv3/vif1-tx.pcap \
    options:rxq_pcap=hv3/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv3-vif2 -- \
    set interface hv3-vif2 external-ids:iface-id=sw1-p3 \
    options:tx_pcap=hv3/vif2-tx.pcap \
    options:rxq_pcap=hv3/vif2-rx.pcap \
    ofport-request=2

OVN_POPULATE_ARP

ip_to_hex() {
    printf "%02x%02x%02x%02x" "$@"
}

send_icmp_packet() {
    local inport=$1 hv=$2 eth_src=$3 eth_dst=$4 ipv4_src=$5 ipv4_dst=$6 ip_chksum=$7 data=$8
    shift 8

    local ip_ttl=ff
    local ip_len=001c
    local packet=${eth_dst}${eth_src}08004500${ip_len}00004000${ip_ttl}01${ip_chksum}${ipv4_src}${ipv4_dst}${data}
    echo $packet > expected
    as hv$hv ovs-appctl netdev-dummy/receive hv$hv-vif$inport $packet
}

AS_BOX([Wait for all ports to be up])
wait_for_ports_up

# Check that there is put_fdb() flow added by ovn-northd for sw0-p1
ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep "ls_in_lookup_fdb" sw0flows | sort], [0], [dnl
  table=2 (ls_in_lookup_fdb   ), priority=0    , dnl
match=(1), action=(next;)
  table=2 (ls_in_lookup_fdb   ), priority=100  , dnl
match=(inport == "sw0-p1"), action=(reg0[[11]] = lookup_fdb(inport, eth.src); next;)
  table=2 (ls_in_lookup_fdb   ), priority=100  , dnl
match=(inport == "sw0-p3"), action=(reg0[[11]] = lookup_fdb(inport, eth.src); next;)
])

AT_CHECK([grep "ls_in_put_fdb" sw0flows | sort], [0], [dnl
  table=3 (ls_in_put_fdb      ), priority=0    , dnl
match=(1), action=(next;)
  table=3 (ls_in_put_fdb      ), priority=100  , dnl
match=(inport == "sw0-p1" && reg0[[11]] == 0), action=(put_fdb(inport, eth.src); next;)
  table=3 (ls_in_put_fdb      ), priority=100  , dnl
match=(inport == "sw0-p3" && reg0[[11]] == 0), action=(put_fdb(inport, eth.src); next;)
])

# Send a packet from sw0-p1 with a different mac not present
# in it's addresses.
AS_BOX([Send a pkt from sw0-p1 with a different mac address])

# Use the src mac 50:54:00:00:00:13 instead of 50:54:00:00:00:03
src_mac=505400000013
src_ip=$(ip_to_hex 10 0 0 13)

# send the packet to sw0-p2
dst_mac=505400000004
dst_ip=$(ip_to_hex 10 0 0 4)

data=0800bee4391a0001
send_icmp_packet 1 1 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# There should be one row in fdb
AS_BOX([Check that the FDB entry is created])
wait_row_count FDB 1

sw0_dpkey=$(fetch_column datapath_binding tunnel_key external_ids:name=sw0)
sw0p1_dpkey=$(fetch_column port_binding tunnel_key logical_port=sw0-p1)
sw0p3_dpkey=$(fetch_column port_binding tunnel_key logical_port=sw0-p3)

dp_key=$(printf "%x" $sw0_dpkey)
port_key=$(printf "%x" $sw0p1_dpkey)

check_column '50:54:00:00:00:13' fdb mac
check_column $sw0_dpkey fdb dp_key
check_column $sw0p1_dpkey fdb port_key

# Make sure that OVS tables 71 and 72 are populated on both hv1 and hv2.
AS_BOX([Check that ovn-controller programs the flows for FDB])
as hv1 ovs-ofctl dump-flows br-int table=71 > hv1_offlows_table71.txt
as hv2 ovs-ofctl dump-flows br-int table=71 > hv2_offlows_table71.txt

AT_CAPTURE_FILE([hv1_offlows_table71.txt])
AT_CAPTURE_FILE([hv2_offlows_table71.txt])
AT_CHECK_UNQUOTED([cat hv1_offlows_table71.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,metadata=0x$dp_key,dl_dst=50:54:00:00:00:13 actions=load:0x$port_key->NXM_NX_REG15[[]]
])

AT_CHECK_UNQUOTED([cat hv2_offlows_table71.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,metadata=0x$dp_key,dl_dst=50:54:00:00:00:13 actions=load:0x$port_key->NXM_NX_REG15[[]]
])

as hv1 ovs-ofctl dump-flows br-int table=72 > hv1_offlows_table72.txt
as hv2 ovs-ofctl dump-flows br-int table=72 > hv2_offlows_table72.txt

AT_CAPTURE_FILE([hv1_offlows_table72.txt])
AT_CAPTURE_FILE([hv2_offlows_table72.txt])
AT_CHECK_UNQUOTED([cat hv1_offlows_table72.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,reg14=0x$port_key,metadata=0x$dp_key,dl_src=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[8]]
])

AT_CHECK_UNQUOTED([cat hv2_offlows_table72.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,reg14=0x$port_key,metadata=0x$dp_key,dl_src=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[8]]
])

# Create the logical port sw0-p4 and this should be claimed by
# hv3 and it should install the fdb flows in table 71 and 72.

check ovn-nbctl lsp-add sw0 sw0-p4
wait_for_ports_up sw0-p4

#as hv3 ovn-appctl -t ovn-controller recompute
check ovn-nbctl --wait=hv sync

as hv3 ovs-ofctl dump-flows br-int table=71 > hv3_offlows_table71.txt
as hv3 ovs-ofctl dump-flows br-int table=72 > hv3_offlows_table72.txt


AT_CAPTURE_FILE([hv3_offlows_table71.txt])
AT_CAPTURE_FILE([hv3_offlows_table72.txt])

AT_CHECK_UNQUOTED([cat hv3_offlows_table71.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,metadata=0x$dp_key,dl_dst=50:54:00:00:00:13 actions=load:0x$port_key->NXM_NX_REG15[[]]
])

AT_CHECK_UNQUOTED([cat hv3_offlows_table72.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,reg14=0x$port_key,metadata=0x$dp_key,dl_src=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[8]]
])

# Use the src mac 50:54:00:00:00:14 instead of 50:54:00:00:00:03
src_mac=505400000014
src_ip=$(ip_to_hex 10 0 0 14)

as hv2 reset_pcap_file hv2-vif1 hv2/vif1

send_icmp_packet 1 1 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# There should be two rows in fdb
wait_row_count FDB 2

check_column "50:54:00:00:00:13 50:54:00:00:00:14" fdb mac
check_column "$sw0_dpkey $sw0_dpkey" fdb dp_key
check_column "$sw0p1_dpkey $sw0p1_dpkey" fdb port_key

# Make sure that OVS tables 71 and 72 are populated on hv1, hv2 and hv3.
as hv1 ovs-ofctl dump-flows br-int table=71 > hv1_offlows_table71.txt
as hv2 ovs-ofctl dump-flows br-int table=71 > hv2_offlows_table71.txt
as hv3 ovs-ofctl dump-flows br-int table=71 > hv3_offlows_table71.txt

AT_CAPTURE_FILE([hv1_offlows_table71.txt])
AT_CAPTURE_FILE([hv2_offlows_table71.txt])
AT_CAPTURE_FILE([hv3_offlows_table71.txt])
AT_CHECK_UNQUOTED([cat hv1_offlows_table71.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,metadata=0x$dp_key,dl_dst=50:54:00:00:00:13 actions=load:0x$port_key->NXM_NX_REG15[[]]
priority=100,metadata=0x$dp_key,dl_dst=50:54:00:00:00:14 actions=load:0x$port_key->NXM_NX_REG15[[]]
])

AT_CHECK_UNQUOTED([cat hv2_offlows_table71.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,metadata=0x$dp_key,dl_dst=50:54:00:00:00:13 actions=load:0x$port_key->NXM_NX_REG15[[]]
priority=100,metadata=0x$dp_key,dl_dst=50:54:00:00:00:14 actions=load:0x$port_key->NXM_NX_REG15[[]]
])

AT_CHECK_UNQUOTED([cat hv3_offlows_table71.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,metadata=0x$dp_key,dl_dst=50:54:00:00:00:13 actions=load:0x$port_key->NXM_NX_REG15[[]]
priority=100,metadata=0x$dp_key,dl_dst=50:54:00:00:00:14 actions=load:0x$port_key->NXM_NX_REG15[[]]
])

as hv1 ovs-ofctl dump-flows br-int table=72 > hv1_offlows_table72.txt
as hv2 ovs-ofctl dump-flows br-int table=72 > hv2_offlows_table72.txt
as hv3 ovs-ofctl dump-flows br-int table=72 > hv3_offlows_table72.txt

AT_CAPTURE_FILE([hv1_offlows_table72.txt])
AT_CAPTURE_FILE([hv2_offlows_table72.txt])
AT_CAPTURE_FILE([hv3_offlows_table72.txt])
AT_CHECK_UNQUOTED([cat hv1_offlows_table72.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,reg14=0x$port_key,metadata=0x$dp_key,dl_src=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[8]]
priority=100,reg14=0x$port_key,metadata=0x$dp_key,dl_src=50:54:00:00:00:14 actions=load:0x1->NXM_NX_REG10[[8]]
])

AT_CHECK_UNQUOTED([cat hv2_offlows_table72.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,reg14=0x$port_key,metadata=0x$dp_key,dl_src=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[8]]
priority=100,reg14=0x$port_key,metadata=0x$dp_key,dl_src=50:54:00:00:00:14 actions=load:0x1->NXM_NX_REG10[[8]]
])

AT_CHECK_UNQUOTED([cat hv3_offlows_table72.txt | grep -v NXST | cut -d ' ' -f8- | sort], [0], [dnl
priority=100,reg14=0x$port_key,metadata=0x$dp_key,dl_src=50:54:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[8]]
priority=100,reg14=0x$port_key,metadata=0x$dp_key,dl_src=50:54:00:00:00:14 actions=load:0x1->NXM_NX_REG10[[8]]
])

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv2 reset_pcap_file hv2-vif1 hv2/vif1

# Send the packet from sw0-p2 to sw0-p1 with the dst mac 50:54:00:00:00:13
src_mac=505400000004
src_ip=$(ip_to_hex 10 0 0 4)

dst_mac=505400000013
dst_ip=$(ip_to_hex 10 0 0 13)

send_icmp_packet 1 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
dst_mac=505400000014
dst_ip=$(ip_to_hex 10 0 0 14)

send_icmp_packet 1 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif3 hv1/vif3

# Send a packet from sw0-p2 to an unknown mac. Should be received
# by both sw0-p1 and sw0-p3 (as unknown is set).
AS_BOX([Send pkt from sw0-p2 to an unknown mac])

src_mac=505400000004
src_ip=$(ip_to_hex 10 0 0 4)

dst_mac=505400000023
dst_ip=$(ip_to_hex 10 0 0 23)

send_icmp_packet 1 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])
OVN_CHECK_PACKETS([hv1/vif3-tx.pcap], [expected])

AS_BOX([Flip the mac - 50:54:00:00:00:13 from sw0-p1 to sw0-p3])

# Use the src mac 50:54:00:00:00:13
src_mac=505400000013
src_ip=$(ip_to_hex 10 0 0 23)

# send the packet to sw0-p2
dst_mac=505400000004
dst_ip=$(ip_to_hex 10 0 0 4)

data=0800bee4391a0001

as hv2 reset_pcap_file hv2-vif1 hv2/vif1
as hv1 reset_pcap_file hv1-vif3 hv1/vif3

# Send the pkt from sw0-p3 to sw0-p2.
send_icmp_packet 3 1 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv2/vif1-tx.pcap], [expected])

# fdb row count should be still 2. But the mac 50:54:00:00:00:13
# should be learnt on sw0-p3.

wait_row_count FDB 2

check_column "50:54:00:00:00:13 50:54:00:00:00:14" fdb mac
check_column "$sw0_dpkey $sw0_dpkey" fdb dp_key
check_column "$sw0p1_dpkey $sw0p3_dpkey" fdb port_key

check_column "$sw0p3_dpkey" fdb port_key mac="50\:54\:00\:00\:00\:13"

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif3 hv1/vif3

# Send the packet from sw0-p2 to sw0-p3 with the dst mac 50:54:00:00:00:13
src_mac=505400000004
src_ip=$(ip_to_hex 10 0 0 4)

dst_mac=505400000013
dst_ip=$(ip_to_hex 10 0 0 13)

send_icmp_packet 1 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data
OVN_CHECK_PACKETS([hv1/vif3-tx.pcap], [expected])

# sw0-p1 should not receive the packet.
: > expected
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

AS_BOX([Test routing])

# Test the routing.
# Send the packet from sw1-p2 (hv1) to sw0-p1 (hv1) with dst ip 10.0.0.14
# The packet should be delivered to sw0-p1 with dst mac 50:54:00:00:00:14
# Before sending add mac_binding entry for 10.0.0.14

lr0_dp_uuid=$(fetch_column datapath_binding _uuid external_ids:name=lr0)

ovn-sbctl create mac_binding ip=10.0.0.14 logical_port=lr0-sw0 \
mac="50\:54\:00\:00\:00\:14" datapath=$lr0_dp_uuid

# Wait till the mac_binding flows appear in hv1
OVS_WAIT_UNTIL([test 1 = $(as hv1 ovs-ofctl dump-flows br-int table=66 \
| grep -c  reg0=0xa00000e)])

src_mac=405400000004
src_ip=$(ip_to_hex 11 0 0 4)

dst_mac=00000000ff02 # lr0-sw1 mac
dst_ip=$(ip_to_hex 10 0 0 14)

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif3 hv1/vif3

send_icmp_packet 2 1 $src_mac $dst_mac $src_ip $dst_ip 0000 $data

exp_packet=50540000001400000000ff0108004500001c00004000fe010100${src_ip}${dst_ip}${data}
echo $exp_packet > expected
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

# sw0-p3 should not receive the packet.
: > expected
OVN_CHECK_PACKETS([hv1/vif3-tx.pcap], [expected])

# Now the send the packet from sw1-p1 (hv2) to sw0-p1 (hv1) with dst ip 10.0.0.14
# The acket should be delivered to sw0-p1 with dst mac 50:54:00:00:00:14

src_mac=405400000003
src_ip=$(ip_to_hex 11 0 0 3)

dst_mac=00000000ff02 # lr0-sw1 mac
dst_ip=$(ip_to_hex 10 0 0 14)

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
send_icmp_packet 2 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data

exp_packet=50540000001400000000ff0108004500001c00004000fe010100${src_ip}${dst_ip}${data}
echo $exp_packet > expected
OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

AS_BOX([Clear the FDB rows])

# Clear the fdb rows.
check ovn-sbctl --all destroy fdb
ovn-sbctl list fdb

as hv1 reset_pcap_file hv1-vif1 hv1/vif1
as hv1 reset_pcap_file hv1-vif3 hv1/vif3

# Send the packet from sw0-p2 to sw0-p1 with the dst mac 50:54:00:00:00:14
# It should be delivered to both sw0-p1 and sw0-p3 since we have cleared the
# FDB table.
src_mac=505400000004
src_ip=$(ip_to_hex 10 0 0 4)

dst_mac=505400000014
dst_ip=$(ip_to_hex 10 0 0 13)

send_icmp_packet 1 2 $src_mac $dst_mac $src_ip $dst_ip 0000 $data

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])
OVN_CHECK_PACKETS([hv1/vif3-tx.pcap], [expected])

# Make sure that OVS tables 71 and 72 are empty.
as hv1 ovs-ofctl dump-flows br-int table=71 > hv1_offlows_table71.txt
as hv2 ovs-ofctl dump-flows br-int table=71 > hv2_offlows_table71.txt

AT_CAPTURE_FILE([hv1_offlows_table71.txt])
AT_CAPTURE_FILE([hv2_offlows_table71.txt])
AT_CHECK([cat hv1_offlows_table71.txt | grep -v NXST], [1], [dnl
])

AT_CHECK([cat hv2_offlows_table71.txt | grep -v NXST], [1], [dnl
])

as hv1 ovs-ofctl dump-flows br-int table=72 > hv1_offlows_table72.txt
as hv2 ovs-ofctl dump-flows br-int table=72 > hv2_offlows_table72.txt

AT_CAPTURE_FILE([hv1_offlows_table72.txt])
AT_CAPTURE_FILE([hv2_offlows_table72.txt])
AT_CHECK([cat hv1_offlows_table72.txt | grep -v NXST], [1], [dnl
])

AT_CHECK([cat hv2_offlows_table72.txt | grep -v NXST], [1], [dnl
])

OVN_CLEANUP([hv1], [hv2], [hv3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([container port changed to normal port and then deleted])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vm1

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls vm1
check ovn-nbctl lsp-add ls vm-cont vm1 1
check as hv1 ovs-vsctl set Interface vm1 external_ids:iface-id=vm1

wait_for_ports_up

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl clear logical_switch_port vm-cont parent_name
check as hv1 ovs-vsctl set Interface vm1 external_ids:iface-id=foo
check ovn-nbctl lsp-del vm-cont
check as hv1 ovn-appctl -t ovn-controller debug/resume

ovn-nbctl --wait=hv sync

# Make sure that ovn-controller has not asserted.
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])

wait_column "false" nb:Logical_Switch_Port up name=vm1

check ovn-nbctl lsp-add ls vm-cont1 vm1 1
check ovn-nbctl lsp-add ls vm-cont2 vm1 2

check ovn-nbctl --wait=sb lsp-del vm1

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl clear logical_switch_port vm-cont1 parent_name
check ovn-nbctl clear logical_switch_port vm-cont2 parent_name

check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync

# Make sure that ovn-controller has not crashed.
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])

check ovn-nbctl lsp-add ls vm1
check ovn-nbctl set logical_switch_port vm-cont1 parent_name=vm1
check ovn-nbctl --wait=sb set logical_switch_port vm-cont2 parent_name=vm1
check as hv1 ovs-vsctl set Interface vm1 external_ids:iface-id=vm1

wait_for_ports_up

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl --wait=sb lsp-del vm1
check ovn-nbctl clear logical_switch_port vm-cont1 parent_name
check ovn-nbctl --wait=sb clear logical_switch_port vm-cont2 parent_name
check ovn-nbctl lsp-del vm-cont1
check ovn-nbctl --wait=sb lsp-del vm-cont2
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync

# Make sure that ovn-controller has not crashed.
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])

check ovn-nbctl lsp-add ls vm1
check ovn-nbctl lsp-add ls vm-cont1 vm1 1
check ovn-nbctl lsp-add ls vm-cont2 vm1 2

wait_for_ports_up

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl clear logical_switch_port vm-cont1 parent_name
check ovn-nbctl --wait=sb clear logical_switch_port vm-cont2 parent_name
check ovn-nbctl lsp-del vm-cont1
check ovn-nbctl lsp-del vm-cont2
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync

# Make sure that ovn-controller has not crashed.
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])

check ovn-nbctl lsp-add ls vm-cont1 vm1 1
check ovn-nbctl lsp-add ls vm-cont2 vm1 2

wait_for_ports_up

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl clear logical_switch_port vm-cont1 parent_name
check ovn-nbctl --wait=sb clear logical_switch_port vm-cont2 parent_name

check as hv1 ovs-vsctl set Interface vm1 external_ids:iface-id=foo

check as hv1 ovn-appctl -t ovn-controller debug/resume

wait_column "false" nb:Logical_Switch_Port up name=vm1
wait_column "false" nb:Logical_Switch_Port up name=vm-cont1
wait_column "false" nb:Logical_Switch_Port up name=vm-cont2

check ovn-nbctl set logical_switch_port vm-cont1 parent_name=vm1
check as hv1 ovs-vsctl set Interface vm1 external_ids:iface-id=vm1
check ovn-nbctl --wait=sb set logical_switch_port vm-cont2 parent_name=vm1

wait_for_ports_up

check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl clear logical_switch_port vm-cont1 parent_name
check as hv1 ovs-vsctl set Interface vm1 external_ids:iface-id=vm-cont1
check as hv1 ovn-appctl -t ovn-controller debug/resume

wait_column "false" nb:Logical_Switch_Port up name=vm1
wait_column "true" nb:Logical_Switch_Port up name=vm-cont1
wait_column "false" nb:Logical_Switch_Port up name=vm-cont2

check ovn-nbctl --wait=sb set logical_switch_port vm-cont2 parent_name=vm-cont1
check ovn-nbctl --wait=sb set logical_switch_port vm1 parent_name=vm-cont1

wait_for_ports_up

# Delete vm1, vm-cont1 and vm-cont2 and recreate again.
check ovn-nbctl lsp-del vm1
check ovn-nbctl lsp-del vm-cont1
check ovn-nbctl --wait=hv lsp-del vm-cont2

check as hv1 ovs-vsctl set Interface vm1 external_ids:iface-id=vm1
check ovn-nbctl lsp-add ls vm1
check ovn-nbctl lsp-add ls vm-cont1 vm1 1
check ovn-nbctl lsp-add ls vm-cont2 vm1 2

wait_for_ports_up

check ovn-nbctl clear logical_switch_port vm-cont1 parent_name
check ovn-nbctl clear logical_switch_port vm-cont2 parent_name

wait_column "true"  sb:Port_Binding up logical_port=vm1
wait_column "false" sb:Port_Binding up logical_port=vm-cont1
wait_column "false" sb:Port_Binding up logical_port=vm-cont2

check ovn-nbctl set logical_switch_port vm-cont1 parent_name=vm1
check ovn-nbctl set logical_switch_port vm-cont2 parent_name=vm1

wait_for_ports_up

# Make vm1 as a child port of some non existent lport - foo. vm1, vm1-cont1 and
# vm1-cont2 should be released.
check ovn-nbctl --wait=sb set logical_switch_port vm1 parent_name=bar
wait_column "false" nb:Logical_Switch_Port up name=vm1
wait_column "false" nb:Logical_Switch_Port up name=vm-cont1
wait_column "false" nb:Logical_Switch_Port up name=vm-cont2

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([container port changed from one parent to another])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vm1 -- set interface vm1 ofport-request=1
ovs-vsctl -- add-port br-int vm2 -- set interface vm1 ofport-request=2

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls vm1
check ovn-nbctl lsp-add ls vm1-cont vm1 1
check ovn-nbctl lsp-add ls vm2
check ovn-nbctl lsp-add ls vm2-cont vm2 2

check as hv1 ovs-vsctl set Interface vm1 external_ids:iface-id=vm1
check as hv1 ovs-vsctl set Interface vm2 external_ids:iface-id=vm2

wait_for_ports_up

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep -c dl_vlan=1], [0], [dnl
1
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep -c dl_vlan=2], [0], [dnl
1
])

# change the parent of vm1-cont to vm2.
as hv1 ovn-appctl -t ovn-controller vlog/set dbg
check ovn-nbctl --wait=sb set logical_switch_port vm1-cont parent_name=vm2 \
-- set logical_switch_port vm1-cont tag_request=3

wait_for_ports_up

check ovn-nbctl --wait=hv sync

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep -c dl_vlan=1], [1], [dnl
0
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep -c dl_vlan=2], [0], [dnl
1
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=0 | grep -c dl_vlan=3], [0], [dnl
1
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([container port use-after-free test])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vm1

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls vm1
check ovn-nbctl lsp-add ls vm-cont vm1 1
check ovs-vsctl set Interface vm1 external_ids:iface-id=vm1
check ovn-nbctl clear logical_switch_port vm-cont parent_name
check ovs-vsctl set Interface vm1 external_ids:iface-id=foo
check ovn-nbctl lsp-del vm-cont
check ovn-nbctl ls-del ls
check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls vm1
check ovn-nbctl lsp-add ls vm-cont vm1 1
check ovs-vsctl set Interface vm1 external_ids:iface-id=vm1
check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl clear logical_switch_port vm-cont parent_name
check ovn-nbctl lsp-del vm-cont
check as hv1 ovn-appctl -t ovn-controller debug/resume
check as hv1 ovs-vsctl set Interface vm1 external_ids:iface-id=foo

ovn-nbctl --wait=hv sync

# Make sure that ovn-controller has not asserted.
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])

wait_column "false" nb:Logical_Switch_Port up name=vm1

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# Test that OVS.external_ids:iface-id doesn't affect non-VIF port bindings.
OVN_FOR_EACH_NORTHD([
AT_SETUP([Non-VIF ports incremental processing])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

check ovn-nbctl ls-add ls1 -- lsp-add ls1 lsp1

as hv1
check ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1

# ovn-controller should bind the interface.
wait_for_ports_up
hv_uuid=$(fetch_column Chassis _uuid name=hv1)
check_column "$hv_uuid" Port_Binding chassis logical_port=lsp1

# Change the port type to router, ovn-controller should release it.
check ovn-nbctl --wait=hv lsp-set-type lsp1 router
check_column "" Port_Binding chassis logical_port=lsp1

# Clear port type, ovn-controller should rebind it.
check ovn-nbctl --wait=hv lsp-set-type lsp1 ''
check_column "$hv_uuid" Port_Binding chassis logical_port=lsp1

# Change the port type to localnet, ovn-controller should release it.
check ovn-nbctl --wait=hv lsp-set-type lsp1 localnet
check_column "" Port_Binding chassis logical_port=lsp1

# Clear port type, ovn-controller should rebind it.
check ovn-nbctl --wait=hv lsp-set-type lsp1 ''
check_column "$hv_uuid" Port_Binding chassis logical_port=lsp1

# Change the port type to localport, ovn-controller should release it.
check ovn-nbctl --wait=hv lsp-set-type lsp1 localport
check_column "" Port_Binding chassis logical_port=lsp1

# Clear port type, ovn-controller should rebind it.
check ovn-nbctl --wait=hv lsp-set-type lsp1 ''
check_column "$hv_uuid" Port_Binding chassis logical_port=lsp1

# Change the port type to localnet and then delete it.
# ovn-controller should handle this properly.
check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl --wait=sb lsp-set-type lsp1 localport
check ovn-nbctl --wait=sb lsp-del lsp1
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync

# Make sure that ovn-controller has not asserted.
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])

check ovn-nbctl lsp-add ls1 lsp1
wait_for_ports_up

# Change the port type to virtual and then delete it.
# ovn-controller should handle this properly.
check as hv1 ovn-appctl -t ovn-controller debug/pause
check ovn-nbctl --wait=sb lsp-set-type lsp1 virtual
check ovn-nbctl --wait=sb lsp-del lsp1
check as hv1 ovn-appctl -t ovn-controller debug/resume

check ovn-nbctl --wait=hv sync

# Make sure that ovn-controller has not asserted.
AT_CHECK([kill -0 $(cat hv1/ovn-controller.pid)])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# Tests that ovn-controller creates local bindings correctly by running
# ovn-appctl -t ovn-controller debug/dump-local-bindings.
# Ideally this test case should have been a unit test case.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller local bindings])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vm1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vm1

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0p1
check ovn-nbctl lsp-add sw0 sw0p2

check as hv1 ovs-vsctl set interface hv1-vm1 external_ids:iface-id=sw0p1
check as hv2 ovs-vsctl set interface hv2-vm1 external_ids:iface-id=sw0p2

wait_for_ports_up

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p1]], OVS interface name : [[hv1-vm1]], num binding lports : [[1]]
primary lport : [[sw0p1]]
----------------------------------------
])

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p2]], OVS interface name : [[hv2-vm1]], num binding lports : [[1]]
primary lport : [[sw0p2]]
----------------------------------------
])

# Create an ovs interface in hv1
check as hv1 ovs-vsctl add-port br-int hv1-vm2 -- set interface hv1-vm2 external_ids:iface-id=sw1p1
check ovn-nbctl --wait=hv sync
AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p1]], OVS interface name : [[hv1-vm1]], num binding lports : [[1]]
primary lport : [[sw0p1]]
----------------------------------------
name: [[sw1p1]], OVS interface name : [[hv1-vm2]], num binding lports : [[0]]
----------------------------------------
])

# Create lport sw1p1
check ovn-nbctl ls-add sw1 -- lsp-add sw1 sw1p1

wait_for_ports_up

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p1]], OVS interface name : [[hv1-vm1]], num binding lports : [[1]]
primary lport : [[sw0p1]]
----------------------------------------
name: [[sw1p1]], OVS interface name : [[hv1-vm2]], num binding lports : [[1]]
primary lport : [[sw1p1]]
----------------------------------------
])

# Swap sw0p1 and sw0p2.
check as hv1 ovs-vsctl set interface hv1-vm1 external_ids:iface-id=sw0p2
check as hv2 ovs-vsctl set interface hv2-vm1 external_ids:iface-id=sw0p1

check ovn-nbctl --wait=hv sync

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p2]], OVS interface name : [[hv1-vm1]], num binding lports : [[1]]
primary lport : [[sw0p2]]
----------------------------------------
name: [[sw1p1]], OVS interface name : [[hv1-vm2]], num binding lports : [[1]]
primary lport : [[sw1p1]]
----------------------------------------
])

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p1]], OVS interface name : [[hv2-vm1]], num binding lports : [[1]]
primary lport : [[sw0p1]]
----------------------------------------
])

# Create child port for sw0p1
check ovn-nbctl --wait=hv lsp-add sw0 sw0p1-c1 sw0p1 1
AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p1]], OVS interface name : [[NULL]], num binding lports : [[2]]
primary lport : [[sw0p1]]
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p2]], OVS interface name : [[hv1-vm1]], num binding lports : [[1]]
primary lport : [[sw0p2]]
----------------------------------------
name: [[sw1p1]], OVS interface name : [[hv1-vm2]], num binding lports : [[1]]
primary lport : [[sw1p1]]
----------------------------------------
])

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p1]], OVS interface name : [[hv2-vm1]], num binding lports : [[2]]
primary lport : [[sw0p1]]
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
----------------------------------------
])

# Create another child port for sw0p1
check ovn-nbctl --wait=hv lsp-add sw0 sw0p1-c2 sw0p1 2

wait_for_ports_up

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p1]], OVS interface name : [[NULL]], num binding lports : [[3]]
primary lport : [[sw0p1]]
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p2]], OVS interface name : [[hv1-vm1]], num binding lports : [[1]]
primary lport : [[sw0p2]]
----------------------------------------
name: [[sw1p1]], OVS interface name : [[hv1-vm2]], num binding lports : [[1]]
primary lport : [[sw1p1]]
----------------------------------------
])

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p1]], OVS interface name : [[hv2-vm1]], num binding lports : [[3]]
primary lport : [[sw0p1]]
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
])

# Swap sw0p1 and sw0p2 again.
check as hv1 ovs-vsctl set interface hv1-vm1 external_ids:iface-id=sw0p1
check as hv2 ovs-vsctl set interface hv2-vm1 external_ids:iface-id=sw0p2

check ovn-nbctl --wait=hv sync

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p1]], OVS interface name : [[hv1-vm1]], num binding lports : [[3]]
primary lport : [[sw0p1]]
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
name: [[sw1p1]], OVS interface name : [[hv1-vm2]], num binding lports : [[1]]
primary lport : [[sw1p1]]
----------------------------------------
])

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0p1]], OVS interface name : [[NULL]], num binding lports : [[3]]
primary lport : [[sw0p1]]
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p2]], OVS interface name : [[hv2-vm1]], num binding lports : [[1]]
primary lport : [[sw0p2]]
----------------------------------------
])

# Make sw0p1 as child port of non existent lport - foo
check ovn-nbctl --wait=hv set logical_switch_port sw0p1 parent_name=foo

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[foo]], OVS interface name : [[NULL]], num binding lports : [[1]]
no primary lport
child lport[[1]] : [[sw0p1]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p1]], OVS interface name : [[hv1-vm1]], num binding lports : [[2]]
no primary lport
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
name: [[sw1p1]], OVS interface name : [[hv1-vm2]], num binding lports : [[1]]
primary lport : [[sw1p1]]
----------------------------------------
])

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[foo]], OVS interface name : [[NULL]], num binding lports : [[1]]
no primary lport
child lport[[1]] : [[sw0p1]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p1]], OVS interface name : [[NULL]], num binding lports : [[2]]
no primary lport
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p2]], OVS interface name : [[hv2-vm1]], num binding lports : [[1]]
primary lport : [[sw0p2]]
----------------------------------------
])

# Change the lport type of sw0p2 to different types and make sure that
# local bindings are correct.

hv2_uuid=$(fetch_column Chassis _uuid name=hv2)
check_column "$hv2_uuid" Port_Binding chassis logical_port=sw0p2

# Change the port type to router, ovn-controller should release it.
check ovn-nbctl --wait=hv lsp-set-type sw0p2 router
check_column "" Port_Binding chassis logical_port=sw0p2

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[foo]], OVS interface name : [[NULL]], num binding lports : [[1]]
no primary lport
child lport[[1]] : [[sw0p1]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p1]], OVS interface name : [[NULL]], num binding lports : [[2]]
no primary lport
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p2]], OVS interface name : [[hv2-vm1]], num binding lports : [[0]]
----------------------------------------
])

# change the port type to external from router.
check ovn-nbctl --wait=hv lsp-set-type sw0p2 external
check_column "" Port_Binding chassis logical_port=sw0p2

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[foo]], OVS interface name : [[NULL]], num binding lports : [[1]]
no primary lport
child lport[[1]] : [[sw0p1]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p1]], OVS interface name : [[NULL]], num binding lports : [[2]]
no primary lport
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p2]], OVS interface name : [[hv2-vm1]], num binding lports : [[0]]
----------------------------------------
])

# change the port type to localnet from external.
check ovn-nbctl --wait=hv lsp-set-type sw0p2 localnet
check_column "" Port_Binding chassis logical_port=sw0p2

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[foo]], OVS interface name : [[NULL]], num binding lports : [[1]]
no primary lport
child lport[[1]] : [[sw0p1]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p1]], OVS interface name : [[NULL]], num binding lports : [[2]]
no primary lport
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p2]], OVS interface name : [[hv2-vm1]], num binding lports : [[0]]
----------------------------------------
])

# change the port type to localport from localnet.
check ovn-nbctl --wait=hv lsp-set-type sw0p2 localnet
check_column "" Port_Binding chassis logical_port=sw0p2

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[foo]], OVS interface name : [[NULL]], num binding lports : [[1]]
no primary lport
child lport[[1]] : [[sw0p1]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p1]], OVS interface name : [[NULL]], num binding lports : [[2]]
no primary lport
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p2]], OVS interface name : [[hv2-vm1]], num binding lports : [[0]]
----------------------------------------
])

# change the port type back to vif.
check ovn-nbctl --wait=hv lsp-set-type sw0p2 ""
wait_column "$hv2_uuid" Port_Binding chassis logical_port=sw0p2

AT_CHECK([as hv2 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[foo]], OVS interface name : [[NULL]], num binding lports : [[1]]
no primary lport
child lport[[1]] : [[sw0p1]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p1]], OVS interface name : [[NULL]], num binding lports : [[2]]
no primary lport
child lport[[1]] : [[sw0p1-c1]], type : [[CONTAINER]]
child lport[[2]] : [[sw0p1-c2]], type : [[CONTAINER]]
----------------------------------------
name: [[sw0p2]], OVS interface name : [[hv2-vm1]], num binding lports : [[1]]
primary lport : [[sw0p2]]
----------------------------------------
])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

# Tests the efficiency of conjunction flow generation when port groups are used
# by ACLs. Make sure there is no open flow explosion in table 44 for an ACL
# with self-referencing match condition of a port group:
#
# "outport == @pg1 && ip4.src == $pg1_ip4"
#
# 10 LSes (ls[0-9]), each has 2 LSPs (lsp[0-9][01]). All LSPs belong to port
# group pg1, but only LSPs of LS0 are bound on HV1.
#
# The expected number of conjunction flows is 2 + 20 = 22.
# - 20 for expanding the address set $pg1_ip4 to 20 ip addresses.
# - 2 for expanding the port group @pg1 to the 2 locally bound lports.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL with Port Group conjunction flow efficiency])
TAG_UNSTABLE
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

ovn-nbctl lr-add lr0

for i in $(seq 0 9); do
    ovn-nbctl ls-add ls$i
    ovn-nbctl lrp-add lr0 lrp_lr0_ls$i aa:bb:bb:00:00:0$i 192.168.${i}.1/24

    ovn-nbctl lsp-add ls$i lsp_ls${i}_lr0 -- \
        lsp-set-addresses lsp_ls${i}_lr0 router -- \
        lsp-set-type lsp_ls${i}_lr0 router -- \
        lsp-set-options lsp_ls${i}_lr0 router-port=lrp_lr0_ls${i}

    for j in 0 1; do
        ovn-nbctl lsp-add ls$i lsp${i}-${j} -- \
            lsp-set-addresses lsp${i}-${j} "aa:aa:aa:00:0$i:0$j 192.168.$i.1$j"
    done
done

ovn-nbctl pg-add pg1
ovn-nbctl pg-set-ports pg1 $(for i in 0 1 2 3 4 5 6 7 8 9; do for j in 0 1; do echo lsp${i}-${j}; done; done)

ovn-nbctl --type=port-group acl-add pg1 to-lport 100 "outport == @pg1 && ip4.src == \$pg1_ip4" allow

ovs-vsctl add-port br-int lsp0-0 -- set interface lsp0-0 external_ids:iface-id=lsp0-0
ovs-vsctl add-port br-int lsp0-1 -- set interface lsp0-1 external_ids:iface-id=lsp0-1

check ovn-nbctl --wait=hv sync
AT_CHECK([test $(ovs-ofctl dump-flows br-int table=46 | grep conjunction | wc -l) == 22])

# Save the current lflow_run counter
lflow_run=$(ovn-appctl -t ovn-controller coverage/read-counter lflow_run)

# Make some changes and make sure the changes are handled properly.
#
# 1. Remove half of the ports from pg1. The excepted conjunction flows should be:
#    2 + 10 = 12
check ovn-nbctl --wait=hv pg-set-ports pg1 $(for i in 0 1 2 3 4; do for j in 0 1; do echo lsp${i}-${j}; done; done)
AT_CHECK([test $(ovs-ofctl dump-flows br-int table=46 | grep conjunction | wc -l) == 12])

# 2. Unbind lsp0-0. The there shouldn't be any conjunction flows because the
#    port group const set should have only one member (lsp0-1). And the total
#    number of flows that has the IP addresses from the address set should be
#    10.
ovs-vsctl del-port br-int lsp0-0
check ovn-nbctl --wait=hv sync
AT_CHECK([test $(ovs-ofctl dump-flows br-int table=46 | grep conjunction | wc -l) == 0])
AT_CHECK([test $(ovs-ofctl dump-flows br-int table=46 | grep 192.168 | wc -l) == 10])

# 3. Rebind lsp0-0. The expected conjunction flows are back to 12.
ovs-vsctl add-port br-int lsp0-0 -- set interface lsp0-0 external_ids:iface-id=lsp0-0
check ovn-nbctl --wait=hv sync
AT_CHECK([test $(ovs-ofctl dump-flows br-int table=46 | grep conjunction | wc -l) == 12])

# 4. Bind a lsp (lsp9-0) that doesn't belong to pg1, should not see any change.
ovs-vsctl add-port br-int lsp9-0 -- set interface lsp9-0 external_ids:iface-id=lsp9-0
check ovn-nbctl --wait=hv sync
AT_CHECK([test $(ovs-ofctl dump-flows br-int table=46 | grep conjunction | wc -l) == 12])

# 5. Bind another 2 lsps (lsp1-0 lsp1-1) that belong to pg1 and on a different
#    LS (ls1), should see conjunction flows doubled (12 x 2 = 24)
ovs-vsctl add-port br-int lsp1-0 -- set interface lsp1-0 external_ids:iface-id=lsp1-0
ovs-vsctl add-port br-int lsp1-1 -- set interface lsp1-1 external_ids:iface-id=lsp1-1
check ovn-nbctl --wait=hv sync
AT_CHECK([test $(ovs-ofctl dump-flows br-int table=46 | grep conjunction | wc -l) == 24])

# 6. Simulate a SB port-group "del and add" notification to ovn-controller in the
#    same IDL iteration. ovn-controller should still program the same flows. In
#    reality it can happen when PG memembership change triggers a SB port-group
#    deletion and creation with the same SB port-group name, while the
#    notification of the changes can come to ovn-controller in one shot and the
#    order of the "del" and "add" in the notification is undefined. This test
#    runs the scenario ten times to make sure the unpleasant order is tested.

for i in $(seq 1 10); do
    # Delete and recreate the SB PG with same name and content.
    sb_pg_name=$(fetch_column port_group name | cut -d ' ' -f1)
    sb_pg_uuid=$(fetch_column port_group _uuid name=$sb_pg_name)
    ports_=$(fetch_column port_group ports name=$sb_pg_name)
    ports=${ports_/ /,}
    AT_CHECK([ovn-sbctl destroy port_group $sb_pg_uuid -- create port_group name=$sb_pg_name ports=$ports], [0], [ignore])

    # Unbind and bind lsp0-0 to trigger runtime data change as well.
    ovs-vsctl del-port br-int lsp0-0
    check ovn-nbctl --wait=hv sync
    ovs-vsctl add-port br-int lsp0-0 -- set interface lsp0-0 external_ids:iface-id=lsp0-0
    check ovn-nbctl --wait=hv sync

    # Finally check flow count is the same as before.
    AT_CHECK([test $(ovs-ofctl dump-flows br-int table=46 | grep conjunction | wc -l) == 24])
done

# Make sure all the above was performed with I-P (no recompute)
AT_CHECK([test $(ovn-appctl -t ovn-controller coverage/read-counter lflow_run) == $lflow_run])

# Make sure there is no unexpected conjunction ID free and reallocation
AT_CHECK([ovn-appctl -t ovn-controller coverage/read-counter lflow_conj_free_unexpected], [0], [0
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# Tests that ACLs referencing port groups that include ports connected to
# logical routers are correctly applied.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL with Port Group including router ports])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl \
    -- lr-add lr \
    -- ls-add ls \
    -- lrp-add lr lrp_ls 00:00:00:00:00:01 42.42.42.1/24 \
    -- lsp-add ls ls_lr \
    -- lsp-set-addresses ls_lr router \
    -- lsp-set-type ls_lr router \
    -- lsp-set-options ls_lr router-port=lr_ls \
    -- lsp-add ls vm1

check ovn-nbctl pg-add pg ls_lr \
    -- acl-add pg from-lport 1 'inport == @pg && ip4.dst == 42.42.42.42' drop

check ovs-vsctl add-port br-int vm1 \
    -- set interface vm1 external_ids:iface-id=vm1

wait_for_ports_up
check ovn-nbctl --wait=hv sync

dp_key=$(fetch_column Datapath_Binding tunnel_key external_ids:name=ls)
rtr_port_key=$(fetch_column Port_Binding tunnel_key logical_port=ls_lr)

ovs-ofctl dump-flows br-int table=16 | grep "reg14=0x${rtr_port_key},metadata=0x${dp_key},nw_dst=42.42.42.42"
# Check that ovn-controller adds a flow to drop packets with dest IP
# 42.42.42.42 coming from the router port.
AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=16 | ofctl_strip_all | \
    grep "reg14=0x${rtr_port_key},metadata=0x${dp_key},nw_dst=42.42.42.42"], [0], [dnl
 table=16, priority=1001,ip,reg14=0x${rtr_port_key},metadata=0x${dp_key},nw_dst=42.42.42.42 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,17)
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Static route with discard nexthop])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Logical network:
# Logical Router lr1 has Logical Switch sw1 (10.0.0.0/24) connected to it. sw1 has one
# switch port sw1-ls1 (10.0.0.100)

ovn-nbctl lr-add lr1

ovn-nbctl ls-add sw1

# Connect sw1 to lr1
ovn-nbctl lrp-add lr1 lr1-sw1 00:00:01:01:02:03 10.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr1
ovn-nbctl lsp-set-type sw1-lr1 router
ovn-nbctl lsp-set-addresses sw1-lr1 router
ovn-nbctl lsp-set-options sw1-lr1 router-port=lr1-sw1

# Create logical port sw1-lp1 in sw1
ovn-nbctl lsp-add sw1 sw1-lp1 \
-- lsp-set-addresses sw1-lp1 "00:00:04:01:02:03 10.0.0.100"

# Create one hypervisor and create OVS ports corresponding to logical ports.

ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

# Install static routes to drop traffic
ovn-nbctl lr-route-add lr1 20.0.0.0/24 discard

# Allow some time for ovn-controller to catch up.
ovn-nbctl --wait=hv sync

# Check logical flows for drop rule
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_ip_routing | grep "20.0.0.0/24" | \
    grep drop | wc -l], [0], [dnl
1
])

# Send packet.
packet="inport==\"sw1-lp1\" && eth.src==00:00:04:01:02:03 &&
       eth.dst==00:00:01:01:02:03 && ip4 && ip.ttl==64 &&
       ip4.src==10.0.0.100 && ip4.dst==20.0.0.200 &&
       udp && udp.src==53 && udp.dst==4369"

OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Check if packet hit the drop rule
AT_CHECK([ovs-ofctl dump-flows br-int | grep "nw_dst=20.0.0.0/24" | \
    grep "actions=drop" | grep "n_packets=1" | wc -l], [0], [dnl
1
])

# Remove destination match and add discard route with source match
ovn-nbctl lr-route-del lr1 20.0.0.0/24
ovn-nbctl --policy="src-ip" lr-route-add lr1 10.0.0.0/24 discard

# Allow some time for ovn-controller to catch up.
ovn-nbctl --wait=hv sync

# Check logical flows for drop rule
AT_CHECK([ovn-sbctl dump-flows | grep lr_in_ip_routing | grep "10.0.0.0/24" | \
    grep drop | wc -l], [0], [dnl
1
])

# Send packet.
packet="inport==\"sw1-lp1\" && eth.src==00:00:04:01:02:03 &&
       eth.dst==00:00:01:01:02:03 && ip4 && ip.ttl==64 &&
       ip4.src==10.0.0.100 && ip4.dst==20.0.0.200 &&
       udp && udp.src==53 && udp.dst==4369"

OVS_WAIT_UNTIL([as hv1 ovs-appctl -t ovn-controller inject-pkt "$packet"])

# Check if packet hit the drop rule
AT_CHECK([ovs-ofctl dump-flows br-int "nw_src=10.0.0.0/24" | \
    grep "actions=drop" | grep "n_packets=1" | wc -l], [0], [dnl
1
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([proxy-arp: 1 HVs, 1 LSs, 1 lport/LS, 1 LR])
AT_KEYWORDS([proxy-arp])
ovn_start

# Logical network:
# One LR - lr1 has switch ls1 (192.16.1.0/24) and ls2 (192.168.2.0/24) connected to it,
# and and one HV with IP 192.16.1.6.

ovn-nbctl lr-add lr1
ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Connect ls1 to lr1
ls1_ro_mac=00:00:00:01:02:f1
ls1_ro_ip4=192.168.1.1
ls1_ro_ip6=fd11::1
ovn-nbctl lrp-add lr1 ls1 $ls1_ro_mac $ls1_ro_ip4/24 $ls1_ro_ip6/64
ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 \
    type=router options:router-port=ls1 addresses=\"router\"

# Create logical port ls1-lp1 in ls1
ls1_p1_mac=00:00:00:01:02:03
ls1_p1_ip4=192.16.1.6
ls1_p1_ip6=fd11::2
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "$ls1_p1_mac $ls1_p1_ip4 $ls1_p1_ip6"

# Connect ls2 to lr1
ls2_ro_mac=00:00:00:01:02:f2
ls2_ro_ip4=192.168.2.1
ls2_ro_ip6=fd12::1
ovn-nbctl lrp-add lr1 ls2 $ls2_ro_mac $ls2_ro_ip4/24 $ls2_ro_ip6/64
ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 \
    type=router options:router-port=ls1 addresses=\"router\"

# Create logical port ls2-lp1 in ls2
ls2_p1_mac=00:00:00:01:02:04
ls2_p1_ip4=192.16.2.6
ls2_p1_ip6=fd12::2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "$ls2_p1_mac $ls2_p1_ip4 $ls2_p1_ip6"

# Create one hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.16.0.1

# Note: tx/rx are with respect to the LS port, so
# tx on switch port is HV rx, etc.
ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap \
    ofport-request=1


# Two proxy arp/ndp configurations with and wihout mac both dual stack
# and with CIDR to check sbflows
arp_proxy_ls1_ip4=169.254.238.2
arp_proxy_ls1_ip6=fd7b:6b4d:7b25:d22d::2
arp_proxy_ls1=(169.254.238.0/24 \
               169.254.239.2 \
               fd7b:6b4d:7b25:d22d::0/64 \
               fd7b:6b4d:7b25:d22f::1)
arp_proxy_ls1_option="\"${arp_proxy_ls1[[*]]}\""

arp_proxy_ls2_ip4=169.254.236.2
arp_proxy_ls2_ip6=fd7b:6b4d:7b25:d22b::2
arp_proxy_ls2=(00:00:00:02:02:f1 \
               169.254.236.0/24 \
               169.254.237.2 \
               fd7b:6b4d:7b25:d22b::0/64 \
               fd7b:6b4d:7b25:d22c::1)
arp_proxy_ls2_option="\"${arp_proxy_ls2[[*]]}\""

ovn-nbctl --wait=hv add Logical_Switch_Port rp-ls1 \
options arp_proxy="$arp_proxy_ls1_option"
ovn-nbctl --wait=hv add Logical_Switch_Port rp-ls2 \
options arp_proxy="$arp_proxy_ls2_option"
ovn-sbctl dump-flows > sbflows
AT_CAPTURE_FILE([sbflows])

# IPv4 LS1 Responder lflows
AT_CHECK([ovn-sbctl dump-flows |
          grep ls_in_arp_rsp |
          grep "${arp_proxy_ls1[[1]]}" |
          sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=30   , match=(arp.op == 1 && dnl
arp.tpa == {169.254.238.0/24,169.254.239.2/32}), dnl
action=(eth.dst = eth.src; eth.src = 00:00:00:01:02:f1; arp.op = 2; dnl
/* ARP reply */ arp.tha = arp.sha; arp.sha = 00:00:00:01:02:f1; dnl
arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
])

# IPv6 LS1 Responder lflows
AT_CHECK([ovn-sbctl dump-flows |
          grep ls_in_arp_rsp |
          grep "${arp_proxy_ls1[[3]]}" |
          sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=30   , dnl
match=(nd_ns && ip6.dst == { fd7b:6b4d:7b25:d22d::/64, ff02::1:ff00:0/64, dnl
fd7b:6b4d:7b25:d22f::1/128, ff02::1:ff00:1/128 } && dnl
nd.target == { fd7b:6b4d:7b25:d22d::/64, fd7b:6b4d:7b25:d22f::1/128 }), dnl
action=(nd_na_router { eth.src = 00:00:00:01:02:f1; ip6.src = nd.target; dnl
nd.target = nd.target; nd.tll = 00:00:00:01:02:f1; outport = inport; dnl
flags.loopback = 1; output; };)
])

# IPv4 LS2 Responder lflows
AT_CHECK([ovn-sbctl dump-flows |
          grep ls_in_arp_rsp |
          grep "${arp_proxy_ls2[[2]]}" |
          sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=30   , dnl
match=(arp.op == 1 && arp.tpa == {169.254.236.0/24,169.254.237.2/32}), dnl
action=(eth.dst = eth.src; eth.src = 00:00:00:02:02:f1; arp.op = 2; dnl
/* ARP reply */ arp.tha = arp.sha; arp.sha = 00:00:00:02:02:f1; dnl
arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
])

# IPv4 LS2 Responder lflows
AT_CHECK([ovn-sbctl dump-flows |
          grep ls_in_arp_rsp |
          grep "${arp_proxy_ls2[[4]]}" |
          sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_arp_rsp      ), priority=30   , dnl
match=(nd_ns && ip6.dst == { fd7b:6b4d:7b25:d22b::/64, ff02::1:ff00:0/64, dnl
fd7b:6b4d:7b25:d22c::1/128, ff02::1:ff00:1/128 } && dnl
nd.target == { fd7b:6b4d:7b25:d22b::/64, fd7b:6b4d:7b25:d22c::1/128 }), dnl
action=(nd_na_router { eth.src = 00:00:00:02:02:f1; ip6.src = nd.target; dnl
nd.target = nd.target; nd.tll = 00:00:00:02:02:f1; outport = inport; dnl
flags.loopback = 1; output; };)
])

# L2 lookup lflows
AT_CHECK([ovn-sbctl dump-flows |
          grep ls_in_l2_lkup |
          grep "${arp_proxy_ls2[[0]]}" |
          sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_l2_lkup      ), priority=50   , dnl
match=(eth.dst == { 00:00:00:02:02:f1, 00:00:00:01:02:f1 }), dnl
action=(outport = "rp-ls2"; output;)
])

# LR admission lflows
AT_CHECK([ovn-sbctl dump-flows |
          grep lr_in_admission |
          grep "${arp_proxy_ls2[[0]]}" |
          sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_admission    ), priority=50   , dnl
match=(eth.dst == { 00:00:00:02:02:f1, 00:00:00:01:02:f1 } && dnl
inport == "ls1"), action=(xreg0[[0..47]] = 00:00:00:01:02:f1; next;)
])


# Remove and check that the flows have been removed
ovn-nbctl --wait=hv remove Logical_Switch_Port rp-ls1 \
options arp_proxy="$arp_proxy_ls1_option"
AT_CHECK([ovn-sbctl dump-flows |
          grep ls_in_arp_rsp |
          grep "${arp_proxy_ls1[[1]]}"], [1], [dnl
])
ovn-nbctl --wait=hv remove Logical_Switch_Port rp-ls2 \
options arp_proxy="$arp_proxy_ls2_option"
AT_CHECK([ovn-sbctl dump-flows |
          grep ls_in_arp_rsp |
          grep "${arp_proxy_ls2[[2]]}"], [1], [dnl
])

# Add the flows back send arp request and check we see an ARP response
ovn-nbctl --wait=hv add Logical_Switch_Port rp-ls1 \
options arp_proxy="$arp_proxy_ls1_option"

ovn-nbctl --wait=hv add Logical_Switch_Port rp-ls2 \
options arp_proxy="$arp_proxy_ls2_option"

bcast_mac=ff:ff:ff:ff:ff:ff

# Send ARP request for ls1 arp_proxy ipv4 /32 address
packet="inport==\"ls1-lp1\" && eth.src==$ls1_p1_mac && eth.dst==$bcast_mac &&
       arp.op==1 && arp.sha==$ls1_p1_mac && arp.spa==$ls1_p1_ip4 &&
       arp.tha==$bcast_mac && arp.tpa==${arp_proxy_ls1[[1]]}"

OVS_WAIT_UNTIL([as hv1 ovn-appctl -t ovn-controller inject-pkt "$packet"])

as hv1 ovs-ofctl dump-flows br-int| \
                 grep ${arp_proxy_ls1[[1]]} | grep priority=50 > debug1
AT_CAPTURE_FILE([debug1])

# Check if packet hit the ARP reply ovs flow
AT_CHECK([ovs-ofctl dump-flows br-int | \
    grep "${arp_proxy_ls1[[1]]}" | \
    grep "priority=30" | \
    grep "arp_op=1" | \
    grep "n_packets=1" | wc -l], [0], [dnl
1
])

# Check that the HV gets an ARP reply
expected="eth.src==$ls1_ro_mac && eth.dst==$ls1_p1_mac &&
       arp.op==2 && arp.sha==$ls1_ro_mac && arp.spa==${arp_proxy_ls1[[1]]} &&
       arp.tha==$ls1_p1_mac && arp.tpa==$ls1_p1_ip4"
echo $expected | ovstest test-ovn expr-to-packets > expected

OVN_CHECK_PACKETS([hv1/vif1-tx.pcap], [expected])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# Test when a logical port name is used in an ACL before it is created. When it
# is created later, the ACL should be programmed as openflow rules by
# ovn-controller. Although this is not likely to happen in real world use
# cases, it is possible that a port-binding is observed by ovn-controller AFTER
# an lflow that references the port is processed. So this test case is to make
# sure the incremental processing in ovn-controller reprocesses the lflow when
# the port-binding is observed.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL referencing lport before creation])
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Bind both lp1 and lp2 on the chasis.
check ovs-vsctl add-port br-int lp1 -- set interface lp1 external_ids:iface-id=lp1
check ovs-vsctl add-port br-int lp2 -- set interface lp2 external_ids:iface-id=lp2

# Create only lport lp1, but not lp2.
check ovn-nbctl ls-add lsw0
check ovn-nbctl lsp-add lsw0 lp1 \
    -- lsp-set-addresses lp1 "f0:00:00:00:00:01 10.0.0.11"

# Each lport is referenced by an ACL.
check ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp1" && ip4.src == 10.0.0.111' allow-related
check ovn-nbctl acl-add lsw0 to-lport 1002 'outport == "lp2" && ip4.src == 10.0.0.122' allow-related

# The first ACL should be programmed, but the second one shouldn't.
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10.0.0.111], [0], [ignore])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10.0.0.122], [1], [ignore])

# Now create the lport lp2.
check ovn-nbctl lsp-add lsw0 lp2 \
    -- lsp-set-addresses lp2 "f0:00:00:00:00:02 10.0.0.22"

check ovn-nbctl --wait=hv sync
# Now the second ACL should be programmed.
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10.0.0.122], [0], [ignore])

# Remove the lport lp2 again, the OVS flow for the second ACL should be
# removed.
check ovn-nbctl --wait=hv lsp-del lp2
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10.0.0.122], [1], [ignore])

# Test similar scenario but when the referenced lport is not bound locally.

# Create only lport lp3, but not lp4.
check ovn-nbctl lsp-add lsw0 lp3 \
    -- lsp-set-addresses lp3 "f0:00:00:00:00:03 10.0.0.33"

ovn-appctl -t ovn-controller vlog/set file:dbg
check ovn-nbctl acl-add lsw0 to-lport 1002 'inport == "lp3" && ip4.dst == 10.0.0.133' allow-related
check ovn-nbctl acl-add lsw0 to-lport 1002 'inport == "lp4" && ip4.dst == 10.0.0.144' allow-related

# The ACL for lp3 should be programmed, but the one for lp4 shouldn't.
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10.0.0.133], [0], [ignore])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10.0.0.144], [1], [ignore])

# Now create the lport lp4.
check ovn-nbctl lsp-add lsw0 lp4 \
    -- lsp-set-addresses lp4 "f0:00:00:00:00:04 10.0.0.44"

# Now the ACL for lp4 should be programmed.
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10.0.0.144], [0], [ignore])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- lr multiple gw ports])
AT_KEYWORDS([multiple-l3dgw-ports])
ovn_start

# Logical network:
# 1 LR, 3 Logical Switches,
# 1 gateway chassis attached to each corresponding LRP.
#
#                | S1 (gw1)
#                |
#      ls  ----  DR -- S3 (gw3)
# (20.0.0.0/24)  |
#                | S2 (gw2)
#
# S1 - VLAN 1000
# S2 - VLAN 2000
# S3 - VLAN 3000
#
# 5 chassis(s), HV1----HV5
#
# HV1 - VIF11
# HV2 - Gateway chassis gw1
# HV3 - Gateway chassis gw2
# HV4 - Gateway chassis gw3
# HV5 - North endpoint

ovn-nbctl lr-add DR
ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24
ovn-nbctl lrp-add DR DR-S2 08:ac:10:01:00:01 10.0.0.1/24
ovn-nbctl lrp-add DR DR-S3 04:ac:10:01:00:01 192.168.0.1/24
ovn-nbctl lrp-add DR DR-ls 06:ac:10:01:00:01 20.0.0.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-DR
ovn-nbctl lsp-set-type S1-DR router
ovn-nbctl lsp-set-addresses S1-DR router
ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1
ovn-nbctl lsp-add S1 ln1 "" 1000
ovn-nbctl lsp-set-addresses ln1 unknown
ovn-nbctl lsp-set-type ln1 localnet
ovn-nbctl lsp-set-options ln1 network_name=phys

ovn-nbctl ls-add S2
ovn-nbctl lsp-add S2 S2-DR
ovn-nbctl lsp-set-type S2-DR router
ovn-nbctl lsp-set-addresses S2-DR router
ovn-nbctl --wait=sb lsp-set-options S2-DR router-port=DR-S2
ovn-nbctl lsp-add S2 ln2 "" 2000
ovn-nbctl lsp-set-addresses ln2 unknown
ovn-nbctl lsp-set-type ln2 localnet
ovn-nbctl lsp-set-options ln2 network_name=phys

ovn-nbctl ls-add S3
ovn-nbctl lsp-add S3 S3-DR
ovn-nbctl lsp-set-type S3-DR router
ovn-nbctl lsp-set-addresses S3-DR router
ovn-nbctl --wait=sb lsp-set-options S3-DR router-port=DR-S3
ovn-nbctl lsp-add S3 ln3 "" 3000
ovn-nbctl lsp-set-addresses ln3 unknown
ovn-nbctl lsp-set-type ln3 localnet
ovn-nbctl lsp-set-options ln3 network_name=phys

ovn-nbctl ls-add ls
ovn-nbctl lsp-add ls ls-DR
ovn-nbctl lsp-set-type ls-DR router
ovn-nbctl lsp-set-addresses ls-DR router
ovn-nbctl --wait=sb lsp-set-options ls-DR router-port=DR-ls

# Add the lsp lp11 to ls. This will map to VIF11.
ovn-nbctl lsp-add ls lp11
ovn-nbctl lsp-set-addresses lp11 "f0:00:00:00:00:10 20.0.0.10"
ovn-nbctl lsp-set-port-security lp11 f0:00:00:00:00:10

# Add the Northbound endpoint, lp-north1
ovn-nbctl ls-add ls-north1
ovn-nbctl lsp-add ls-north1 ln4 "" 1000
ovn-nbctl lsp-set-addresses ln4 unknown
ovn-nbctl lsp-set-type ln4 localnet
ovn-nbctl lsp-set-options ln4 network_name=phys

ovn-nbctl lsp-add ls-north1 lp-north1
ovn-nbctl lsp-set-addresses lp-north1 "f0:f0:00:00:00:11 172.16.1.10"
ovn-nbctl lsp-set-port-security lp-north1 f0:f0:00:00:00:11

# Add the Northbound endpoint, lp-north2
ovn-nbctl ls-add ls-north2
ovn-nbctl lsp-add ls-north2 ln5 "" 2000
ovn-nbctl lsp-set-addresses ln5 unknown
ovn-nbctl lsp-set-type ln5 localnet
ovn-nbctl lsp-set-options ln5 network_name=phys

ovn-nbctl lsp-add ls-north2 lp-north2
ovn-nbctl lsp-set-addresses lp-north2 "f0:f0:00:00:00:22 10.0.0.10"
ovn-nbctl lsp-set-port-security lp-north2 f0:f0:00:00:00:22

# Add the Northbound endpoint, lp-north3
ovn-nbctl ls-add ls-north3
ovn-nbctl lsp-add ls-north3 ln6 "" 3000
ovn-nbctl lsp-set-addresses ln6 unknown
ovn-nbctl lsp-set-type ln6 localnet
ovn-nbctl lsp-set-options ln6 network_name=phys

ovn-nbctl lsp-add ls-north3 lp-north3
ovn-nbctl lsp-set-addresses lp-north3 "f0:f0:00:00:00:33 192.168.0.10"
ovn-nbctl lsp-set-port-security lp-north3 f0:f0:00:00:00:33

# Add 5 chassis
net_add n1
for i in 1 2 3 4 5; do
    sim_add hv$i
    as hv$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovn_attach n1 br-phys 192.168.0.$i 24 $encap
done

# Add a vif on HV1
as hv1 ovs-vsctl add-port br-int vif11 -- \
    set Interface vif11 external-ids:iface-id=lp11 \
                              options:tx_pcap=hv1/vif11-tx.pcap \
                              options:rxq_pcap=hv1/vif11-rx.pcap \
                              ofport-request=11
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lp11` = xup])

as hv5 ovs-vsctl add-port br-int vif-north1 -- \
        set Interface vif-north1 external-ids:iface-id=lp-north1 \
                              options:tx_pcap=hv5/vif-north1-tx.pcap \
                              options:rxq_pcap=hv5/vif-north1-rx.pcap \
                              ofport-request=44

as hv5 ovs-vsctl add-port br-int vif-north2 -- \
        set Interface vif-north2 external-ids:iface-id=lp-north2 \
                              options:tx_pcap=hv5/vif-north2-tx.pcap \
                              options:rxq_pcap=hv5/vif-north2-rx.pcap \
                              ofport-request=45

as hv5 ovs-vsctl add-port br-int vif-north3 -- \
        set Interface vif-north3 external-ids:iface-id=lp-north3 \
                              options:tx_pcap=hv5/vif-north3-tx.pcap \
                              options:rxq_pcap=hv5/vif-north3-rx.pcap \
                              ofport-request=46

ovn-nbctl lrp-set-gateway-chassis DR-S1 hv2
ovn-nbctl lrp-set-gateway-chassis DR-S2 hv3
ovn-nbctl lrp-set-gateway-chassis DR-S3 hv4

ovn-nbctl --wait=sb sync
OVN_POPULATE_ARP
vif_to_ls () {
    case ${1} in dnl (
        vif?[[11]]) echo ls ;; dnl (
        vif-north1) echo ls-north1 ;; dnl (
        vif-north2) echo ls-north2 ;; dnl (
        vif-north3) echo ls-north3 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_hv () {
    case ${1} in dnl (
        vif[[1]]?) echo hv1 ;; dnl (
        vif-north1) echo hv5 ;; dnl (
        vif-north2) echo hv5 ;; dnl (
        vif-north3) echo hv5 ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac
}

vif_to_lrp () {
    case ${1} in dnl (
        vif?[[11]]) echo DR-ls ;; dnl (
        *) AT_FAIL_IF([:]) ;;
    esac

}

ip_to_hex() {
       printf "%02x%02x%02x%02x" "${@}"
}

# test_arp INPORT SHA SPA TPA
#
# Causes a packet to be received on INPORT.  The packet is an ARP
# request with SHA, SPA, and TPA as specified.
test_arp() {
    local inport=$1 sha=$2 spa=$3 tpa=$4
    local request=ffffffffffff${sha}08060001080006040001${sha}${spa}ffffffffffff${tpa}
    hv=`vif_to_hv $inport`
    as $hv ovs-appctl netdev-dummy/receive $inport $request
}


test_ip() {
        # This packet has bad checksums but logical L3 routing doesn't check.
        local inport=${1} src_mac=${2} dst_mac=${3} src_ip=${4} dst_ip=${5} outport=${6}
        local packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
        shift; shift; shift; shift; shift
        hv=`vif_to_hv $inport`
        as $hv ovs-appctl netdev-dummy/receive $inport $packet
        in_ls=`vif_to_ls $inport`
        for outport; do
            out_ls=`vif_to_ls $outport`
            if test $in_ls = $out_ls; then
                # Ports on the same logical switch receive exactly the same packet.
                echo $packet
            else
                # Routing decrements TTL and updates source and dest MAC
                # (and checksum).
                # For North-South, packet will come via gateway chassis, i.e hv3
                if test $inport = vif-north1; then
                    echo f0000000001006ac1001000108004500001c000000003f110100${src_ip}${dst_ip}0035111100080000 >> $outport.expected
                fi
                if test $outport = vif-north1; then
                    echo f0f00000001102ac1001000108004500001c000000003f110100${src_ip}${dst_ip}0035111100080000 >> $outport.expected
                fi
                if test $outport = vif-north2; then
                    echo f0f00000002208ac1001000108004500001c000000003f110100${src_ip}${dst_ip}0035111100080000 >> $outport.expected
                fi
                if test $outport = vif-north3; then
                    echo f0f00000003304ac1001000108004500001c000000003f110100${src_ip}${dst_ip}0035111100080000 >> $outport.expected
                fi
            fi >> $outport.expected
        done
}

echo "------ OVN dump ------"
ovn-nbctl show
ovn-sbctl show
ovn-sbctl list port_binding
ovn-sbctl list mac_binding
ovn-sbctl list datapath_binding

ovn-sbctl dump-flows DR
ovn-sbctl dump-flows S1
ovn-sbctl dump-flows ls

echo "------ hv1 dump ------"
as hv1 ovs-vsctl show
as hv1 ovs-vsctl list Open_Vswitch
as hv1 ovs-ofctl dump-flows br-int

echo "------ hv2 dump ------"
as hv2 ovs-vsctl show
as hv2 ovs-vsctl list Open_Vswitch
as hv2 ovs-ofctl dump-flows br-int

echo "------ hv3 dump ------"
as hv3 ovs-vsctl show
as hv3 ovs-vsctl list Open_Vswitch
as hv3 ovs-ofctl dump-flows br-int

echo "------ hv4 dump ------"
as hv4 ovs-vsctl show
as hv4 ovs-vsctl list Open_Vswitch
as hv5 ovs-ofctl dump-flows br-int

# N-S with lp-north1
echo "Send Dummy ARP"
sip=`ip_to_hex 172 16 1 10`
tip=`ip_to_hex 172 16 1 50`
test_arp vif-north1 f0f000000011 $sip $tip
OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=f0:f0:00:00:00:11 | wc -l`]
)

echo "Send traffic North to South"
sip=`ip_to_hex 172 16 1 10`
dip=`ip_to_hex 20 0 0 10`
test_ip vif-north1 f0f000000011 02ac10010001 $sip $dip vif11
# Confirm that North to south traffic works fine.
OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv1/vif11-tx.pcap], [vif11.expected])

echo "Send traffic South to North1"
sip=`ip_to_hex 20 0 0 10`
dip=`ip_to_hex 172 16 1 10`
test_ip vif11 f00000000010 06ac10010001 $sip $dip vif-north1
# Confirm that South to North traffic works fine.
OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv5/vif-north1-tx.pcap], [vif-north1.expected])

# N-S with lp-north2
echo "Send Dummy ARP"
sip=`ip_to_hex 10 0 0 10`
tip=`ip_to_hex 10 0 0 50`
test_arp vif-north2 f0f000000022 $sip $tip
OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=f0:f0:00:00:00:22 | wc -l`]
)

echo "Send traffic South to North2"
sip=`ip_to_hex 20 0 0 10`
dip=`ip_to_hex 10 0 0 10`
test_ip vif11 f00000000010 06ac10010001 $sip $dip vif-north2
# Confirm that South to North traffic works fine.
OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv5/vif-north2-tx.pcap], [vif-north2.expected])

# N-S with lp-north3
echo "Send Dummy ARP"
sip=`ip_to_hex 192 168 0 10`
tip=`ip_to_hex 192 168 0 50`
test_arp vif-north3 f0f000000033 $sip $tip
OVS_WAIT_UNTIL(
    [test 1 = `as hv1 ovs-ofctl dump-flows br-int table=67 | grep dl_src=f0:f0:00:00:00:33 | wc -l`]
)

echo "Send traffic South to North3"
sip=`ip_to_hex 20 0 0 10`
dip=`ip_to_hex 192 168 0 10`
test_ip vif11 f00000000010 06ac10010001 $sip $dip vif-north3
# Confirm that South to North traffic works fine.
OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv5/vif-north3-tx.pcap], [vif-north3.expected])

AT_CLEANUP
])

# This test ensures that an ovn-controller doesn't program OVS flows for
# datapaths that are beyond a distributed gateway port.
#
#    lsp0@hv1 - ls1 - lrp_lr_ls1 (DGP@hv0)
#                                         \
#                                         lr
#                                         /
#    lsp1@hv2 - ls2 - lrp_lr_ls2 (DGP@hv1)
#
# In this topology, hv1 shouldn't have flows of ls2, and hv2 shouldn't have
# flows of ls1.
OVN_FOR_EACH_NORTHD([
AT_SETUP([Dont flood fill local datapaths beyond distributed gateway port])
ovn_start

net_add n1
check ovn-nbctl lr-add lr
for i in 1 2; do
    sim_add hv$i
    as hv$i
    check ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.$i

    check ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i

    check ovn-nbctl ls-add ls$i
    check ovn-nbctl lsp-add ls$i lsp$i \
        -- lsp-set-addresses lsp$i "f0:00:00:00:00:0$i 10.0.$i.2"

    lrp=lrp_lr_ls$i
    lsp_lr=lsp_ls${i}_lr
    check ovn-nbctl lrp-add lr $lrp f0:00:00:00:aa:0$i 10.0.$i.1/24 \
        -- lsp-add ls$i $lsp_lr \
        -- lsp-set-type $lsp_lr router \
        -- lsp-set-options $lsp_lr router-port=$lrp \
        -- lsp-set-addresses $lsp_lr router \
        -- lrp-set-gateway-chassis $lrp hv$i 1
done

check ovn-nbctl --wait=hv sync

# hv0 should see flows for lsp1 but not lsp2
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=29 | grep 10.0.1.2], [0], [ignore])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=29 | grep 10.0.2.2], [1])
# hv2 should see flows for lsp2 but not lsp1
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=29 | grep 10.0.2.2], [0], [ignore])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=29 | grep 10.0.1.2], [1])

# Change lrp_lr_ls1 to a regular lrp, hv2 should see flows for lsp1
check ovn-nbctl --wait=hv lrp-del-gateway-chassis lrp_lr_ls1 hv1
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=29 | grep 10.0.1.2], [0], [ignore])

# Change it back, and trigger recompute to make sure extra flows are removed
# from hv2 (recompute is needed because currently I-P adds local datapaths but
# doesn't remove.)
check ovn-nbctl --wait=hv lrp-set-gateway-chassis lrp_lr_ls1 hv1 1
as hv2 check ovn-appctl -t ovn-controller recompute
ovn-nbctl --wait=hv sync
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=29 | grep 10.0.1.2], [1])

# Enable dnat_and_snat on lr, and now hv2 should see flows for lsp1.
AT_CHECK([ovn-nbctl --wait=hv --gateway-port=lrp_lr_ls1 lr-nat-add lr dnat_and_snat 192.168.0.1 10.0.1.3 lsp1 f0:00:00:00:00:03])
AT_CHECK([as hv2 ovs-ofctl dump-flows br-int table=29 | grep 10.0.1.2], [0], [ignore])

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])


OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller port binding with iface-id-ver])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vm1

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-port1
ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 10.0.0.3"

ovn-nbctl lsp-set-options sw0-port1 iface-id-ver=foo

ovn-nbctl lsp-add sw0 sw0-port2
ovn-nbctl --wait=hv lsp-set-addresses sw0-port2 "50:54:00:00:00:02 10.0.0.4"

hv1_uuid=$(fetch_column Chassis _uuid name=hv1)
hv2_uuid=$(fetch_column Chassis _uuid name=hv2)

check as hv1 ovs-vsctl add-port br-int vif11 \
    -- set interface vif11 external_ids:iface-id=sw0-port1

# sw0-port1 should not be claimed.
ovn-nbctl --wait=hv sync
check_column "" Port_Binding chassis logical_port=sw0-port1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0-port1]], OVS interface name : [[vif11]], num binding lports : [[0]]
----------------------------------------
])

# Set iface-id-ver on vif11. hv1 ovn-controller should claim it now.
check as hv1 ovs-vsctl set interface vif11 external_ids:iface-id-ver=foo

wait_for_ports_up sw0-port1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0-port1]], OVS interface name : [[vif11]], num binding lports : [[1]]
primary lport : [[sw0-port1]]
----------------------------------------
])

# Clear the iface-id-ver from vif11 and hv1 ovn-controller should release it.
check as hv1 ovs-vsctl remove interface vif11 external_ids iface-id-ver
ovn-nbctl --wait=hv sync
check_column "" Port_Binding chassis logical_port=sw0-port1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0-port1]], OVS interface name : [[vif11]], num binding lports : [[0]]
----------------------------------------
])

# Clear the sw0-port1 iface-id-ver options and sw0-port1 should be claimed.
check ovn-nbctl clear logical_switch_port sw0-port1 options

wait_for_ports_up sw0-port1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0-port1]], OVS interface name : [[vif11]], num binding lports : [[1]]
primary lport : [[sw0-port1]]
----------------------------------------
])

# Set the options:iface-id-ver to sw0-port1 with different value.
check ovn-nbctl lsp-set-options sw0-port1 iface-id-ver=bar

ovn-nbctl --wait=hv sync
check_column "" Port_Binding chassis logical_port=sw0-port1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0-port1]], OVS interface name : [[vif11]], num binding lports : [[0]]
----------------------------------------
])

# Set iface-id-ver on vif11. hv1 ovn-controller should claim it now.
check as hv1 ovs-vsctl set interface vif11 external_ids:iface-id-ver=bar
wait_for_ports_up sw0-port1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0-port1]], OVS interface name : [[vif11]], num binding lports : [[1]]
primary lport : [[sw0-port1]]
----------------------------------------
])

# Set a different iface-id-ver on vif11.
check as hv1 ovs-vsctl set interface vif11 external_ids:iface-id-ver=bar2

ovn-nbctl --wait=hv sync
check_column "" Port_Binding chassis logical_port=sw0-port1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0-port1]], OVS interface name : [[vif11]], num binding lports : [[0]]
----------------------------------------
])

# Set the type of sw0-port1 to localport. iface-id-ver is ignored for localports.
# So sw0-port1 should be internally claimed without setting sw0-port1 to up.
check ovn-nbctl lsp-set-type sw0-port1 localport

ovn-nbctl --wait=hv sync
check_column "" Port_Binding chassis logical_port=sw0-port1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0-port1]], OVS interface name : [[vif11]], num binding lports : [[1]]
localport lport : [[sw0-port1]]
----------------------------------------
])

check as hv1 ovs-vsctl add-port br-int vif12 \
    -- set interface vif12 external_ids:iface-id=sw0-port2

wait_for_ports_up sw0-port2

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[sw0-port1]], OVS interface name : [[vif11]], num binding lports : [[1]]
localport lport : [[sw0-port1]]
----------------------------------------
name: [[sw0-port2]], OVS interface name : [[vif12]], num binding lports : [[1]]
primary lport : [[sw0-port2]]
----------------------------------------
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller ct zone I-P handling])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check as hv1 ovs-vsctl add-port br-int vif11 \
    -- set interface vif11 external_ids:iface-id=sw0-port1

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-port1
ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 10.0.0.3"
check ovn-nbctl lsp-add sw0 sw0-port2
check ovn-nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:01 10.0.0.4"
check ovn-nbctl lsp-set-type sw0-port2 localport

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

wait_for_ports_up sw0-port1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller ct-zone-list | \
grep sw0-port1 -c], [0], [1
])

check as hv1 ovs-vsctl add-port br-int vif13 \
    -- set interface vif13 external_ids:iface-id=sw0-port2 ofport-request=13

ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([test `ovs-ofctl dump-flows br-int table=0 | grep "in_port=13" | wc -l` -eq 1])

# There should be ct zone for sw0-port2 (localport).
AT_CHECK([as hv1 ovn-appctl -t ovn-controller ct-zone-list | \
grep sw0-port2 -c], [0], [1
])

# There should be no ct-zone id allocated for sw0-lr0 and lr0-sw0
AT_CHECK([as hv1 ovn-appctl -t ovn-controller ct-zone-list | \
grep sw0-lr0], [1], [])

AT_CHECK([as hv1 ovn-appctl -t ovn-controller ct-zone-list | \
grep lr0-sw0], [1], [])

check as hv1 ovs-vsctl add-port br-int vif12 \
    -- set interface vif12 external_ids:iface-id=sw1-port1

ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-port1

wait_for_ports_up sw1-port1
AT_CHECK([as hv1 ovn-appctl -t ovn-controller ct-zone-list | \
grep sw1-port1 -c], [0], [1
])

# Attach sw1 to lr0
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

# There should be no ct-zone id allocated for sw1-lr0
AT_CHECK([as hv1 ovn-appctl -t ovn-controller ct-zone-list | \
grep sw1-lr0], [1], [])

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24

# There should be no ct-zone id allocated for lr0-sw1
AT_CHECK([as hv1 ovn-appctl -t ovn-controller ct-zone-list | \
grep lr0-sw1], [1], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller requested-chassis localport])
ovn_start

net_add n1

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-localport
check ovn-nbctl lsp-set-addresses sw0-localport "50:54:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-type sw0-localport localport
check ovn-nbctl lsp-set-options sw0-localport requested-chassis=""

check ovn-nbctl lsp-add sw0 sw0-vm1
check ovn-nbctl lsp-set-addresses sw0-vm1 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-options sw0-vm1 requested-chassis="hv1"

check ovn-nbctl lsp-add sw0 sw0-vm2
check ovn-nbctl lsp-set-addresses sw0-vm2 "50:54:00:00:00:04 10.0.0.4"
check ovn-nbctl lsp-set-options sw0-vm2 requested-chassis="hv2"

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl add-port br-int localport \
    -- set interface localport \
       external_ids:iface-id=sw0-localport \
       ofport-request=13
ovs-vsctl add-port br-int vm1 \
    -- set interface vm1 external_ids:iface-id=sw0-vm1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl add-port br-int localport \
    -- set interface localport \
       external_ids:iface-id=sw0-localport \
       ofport-request=13
ovs-vsctl add-port br-int vm2 \
    -- set interface vm2 external_ids:iface-id=sw0-vm2

# Only the VIFs will get status UP
wait_for_ports_up sw0-vm1 sw0-vm2

# Check that flows are generated for the localport
OVS_WAIT_UNTIL([
    as hv1 \
    ovs-ofctl -O OpenFlow15 dump-flows br-int table=0 \
    | tee 1-hv1-br-int-table-0.txt \
    && grep -q in_port=13 1-hv1-br-int-table-0.txt
])
OVS_WAIT_UNTIL([
    as hv2 \
    ovs-ofctl -O OpenFlow15 dump-flows br-int table=0 \
    | tee 1-hv2-br-int-table-0.txt \
    && grep in_port=13 1-hv2-br-int-table-0.txt
])

# Confirm that the controllers did not attempt to claim the localport
AT_CHECK([grep -q "Claiming lport sw0-localport" hv1/ovn-controller.log], [1], [])
AT_CHECK([grep -q "Claiming lport sw0-localport" hv2/ovn-controller.log], [1], [])

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - requested-chassis claim lport on startup])
ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int vif1 -- \
    set Interface vif1 external-ids:iface-id=lsp1

check ovn-nbctl ls-add lsw0

check ovn-nbctl lsp-add lsw0 lsp1
check ovn-nbctl lsp-set-addresses lsp1 "f0:00:00:00:00:01 172.16.0.101"
check ovn-nbctl set Logical_Switch_Port lsp1 \
    options:requested-chassis=hv1

wait_for_ports_up lsp1

lsp1_pb_uuid=$(ovn-sbctl --bare --columns _uuid \
               find Port_Binding logical_port=lsp1)

# Stop ovn-controller on hv1 without the --restart flag
check as hv1 ovn-appctl -t ovn-controller exit

# Pause northd to guarantee that ovn-controller starts before requested_chassis
# column is filled.
check as northd ovn-appctl -t ovn-northd pause

# Wait until requested_chassis is empty
OVS_WAIT_UNTIL([
    test x"3" = x$(ovn-sbctl get Port_Binding ${lsp1_pb_uuid} requested_chassis) | wc -c
])

# Start controller and wait for it to register itself
as hv1 start_daemon ovn-controller
wait_column "hv1" Chassis name

# Start northd and wait for events to be processed
check as northd ovn-appctl -t ovn-northd resume

wait_for_ports_up lsp1

# Confirm that the controller did not refuse to claim its port on the initial
# run.
AT_CHECK([grep -q "Not claiming" hv1/ovn-controller.log], [1], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - VIF plugging])
AT_KEYWORDS([vif-plug])

ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

sim_add hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

check ovn-nbctl ls-add lsw0

check ovn-nbctl lsp-add lsw0 lsp1
check ovn-nbctl lsp-set-addresses lsp1 "f0:00:00:00:00:01 172.16.0.101"
check ovn-nbctl lsp-set-options lsp1 \
    requested-chassis=hv1 \
    vif-plug-type=dummy \
    vif-plug-mtu-request=42

check ovn-nbctl lsp-add lsw0 lsp2
check ovn-nbctl lsp-set-addresses lsp2 "f0:00:00:00:00:02 172.16.0.102"
check ovn-nbctl lsp-set-options lsp2 \
    requested-chassis=hv2 \
    vif-plug-type=dummy \
    vif-plug-mtu-request=42

wait_for_ports_up lsp1 lsp2

lsp1_uuid=$(ovn-nbctl --bare --columns _uuid find Logical_Switch_Port name=lsp1)
iface1_uuid=$(as hv1 ovs-vsctl --bare --columns _uuid find Interface name=lsp1)

lsp2_uuid=$(ovn-nbctl --bare --columns _uuid find Logical_Switch_Port name=lsp2)
iface2_uuid=$(as hv2 ovs-vsctl --bare --columns _uuid find Interface name=lsp2)

# Check that the lport was plugged
AT_CHECK([test xvalue = x$(as hv1 ovs-vsctl get Interface ${iface1_uuid} options:vif-plug-dummy-option)], [0], [])
AT_CHECK([test x42 = x$(as hv1 ovs-vsctl get Interface ${iface1_uuid} mtu_request)], [0], [])

# Check that updating the lport updates the local iface
check ovn-nbctl --wait=hv lsp-set-options lsp1 \
    requested-chassis=hv1 \
    vif-plug-type=dummy \
    vif-plug-mtu-request=43
OVS_WAIT_UNTIL([
    test x43 = x$(as hv1 ovs-vsctl get Interface ${iface1_uuid} mtu_request)
])

# Check that local modification of iface will trigger ovn-controller to update
# the iface record
check as hv1 ovs-vsctl set interface ${iface1_uuid} mtu_request=44
OVS_WAIT_UNTIL([
    test x43 = x$(as hv1 ovs-vsctl get Interface ${iface1_uuid} mtu_request)
])

as hv1 check ovn-appctl -t ovn-controller debug/ignore-startup-delay
# Check that pointing requested-chassis somewhere else will unplug the port
check ovn-nbctl --wait=hv set Logical_Switch_Port lsp1 \
    options:requested-chassis=non-existent-chassis
OVS_WAIT_UNTIL([
    ! as hv1 ovs-vsctl get Interface ${iface1_uuid} _uuid
])

as hv2 check ovn-appctl -t ovn-controller debug/ignore-startup-delay
# Check that removing an lport will unplug it
AT_CHECK([test x${iface2_uuid} = x$(as hv2 ovs-vsctl get Interface ${iface2_uuid} _uuid)], [0], [])
check ovn-nbctl --wait=hv lsp-del ${lsp2_uuid}
OVS_WAIT_UNTIL([
    ! as hv2 ovs-vsctl get Interface ${iface2_uuid} _uuid
])

# Check that port is unplugged when we simulate presence of a port previously
# plugged by us in local OVSDB with no record in SB DB.
check as hv2 ovs-vsctl \
    -- add-port br-int vif1

# From one moment it's there...
vif1_uuid=$(as hv2 ovs-vsctl --bare --columns _uuid find Interface name=vif1)
OVS_WAIT_UNTIL([
    as hv2 ovs-vsctl get Interface ${vif1_uuid} _uuid
])

# Add the external-ids we expect
check as hv2 ovs-vsctl \
    -- set Interface ${vif1_uuid} \
           external-ids:ovn-plugged=dummy \
           external-ids:iface-id=non-existing-lsp

# ...to the next moment it's gone.
OVS_WAIT_UNTIL([
    ! as hv2 ovs-vsctl get Interface ${vif1_uuid} _uuid
])

# Check that a warning is logged when CMS requests plugging of an interface
# with lbinding already plugged by someone else.
check as hv2 ovs-vsctl \
    -- add-port br-int vif3 \
    -- set Interface vif3 \
       external-ids:iface-id=lsp3

check ovn-nbctl lsp-add lsw0 lsp3
check ovn-nbctl lsp-set-addresses lsp3 "f0:00:00:00:00:03 172.16.0.103"
check ovn-nbctl lsp-set-options lsp3 \
    requested-chassis=hv2

wait_for_ports_up lsp3

check ovn-nbctl --wait=hv lsp-set-options lsp3 \
    requested-chassis=hv2 \
    vif-plug-type=dummy

OVS_WAIT_UNTIL([
    grep -q "CMS requested plugging of lport lsp3" hv2/ovn-controller.log
])

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - check meters update])
AT_KEYWORDS([meters-update])

ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.10

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 lsp

as hv1 ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp

# Wait for port to be bound.
wait_row_count Chassis 1 name=hv1
ch=$(fetch_column Chassis _uuid name=hv1)
wait_row_count Port_Binding 1 logical_port=lsp chassis=$ch

# Add a new meter
check ovn-nbctl --event lb-add lb0 192.168.1.100:80 ""
check ovn-nbctl ls-lb-add sw0 lb0
check ovn-nbctl meter-add meter0 drop 10 pktps
ovn-nbctl --wait=hv copp-add copp0 event-elb meter0
ovn-nbctl --wait=hv ls-copp-add copp0 sw0
check ovn-nbctl --wait=hv sync

AT_CHECK([as hv1 ovs-ofctl -OOpenFlow15 dump-meters br-int | grep -q rate=10], [0])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int 2>&1 | grep -q meter_id=1], [0])

# Update existing meter
check ovn-nbctl --may-exist meter-add meter0 drop 20 pktps
check ovn-nbctl --wait=hv sync

AT_CHECK([as hv1 ovs-ofctl -OOpenFlow15 dump-meters br-int | grep -q rate=20], [0])

# Add a new meter
check ovn-nbctl meter-add meter1 drop 30 pktps
check ovn-nbctl --log --severity=alert --meter=meter1 \
                --name=dns acl-add sw0 to-lport 1000 'udp.dst == 53' drop
check ovn-nbctl --wait=hv sync
AT_CHECK([as hv1 ovs-ofctl -OOpenFlow15 dump-meters br-int | grep -q rate=30], [0])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int 2>&1 | grep -q meter_id=2], [0])

# Remove meter0
check ovn-nbctl meter-del meter0
check ovn-nbctl --wait=hv sync
AT_CHECK([as hv1 ovs-ofctl -OOpenFlow15 dump-meters br-int | grep -q rate=10], [1])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep -q meter_id=1], [1])

check ovn-nbctl meter-del meter1
check ovn-nbctl --wait=hv sync
AT_CHECK([as hv1 ovs-ofctl -OOpenFlow15 dump-meters br-int | grep -q rate=30], [1])

# create meters in the opposite order
check ovn-nbctl --log --severity=alert --meter=meter2 \
                --name=dns acl-add sw0 to-lport 1000 'tcp.dst == 80' drop
check ovn-nbctl meter-add meter2 drop 100 pktps
check ovn-nbctl --wait=hv sync
AT_CHECK([as hv1 ovs-ofctl -OOpenFlow15 dump-meters br-int | grep -q rate=100], [0])
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int 2>&1 | grep -q meter_id=1], [0])

check ovn-nbctl meter-del meter2
check ovn-nbctl --wait=hv sync
AT_CHECK([as hv1 ovs-ofctl -OOpenFlow15 dump-meters br-int | grep -q rate=100], [1])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

AT_SETUP([ovn -- lr static_mac_binding])
AT_KEYWORDS([static_mac_binding])
ovn_start

# Add chassis
net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.1

# Create a logical router
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-ls0 00:00:11:11:22:22 20.0.0.1/24
ovn-nbctl lrp-add lr0 lr0-ext-ls0 00:00:11:11:33:33 172.16.1.10/24

# Create logical switch and connect to logical router
ovn-nbctl ls-add ls0
ovn-nbctl lsp-add ls0 ls0-lr0
ovn-nbctl lsp-set-type ls0-lr0 router
ovn-nbctl lsp-set-addresses ls0-lr0 router
ovn-nbctl --wait=sb lsp-set-options ls0-lr0 router-port=lr0-ls0

# Create external gateway switch and connect to logical router
ovn-nbctl ls-add ext-ls0
ovn-nbctl lsp-add ext-ls0 ext-ls0-lr0
ovn-nbctl lsp-set-type ext-ls0-lr0 router
ovn-nbctl lsp-set-addresses ext-ls0-lr0 router
ovn-nbctl --wait=sb lsp-set-options ext-ls0-lr0 router-port=lr0-ext-ls0

ovn-nbctl lsp-add ext-ls0 ln0 "" 1000
ovn-nbctl lsp-set-addresses ln0 unknown
ovn-nbctl lsp-set-type ln0 localnet
ovn-nbctl lsp-set-options ln0 network_name=phys

# Add the lsp lp11 to ls0. This will map to VIF11.
ovn-nbctl lsp-add ls0 lp11
ovn-nbctl lsp-set-addresses lp11 "00:00:11:11:44:44 20.0.0.10"

# Add a vif on HV1
ovs-vsctl add-port br-int vif11 -- \
    set Interface vif11 external-ids:iface-id=lp11 \
                              options:tx_pcap=hv1/vif11-tx.pcap \
                              options:rxq_pcap=hv1/vif11-rx.pcap \
                              ofport-request=11
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up lp11) = xup])

ovn-nbctl lrp-set-gateway-chassis lr0-ext-ls0 hv1

ovn-nbctl --wait=sb sync
OVN_POPULATE_ARP

ovn-nbctl --wait=hv lr-nat-add lr0 snat 172.16.1.10 20.0.0.0/24
ovn-nbctl --wait=hv lr-route-add lr0 0.0.0.0/0 172.16.1.1

test_mac_binding_flows() {
    local priority=$1 mac=$2 count=$3
    OVS_WAIT_UNTIL([test $(ovs-ofctl dump-flows br-int | grep table=66 | grep priority=${priority} | grep actions=mod_dl_dst:${mac} | wc -l) -eq ${count}])
}
# Create SB MAC_Binding entry on external gateway port
lr0_dp_uuid=$(fetch_column datapath_binding _uuid external_ids:name=lr0)

ovn-sbctl create mac_binding ip=172.16.1.1 logical_port=lr0-ext-ls0 mac="00\:00\:11\:22\:33\:44" datapath=$lr0_dp_uuid
test_mac_binding_flows 100 00:00:11:22:33:44 1

# Create Static_MAC_Binding entry on external gateway port. This should have
# higher priority than MAC_Binding entry
ovn-nbctl static-mac-binding-add lr0-ext-ls0 172.16.1.1 00:00:11:22:33:66
test_mac_binding_flows 50 00:00:11:22:33:66 1

# Update MAC for existing Static_MAC_Binding. Existing flow should be updated.
ovn-nbctl --may-exist static-mac-binding-add lr0-ext-ls0 172.16.1.1 00:00:11:22:33:88
test_mac_binding_flows 50 00:00:11:22:33:66 0
test_mac_binding_flows 50 00:00:11:22:33:88 1

# Update override_dynamic_mac for existing Static_MAC_Binding. Existing flow should be updated.
smb_uuid=$(fetch_column nb:static_mac_binding _uuid ip=172.16.1.1)

ovn-nbctl set static_mac_binding $smb_uuid override_dynamic_mac=true
test_mac_binding_flows 50 00:00:11:22:33:88 0
test_mac_binding_flows 150 00:00:11:22:33:88 1

# Delete Static_MAC_Binding. Higher priority flow should get deleted.
ovn-nbctl static-mac-binding-del lr0-ext-ls0 172.16.1.1
test_mac_binding_flows 150 00:00:11:22:33:88 0

OVN_CLEANUP([hv1])
AT_CLEANUP

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- lr mac_binding I-P update])
AT_KEYWORDS([mac_binding])
ovn_start

# Add chassis
net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.1

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.2

check as hv1 ovs-vsctl set open . external_ids:ovn-monitor-all=true
check as hv2 ovs-vsctl set open . external_ids:ovn-monitor-all=true

# Wait until ovn-monitor-all is processed by ovn-controller.
wait_row_count Chassis 1 name=hv1 other_config:ovn-monitor-all=true
wait_row_count Chassis 1 name=hv2 other_config:ovn-monitor-all=true

check ovn-nbctl ls-add public
check ovn-nbctl ls-add internal

check ovn-nbctl lsp-add public ln_port
check ovn-nbctl lsp-set-addresses ln_port unknown
check ovn-nbctl lsp-set-type ln_port localnet
check ovn-nbctl lsp-set-options ln_port network_name=phys

check ovn-nbctl lsp-add public public-gw
check ovn-nbctl lsp-set-type public-gw router
check ovn-nbctl lsp-set-addresses public-gw router
check ovn-nbctl lsp-set-options public-gw router-port=gw-public

check ovn-nbctl lsp-add internal internal-gw
check ovn-nbctl lsp-set-type internal-gw router
check ovn-nbctl lsp-set-addresses internal-gw router
check ovn-nbctl lsp-set-options internal-gw router-port=gw-internal

check ovn-nbctl lsp-add internal vif1
check ovn-nbctl lsp-set-addresses vif1 "00:00:00:00:20:11 192.168.20.11"

check ovn-nbctl lsp-add internal vif2
check ovn-nbctl lsp-set-addresses vif2 "00:00:00:00:20:12 192.168.20.12"

check ovn-nbctl lr-add gw
check ovn-nbctl lrp-add gw gw-public 00:00:00:00:10:01 192.168.10.1/24
check ovn-nbctl lrp-add gw gw-internal 00:00:00:00:20:01 192.168.20.1/24

# Add a vif1 on HV1
check as hv1 ovs-vsctl add-port br-int vif1 -- \
    set Interface vif1 external-ids:iface-id=vif1 \
                              options:tx_pcap=hv1/vif1-tx.pcap \
                              options:rxq_pcap=hv1/vif1-rx.pcap
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up vif1) = xup])

check ovn-nbctl lrp-set-gateway-chassis gw-public hv1
check ovn-nbctl --wait=sb sync

test_mac_binding_flows() {
    local hv=$1 mac=$2 count=$3
    OVS_WAIT_UNTIL([test $(as $hv ovs-ofctl dump-flows br-int | grep table=66 | grep priority=100 | grep -c actions=mod_dl_dst:${mac}) -eq ${count}])
}

# Create SB MAC_Binding entry on external gateway port
gw_dp_uuid=$(fetch_column datapath_binding _uuid external_ids:name=gw)
ovn-sbctl create mac_binding ip=192.168.10.10 logical_port=gw-public mac="00\:00\:00\:00\:10\:10" datapath=$gw_dp_uuid

test_mac_binding_flows hv1 00\:00\:00\:00\:10\:10 1
test_mac_binding_flows hv2 00\:00\:00\:00\:10\:10 0

# Add a vif2 on HV2
check as hv2 ovs-vsctl add-port br-int vif2 -- \
    set Interface vif2 external-ids:iface-id=vif2 \
                              options:tx_pcap=hv1/vif2-tx.pcap \
                              options:rxq_pcap=hv1/vif2-rx.pcap
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up vif2) = xup])

test_mac_binding_flows hv1 00\:00\:00\:00\:10\:10 1
test_mac_binding_flows hv2 00\:00\:00\:00\:10\:10 1

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller port security OF flows])
ovn_start

net_add n1

# create two hypervisors, each with one vif port
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.12

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0p1 -- lsp-set-addresses sw0p1 "00:00:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-add sw0 sw0p2 -- lsp-set-addresses sw0p2 "00:00:00:00:00:04 10.0.0.4"

as hv1
ovs-vsctl -- add-port br-int hv1-vif0 -- \
set Interface hv1-vif0 external-ids:iface-id=sw0p1 ofport-request=1

wait_for_ports_up sw0p1

sw0_dp_key=$(printf "%x" $(fetch_column Datapath_Binding tunnel_key external_ids:name=sw0))
sw0p1_key=$(printf "%x" $(fetch_column Port_Binding tunnel_key logical_port=sw0p1))
sw0p2_key=$(printf "%x" $(fetch_column Port_Binding tunnel_key logical_port=sw0p2))

# There should be no flows in table 73, 74 and 75 in hv1 and hv2
> hv1_t73_flows.expected
> hv1_t74_flows.expected
> hv1_t75_flows.expected

> hv2_t73_flows.expected
> hv2_t74_flows.expected
> hv2_t75_flows.expected

check_port_sec_offlows() {
    hv=$1
    t=$2

    as $hv ovs-ofctl dump-flows br-int table=${t} | ofctl_strip_all | sort | grep -v NXST_FLOW > ${hv}_t${t}_flows.actual
    AT_CHECK([diff -u ${hv}_t${t}_flows.actual ${hv}_t${t}_flows.expected])
}

check_port_sec_offlows hv1 73
check_port_sec_offlows hv1 74
check_port_sec_offlows hv1 75

check_port_sec_offlows hv2 73
check_port_sec_offlows hv2 74
check_port_sec_offlows hv2 75

# Set port security for sw0p1
check ovn-nbctl --wait=hv lsp-set-port-security sw0p1 "00:00:00:00:00:03"

echo " table=73, priority=80,reg14=0x$sw0p1_key,metadata=0x$sw0_dp_key actions=load:0x1->NXM_NX_REG10[[12]]
 table=73, priority=90,reg14=0x$sw0p1_key,metadata=0x$sw0_dp_key,dl_src=00:00:00:00:00:03 actions=resubmit(,74)
 table=73, priority=95,arp,reg14=0x$sw0p1_key,metadata=0x$sw0_dp_key actions=resubmit(,74)" > hv1_t73_flows.expected

check_port_sec_offlows hv1 73

echo " table=74, priority=80,arp,reg14=0x$sw0p1_key,metadata=0x1 actions=load:0x1->NXM_NX_REG10[[12]]
 table=74, priority=80,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=135 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=80,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=136 actions=load:0x1->NXM_NX_REG10[[12]]
 table=74, priority=90,arp,reg14=0x$sw0p1_key,metadata=0x1,dl_src=00:00:00:00:00:03,arp_sha=00:00:00:00:00:03 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:00 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:03 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=136,icmp_code=0,nd_tll=00:00:00:00:00:00 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=136,icmp_code=0,nd_tll=00:00:00:00:00:03 actions=load:0->NXM_NX_REG10[[12]]" > hv1_t74_flows.expected

check_port_sec_offlows hv1 74

echo " table=75, priority=80,reg15=0x$sw0p1_key,metadata=0x1 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=85,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:03 actions=load:0->NXM_NX_REG10[[12]]" > hv1_t75_flows.expected

check_port_sec_offlows hv1 75

> hv2_t73_flows.expected
> hv2_t74_flows.expected
> hv2_t75_flows.expected

check_port_sec_offlows hv2 73
check_port_sec_offlows hv2 74
check_port_sec_offlows hv2 75

# Add IPv4 addresses to sw0p1
check ovn-nbctl --wait=hv lsp-set-port-security sw0p1 "00:00:00:00:00:03 10.0.0.3" "00:00:00:00:00:13 10.0.0.13"

echo " table=73, priority=80,reg14=0x$sw0p1_key,metadata=0x1 actions=load:0x1->NXM_NX_REG10[[12]]
 table=73, priority=90,ip,reg14=0x$sw0p1_key,metadata=0x1,dl_src=00:00:00:00:00:03,nw_src=10.0.0.3 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=90,ip,reg14=0x$sw0p1_key,metadata=0x1,dl_src=00:00:00:00:00:13,nw_src=10.0.0.13 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=90,udp,reg14=0x$sw0p1_key,metadata=0x1,dl_src=00:00:00:00:00:03,nw_src=0.0.0.0,nw_dst=255.255.255.255,tp_src=68,tp_dst=67 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=90,udp,reg14=0x$sw0p1_key,metadata=0x1,dl_src=00:00:00:00:00:13,nw_src=0.0.0.0,nw_dst=255.255.255.255,tp_src=68,tp_dst=67 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=95,arp,reg14=0x$sw0p1_key,metadata=0x1 actions=resubmit(,74)" > hv1_t73_flows.expected

check_port_sec_offlows hv1 73

echo " table=74, priority=80,arp,reg14=0x$sw0p1_key,metadata=0x1 actions=load:0x1->NXM_NX_REG10[[12]]
 table=74, priority=80,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=135 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=80,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=136 actions=load:0x1->NXM_NX_REG10[[12]]
 table=74, priority=90,arp,reg14=0x$sw0p1_key,metadata=0x1,dl_src=00:00:00:00:00:03,arp_spa=10.0.0.3,arp_sha=00:00:00:00:00:03 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,arp,reg14=0x$sw0p1_key,metadata=0x1,dl_src=00:00:00:00:00:13,arp_spa=10.0.0.13,arp_sha=00:00:00:00:00:13 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:00 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:03 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:13 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=136,icmp_code=0,nd_tll=00:00:00:00:00:00 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=136,icmp_code=0,nd_tll=00:00:00:00:00:03 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p1_key,metadata=0x1,nw_ttl=255,icmp_type=136,icmp_code=0,nd_tll=00:00:00:00:00:13 actions=load:0->NXM_NX_REG10[[12]]" > hv1_t74_flows.expected

check_port_sec_offlows hv1 74

echo " table=75, priority=80,reg15=0x$sw0p1_key,metadata=0x1 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=85,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:03 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=85,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:13 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=90,ip,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:03 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=90,ip,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=90,ipv6,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:03 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=90,ipv6,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:03,nw_dst=10.0.0.3 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:03,nw_dst=224.0.0.0/4 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:03,nw_dst=255.255.255.255 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:13,nw_dst=10.0.0.13 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:13,nw_dst=224.0.0.0/4 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p1_key,metadata=0x1,dl_dst=00:00:00:00:00:13,nw_dst=255.255.255.255 actions=load:0->NXM_NX_REG10[[12]]" > hv1_t75_flows.expected

check_port_sec_offlows hv1 75

check_port_sec_offlows hv2 73
check_port_sec_offlows hv2 74
check_port_sec_offlows hv2 75

# Configure IPv4 and IPv6 addresses in sw0p2
check ovn-nbctl --wait=hv lsp-set-port-security sw0p2 "00:00:00:00:00:04 10.0.0.4 20.0.0.4/24 30.0.0.0/16 1000::4 2000::/64" "00:00:00:00:00:13 aef0::4"

# There should be no changes in hv1 and hv2 as sw0p2 is not claimed.
check_port_sec_offlows hv1 73
check_port_sec_offlows hv1 74
check_port_sec_offlows hv1 75

check_port_sec_offlows hv2 73
check_port_sec_offlows hv2 74
check_port_sec_offlows hv2 75

as hv2
ovs-vsctl -- add-port br-int hv2-vif0 -- \
set Interface hv2-vif0 external-ids:iface-id=sw0p2 ofport-request=1

wait_for_ports_up
# There should be no changes in hv1
check_port_sec_offlows hv1 73
check_port_sec_offlows hv1 74
check_port_sec_offlows hv1 75

#hv2 ovn-controller should program flows.
echo " table=73, priority=80,reg14=0x$sw0p2_key,metadata=0x1 actions=load:0x1->NXM_NX_REG10[[12]]
 table=73, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,ipv6_src=::,ipv6_dst=ff02::/16,icmp_type=131,icmp_code=0 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,ipv6_src=::,ipv6_dst=ff02::/16,icmp_type=135,icmp_code=0 actions=resubmit(,74)
 table=73, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,ipv6_src=::,ipv6_dst=ff02::/16,icmp_type=143,icmp_code=0 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:13,ipv6_src=::,ipv6_dst=ff02::/16,icmp_type=131,icmp_code=0 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:13,ipv6_src=::,ipv6_dst=ff02::/16,icmp_type=135,icmp_code=0 actions=resubmit(,74)
 table=73, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:13,ipv6_src=::,ipv6_dst=ff02::/16,icmp_type=143,icmp_code=0 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=90,ip,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,nw_src=10.0.0.4 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=90,ip,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,nw_src=20.0.0.4 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=90,ip,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,nw_src=30.0.0.0/16 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=90,ipv6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,ipv6_src=1000::4 actions=resubmit(,74)
 table=73, priority=90,ipv6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,ipv6_src=2000::/64 actions=resubmit(,74)
 table=73, priority=90,ipv6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,ipv6_src=fe80::200:ff:fe00:4 actions=resubmit(,74)
 table=73, priority=90,ipv6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:13,ipv6_src=aef0::4 actions=resubmit(,74)
 table=73, priority=90,ipv6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:13,ipv6_src=fe80::200:ff:fe00:13 actions=resubmit(,74)
 table=73, priority=90,udp,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,nw_src=0.0.0.0,nw_dst=255.255.255.255,tp_src=68,tp_dst=67 actions=load:0->NXM_NX_REG10[[12]]
 table=73, priority=95,arp,reg14=0x$sw0p2_key,metadata=0x1 actions=resubmit(,74)" > hv2_t73_flows.expected

check_port_sec_offlows hv2 73

echo " table=74, priority=80,arp,reg14=0x$sw0p2_key,metadata=0x1 actions=load:0x1->NXM_NX_REG10[[12]]
 table=74, priority=80,icmp6,reg14=0x$sw0p2_key,metadata=0x1,nw_ttl=255,icmp_type=135 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=80,icmp6,reg14=0x$sw0p2_key,metadata=0x1,nw_ttl=255,icmp_type=136 actions=load:0x1->NXM_NX_REG10[[12]]
 table=74, priority=90,arp,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,arp_spa=10.0.0.4,arp_sha=00:00:00:00:00:04 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,arp,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,arp_spa=20.0.0.4,arp_sha=00:00:00:00:00:04 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,arp,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,arp_spa=30.0.0.0/16,arp_sha=00:00:00:00:00:04 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,icmp_type=136,icmp_code=0,nd_target=1000::4,nd_tll=00:00:00:00:00:00 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,icmp_type=136,icmp_code=0,nd_target=1000::4,nd_tll=00:00:00:00:00:04 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,icmp_type=136,icmp_code=0,nd_target=2000::/64,nd_tll=00:00:00:00:00:00 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04,icmp_type=136,icmp_code=0,nd_target=2000::/64,nd_tll=00:00:00:00:00:04 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:13,icmp_type=136,icmp_code=0,nd_target=aef0::4,nd_tll=00:00:00:00:00:00 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:13,icmp_type=136,icmp_code=0,nd_target=aef0::4,nd_tll=00:00:00:00:00:13 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,nw_ttl=255,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:00 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,nw_ttl=255,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:04 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,nw_ttl=255,icmp_type=135,icmp_code=0,nd_sll=00:00:00:00:00:13 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,nw_ttl=255,icmp_type=136,icmp_code=0,nd_target=fe80::200:ff:fe00:13,nd_tll=00:00:00:00:00:00 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,nw_ttl=255,icmp_type=136,icmp_code=0,nd_target=fe80::200:ff:fe00:13,nd_tll=00:00:00:00:00:13 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,nw_ttl=255,icmp_type=136,icmp_code=0,nd_target=fe80::200:ff:fe00:4,nd_tll=00:00:00:00:00:00 actions=load:0->NXM_NX_REG10[[12]]
 table=74, priority=90,icmp6,reg14=0x$sw0p2_key,metadata=0x1,nw_ttl=255,icmp_type=136,icmp_code=0,nd_target=fe80::200:ff:fe00:4,nd_tll=00:00:00:00:00:04 actions=load:0->NXM_NX_REG10[[12]]" > hv2_t74_flows.expected

check_port_sec_offlows hv2 74

echo " table=75, priority=80,reg15=0x$sw0p2_key,metadata=0x1 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=85,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=85,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:13 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=90,ip,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=90,ip,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=90,ipv6,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=90,ipv6,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:13 actions=load:0x1->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04,nw_dst=10.0.0.4 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04,nw_dst=20.0.0.255 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04,nw_dst=20.0.0.4 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04,nw_dst=224.0.0.0/4 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04,nw_dst=255.255.255.255 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ip,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04,nw_dst=30.0.0.0/16 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ipv6,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04,ipv6_dst=1000::4 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ipv6,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04,ipv6_dst=2000::/64 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ipv6,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04,ipv6_dst=fe80::200:ff:fe00:4 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ipv6,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:04,ipv6_dst=ff00::/8 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ipv6,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:13,ipv6_dst=aef0::4 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ipv6,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:13,ipv6_dst=fe80::200:ff:fe00:13 actions=load:0->NXM_NX_REG10[[12]]
 table=75, priority=95,ipv6,reg15=0x$sw0p2_key,metadata=0x1,dl_dst=00:00:00:00:00:13,ipv6_dst=ff00::/8 actions=load:0->NXM_NX_REG10[[12]]" > hv2_t75_flows.expected

check_port_sec_offlows hv2 75

check ovn-nbctl --wait=hv lsp-set-port-security sw0p2 ""

check_port_sec_offlows hv1 73
check_port_sec_offlows hv1 74
check_port_sec_offlows hv1 75

> hv2_t73_flows.expected
> hv2_t74_flows.expected
> hv2_t75_flows.expected

check_port_sec_offlows hv2 73
check_port_sec_offlows hv2 74
check_port_sec_offlows hv2 75

check ovn-nbctl --wait=hv lsp-set-port-security sw0p2 "00:00:00:00:00:04"

check_port_sec_offlows hv1 73
check_port_sec_offlows hv1 74
check_port_sec_offlows hv1 75

echo " table=73, priority=80,reg14=0x$sw0p2_key,metadata=0x1 actions=load:0x1->NXM_NX_REG10[[12]]
 table=73, priority=90,reg14=0x$sw0p2_key,metadata=0x1,dl_src=00:00:00:00:00:04 actions=resubmit(,74)
 table=73, priority=95,arp,reg14=0x$sw0p2_key,metadata=0x1 actions=resubmit(,74)" > hv2_t73_flows.expected

check_port_sec_offlows hv2 73

# Delete sw0p2
check ovn-nbctl --wait=hv lsp-del sw0p2

> hv2_t73_flows.expected
> hv2_t74_flows.expected
> hv2_t75_flows.expected

check_port_sec_offlows hv1 73
check_port_sec_offlows hv1 74
check_port_sec_offlows hv1 75

check_port_sec_offlows hv2 73
check_port_sec_offlows hv2 74
check_port_sec_offlows hv2 75

# Release sw0p1 from hv1
as hv1 ovs-vsctl del-port hv1-vif0

wait_column '' Port_Binding chassis logical_port=sw0p1

> hv1_t73_flows.expected
> hv1_t74_flows.expected
> hv1_t75_flows.expected

check_port_sec_offlows hv1 73
check_port_sec_offlows hv1 74
check_port_sec_offlows hv1 75

check_port_sec_offlows hv2 73
check_port_sec_offlows hv2 74
check_port_sec_offlows hv2 75

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

AT_SETUP([snat-ct-zone with common NAT zone])
# This test sets up a couple of simple NATs. OVN will program logical
# flows for ct_snat_in_czone() and ct_dnat_in_czone() as a result. We
# want to ensure that the common zone used by these flows is the DNAT
# zone. Then, we will set the snat-ct-zone option on our datapath and
# ensure that the flows now use the SNAT zone as the common zone.

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl add-port br-int ls0-hv -- set Interface ls0-hv external-ids:iface-id=ls0-hv

check ovn-nbctl lr-add lr0

check ovn-nbctl ls-add ls0
check ovn-nbctl lsp-add ls0 ls0-lr0 
check ovn-nbctl lsp-set-type ls0-lr0 router
check ovn-nbctl lsp-set-addresses ls0-lr0 router
check ovn-nbctl lrp-add lr0 lr0-ls0 00:00:00:00:00:01 10.0.0.1

check ovn-nbctl lsp-add ls0 ls0-hv
check ovn-nbctl lsp-set-addresses ls0-hv "00:00:00:00:00:02 10.0.0.2"

check ovn-nbctl ls-add ext
check ovn-nbctl lsp-add ext ext-lr0
check ovn-nbctl lsp-set-type ext-lr0 router
check ovn-nbctl lsp-set-addresses ext-lr0 router
check ovn-nbctl lrp-add lr0 lr0-ext  00:00:00:00:01:01 20.0.0.1

check ovn-nbctl lrp-set-gateway-chassis lr0-ext hv1

check ovn-nbctl lr-nat-add lr0 snat 172.16.0.2 10.0.0.0/24
check ovn-nbctl lr-nat-add lr0 dnat 172.16.0.2 10.0.0.2

# Use common zone
check ovn-nbctl set nb_global . options:use_common_zone="true"

check ovn-nbctl --wait=hv sync
# Use constants so that if tables or registers change, this test can
# be updated easily.
DNAT_TABLE=15
SNAT_TABLE=45
DNAT_ZONE_REG="NXM_NX_REG11[[0..15]]"
SNAT_ZONE_REG="NXM_NX_REG12[[0..15]]"

lr0_dp_key=$(printf "%x" $(fetch_column Datapath_Binding tunnel_key external_ids:name=lr0))

dnat_zone=$(ovs-ofctl dump-flows br-int table=$DNAT_TABLE,metadata=0x${lr0_dp_key} | grep "nw_dst=172.16.0.2" | grep -o zone=.*, | cut -d '=' -f 2)
if test -n "$dnat_zone"; then
  dnat_zone=${dnat_zone::-1}
fi
snat_zone=$(ovs-ofctl dump-flows br-int table=$SNAT_TABLE,metadata=0x${lr0_dp_key} | grep priority=153 | grep ct_state=-trk | grep -o zone=.*, | cut -d '=' -f 2)
if test -n "$snat_zone"; then
  snat_zone=${snat_zone::-1}
fi
echo d="$dnat_zone" s="$snat_zone" "$DNAT_ZONE_REG" "$DNAT_ZONE_REG"

# For now, we expect that the common zone is the dnat zone

check test "$dnat_zone" = "$DNAT_ZONE_REG"
check test "$snat_zone" = "$DNAT_ZONE_REG"

check ovn-nbctl --wait=hv set logical_router lr0 options:snat-ct-zone=666

dnat_zone=$(ovs-ofctl dump-flows br-int table=$DNAT_TABLE,metadata=0x${lr0_dp_key} | grep "nw_dst=172.16.0.2" | grep -o zone=.*, | cut -d '=' -f 2)
if test -n "$dnat_zone"; then
  dnat_zone=${dnat_zone::-1}
fi
snat_zone=$(ovs-ofctl dump-flows br-int table=$SNAT_TABLE,metadata=0x${lr0_dp_key} | grep priority=153 | grep ct_state=-trk | grep -o zone=.*, | cut -d '=' -f 2)
if test -n "$snat_zone"; then
  snat_zone=${snat_zone::-1}
fi

# Now with an snat-ct-zone set, the common zone is the snat zone

check test "$dnat_zone" = "$SNAT_ZONE_REG"
check test "$snat_zone" = "$SNAT_ZONE_REG"

OVN_CLEANUP([hv1])
AT_CLEANUP

OVN_FOR_EACH_NORTHD([
AT_SETUP([OVN FDB (MAC learning) - Localnet])
ovn_start

net_add n1

AT_CHECK([ovn-nbctl ls-add ls0])

AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])

AT_CHECK([ovn-nbctl lsp-add ls0 vif0])
AT_CHECK([ovn-nbctl lsp-set-addresses vif0 "00:00:00:00:10:10 192.168.10.10"])

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int vif0 -- \
    set interface vif0 external-ids:iface-id=vif0 \
    options:tx_pcap=hv1/vif0-tx.pcap \
    options:rxq_pcap=hv1/vif0-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-phys ext0 -- \
    set interface ext0 \
    options:tx_pcap=hv1/ext0-tx.pcap \
    options:rxq_pcap=hv1/ext0-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external_ids:ovn-bridge-mappings=physnet1:br-phys

send_packet() {
    dev_byte=$1

    src_mac="0000000010$dev_byte"
    src_ip=`ip_to_hex 192 168 10 $dev_byte`
    dst_ip=`ip_to_hex 192 168 10 10`
    dst_mac="000000001010"
    packet=${dst_mac}${src_mac}08004500001c0000000040110000${src_ip}${dst_ip}0035111100080000
    ovs-appctl netdev-dummy/receive ext0 $packet
}

wait_for_ports_up
AT_CHECK([ovn-nbctl --wait=hv sync])

# Learning is disabled, the table should be empty
send_packet 20
AT_CHECK([ovn-nbctl --wait=hv sync])
AT_CHECK([test $(ovn-sbctl list fdb | grep -c "00:00:00:00:10:20") = 0])

# Enable learning on localnet port
AT_CHECK([ovn-nbctl set logical_switch_port ln_port options:localnet_learn_fdb=true])
AT_CHECK([ovn-nbctl --wait=hv sync])
send_packet 20
AT_CHECK([ovn-nbctl --wait=hv sync])
AT_CHECK([test $(ovn-sbctl list fdb | grep -c "00:00:00:00:10:20") = 1])

# Disable learning on localnet port
AT_CHECK([ovn-nbctl set logical_switch_port ln_port options:localnet_learn_fdb=false])
AT_CHECK([ovn-nbctl --wait=hv sync])
send_packet 30
AT_CHECK([ovn-nbctl --wait=hv sync])
AT_CHECK([test $(ovn-sbctl list fdb | grep -c "00:00:00:00:10:30") = 0])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([MAC binding aging])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

net_add n1

AT_CHECK([ovn-nbctl ls-add public])
AT_CHECK([ovn-nbctl ls-add internal])

AT_CHECK([ovn-nbctl lsp-add public ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=physnet1])

AT_CHECK([ovn-nbctl lsp-add public public-gw])
AT_CHECK([ovn-nbctl lsp-set-type public-gw router])
AT_CHECK([ovn-nbctl lsp-set-addresses public-gw 00:00:00:00:10:00 router])
AT_CHECK([ovn-nbctl lsp-set-options public-gw router-port=gw-public])

AT_CHECK([ovn-nbctl lsp-add internal internal-gw])
AT_CHECK([ovn-nbctl lsp-set-type internal-gw router])
AT_CHECK([ovn-nbctl lsp-set-addresses internal-gw 00:00:00:00:20:00 router])
AT_CHECK([ovn-nbctl lsp-set-options internal-gw router-port=gw-internal])

AT_CHECK([ovn-nbctl lsp-add internal vif1])
AT_CHECK([ovn-nbctl lsp-set-addresses vif1 "00:00:00:00:20:10 192.168.20.10"])

AT_CHECK([ovn-nbctl lsp-add internal vif2])
AT_CHECK([ovn-nbctl lsp-set-addresses vif2 "00:00:00:00:20:20 192.168.20.20"])

AT_CHECK([ovn-nbctl lr-add gw])
AT_CHECK([ovn-nbctl lrp-add gw gw-public 00:00:00:00:10:00 192.168.10.1/24])
AT_CHECK([ovn-nbctl lrp-add gw gw-internal 00:00:00:00:20:00 192.168.20.1/24])

sim_add hv1
as hv1
ovs-vsctl add-br br-underlay
ovn_attach n1 br-underlay 192.168.0.1
ovs-vsctl add-br br-phys
ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=vif1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-phys ext1 -- \
    set interface ext1 \
    options:tx_pcap=hv1/ext1-tx.pcap \
    options:rxq_pcap=hv1/ext1-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external_ids:ovn-bridge-mappings=physnet1:br-phys

sim_add hv2
as hv2
ovs-vsctl add-br br-underlay
ovn_attach n1 br-underlay 192.168.0.2
ovs-vsctl add-br br-phys
ovs-vsctl -- add-port br-int vif2 -- \
    set interface vif2 external-ids:iface-id=vif2 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-phys ext2 -- \
    set interface ext2 \
    options:tx_pcap=hv2/ext2-tx.pcap \
    options:rxq_pcap=hv2/ext2-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external_ids:ovn-bridge-mappings=physnet1:br-phys

OVN_POPULATE_ARP
wait_for_ports_up
AT_CHECK([ovn-nbctl --wait=hv sync])

# Wait for pinctrl thread to be connected
OVS_WAIT_UNTIL([grep pinctrl hv1/ovn-controller.log | grep -c connected])
OVS_WAIT_UNTIL([grep pinctrl hv2/ovn-controller.log | grep -c connected])

send_garp() {
    hv=$1
    dev=$2
    mac_byte=$3
    ip_byte=${4-$3}

    mac="00:00:00:00:10:${mac_byte}"
    ip="192.168.10.${ip_byte}"
    packet=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='${mac}')/ \
                      ARP(op=2, hwsrc='${mac}', hwdst='${mac}', \
                      psrc='${ip}', pdst='${ip}')")
    as $hv ovs-appctl netdev-dummy/receive $dev $packet
}

send_udp() {
    hv=$1
    dev=$2
    byte=$3

    packet=$(fmt_pkt "Ether(dst='00:00:00:00:10:00', src='00:00:00:00:10:${byte}')/ \
                      IP(dst='192.168.20.${byte}', src='192.168.10.${byte}')/UDP()")
    as $hv ovs-appctl netdev-dummy/receive $dev $packet
}
# Check if the option is not present by default
AT_CHECK([fetch_column nb:logical_router options name="gw" | grep -q mac_binding_age_threshold], [1])

# Send GARP to populate MAC binding table records
send_garp hv1 ext1 10
send_garp hv2 ext2 20

wait_row_count mac_binding 1 ip="192.168.10.10"
wait_row_count mac_binding 1 ip="192.168.10.20"

dp_key=$(printf "0x%x" $(as hv1 fetch_column datapath tunnel_key external_ids:name=gw))
port_key=$(printf "0x%x" $(as hv1 fetch_column port_binding tunnel_key logical_port=gw-public))

AT_CHECK_UNQUOTED([as hv1 ovs-ofctl dump-flows br-int table=79 --no-stats | strip_cookie | sort], [0], [dnl
 table=79, priority=100,ip,reg14=${port_key},metadata=${dp_key},dl_src=00:00:00:00:10:10,nw_src=192.168.10.10 actions=drop
 table=79, priority=100,ip,reg14=${port_key},metadata=${dp_key},dl_src=00:00:00:00:10:20,nw_src=192.168.10.20 actions=drop
])

timestamp=$(fetch_column mac_binding timestamp ip="192.168.10.20")

send_udp hv1 ext1 10
send_udp hv2 ext2 20

OVS_WAIT_UNTIL([as hv1 ovs-ofctl dump-flows br-int table=79 | grep "192.168.10.10" | grep -q "n_packets=1"])
OVS_WAIT_UNTIL([as hv2 ovs-ofctl dump-flows br-int table=79 | grep "192.168.10.20" | grep -q "n_packets=1"])

# Set the MAC binding aging threshold
AT_CHECK([ovn-nbctl set logical_router gw options:mac_binding_age_threshold=5])
AT_CHECK([fetch_column nb:logical_router options | grep -q mac_binding_age_threshold=5])
AT_CHECK([ovn-nbctl --wait=sb sync])

# Wait send few packets for "192.168.10.20" to indicate that it is still in use
send_udp hv2 ext2 20
sleep 1
send_udp hv2 ext2 20

# Set the timeout for OVS_WAIT* functions to 5 seconds
OVS_CTL_TIMEOUT=10
OVS_WAIT_UNTIL([
    test "$timestamp" != "$(fetch_column mac_binding timestamp ip='192.168.10.20')"
])
check $(test "$(fetch_column mac_binding timestamp ip='192.168.10.20')" != "")

# Check if the records are removed after some inactivity
OVS_WAIT_UNTIL([
    test "0" = "$(ovn-sbctl list mac_binding | grep -c '192.168.10.10')"
])
# The second one takes longer because it got refreshed
OVS_WAIT_UNTIL([
    test "0" = "$(ovn-sbctl list mac_binding | grep -c '192.168.10.20')"
])

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=79 --no-stats | strip_cookie], [0], [])

OVN_CLEANUP([hv1], [hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([router port type update and then remove])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

check ovn-nbctl ls-add sw0
check ovn-nbctl lr-add ro0
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-add sw0 lsp
check ovn-nbctl lsp-set-type lsp router
check ovn-nbctl lsp-set-options lsp router-port=lrp
check ovn-nbctl lsp-set-addresses lsp  00:00:00:00:00:1
check ovn-nbctl lrp-add ro0 lrp 00:00:00:00:00:1 aef0:0:0:0:0:0:0:1/64
check ovn-nbctl set Logical_Router_Port lrp ipv6_ra_configs:send_periodic=true \
        -- set Logical_Router_Port lrp ipv6_ra_configs:address_mode=slaac \
        -- set Logical_Router_Port lrp ipv6_ra_configs:mtu=1280 \
        -- set Logical_Router_Port lrp ipv6_ra_configs:max_interval=2 \
        -- set Logical_Router_Port lrp ipv6_ra_configs:min_interval=1

# The below commands change the LSP from "router" type in order to ensure that
# no incorrect memory accesses occur. The test passes because there is no crash
# in ovn-controller.
check ovn-nbctl lsp-set-type lsp localnet
check ovn-nbctl --wait=hv sync
check ovn-nbctl lsp-del lsp
check ovn-nbctl lrp-del lrp
check ovn-nbctl --wait=hv sync
OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([recomputes])
TAG_UNSTABLE
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n1 br-phys 192.168.0.1 24 geneve

check ovn-nbctl ls-add ls1
check ovn-nbctl set Logical_Switch ls1 other_config:subnet=10.1.0.0/16
check ovn-nbctl set Logical_Switch ls1 other_config:exclude_ips=10.1.255.254

check ovn-nbctl --wait=hv sync

as hv1
lflow_run=$(ovn-appctl -t ovn-controller coverage/read-counter lflow_run)

check ovn-nbctl lsp-add ls1 lsp1
check ovn-nbctl lsp-add ls1 lsp2
check ovn-nbctl --wait=hv sync

# Make sb sleep
AT_CHECK([kill -STOP $(cat ovn-sb/ovsdb-server.pid)])

as hv1
ovs-vsctl --no-wait -- add-port br-int vif1 \
                    -- set Interface vif1 external_ids:iface-id=lsp1
ovs-vsctl --no-wait -- add-port br-int vif2 \
                    -- set Interface vif2 external_ids:iface-id=lsp2

# Check that ovn-controller handled the bindings
OVS_WAIT_UNTIL(
    [test `ovs-appctl -t ovn-controller debug/dump-local-bindings | grep interface | wc -l` -eq 2],
    [kill -CONT $(cat ovn-sb/ovsdb-server.pid)]
)
AT_CHECK([kill -CONT $(cat ovn-sb/ovsdb-server.pid)])

wait_for_ports_up
check ovn-nbctl --wait=hv sync

as hv1
lflow_run_end=$(ovn-appctl -t ovn-controller coverage/read-counter lflow_run)

n_recomputes=`expr $lflow_run_end - $lflow_run`
echo "$n_recomputes recomputes"

AT_CHECK([test $lflow_run_end == $lflow_run])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([router port add then remove - lsp first])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap

check ovn-nbctl ls-add sw0
check ovn-nbctl lr-add ro0
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-add sw0 lsp
check ovn-nbctl lsp-set-type lsp router
check ovn-nbctl lsp-set-options lsp router-port=lrp
check ovn-nbctl lsp-set-addresses lsp  00:00:00:00:00:1
check ovn-nbctl --wait=hv lrp-add ro0 lrp 00:00:00:00:00:1 aef0:0:0:0:0:0:0:1/64
check ovn-nbctl --wait=hv lsp-del lsp
check ovn-nbctl lrp-del lrp
check ovn-nbctl --wait=hv sync
OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([router port add then remove - distributed router gateway port])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p0 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=sw1-p0 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap

ovs-vsctl -- add-port br-int hv2-vif2 -- \
    set interface hv2-vif2 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv2/vif2-tx.pcap \
    options:rxq_pcap=hv2/vif2-rx.pcap

ovn-nbctl create Logical_Router name=lr0
ovn-nbctl ls-add sw0
ovn-nbctl ls-add sw1

ovn-nbctl lrp-add lr0 lr0-sw0 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add sw0 sw0-lr0 -- set Logical_Switch_Port sw0-lr0 \
    type=router options:router-port=lr0-sw0 \
    -- lsp-set-addresses sw0-lr0 router

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-gateway-chassis lr0-sw1 hv2
ovn-nbctl lsp-add sw1 sw1-lr0 -- set Logical_Switch_Port sw1-lr0 \
    type=router options:router-port=lr0-sw1 \
    -- lsp-set-addresses sw1-lr0 router

ovn-nbctl lsp-add sw0 sw0-p0 \
    -- lsp-set-addresses sw0-p0 "f0:00:00:01:02:03 192.168.1.2"

ovn-nbctl lsp-add sw0 sw0-p1 \
    -- lsp-set-addresses sw0-p1 "f0:00:00:11:02:03 192.168.1.3"

ovn-nbctl --wait=hv lsp-add sw1 sw1-p0 \
    -- lsp-set-addresses sw1-p0 unknown

check ovn-nbctl --wait=hv lsp-del sw1-lr0
check ovn-nbctl lrp-del lr0-sw1

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller: deleting a port being claimed])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl add-port br-int p0
check ovs-vsctl add-port br-int p1

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-port0 -- lsp-set-addresses sw0-port0 "50:54:00:00:00:01 192.168.0.2"
ovn-nbctl lsp-add sw0 sw0-port1 -- lsp-set-addresses sw0-port1 "50:54:00:00:00:02 192.168.0.3"
check ovn-nbctl --wait=hv sync

# Pause SB
AT_CHECK([kill -STOP $(cat ovn-sb/ovsdb-server.pid)])

# Make us claim psw0-port0. This will make SB ro
ovs-vsctl set interface p0 external-ids:iface-id=sw0-port0
sleep 0.5
# Make us claim sw0-port1. Claim should be delayed
ovs-vsctl set interface p1 external-ids:iface-id=sw0-port1
# Delete sw0-port1
ovn-nbctl lsp-del sw0-port1
sleep 0.5
# Restart SB
AT_CHECK([kill -CONT $(cat ovn-sb/ovsdb-server.pid)])
check ovn-nbctl --wait=hv sync
ovn-nbctl ls-del sw0
check ovn-nbctl --wait=hv sync
OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller: checking flows after delaying port claims])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl add-port br-int p0
check ovs-vsctl add-port br-int p1

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-port0 -- lsp-set-addresses sw0-port0 "50:54:00:00:00:01 192.168.0.2"
check ovn-nbctl --wait=hv sync
ovn-nbctl lsp-add sw0 sw0-port1 -- lsp-set-addresses sw0-port1 "50:54:00:00:00:02 192.168.0.3"
ovs-vsctl set interface p0 external-ids:iface-id=sw0-port0
ovs-vsctl set interface p1 external-ids:iface-id=sw0-port1
check ovn-nbctl --wait=hv sync
as hv1 ovs-ofctl dump-flows br-int  | sed 's/cookie=0x.*, duration=.*, table/cookie=??, duration=??, table/' | sed 's/load:0x.->NXM_NX_REG1/load:0x?->NXM_NX_REG1/g' | sed 's/idle_age=[[0-9]], //g' | sort > offlows1

ovs-vsctl set interface p0 external-ids:iface-id=foo0
ovs-vsctl set interface p1 external-ids:iface-id=foo1
ovn-nbctl lsp-del sw0-port0
ovn-nbctl lsp-del sw0-port1
ovn-nbctl ls-del sw0
check ovn-nbctl --wait=hv sync

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-port0 -- lsp-set-addresses sw0-port0 "50:54:00:00:00:01 192.168.0.2"
check ovn-nbctl --wait=hv sync
ovn-nbctl lsp-add sw0 sw0-port1 -- lsp-set-addresses sw0-port1 "50:54:00:00:00:02 192.168.0.3"
check ovn-nbctl --wait=hv sync

# Pause SB
AT_CHECK([kill -STOP $(cat ovn-sb/ovsdb-server.pid)])

# Make us claim psw0-port0. This will make SB ro
ovs-vsctl set interface p0 external-ids:iface-id=sw0-port0
sleep 0.5
# Make us claim sw0-port1. Claim should be delayed
ovs-vsctl set interface p1 external-ids:iface-id=sw0-port1
sleep 0.5
# Restart SB
AT_CHECK([kill -CONT $(cat ovn-sb/ovsdb-server.pid)])
check ovn-nbctl --wait=hv sync
as hv1 ovs-ofctl dump-flows br-int | sed 's/cookie=0x.*, duration=.*, table/cookie=??, duration=??, table/' | sed 's/load:0x.->NXM_NX_REG1/load:0x?->NXM_NX_REG1/g' | sed 's/idle_age=[[0-9]], //g' | sort > offlows2
AT_CHECK([diff  offlows1 offlows2])

ovn-nbctl ls-del sw0
check ovn-nbctl --wait=hv sync
OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller: batch add port and delete port in same IDL])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl add-port br-int p1

check ovs-vsctl set interface p1 external-ids:iface-id=sw0-port1
check ovn-nbctl --wait=hv sync
ovn-appctl debug/pause
OVS_WAIT_UNTIL([test x$(as hv1 ovn-appctl -t ovn-controller debug/status) = "xpaused"])

check ovn-nbctl ls-add sw0 -- lsp-add sw0 sw0-port1
check ovn-nbctl lsp-del sw0-port1
check ovn-nbctl --wait=sb sync

ovn-appctl debug/resume
check ovn-nbctl --wait=hv sync

check ovn-nbctl ls-del sw0
check ovn-nbctl --wait=hv sync
OVN_CLEANUP([hv1])
AT_CLEANUP
])

m4_define([MULTIPLE_OVS_INT],
  [OVN_FOR_EACH_NORTHD([
   AT_SETUP([ovn-controller: Multiple OVS interfaces bound to same logical port ($1)])
   ovn_start
   net_add n1

   sim_add hv1
   as hv1
   ovs-vsctl add-br br-phys
   ovn_attach n1 br-phys 192.168.0.1

   get_flows()
   {
       cookie=${1}
       ovs-ofctl dump-flows br-int | grep $cookie |
           sed -e 's/duration=[[0-9.]]*s, //g' |
           sed -e 's/idle_age=[[0-9]]*, //g' |
           sed -e 's/hard_age=[[0-9]]*, //g' |
           sed -e 's/n_packets=[[0-9]]*, //g' |
           sed -e 's/n_bytes=[[0-9]]*, //g'
   }

   check ovn-nbctl ls-add ls
   check ovn-nbctl lsp-add ls lp
   if test X$1 != X; then
       check ovn-nbctl lsp-set-type lp $1
   fi
   check ovn-nbctl lsp-set-addresses lp "00:00:00:01:01:02 192.168.1.2"

   check ovn-nbctl lsp-add ls vm1
   check ovn-nbctl lsp-set-addresses vm1 "00:00:00:01:01:11 192.168.1.11"
   check ovs-vsctl add-port br-int vm1 -- set interface vm1 type=internal external_ids:iface-id=vm1

   check ovn-nbctl --wait=hv sync

   check ovs-vsctl add-port br-int lpold -- set interface lpold type=internal
   check ovs-vsctl set interface lpold external_ids:iface-id=lp

   OVS_WAIT_UNTIL([test x$(ovn-sbctl --bare --columns _uuid find port_binding logical_port=lp) != x])
   echo ======================================================
   echo === Flows after iface-id set for the old interface ===
   echo ======================================================
   COOKIE=$(ovn-sbctl find port_binding logical_port=lp|grep uuid|cut -d: -f2| cut -c1-8 | sed 's/^\s*0\{0,8\}//')

   OVS_WAIT_UNTIL([
       ofport=$(ovs-vsctl --bare --columns ofport find Interface name=lpold)
       ovs-ofctl dump-flows br-int | grep $COOKIE | grep "actions=output:$ofport"
   ])
   nb_flows=`ovs-ofctl dump-flows br-int | grep $COOKIE | wc -l`
   echo $nb_flows "flows after iface-id set for old interface"

   echo ======================================================
   echo === Flows after iface-id set for the new interface ===
   echo ======================================================
   # Set external_ids:iface-id within same transaction as adding the port.
   # This will generally cause ovn-controller to get initially notified of ovs interface changes with ofport == 0.
   check ovs-vsctl add-port br-int lpnew -- set interface lpnew type=internal -- set interface lpnew external_ids:iface-id=lp
   OVS_WAIT_UNTIL([
       ofport=$(ovs-vsctl --bare --columns ofport find Interface name=lpnew)
       ovs-ofctl dump-flows br-int | grep $COOKIE | grep "actions=output:$ofport"
   ])
   check test "$nb_flows" = $(ovs-ofctl dump-flows br-int | grep $COOKIE | wc -l)
   flows_lpnew=$(get_flows $COOKIE)

   echo ======================================================
   echo ======= Flows after old interface is deleted =========
   echo ======================================================
   check ovs-vsctl del-port br-int lpold
   # We do not expect changes, so let's wait for controller to get time to process any update
   check ovn-nbctl --wait=hv sync
   check test "$nb_flows" = $(ovs-ofctl dump-flows br-int | grep $COOKIE | wc -l)
   flows_after_deletion=$(get_flows $COOKIE)
   check test "$flows_lpnew" = "$flows_after_deletion"

   echo ======================================================
   echo ======= Flows after lptemp interface is created ====
   echo ======================================================
   # Set external_ids:iface-id in a different transaction as adding the port.
   # This will generally cause ovn-controller to get notified of ovs interface changes with a proper ofport.
   check ovs-vsctl add-port br-int lptemp -- set Interface lptemp type=internal
   check ovs-vsctl set Interface lptemp external_ids:iface-id=lp
   OVS_WAIT_UNTIL([
       ofport=$(ovs-vsctl --bare --columns ofport find Interface name=lptemp)
       ovs-ofctl dump-flows br-int | grep $COOKIE | grep "actions=output:$ofport"
   ])
   check test "$nb_flows" = $(ovs-ofctl dump-flows br-int | grep $COOKIE | wc -l)

   echo ======================================================
   echo ======= Flows after lptemp interface is deleted ======
   echo ======================================================
   check ovs-vsctl del-port br-int lptemp
   OVS_WAIT_UNTIL([
       ofport=$(ovs-vsctl --bare --columns ofport find Interface name=lpnew)
       echo $ofport
       ovs-ofctl dump-flows br-int  | grep $COOKIE
       ovs-ofctl dump-flows br-int | grep $COOKIE | grep "actions=output:$ofport"
   ])
   check test "$nb_flows" = $(ovs-ofctl dump-flows br-int | grep $COOKIE | wc -l)
   flows_after_deletion=$(get_flows $COOKIE)
   check test "$flows_lpnew" = "$flows_after_deletion"

   echo ======================================================
   echo ======= Flows after new interface is deleted =========
   echo ======================================================
   check ovs-vsctl del-port br-int lpnew
   OVS_WAIT_UNTIL([
       nb_flows=`ovs-ofctl dump-flows br-int | grep $COOKIE | wc -l`
       test "${nb_flows}" = 0
   ])

   echo ======================================================
   echo ======= Three interfaces bound to the same port ======
   echo ======================================================
   check ovs-vsctl add-port br-int lpold -- set interface lpold type=internal
   check ovs-vsctl set interface lpold external_ids:iface-id=lp
   check ovs-vsctl add-port br-int lpnew -- set interface lpnew type=internal
   check ovs-vsctl set interface lpnew external_ids:iface-id=lp

   # Wait for lpnew  flows to be installed
   OVS_WAIT_UNTIL([
       ofport=$(ovs-vsctl --bare --columns ofport find Interface name=lpnew)
       ovs-ofctl dump-flows br-int | grep $COOKIE | grep "actions=output:$ofport"
   ])
   flows_lpnew=$(get_flows $COOKIE)
   nb_flows=`ovs-ofctl dump-flows br-int | grep $COOKIE | wc -l`

   check ovs-vsctl add-port br-int lptemp -- set Interface lptemp type=internal
   check ovs-vsctl set Interface lptemp external_ids:iface-id=lp

   # Wait for lptemp  flows to be installed
   OVS_WAIT_UNTIL([
       ofport=$(ovs-vsctl --bare --columns ofport find Interface name=lptemp)
       ovs-ofctl dump-flows br-int | grep $COOKIE | grep "actions=output:$ofport"
   ])

   # Delete both lpold and lptemp to go to a stable situation
   check ovs-vsctl del-port br-int lptemp
   check ovs-vsctl del-port br-int lpold

   OVS_WAIT_UNTIL([
        test 0 = $(ovs-vsctl show | grep "Port lpold" | wc -l)
   ])

   # Wait for correct/lpnew flows to be installed
   OVS_WAIT_UNTIL([
       ofport=$(ovs-vsctl --bare --columns ofport find Interface name=lpnew)
       ovs-ofctl dump-flows br-int | grep $COOKIE | grep "actions=output:$ofport"
   ])
   check test "$nb_flows" = $(ovs-ofctl dump-flows br-int | grep $COOKIE | wc -l)
   flows_after_deletion=$(get_flows $COOKIE)
   check test "$flows_lpnew" = "$flows_after_deletion"

   # Check that recompute still works
   check ovn-appctl -t ovn-controller recompute
   OVS_WAIT_UNTIL([
       ofport=$(ovs-vsctl --bare --columns ofport find Interface name=lpnew)
       ovs-ofctl dump-flows br-int | grep $COOKIE | grep "actions=output:$ofport"
   ])
   check test "$nb_flows" = $(ovs-ofctl dump-flows br-int | grep $COOKIE | wc -l)
   flows_after_deletion=$(get_flows $COOKIE)
   check test "$flows_lpnew" = "$flows_after_deletion"

   OVN_CLEANUP([hv1])
   AT_CLEANUP
   ])])

MULTIPLE_OVS_INT([localport])
MULTIPLE_OVS_INT([])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Check default openflow flows])
TAG_UNSTABLE
ovn_start

# Check that every table has a default (i.e: priority=0) flow.
# Technically a default flow would have no match but we allow the datapath
# match (metadata=0xXX) to be present.
check_default_flows() {
    ovs-ofctl dump-flows br-int > oflows
    AT_CAPTURE_FILE([oflows])
    for table in $(grep -oP "table=\K\d*, " oflows | tr -d ',' | sort -n | uniq); do
        # Tables 68 and 70 are part of the chk_lb_hairpin and ct_snat_to_vip actions
        # respectively and it's OK if they don't have a default action.
        if test ${table} -eq 68 -o ${table} -eq 70; then
            continue;
        fi
        AT_CHECK([grep -qe "table=$table.* priority=0\(,metadata=0x\w*\)\? actions" oflows], [0], [ignore], [ignore], [echo "Table $table does not contain a default action"])
    done
}

# Check that every drop flow gets sampled.
check_sample_drops() {

    check ovn-nbctl -- remove NB_Global . options debug_drop_collector_set \
                    -- remove NB_Global . options debug_drop_domain_id
    check ovn-nbctl --wait=hv sync

    ovs-ofctl dump-flows --no-stats br-int > oflows_nosample
    AT_CAPTURE_FILE([oflows_nosample])
    # Take match part of flows that contain "drop".
    drop_matches="$(grep 'drop' oflows_nosample | grep -oP 'table=\d*, priority=.* ')"

    ovs-vsctl --id=@br get Bridge br-int --  \
        --id=@i create IPFIX targets=\"192.168.1.1\"  -- \
        create Flow_Sample_Collector_Set bridge=@br id=123 ipfix=@i

    check ovn-nbctl -- set NB_Global . options:debug_drop_collector_set="123" \
                    -- set NB_Global . options:debug_drop_domain_id="1"
    check ovn-nbctl --wait=hv sync

    ovs-ofctl dump-flows --no-stats br-int > oflows_sample
    AT_CAPTURE_FILE([oflows_sample])

    # Check that every drop has now contains a "sample" action.
    save_IFS=$IFS
    IFS=$'\n'
    for flow in $drop_matches; do
        AT_CHECK([grep "${flow}actions=.*sample.*" oflows_sample], [0], [ignore], [ignore], [echo "Flow $flow has a drop and did not get sampled"])
    done
    IFS=$save_IFS
}

check_drops() {
    as hv1
    check_default_flows
    as hv2
    check_default_flows

    as hv1
    check_sample_drops
    as hv2
    check_sample_drops
}

# Logical network:
# Two LRs - R1 and R2 that are connected to each other as peers in 20.0.0.0/24
# network. R1 has a switchs ls1 (191.168.1.0/24) connected to it.
# R2 has ls2 (172.16.1.0/24) connected to it.

ls1_lp1_mac="f0:00:00:01:02:03"
rp_ls1_mac="00:00:00:01:02:03"
rp_ls2_mac="00:00:00:01:02:04"
ls2_lp1_mac="f0:00:00:01:02:04"

ls1_lp1_ip="192.168.1.2"
ls2_lp1_ip="172.16.1.2"

ovn-nbctl lr-add R1
ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2

# Connect ls1 to R1
ovn-nbctl lrp-add R1 ls1 $rp_ls1_mac 192.168.1.1/24

ovn-nbctl lsp-add ls1 rp-ls1 -- set Logical_Switch_Port rp-ls1 type=router \
  options:router-port=ls1 addresses=\"$rp_ls1_mac\"

# Connect ls2 to R1
ovn-nbctl lrp-add R1 ls2 $rp_ls2_mac 172.16.1.1/24

ovn-nbctl lsp-add ls2 rp-ls2 -- set Logical_Switch_Port rp-ls2 type=router \
  options:router-port=ls2 addresses=\"$rp_ls2_mac\"

# Create logical port ls1-lp1 in ls1
ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "$ls1_lp1_mac $ls1_lp1_ip"

# Create logical port ls2-lp1 in ls2
ovn-nbctl lsp-add ls2 ls2-lp1 \
-- lsp-set-addresses ls2-lp1 "$ls2_lp1_mac $ls2_lp1_ip"

# Create two hypervisor and create OVS ports corresponding to logical ports.
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2
ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=ls2-lp1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap \
    ofport-request=1


# Allow some time for ovn-northd and ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

check_debug

# Add stateless ACL
check ovn-nbctl --wait=sb \
                -- acl-add ls1 from-lport 100 'ip4' allow-stateless
check ovn-nbctl --wait=sb \
                -- acl-add ls2 from-lport 100 'ip4' allow-stateless

check_debug

check ovn-nbctl --wait=sb acl-del ls1
check ovn-nbctl --wait=sb acl-del ls2

# Add stateful ACL
check ovn-nbctl --wait=sb \
                -- acl-add ls1 from-lport 100 "udp" allow-related
check ovn-nbctl --wait=sb \
                -- acl-add ls2 from-lport 100 "udp" allow-related

check_debug

check ovn-nbctl --wait=sb acl-del ls1
check ovn-nbctl --wait=sb acl-del ls2

# Add LB
check ovn-nbctl --wait=sb \
    -- lb-add lb1 "10.0.0.1" "10.0.0.2" \
    -- ls-lb-add ls1 lb1

check ovn-nbctl --wait=sb \
    -- lb-add lb2 "10.0.1.1" "10.0.1.2" \
    -- ls-lb-add ls2 lb2

check_drops

# LB + stateless ACL
check ovn-nbctl --wait=sb \
                -- acl-add ls1 from-lport 100 'ip4' allow-stateless
check ovn-nbctl --wait=sb \
                -- acl-add ls2 from-lport 100 'ip4' allow-stateless

check_drops

check ovn-nbctl --wait=sb acl-del ls1
check ovn-nbctl --wait=sb acl-del ls2

# LB + stateful ACL
check ovn-nbctl --wait=sb \
                -- acl-add ls1 from-lport 100 "udp" allow-related
check ovn-nbctl --wait=sb \
                -- acl-add ls2 from-lport 100 "udp" allow-related

check_drops

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Logical flows with Chassis_Template_Var references])
AT_KEYWORDS([templates])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl ls-add sw

dnl Use --wait=sb to ensure lsp1 getting a tunnel_key before lsp2.
check ovn-nbctl --wait=sb lsp-add sw lsp1
check ovn-nbctl --wait=sb lsp-add sw lsp2

AT_CHECK([ovn-nbctl create Chassis_Template_Var chassis=hv1], [0], [ignore])

check ovn-nbctl pg-add pg1 lsp1 lsp2
AT_CHECK([ovn-nbctl create address_set name=as1 addresses=\"1.1.1.1\",\"1.1.1.2\"], [0], [ignore])

dnl Create an ACL that uses an "uninstantiated" template.
check ovn-nbctl acl-add sw from-lport 1 "ip4.src == 42.42.42.42 && ^CONDITION" allow

check ovs-vsctl add-port br-int p1 -- set interface p1 external_ids:iface-id=lsp1
check ovs-vsctl add-port br-int p2 -- set interface p2 external_ids:iface-id=lsp2

wait_for_ports_up
ovn-nbctl --wait=hv sync

dnl Ensure the ACL is not translated to OpenFlow.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep '42\.42\.42\.42'], [1], [])

dnl Create a Chassis_Template_Var mapping for CONDITION.
check ovn-nbctl --wait=hv set Chassis_Template_Var hv1 variables:CONDITION='inport == @pg1'

lsp1=0x$(fetch_column Port_Binding tunnel_key logical_port=lsp1)
lsp2=0x$(fetch_column Port_Binding tunnel_key logical_port=lsp2)

dnl Ensure the ACL is translated to OpenFlows expanding pg1.
as hv1
AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int | grep '42\.42\.42\.42' | ofctl_strip_all], [0], [dnl
 table=16, priority=1001,ip,reg14=$lsp1,metadata=0x1,nw_src=42.42.42.42 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,17)
 table=16, priority=1001,ip,reg14=$lsp2,metadata=0x1,nw_src=42.42.42.42 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,17)
])

dnl Remove a port from pg1 and expect OpenFlows to be correctly updated.
check ovn-nbctl --wait=hv pg-set-ports pg1 lsp2
AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int | grep '42\.42\.42\.42' | ofctl_strip_all], [0], [dnl
 table=16, priority=1001,ip,reg14=$lsp2,metadata=0x1,nw_src=42.42.42.42 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,17)
])

dnl Change the Chassis_Template_Var mapping to use the address set.
check ovn-nbctl --wait=hv set Chassis_Template_Var hv1 variables:CONDITION='ip4.dst == $as1'

dnl Ensure the ACL is translated to OpenFlows expanding as1.
as hv1
AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int | grep '42\.42\.42\.42' | ofctl_strip_all], [0], [dnl
 table=16, priority=1001,ip,metadata=0x1,nw_src=42.42.42.42,nw_dst=1.1.1.1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,17)
 table=16, priority=1001,ip,metadata=0x1,nw_src=42.42.42.42,nw_dst=1.1.1.2 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,17)
])

dnl Remove an IP from AS1 and expect OpenFlows to be correctly updated.
check ovn-nbctl --wait=hv set address_set as1 addresses=\"1.1.1.1\"
AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int | grep '42\.42\.42\.42' | ofctl_strip_all], [0], [dnl
 table=16, priority=1001,ip,metadata=0x1,nw_src=42.42.42.42,nw_dst=1.1.1.1 actions=load:0x1->OXM_OF_PKT_REG4[[48]],resubmit(,17)
])

dnl Remove the mapping and expect OpenFlows to be removed.
check ovn-nbctl --wait=hv clear Chassis_Template_Var hv1 variables
AT_CHECK([ovs-ofctl dump-flows br-int | grep '42\.42\.42\.42'], [1], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load balancers with Chassis_Template_Var references])
AT_KEYWORDS([templates])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl ls-add sw

dnl Use --wait=sb to ensure lsp1 getting a tunnel_key before lsp2.
check ovn-nbctl --wait=sb lsp-add sw lsp1
check ovn-nbctl --wait=sb lsp-add sw lsp2

AT_CHECK([ovn-nbctl create Chassis_Template_Var chassis=hv1], [0], [ignore])

dnl Create a few LBs that use "uninstantiated" templates.
check ovn-nbctl --template lb-add lb-test1 "^VIP1:^VPORT1" "^BACKENDS1" tcp
check ovn-nbctl --template lb-add lb-test2 "^VIP2:^VPORT2" "^BACKENDS21,^BACKENDS22" tcp
check ovn-nbctl --template lb-add lb-test3 "^VIP3:^VPORT3" "^BACKENDS31:^BPORT1,^BACKENDS32:^BPORT2" tcp
check ovn-nbctl --template lb-add lb-test4 "^VIP4:^VPORT4" "^BACKENDS41,^BACKENDS42" tcp
check ovn-nbctl ls-lb-add sw lb-test1
check ovn-nbctl ls-lb-add sw lb-test2
check ovn-nbctl ls-lb-add sw lb-test3
check ovn-nbctl ls-lb-add sw lb-test4

check ovs-vsctl add-port br-int p1 -- set interface p1 external_ids:iface-id=lsp1
check ovs-vsctl add-port br-int p2 -- set interface p2 external_ids:iface-id=lsp2

wait_for_ports_up
ovn-nbctl --wait=hv sync

dnl Ensure the LBs are not translated to OpenFlow.
as hv1
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat'], [1], [])

dnl Create Chassis_Template_Var mappings.
check ovn-nbctl --wait=hv set Chassis_Template_Var hv1 \
    variables:VIP1='43.43.43.1' variables:VPORT1='4301' \
    variables:BACKENDS1='85.85.85.1:8501' \
    variables:VIP2='43.43.43.2' variables:VPORT2='4302' \
    variables:BACKENDS21='85.85.85.21:8502' \
    variables:BACKENDS22='85.85.85.22:8502' \
    variables:VIP3='43.43.43.3' variables:VPORT3='4303' \
    variables:BACKENDS31='85.85.85.31' \
    variables:BACKENDS32='85.85.85.32' \
    variables:BPORT1='8503' variables:BPORT2='8503' \
    variables:VIP4='43.43.43.4' variables:VPORT4='4304' \
    variables:BACKENDS41='85.85.85.41:8504,85.85.85.42:8504' \
    variables:BACKENDS42='85.85.85.43:8504,85.85.85.44:8504'

dnl Ensure the LBs are translated to OpenFlow.
as hv1
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=85.85.85.1:8501)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=85.85.85.21:8502)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=85.85.85.22:8502)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=85.85.85.31:8503)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=85.85.85.32:8503)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=85.85.85.41:8504)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=85.85.85.42:8504)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=85.85.85.43:8504)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=85.85.85.44:8504)' -c], [0], [dnl
1
])

dnl Ensure hairpin flows are correct.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep table=68 | ofctl_strip_all], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2b2b2b01,reg2=0x10cd/0xffff,nw_src=85.85.85.1,nw_dst=85.85.85.1,tp_dst=8501 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=43.43.43.1,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2b2b2b02,reg2=0x10ce/0xffff,nw_src=85.85.85.21,nw_dst=85.85.85.21,tp_dst=8502 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=43.43.43.2,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2b2b2b02,reg2=0x10ce/0xffff,nw_src=85.85.85.22,nw_dst=85.85.85.22,tp_dst=8502 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=43.43.43.2,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2b2b2b03,reg2=0x10cf/0xffff,nw_src=85.85.85.31,nw_dst=85.85.85.31,tp_dst=8503 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=43.43.43.3,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2b2b2b03,reg2=0x10cf/0xffff,nw_src=85.85.85.32,nw_dst=85.85.85.32,tp_dst=8503 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=43.43.43.3,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2b2b2b04,reg2=0x10d0/0xffff,nw_src=85.85.85.41,nw_dst=85.85.85.41,tp_dst=8504 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=43.43.43.4,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2b2b2b04,reg2=0x10d0/0xffff,nw_src=85.85.85.42,nw_dst=85.85.85.42,tp_dst=8504 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=43.43.43.4,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2b2b2b04,reg2=0x10d0/0xffff,nw_src=85.85.85.43,nw_dst=85.85.85.43,tp_dst=8504 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=43.43.43.4,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2b2b2b04,reg2=0x10d0/0xffff,nw_src=85.85.85.44,nw_dst=85.85.85.44,tp_dst=8504 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=43.43.43.4,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

dnl Change Chassis_Template_Var mappings
check ovn-nbctl --wait=hv set Chassis_Template_Var hv1 \
    variables:VIP1='42.42.42.1' variables:VPORT1='4201' \
    variables:BACKENDS1='84.84.84.1:8401' \
    variables:VIP2='42.42.42.2' variables:VPORT2='4202' \
    variables:BACKENDS21='84.84.84.21:8402' \
    variables:BACKENDS22='84.84.84.22:8402' \
    variables:VIP3='42.42.42.3' variables:VPORT3='4203' \
    variables:BACKENDS31='84.84.84.31' \
    variables:BACKENDS32='84.84.84.32' \
    variables:BPORT1='8403' variables:BPORT2='8403' \
    variables:VIP4='42.42.42.4' variables:VPORT4='4204' \
    variables:BACKENDS41='84.84.84.41:8404,84.84.84.42:8404' \
    variables:BACKENDS42='84.84.84.43:8404,84.84.84.44:8404'

dnl Ensure the LBs are translated to OpenFlow.
as hv1
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=84.84.84.1:8401)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=84.84.84.21:8402)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=84.84.84.22:8402)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=84.84.84.31:8403)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=84.84.84.32:8403)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=84.84.84.41:8404)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=84.84.84.42:8404)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=84.84.84.43:8404)' -c], [0], [dnl
1
])
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat(dst=84.84.84.44:8404)' -c], [0], [dnl
1
])

dnl Ensure hairpin flows are correct.
as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep table=68 | ofctl_strip_all], [0], [dnl
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2a2a2a01,reg2=0x1069/0xffff,nw_src=84.84.84.1,nw_dst=84.84.84.1,tp_dst=8401 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=42.42.42.1,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2a2a2a02,reg2=0x106a/0xffff,nw_src=84.84.84.21,nw_dst=84.84.84.21,tp_dst=8402 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=42.42.42.2,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2a2a2a02,reg2=0x106a/0xffff,nw_src=84.84.84.22,nw_dst=84.84.84.22,tp_dst=8402 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=42.42.42.2,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2a2a2a03,reg2=0x106b/0xffff,nw_src=84.84.84.31,nw_dst=84.84.84.31,tp_dst=8403 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=42.42.42.3,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2a2a2a03,reg2=0x106b/0xffff,nw_src=84.84.84.32,nw_dst=84.84.84.32,tp_dst=8403 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=42.42.42.3,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2a2a2a04,reg2=0x106c/0xffff,nw_src=84.84.84.41,nw_dst=84.84.84.41,tp_dst=8404 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=42.42.42.4,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2a2a2a04,reg2=0x106c/0xffff,nw_src=84.84.84.42,nw_dst=84.84.84.42,tp_dst=8404 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=42.42.42.4,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2a2a2a04,reg2=0x106c/0xffff,nw_src=84.84.84.43,nw_dst=84.84.84.43,tp_dst=8404 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=42.42.42.4,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
 table=68, priority=100,ct_mark=0x2/0x2,tcp,reg1=0x2a2a2a04,reg2=0x106c/0xffff,nw_src=84.84.84.44,nw_dst=84.84.84.44,tp_dst=8404 actions=load:0x1->NXM_NX_REG10[[7]],learn(table=69,delete_learned,OXM_OF_METADATA[[]],eth_type=0x800,NXM_OF_IP_SRC[[]],ip_dst=42.42.42.4,nw_proto=6,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],load:0x1->NXM_NX_REG10[[7]])
])

dnl Remove Chassis_Template_Variables and check that everything is
dnl removed from OpenFlow.
check ovn-nbctl --wait=hv clear Chassis_Template_Var hv1 variables

as hv1
AT_CHECK([ovs-ofctl dump-groups br-int | grep 'nat'], [1], [])

as hv1
AT_CHECK([ovs-ofctl dump-flows br-int | grep table=68 | ofctl_strip_all], [0], [])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-chassis-idx maintenance in ovsdb])
ovn_start
net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys

# check that chassis index is unset before ovn-controller is started
AT_CHECK([ovs-vsctl get Open_vSwitch . other_config:ovn-chassis-idx-hv1], [1], [ignore], [ignore])

ovn_attach n1 br-phys 192.168.0.1

# check that chassis index is set now that ovn-controller is running
OVS_WAIT_UNTIL([ovs-vsctl get Open_vSwitch . other_config:ovn-chassis-idx-hv1])
OVS_WAIT_UNTIL([test x$(ovs-vsctl get Open_vSwitch . other_config:ovn-chassis-idx-hv1) = 'x""'])

# exit ovn-controller which should clean up allocated index in the database
OVS_APP_EXIT_AND_WAIT([ovn-controller])

# check that chassis index is unset since ovn-controller cleaned it up
OVS_WAIT_UNTIL([ovs-vsctl get Open_vSwitch . other_config:ovn-chassis-idx-hv1; test $? -eq 1])

# clean up the rest of services on hv1
OVN_CLEANUP_VSWITCH([hv1])

# tear down main services
OVN_CLEANUP

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([chassis-specific configuration options])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys

ovs-vsctl \
    -- set Open_vSwitch . external-ids:ovn-encap-type-hv3=geneve \
    -- set Open_vSwitch . external-ids:ovn-encap-ip-hv3=192.168.1.1

as hv1 ovs-vsctl set-ssl \
   $PKIDIR/testpki-hv3-privkey.pem \
   $PKIDIR/testpki-hv3-cert.pem \
   $PKIDIR/testpki-cacert.pem

ovn_attach n1 br-phys 192.168.0.1 24 vxlan hv3

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2 24 geneve

# despite that we configured ovn-encap-ip=192.168.0.1, this setting is
# overridden by chassis specific ovn-encap-ip-hv3
wait_column 192.168.1.1 Encap ip chassis_name=hv3 type=geneve

check_column "" Encap ip chassis_name=hv1 type=vxlan

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([chassis name override via file])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys

ovs-vsctl \
    -- set Open_vSwitch . external-ids:ovn-encap-type-hv3=geneve \
    -- set Open_vSwitch . external-ids:ovn-encap-ip-hv3=192.168.1.1

as hv1 ovs-vsctl set-ssl \
   $PKIDIR/testpki-hv3-privkey.pem \
   $PKIDIR/testpki-hv3-cert.pem \
   $PKIDIR/testpki-cacert.pem

echo hv3 > ${OVN_SYSCONFDIR}/system-id-override
ovn_attach n1 br-phys 192.168.0.1 24 vxlan

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2 24 geneve

# despite that we configured ovn-encap-ip=192.168.0.1, this setting is
# overridden by chassis specific ovn-encap-ip-hv3
wait_column 192.168.1.1 Encap ip chassis_name=hv3 type=geneve

check_column "" Encap ip chassis_name=hv1 type=vxlan

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([chassis name override via CLI])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys

ovs-vsctl \
    -- set Open_vSwitch . external-ids:ovn-encap-type-hv3=geneve \
    -- set Open_vSwitch . external-ids:ovn-encap-ip-hv3=192.168.1.1

as hv1 ovs-vsctl set-ssl \
   $PKIDIR/testpki-hv3-privkey.pem \
   $PKIDIR/testpki-hv3-cert.pem \
   $PKIDIR/testpki-cacert.pem

# also validate that even with the override file present, CLI takes precedence
echo hv3 > ${OVN_SYSCONFDIR}/test_hv

# the last argument is passed to ovn-controller through cli
ovn_attach n1 br-phys 192.168.0.1 24 vxlan hv1 hv3

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2 24 geneve

# despite that we configured ovn-encap-ip=192.168.0.1, this setting is
# overridden by chassis specific ovn-encap-ip-hv3
wait_column 192.168.1.1 Encap ip chassis_name=hv3 type=geneve

check_column "" Encap ip chassis_name=hv1 type=vxlan

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([controllers don't touch tunnels that are not on br-int])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys1
ovn_attach n1 br-phys1 192.168.0.1

# use a port as a canary in the mine to wait until the controller is up
# (meaning, ssl configuration was read from the database)
ovn-nbctl ls-add ls
ovn-nbctl lsp-add ls lp
ovn-nbctl lsp-set-options lp requested-chassis=hv1
ovs-vsctl -- add-port br-int vif -- \
    set interface vif external-ids:iface-id=lp
wait_for_ports_up
ovn-nbctl --wait=hv sync

# the file is read once at startup so it's safe to write it
# here after the first ovn-controller has started
echo hv2 > ${OVN_SYSCONFDIR}/system-id-override
ovs-vsctl add-br br-phys2

# for some reason SSL ovsdb configuration overrides CLI, so
# delete ssl config from ovsdb to give CLI arguments priority
ovs-vsctl del-ssl

start_virtual_controller n1 br-phys2 br-int-2 192.168.0.2 24 geneve,vxlan hv2 \
    --pidfile=${OVS_RUNDIR}/ovn-controller-2.pid \
    --log-file=${OVS_RUNDIR}/ovn-controller-2.log \
    -p $PKIDIR/testpki-hv2-privkey.pem \
    -c $PKIDIR/testpki-hv2-cert.pem \
    -C $PKIDIR/testpki-cacert.pem
pidfile="$OVS_RUNDIR"/ovn-controller-2.pid
on_exit "test -e \"$pidfile\" && kill \`cat \"$pidfile\"\`"

ovn-nbctl lsp-add ls lp2
ovn-nbctl lsp-set-options lp2 requested-chassis=hv2
ovs-vsctl -- add-port br-int-2 vif2 -- \
    set interface vif2 external-ids:iface-id=lp2
wait_for_ports_up
ovn-nbctl --wait=hv sync

# check that both tunnel ports are present, meaning controllers
# don't step on each other
ovs-vsctl show
OVS_WAIT_UNTIL([
    test 1 = $(ovs-vsctl --columns _uuid --bare find Port name=ovn0-hv1-0 | wc -l)
])
OVS_WAIT_UNTIL([
    test 1 = $(ovs-vsctl --columns _uuid --bare find Port name=ovn-hv2-0 | wc -l)
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller deletes OVN patch ports for its integration bridge only])
ovn_start
net_add n1

sim_add hv1
as hv1

# prepare OVN patch ports on both "integration" bridges
ovs-vsctl add-br br-phys
ovs-vsctl add-br br-int
ovs-vsctl -- add-port br-int fake-int-to-phys -- \
    set port fake-int-to-phys external-ids:ovn-localnet-port=fake-port -- \
    set interface fake-int-to-phys options:peer=fake-phys-to-int type=patch
ovs-vsctl -- add-port br-phys fake-phys-to-int -- \
    set port fake-phys-to-int external-ids:ovn-localnet-port=fake-port -- \
    set interface fake-phys-to-int options:peer=fake-int-to-phys type=patch

ovs-vsctl add-br br-phys-2
ovs-vsctl add-br br-int-2
ovs-vsctl -- add-port br-int-2 fake-int-2-to-phys-2 -- \
    set port fake-int-2-to-phys-2 external-ids:ovn-localnet-port=fake-port-2 -- \
    set interface fake-int-2-to-phys-2 options:peer=fake-phys-2-to-int-2 type=patch
ovs-vsctl -- add-port br-phys-2 fake-phys-2-to-int-2 -- \
    set port fake-phys-2-to-int-2 external-ids:ovn-localnet-port=fake-port-2 -- \
    set interface fake-phys-2-to-int-2 options:peer=fake-int-2-to-phys-2 type=patch

ovn_attach n1 br-phys 192.168.1.1 24

# allow controller to immediately clean patch ports up
check ovn-appctl -t ovn-controller debug/ignore-startup-delay

# check that patch port on br-int is cleaned up (and also its peer)
OVS_WAIT_UNTIL([
    test 0 = $(ovs-vsctl --columns _uuid --bare find Port name=fake-int-to-phys | wc -l)
])
OVS_WAIT_UNTIL([
    test 0 = $(ovs-vsctl --columns _uuid --bare find Port name=fake-phys-to-int | wc -l)
])

# check that patch port on a different bridge is not touched
OVS_WAIT_UNTIL([
    test 1 = $(ovs-vsctl --columns _uuid --bare find Port name=fake-int-2-to-phys-2 | wc -l)
])
OVS_WAIT_UNTIL([
    test 1 = $(ovs-vsctl --columns _uuid --bare find Port name=fake-phys-2-to-int-2 | wc -l)
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# NOTE: This test case runs two ovn-controllers inside the same sandbox (hv1).
# Each controller uses a unique chassis name - hv1 and hv2 - and manage
# different bridges with different ports. This is why all 'as' commands below
# are executed from the same - hv1 - sandbox, regardless of whether they
# logically belong to ports of chassis named hv1 or hv2.
OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple controllers on the same host can talk to each other])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys-1
ovs-vsctl set open . external-ids:ovn-bridge-mappings-hv1=phys:br-phys-1

ovn_attach n1 br-phys-1 192.168.1.1 24

# Disable local ARP responder to pass ARP requests through tunnels
check ovn-nbctl \
    ls-add ls \
    -- add Logical_Switch ls other_config vlan-passthru=true
ovn-nbctl lsp-add ls lp1
ovn-nbctl lsp-set-addresses lp1 "00:00:00:00:00:01 10.0.0.1"

ovn-nbctl lsp-add ls ln_port
ovn-nbctl lsp-set-addresses ln_port unknown
ovn-nbctl lsp-set-type ln_port localnet
ovn-nbctl lsp-set-options ln_port network_name=phys

ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=lp1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap

reset_env() {
    as hv1 reset_pcap_file vif1 hv1/vif1
    as hv1 reset_pcap_file vif2 hv1/vif2
    for port in hv1/vif1 hv1/vif2; do
        : > $port.expected
    done
}

check_packets() {
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv1/vif1-tx.pcap], [hv1/vif1.expected])
    OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv1/vif2-tx.pcap], [hv1/vif2.expected])
}

send_arp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as ${hv} ovs-appctl netdev-dummy/receive $inport $request
    echo "${request}"
}

wait_for_ports_up
ovn-nbctl --wait=hv sync

# now start the second virtual controller
ovs-vsctl add-br br-phys-2
ovs-vsctl set open . external-ids:ovn-bridge-mappings-hv2=phys:br-phys-2

ovn-nbctl lsp-add ls lp2
ovn-nbctl lsp-set-addresses lp2 "00:00:00:00:00:02 10.0.0.2"

# the file is read once at startup so it's safe to write it
# here after the first ovn-controller has started
echo hv2 > ${OVN_SYSCONFDIR}/system-id-override

# for some reason SSL ovsdb configuration overrides CLI, so
# delete ssl config from ovsdb to give CLI arguments priority
ovs-vsctl del-ssl

start_virtual_controller n1 br-phys-2 br-int-2 192.168.2.1 24 geneve,vxlan hv2 \
    --pidfile=${OVS_RUNDIR}/ovn-controller-2.pid \
    --log-file=${OVS_RUNDIR}/ovn-controller-2.log \
    -p $PKIDIR/testpki-hv2-privkey.pem \
    -c $PKIDIR/testpki-hv2-cert.pem \
    -C $PKIDIR/testpki-cacert.pem
pidfile="$OVS_RUNDIR"/ovn-controller-2.pid
on_exit "test -e \"$pidfile\" && kill \`cat \"$pidfile\"\`"

ovs-vsctl -- add-port br-int-2 vif2 -- \
    set interface vif2 external-ids:iface-id=lp2 \
    options:tx_pcap=hv1/vif2-tx.pcap \
    options:rxq_pcap=hv1/vif2-rx.pcap

wait_for_ports_up
ovn-nbctl --wait=hv sync

OVN_POPULATE_ARP

reset_env

lp1_spa=$(ip_to_hex 10 0 0 1)
lp2_spa=$(ip_to_hex 10 0 0 2)
request=$(send_arp hv1 vif1 000000000001 000000000002 $lp1_spa $lp2_spa)
echo $request >> hv1/vif2.expected
request=$(send_arp hv1 vif2 000000000002 000000000001 $lp2_spa $lp1_spa)
echo $request >> hv1/vif1.expected

check_packets

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([CT flush load balancer backends])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-appctl vlog/set ofctrl:dbg

check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw lsp1
check ovs-vsctl add-port br-int p1 -- set interface p1 external_ids:iface-id=lsp1

wait_for_ports_up
ovn-nbctl --wait=hv sync

check ovn-nbctl lb-add lb1 "192.168.0.10" "192.168.10.10,192.168.10.20" \
    -- set load_balancer lb1 options:ct_flush="true"
check ovn-nbctl --wait=hv ls-lb-add sw lb1

# Remove a single backend
check ovn-nbctl set load_balancer lb1 vips='"192.168.0.10"="192.168.10.10"'
check ovn-nbctl --wait=hv sync

AT_CHECK([grep -q "Flushing CT for 5-tuple: vip=192.168.0.10:0, backend=192.168.10.20:0, protocol=0" hv1/ovn-controller.log], [0])

# Add a new backend (there shouldn't be any flush)
check ovn-nbctl set load_balancer lb1 vips='"192.168.0.10"="192.168.10.10,192.168.10.30"'
check ovn-nbctl --wait=hv sync

AT_CHECK([test "$(grep -c "Flushing CT for 5-tuple" hv1/ovn-controller.log)" = "1"], [0])

# Remove the whole LB
check ovn-nbctl lb-del lb1
check ovn-nbctl --wait=hv sync

AT_CHECK([grep -q "Flushing CT for 5-tuple: vip=192.168.0.10:0, backend=192.168.10.10:0, protocol=0" hv1/ovn-controller.log], [0])
AT_CHECK([grep -q "Flushing CT for 5-tuple: vip=192.168.0.10:0, backend=192.168.10.30:0, protocol=0" hv1/ovn-controller.log], [0])

# Check flush for LB with port and protocol
check ovn-nbctl lb-add lb1 "192.168.30.10:80" "192.168.40.10:8080,192.168.40.20:8090" udp \
    -- set load_balancer lb1 options:ct_flush="true"
check ovn-nbctl --wait=hv ls-lb-add sw lb1
check ovn-nbctl --wait=hv lb-del lb1

AT_CHECK([grep -q "Flushing CT for 5-tuple: vip=192.168.30.10:80, backend=192.168.40.10:8080, protocol=17" hv1/ovn-controller.log], [0])
AT_CHECK([grep -q "Flushing CT for 5-tuple: vip=192.168.30.10:80, backend=192.168.40.20:8090, protocol=17" hv1/ovn-controller.log], [0])

# Check recompute when LB is no longer local
check ovn-nbctl lb-add lb1 "192.168.50.10:80" "192.168.60.10:8080" \
    -- set load_balancer lb1 options:ct_flush="true"

# Make sure (with wait=hv) that lb1 change reached ovn-controller before recompute
check ovn-nbctl --wait=hv ls-lb-add sw lb1

check ovs-vsctl remove interface p1 external_ids iface-id
check ovn-appctl inc-engine/recompute
check ovn-nbctl --wait=hv sync

AT_CHECK([grep -q "Flushing CT for 5-tuple: vip=192.168.50.10:80, backend=192.168.60.10:8080, protocol=6" hv1/ovn-controller.log], [0])

AT_CHECK([test "$(grep -c "Flushing CT for 5-tuple" hv1/ovn-controller.log)" = "6"], [0])

# Check if CT flush is disabled by default
check ovn-nbctl --wait=hv lb-del lb1
check ovn-nbctl lb-add lb1 "192.168.70.10:80" "192.168.80.10:8080,192.168.90.10:8080"
check ovn-nbctl ls-lb-add sw lb1
check ovs-vsctl set interface p1 external_ids:iface-id=lsp1
check ovn-nbctl --wait=hv sync

AT_CHECK([test "$(grep -c "Flushing CT for 5-tuple" hv1/ovn-controller.log)" = "6"], [0])

# Remove one backend
check ovn-nbctl --wait=hv set load_balancer lb1 vips='"192.168.70.10:80"="192.168.80.10:8080"'

AT_CHECK([grep -q "Flushing CT for 5-tuple: vip=192.168.70.10:80, backend=192.168.90.10:8080, protocol=6" hv1/ovn-controller.log], [1])
AT_CHECK([test "$(grep -c "Flushing CT for 5-tuple" hv1/ovn-controller.log)" = "6"], [0])

check ovn-nbctl --wait=hv lb-del lb1
AT_CHECK([grep -q "Flushing CT for 5-tuple: vip=192.168.70.10:80, backend=192.168.80.10:8080, protocol=6" hv1/ovn-controller.log], [1])
AT_CHECK([test "$(grep -c "Flushing CT for 5-tuple" hv1/ovn-controller.log)" = "6"], [0])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Re-create encap tunnels during integration bridge migration])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

sim_add hv2
as hv2
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.2

check ovn-nbctl --wait=hv sync

check_tunnel_port() {
    local hv=$1
    local br=$2
    local id=$3

    as $hv
    OVS_WAIT_UNTIL([
        test "$(ovs-vsctl --format=table --no-headings find port external_ids:ovn-chassis-id="$id" | wc -l)" = "1"
    ])
    local tunnel_id=$(ovs-vsctl --bare --columns _uuid find port external_ids:ovn-chassis-id="$id")
    AT_CHECK([ovs-vsctl --bare --columns ports find bridge name="$br" | grep -q "$tunnel_id"])
}

# Check that both chassis have tunnel
check_tunnel_port hv1 br-int hv2@192.168.0.2
check_tunnel_port hv2 br-int hv1@192.168.0.1

# Stop ovn-controller on hv1
check as hv1 ovn-appctl -t ovn-controller exit --restart

# The tunnel should remain intact
check_tunnel_port hv1 br-int hv2@192.168.0.2

# Change the bridge to br-int1 on hv1
as hv1
check ovs-vsctl add-br br-int1
check ovs-vsctl set open . external_ids:ovn-bridge="br-int1"
start_daemon ovn-controller --verbose="encaps:dbg"
check ovn-nbctl --wait=hv sync

# Check that the tunnel was created on br-int1 instead
check_tunnel_port hv1 br-int1 hv2@192.168.0.2
check grep -q "Clearing old tunnel port \"ovn-hv2-0\" (hv2@192.168.0.2) from bridge \"br-int\"" hv1/ovn-controller.log

# Change the bridge to br-int1 on hv2
as hv2
check ovn-appctl vlog/set encaps:dbg
check ovs-vsctl add-br br-int1
check ovs-vsctl set open . external_ids:ovn-bridge="br-int1"
check ovn-nbctl --wait=hv sync


# Check that the tunnel was created on br-int1 instead
check_tunnel_port hv2 br-int1 hv1@192.168.0.1
check grep -q "Clearing old tunnel port \"ovn-hv1-0\" (hv1@192.168.0.1) from bridge \"br-int\"" hv2/ovn-controller.log

# Stop ovn-controller on hv1
check as hv1 ovn-appctl -t ovn-controller exit --restart

# The tunnel should remain intact
check_tunnel_port hv1 br-int1 hv2@192.168.0.2
prev_id=$(ovs-vsctl --bare --columns _uuid find port external_ids:ovn-chassis-id="hv2@192.168.0.2")

# Start the controller again
start_daemon ovn-controller --verbose="encaps:dbg"
check ovn-nbctl --wait=hv sync
check_tunnel_port hv1 br-int1 hv2@192.168.0.2
current_id=$(ovs-vsctl --bare --columns _uuid find port external_ids:ovn-chassis-id="hv2@192.168.0.2")

# The tunnel should be the same after restart
check test "$current_id" = "$prev_id"

OVN_CLEANUP([hv1],[hv2])
AT_CLEANUP
])

# NOTE: This test case runs two ovn-controllers inside the same sandbox (hv1).
# Each controller uses a unique chassis name - hv1 and hv2 - and manage
# different bridges with different ports.
OVN_FOR_EACH_NORTHD([
AT_SETUP([Encaps tunnel cleanup does not interfere with multiple controller on the same host])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys-1
ovn_attach n1 br-phys-1 192.168.0.1 24


# now start the second virtual controller
ovs-vsctl add-br br-phys-2


# the file is read once at startup so it's safe to write it
# here after the first ovn-controller has started
echo hv2 > ${OVN_SYSCONFDIR}/system-id-override

# for some reason SSL ovsdb configuration overrides CLI, so
# delete ssl config from ovsdb to give CLI arguments priority
ovs-vsctl del-ssl

start_virtual_controller n1 br-phys-2 br-int-2 192.168.0.2 24 geneve,vxlan hv2 \
    --pidfile=${OVS_RUNDIR}/ovn-controller-2.pid \
    --log-file=${OVS_RUNDIR}/ovn-controller-2.log \
    -p $PKIDIR/testpki-hv2-privkey.pem \
    -c $PKIDIR/testpki-hv2-cert.pem \
    -C $PKIDIR/testpki-cacert.pem
pidfile="$OVS_RUNDIR"/ovn-controller-2.pid
on_exit "test -e \"$pidfile\" && kill \`cat \"$pidfile\"\`"

ovn-nbctl --wait=hv sync

check_tunnel_port() {
    local hv=$1
    local br=$2
    local id=$3

    as $hv
    OVS_WAIT_UNTIL([
        test "$(ovs-vsctl --format=table --no-headings find port external_ids:ovn-chassis-id="$id" | wc -l)" = "1"
    ])
    local tunnel_id=$(ovs-vsctl --bare --columns _uuid find port external_ids:ovn-chassis-id="$id")
    AT_CHECK([ovs-vsctl --bare --columns ports find bridge name="$br" | grep -q "$tunnel_id"])
}

check_tunnel_port hv1 br-int hv2@192.168.0.2
check_tunnel_port hv1 br-int-2 hv1@192.168.0.1
prev_id1=$(ovs-vsctl --bare --columns _uuid find port external_ids:ovn-chassis-id="hv1@192.168.0.1")
prev_id2=$(ovs-vsctl --bare --columns _uuid find port external_ids:ovn-chassis-id="hv2@192.168.0.2")

# The hv2 is running we can remove the override file
rm -f ${OVN_SYSCONFDIR}/system-id-override

check ovn-appctl -t ovn-controller exit --restart

# Make sure ovn-controller stopped before restarting it
OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) != "xrunning"])

# for some reason SSL ovsdb configuration overrides CLI, so
# delete ssl config from ovsdb to give CLI arguments priority
ovs-vsctl del-ssl

start_daemon ovn-controller --verbose="encaps:dbg" \
    -p $PKIDIR/testpki-hv1-privkey.pem \
    -c $PKIDIR/testpki-hv1-cert.pem \
    -C $PKIDIR/testpki-cacert.pem

check ovn-nbctl --wait=hv sync

check_tunnel_port hv1 br-int hv2@192.168.0.2
check_tunnel_port hv1 br-int-2 hv1@192.168.0.1
current_id1=$(ovs-vsctl --bare --columns _uuid find port external_ids:ovn-chassis-id="hv1@192.168.0.1")
current_id2=$(ovs-vsctl --bare --columns _uuid find port external_ids:ovn-chassis-id="hv2@192.168.0.2")

# Check that restart of hv1 ovn-controller did not interfere with hv2
AT_CHECK([grep -q "Clearing old tunnel port \"ovn0-hv1-0\" (hv1@192.168.0.1) from bridge \"br-int-2\"" hv1/ovn-controller.log], [1])
check test "$current_id1" = "$prev_id1"
check test "$current_id2" = "$prev_id2"

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([OVN QoS])
ovn_start

check ovn-nbctl ls-add ls0
check ovn-nbctl lsp-add ls0 public0
check ovn-nbctl lsp-set-addresses public0 unknown
check ovn-nbctl lsp-set-type public0 localnet
check ovn-nbctl lsp-set-options public0 network_name=phys
net_add n

# two hypervisors, each connected to the same network
for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovn_attach n br-phys 192.168.0.$i
done

for i in 1 2; do
    check ovn-nbctl lsp-add ls0 lsp$i
    check ovn-nbctl lsp-set-addresses lsp$i f0:00:00:00:00:0$i
done

for i in 1 2; do
    as hv-$i
    ovs-vsctl add-port br-int vif$i -- set Interface vif$i external-ids:iface-id=lsp$i \
                                  ofport-request=$i
    OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp$i` = xup])

    # Patch port might be created after ports are reported up
    # Wait for a flow outputing to patch port
    OVN_WAIT_PATCH_PORT_FLOWS(["public0"], ["hv-$i"])
done

check ovn-nbctl set Logical_Switch_Port lsp1 options:qos_min_rate=200000

OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list qos | grep -c linux-htb) -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="200000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="0"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="0"') -eq 1])

check ovn-nbctl set Logical_Switch_Port lsp1 options:qos_max_rate=350000
check ovn-nbctl set Logical_Switch_Port lsp1 options:qos_burst=3000000

OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="350000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="3000000"') -eq 1])

check ovn-nbctl set Logical_Switch_Port lsp2 options:qos_min_rate=400000
check ovn-nbctl set Logical_Switch_Port lsp2 options:qos_max_rate=500000
check ovn-nbctl set Logical_Switch_Port lsp2 options:qos_burst=3000000

OVS_WAIT_UNTIL([test $(as hv-2 ovs-vsctl list qos | grep -c linux-htb) -eq 1])
OVS_WAIT_UNTIL([test $(as hv-2 ovs-vsctl list queue | grep -c 'min-rate="400000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-2 ovs-vsctl list queue | grep -c 'max-rate="500000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-2 ovs-vsctl list queue | grep -c 'burst="3000000"') -eq 1])

check ovn-nbctl lsp-add ls0 lsp3
check ovn-nbctl lsp-set-addresses lsp3 f0:00:00:00:00:03
as hv-1
ovs-vsctl add-port br-int vif3 -- \
    set Interface vif3 external-ids:iface-id=lsp3 \
    ofport-request=3
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp3` = xup])

check ovn-nbctl lsp-add ls0 lsp4
check ovn-nbctl lsp-set-addresses lsp4 f0:00:00:00:00:04
as hv-1
ovs-vsctl add-port br-int vif4 -- \
    set Interface vif4 external-ids:iface-id=lsp4 \
    ofport-request=4
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp4` = xup])

check ovn-nbctl set Logical_Switch_Port lsp3 options:qos_min_rate=700000
check ovn-nbctl set Logical_Switch_Port lsp3 options:qos_max_rate=800000
check ovn-nbctl set Logical_Switch_Port lsp3 options:qos_burst=9000000

OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list qos | grep -c linux-htb) -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="200000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="350000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="3000000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="700000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="800000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="9000000"') -eq 1])

check ovn-nbctl remove Logical_Switch_Port lsp3 options qos_min_rate=700000
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list qos | grep -c linux-htb) -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="0"') -eq 1])

check ovn-nbctl remove Logical_Switch_Port lsp3 options qos_max_rate=800000
check ovn-nbctl remove Logical_Switch_Port lsp3 options qos_burst=9000000

OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list qos | grep -c linux-htb) -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="200000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="350000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="3000000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="700000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="800000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="9000000"') -eq 0])

check ovn-nbctl set Logical_Switch_Port lsp4 options:qos_min_rate=1700000
check ovn-nbctl set Logical_Switch_Port lsp4 options:qos_max_rate=1800000
check ovn-nbctl set Logical_Switch_Port lsp4 options:qos_burst=19000000
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="1700000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="1800000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="19000000"') -eq 1])

as hv-1
ovs-vsctl remove Interface vif4 external-ids iface-id
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="1700000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="1800000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="19000000"') -eq 0])

check ovn-nbctl set Logical_Switch_Port lsp2 options:qos_min_rate=410000
OVS_WAIT_UNTIL([test $(as hv-2 ovs-vsctl list queue | grep -c 'min-rate="410000"') -eq 1])

check ovn-nbctl remove Logical_Switch_Port lsp2 options qos_min_rate=410000
check ovn-nbctl remove Logical_Switch_Port lsp2 options qos_max_rate=500000
check ovn-nbctl remove Logical_Switch_Port lsp2 options qos_burst=3000000

OVS_WAIT_UNTIL([test $(as hv-2 ovs-vsctl list qos | grep -c linux-htb) -eq 0])
OVS_WAIT_UNTIL([test $(as hv-2 ovs-vsctl list queue | grep -c 'min-rate="410000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-2 ovs-vsctl list queue | grep -c 'max-rate="500000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-2 ovs-vsctl list queue | grep -c 'burst="3000000"') -eq 0])

check ovn-nbctl lsp-del lsp1
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list qos | grep -c linux-htb) -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="200000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="350000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="3000000"') -eq 0])

check ovn-nbctl set Logical_Switch_Port public0 options:qos_min_rate=100000
check ovn-nbctl set Logical_Switch_Port public0 options:qos_max_rate=200000
check ovn-nbctl set Logical_Switch_Port public0 options:qos_burst=3000000
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list qos | grep -c linux-htb) -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="100000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="200000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="3000000"') -eq 1])

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 public1
check ovn-nbctl lsp-set-addresses public1 unknown
check ovn-nbctl lsp-set-type public1 localnet
check ovn-nbctl lsp-set-options public1 network_name=phys

check ovn-nbctl lsp-add ls1 lsp5
check ovn-nbctl lsp-set-addresses lsp5 f0:00:00:00:00:05
as hv-1
ovs-vsctl add-port br-int vif5 -- \
    set Interface vif5 external-ids:iface-id=lsp5 \
    ofport-request=5
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp5` = xup])

# Delete and add back public1
check ovn-nbctl --wait=hv lsp-del public1
check ovn-nbctl lsp-add ls1 public1
check ovn-nbctl lsp-set-addresses public1 unknown
check ovn-nbctl lsp-set-type public1 localnet

check ovn-nbctl set Logical_Switch_Port public1 options:qos_min_rate=6000000000
check ovn-nbctl set Logical_Switch_Port public1 options:qos_max_rate=7000000000
check ovn-nbctl set Logical_Switch_Port public1 options:qos_burst=8000000000

OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="6000000000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="7000000000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="8000000000"') -eq 0])

check ovn-nbctl set Logical_Switch_Port public1 options:qos_min_rate=6000000000 options:qos_max_rate=7000000000 options:qos_burst=8000000000 options:network_name=phys

OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="6000000000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="7000000000"') -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="8000000000"') -eq 1])

check ovn-nbctl lsp-del public0
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list qos | grep -c linux-htb) -eq 1])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="100000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="200000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="3000000"') -eq 0])

check ovn-nbctl remove Logical_Switch_Port public1 options qos_min_rate=6000000000
check ovn-nbctl remove Logical_Switch_Port public1 options qos_max_rate=7000000000
check ovn-nbctl remove Logical_Switch_Port public1 options qos_burst=8000000000

OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list qos | grep -c linux-htb) -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'min-rate="6000000000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'max-rate="7000000000"') -eq 0])
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list queue | grep -c 'burst="8000000000"') -eq 0])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([FDB aging])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

net_add n1

check ovn-nbctl ls-add ls0

check ovn-nbctl lsp-add ls0 ln_port -- \
      lsp-set-addresses ln_port unknown -- \
      lsp-set-type ln_port localnet -- \
      lsp-set-options ln_port network_name=physnet1 -- \
      set logical_switch_port ln_port options:localnet_learn_fdb=true

check ovn-nbctl lsp-add ls0 vif1 -- \
      lsp-set-addresses vif1 "00:00:00:00:10:10 192.168.10.10"

sim_add hv1
as hv1
ovs-vsctl add-br br-underlay
ovn_attach n1 br-underlay 192.168.0.1
ovs-vsctl add-br br-phys
ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=vif1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-phys ext0 -- \
    set interface ext0 \
    options:tx_pcap=hv1/ext0-tx.pcap \
    options:rxq_pcap=hv1/ext0-rx.pcap \
    ofport-request=2
ovs-vsctl set open . external_ids:ovn-bridge-mappings=physnet1:br-phys

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync

send_packet() {
    packet=$(fmt_pkt "
            Ether(dst='00:00:00:00:10:10', src='00:00:00:00:10:${1}') /
            IP(src='192.168.10.${1}', dst='192.168.10.10') /
            UDP(sport=1234, dport=1235)
           ")
    ovs-appctl netdev-dummy/receive ext0 $packet
}

# Send packet to create FDB row
send_packet 20
wait_row_count fdb 1 mac='"00:00:00:00:10:20"'
timestamp=$(fetch_column fdb timestamp mac='"00:00:00:00:10:20"')

# Set the FDB aging threshold
check ovn-nbctl set logical_switch ls0 other_config:fdb_age_threshold=5
AT_CHECK([fetch_column nb:logical_switch other_config | grep -q fdb_age_threshold=5])
check ovn-nbctl --wait=sb sync

# Send few packets for "00:00:00:00:10:20" to indicate that it is still in use
send_packet 20
sleep 1
send_packet 20

# Set the timeout for OVS_WAIT* functions to 5 seconds
OVS_CTL_TIMEOUT=10
OVS_WAIT_UNTIL([
    curr_timestamp=$(fetch_column fdb timestamp mac='"00:00:00:00:10:20"')
    test "$timestamp" != "$curr_timestamp"
])
timestamp=$(fetch_column fdb timestamp mac='"00:00:00:00:10:20"')
check $(test "$timestamp" != "")

# Check if the records are removed after some inactivity
wait_row_count fdb 0 mac='"00:00:00:00:10:20"'

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT_SNAT and LB traffic])
AT_KEYWORDS([dnat-snat-lb])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

test_ip_req_packet() {
    local src_mac="50:54:00:00:00:88"
    local dst_mac="$1"
    local src_ip="172.168.0.200"
    local dst_ip="$2"

    local packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/
                    IP(dst='${dst_ip}', src='${src_ip}')/ \
                    UDP(sport=53, dport=4369)")

    as hv1 reset_pcap_file hv1-vif1 hv1/vif1
    as hv2 reset_pcap_file hv2-vif1 hv2/vif1
    check as hv2 ovs-appctl netdev-dummy/receive hv2-vif1 $packet
}

test_ip_rep_packet() {
    local src_mac="50:54:00:00:00:01"
    local dst_mac="00:00:00:00:ff:01"
    local src_ip="10.0.0.2"
    local dst_ip="172.168.0.200"

    local packet=$(fmt_pkt "Ether(dst='${dst_mac}', src='${src_mac}')/
                    IP(dst='${dst_ip}', src='${src_ip}')/ \
                    UDP(sport=4369, dport=53)")

    check as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $packet
}

net_add n

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n br-phys 192.168.0.1
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-port1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap

sim_add hv2
as hv2
check ovs-vsctl add-br br-phys
ovn_attach n br-phys 192.168.0.2
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
check ovs-vsctl -- add-port br-int hv2-vif1 -- \
    set interface hv2-vif1 external-ids:iface-id=public-port1 \
    options:tx_pcap=hv2/vif1-tx.pcap \
    options:rxq_pcap=hv2/vif1-rx.pcap

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 10.0.0.2"

check ovn-nbctl ls-add public
check ovn-nbctl lsp-add public ln-public
check ovn-nbctl lsp-set-type ln-public localnet
check ovn-nbctl lsp-set-addresses ln-public unknown
check ovn-nbctl lsp-set-options ln-public network_name=phys
check ovn-nbctl lsp-add public public-port1
check ovn-nbctl lsp-set-addresses public-port1 "50:54:00:00:00:88 172.168.0.200"

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.1/24
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

check ovn-nbctl lrp-set-gateway-chassis lr0-public hv2 20

check ovn-nbctl lr-nat-add lr0 snat 172.168.0.1 10.0.0.0/24
check ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.168.0.110 10.0.0.2 sw0-port1 f0:00:00:01:02:03

wait_for_ports_up
OVN_POPULATE_ARP

# send UDP request to the FIP associated to sw0-port1
test_ip_req_packet "f0:00:00:01:02:03" "172.168.0.110"
OVS_WAIT_UNTIL([test $($PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap | wc -l) -ge 1])
# send UDP reply from sw0-port1
test_ip_rep_packet
# packet sent by the FIP
fip_packet=$(fmt_pkt "Ether(dst='50:54:00:00:00:88', src='f0:00:00:01:02:03')/
                      IP(dst='172.168.0.200', src='172.168.0.110', ttl=63)/ \
                      UDP(sport=4369, dport=53)")
echo $fip_packet > expected
OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv2/vif1-tx.pcap], [expected])

check ovn-nbctl lb-add lb0 172.168.0.1:4369 10.0.0.2:4369 udp
check ovn-nbctl lr-lb-add lr0 lb0

# send UDP request to the load-balancer VIP
test_ip_req_packet "00:00:20:20:12:13" "172.168.0.1"
OVS_WAIT_UNTIL([test $($PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif1-tx.pcap | wc -l) -ge 1])
# send UDP reply from sw0-port1
test_ip_rep_packet
# packet sent by the load balancer VIP
packet=$(fmt_pkt "Ether(dst='50:54:00:00:00:88', src='00:00:20:20:12:13')/
                      IP(dst='172.168.0.200', src='172.168.0.1', ttl=63)/ \
                      UDP(sport=4369, dport=53)")
echo $packet > expected
OVN_CHECK_PACKETS_REMOVE_BROADCAST([hv2/vif1-tx.pcap], [expected])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([OVN QoS port deletion])
ovn_start

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 public1
check ovn-nbctl lsp-set-addresses public1 unknown
check ovn-nbctl lsp-set-type public1 localnet
check ovn-nbctl lsp-set-options public1 network_name=phys
net_add n

# two hypervisors, each connected to the same network
for i in 1 2; do
    sim_add hv-$i
    as hv-$i
    ovs-vsctl add-br br-phys
    ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
    ovn_attach n br-phys 192.168.0.$i
done

check ovn-nbctl lsp-add ls1 lsp1
check ovn-nbctl lsp-set-addresses lsp1 f0:00:00:00:00:03
as hv-1
ovs-vsctl add-port br-int vif1 -- \
    set Interface vif1 external-ids:iface-id=lsp1 \
    ofport-request=3

OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp1` = xup])

check ovn-nbctl set Logical_Switch_Port lsp1 options:qos_max_rate=800000
check ovn-nbctl --wait=hv set Logical_Switch_Port lsp1 options:qos_burst=9000000

AS_BOX([$(date +%H:%M:%S.%03N) checking deletion of port with qos options])
check ovn-nbctl ls-add ls2
check ovn-nbctl lsp-add ls2 lsp2
check ovn-nbctl lsp-set-addresses lsp2 f0:00:00:00:00:05
as hv-1
ovs-vsctl add-port br-int vif2 -- \
    set Interface vif2 external-ids:iface-id=lsp2 \
    ofport-request=5
OVS_WAIT_UNTIL([test x`ovn-nbctl lsp-get-up lsp2` = xup])

# Sleep ovs to postpone ofport notification to ovn
sleep_ovs hv-1

# Create localnet; this will cause patch-port creation
check ovn-nbctl lsp-add ls2 public2
check ovn-nbctl lsp-set-addresses public2 unknown
check ovn-nbctl lsp-set-type public2 localnet
check ovn-nbctl --wait=sb set Logical_Switch_Port public2 options:qos_min_rate=6000000000 options:qos_max_rate=7000000000 options:qos_burst=8000000000 options:network_name=phys

# Let's now send ovn controller to sleep, so it will receive both ofport notification and ls deletion simultaneously
sleep_controller hv-1

# Tme to wake up ovs
wake_up_ovs hv-1

# Delete lsp1
check ovn-nbctl --wait=sb lsp-del lsp1

# And finally wake up controller
wake_up_controller hv-1

# Make sure ovn-controller is still OK
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([test $(as hv-1 ovs-vsctl list qos | grep -c linux-htb) -eq 1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-install and recomputes])
AT_KEYWORDS([ovn-install])

ovn_start

check ovn-nbctl ls-add ls1
check ovn-nbctl --wait=sb add Logical-Switch ls1 other_config vlan-passthru=true
net_add n

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys
ovn_attach n br-phys 192.168.0.1

check ovn-nbctl --wait=hv sync

check ovn-nbctl lsp-add ls1 lsp1
check ovn-nbctl lsp-add ls1 lsp2
as hv1 ovs-vsctl --no-wait -- add-port br-int vif1 \
                    -- set Interface vif1 external_ids:iface-id=lsp1 \
                    -- set Interface vif1 type=internal
as hv1 ovs-vsctl --no-wait -- add-port br-int vif2 \
                    -- set Interface vif2 external_ids:iface-id=lsp2 \
                    -- set Interface vif2 type=internal
wait_for_ports_up
check ovn-nbctl --wait=hv sync

sleep_ovsdb hv1

# Do following operations through one nbctl command
# Otherwise, they would probably result in multiple sb updates to ovn-controller
# As ovsdb is sleeping those multiple updates would resulti in requests to ovsdb being
# postponed as ovsdb becomes ro.
# Hence, patch port creation would be delayed after ovsdb becomes rw.
check ovn-nbctl --wait=hv lsp-add ls1 ln1                  \
                -- lsp-set-addresses ln1 unknown \
                -- lsp-set-type ln1 localnet     \
                -- lsp-set-options ln1 network_name=phys

# Controller should now have created the patch port, but is not yet notified of the ofport of those interfaces
sleep_controller hv1
wake_up_ovsdb hv1
check as hv1 ovs-vsctl remove Interface vif1 external_ids iface-id

# Now wake up controller. It should receive patch port ofport and iface vif1 removal notification
wake_up_controller hv1
check as hv1 ovs-vsctl --no-wait -- del-port vif2

# Check ovn-install has been removed.
OVS_WAIT_UNTIL([test x`as hv1 ovs-vsctl get Interface vif2 external_ids:ovn-installed` = x])
OVS_WAIT_UNTIL([test x`as hv1 ovs-vsctl get Interface vif1 external_ids:ovn-installed` = x])

# Check ports are down
OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp1 up` = 'false'])
OVS_WAIT_UNTIL([test `ovn-sbctl get Port_Binding lsp2 up` = 'false'])

# Check ports are unbound
wait_column "" Port_Binding chassis logical_port=lsp1
wait_column "" Port_Binding chassis logical_port=lsp2
OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Add and delete port])
ovn_start

net_add n1

sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11

check ovn-nbctl ls-add ls0
check ovn-nbctl --wait=hv lsp-add ls0 lsp1
as hv1 check ovs-vsctl -- add-port br-int lsp1 -- \
    set Interface lsp1 external-ids:iface-id=lsp1

wait_for_ports_up
sleep_controller hv1
check ovn-nbctl --wait=sb lsp-add ls0 lsp0
check ovn-nbctl --wait=sb lsp-del lsp0
wake_up_controller hv1
AT_CHECK([check_logs [""] hv1])
OVN_CLEANUP([hv1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Migration of CT zone from UUID to name])
ovn_start
net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# sw0-port1 -- sw0 -- lr0

check ovn-nbctl lr-add lr0
check ovn-nbctl set logical_router lr0 options:chassis=hv1
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 192.168.0.1/24
check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 11.0.0.1/24

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 192.168.0.2"

ovs-vsctl add-port br-int p1 -- \
    set Interface p1 external_ids:iface-id=sw0-port1

check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-appctl -t ovn-controller vlog/set dbg:main

wait_for_ports_up
ovn-nbctl --wait=hv sync

get_zone_num () {
    output=$1
    name=$2
    printf "$output" | grep $name | cut -d ' ' -f 2
}

replace_with_uuid() {
    name=$1

    id=$(ovn-sbctl --bare --columns _uuid find datapath external_ids:name=${name})
    dnat=$(ovs-vsctl --bare get bridge br-int external_ids:ct-zone-${name}_dnat)
    snat=$(ovs-vsctl --bare get bridge br-int external_ids:ct-zone-${name}_snat)

    check ovs-vsctl remove bridge br-int external_ids ct-zone-${name}_snat
    check ovs-vsctl remove bridge br-int external_ids ct-zone-${name}_dnat

    check ovs-vsctl set bridge br-int external_ids:ct-zone-${id}_snat=$snat
    check ovs-vsctl set bridge br-int external_ids:ct-zone-${id}_dnat=$dnat
}

check_zones_in_ovsdb() {
    zone_list=$1
    name=$2

    id=$(ovn-sbctl --bare --columns _uuid find datapath external_ids:name=${name})

    dnat=$(get_zone_num "$zone_list" ${name}_dnat)
    snat=$(get_zone_num "$zone_list" ${name}_snat)

    OVS_WAIT_UNTIL([ovs-vsctl --bare get bridge br-int external_ids:ct-zone-${name}_dnat])
    dnat_ovs=$(ovs-vsctl --bare get bridge br-int external_ids:ct-zone-${name}_dnat | tr -d '"')
    OVS_WAIT_UNTIL([ovs-vsctl --bare get bridge br-int external_ids:ct-zone-${name}_dnat])
    snat_ovs=$(ovs-vsctl --bare get bridge br-int external_ids:ct-zone-${name}_snat | tr -d '"')

    check test "$dnat" = "$dnat_ovs"
    check test "$snat" = "$snat_ovs"

    AT_CHECK([ovs-vsctl --bare get bridge br-int external_ids:ct-zone-${id}_dnat], [1], [ignore], [ignore])
    AT_CHECK([ovs-vsctl --bare get bridge br-int external_ids:ct-zone-${id}_snat], [1], [ignore], [ignore])
}

AS_BOX([Check newly created are with name only])
AT_CHECK([ovn-appctl -t ovn-controller ct-zone-list | sed "s/ [[0-9]]*/ ??/" | sort], [0], [dnl
lr0-sw0 ??
lr0-sw1 ??
lr0_dnat ??
lr0_snat ??
sw0-lr0 ??
sw0-port1 ??
sw0_dnat ??
sw0_snat ??
])

zone_list=$(ovn-appctl -t ovn-controller ct-zone-list)

check_zones_in_ovsdb "$zone_list" lr0
check_zones_in_ovsdb "$zone_list" sw0

# Check that we did just the initial zone flush
AT_CHECK([grep -c "NXT_CT_FLUSH_ZONE" hv1/ovs-vswitchd.log], [0], [dnl
8
])

AS_BOX([Check conversion from UUID - recompute])
replace_with_uuid lr0
replace_with_uuid sw0

# XXX: This is potentially a bug, the fact that we have to call
# recompute for the change to be reflected. Currently we don't
# track the OVS.bridge.external_ids which should be addressed in future.
ovn-appctl -t ovn-controller inc-engine/recompute

OVS_WAIT_UNTIL([test "$(grep -c 'ct zone .* replace uuid name' hv1/ovn-controller.log)" = "4"])

AT_CHECK([ovn-appctl -t ovn-controller ct-zone-list | sed "s/ [[0-9]]*/ ??/" | sort], [0], [dnl
lr0-sw0 ??
lr0-sw1 ??
lr0_dnat ??
lr0_snat ??
sw0-lr0 ??
sw0-port1 ??
sw0_dnat ??
sw0_snat ??
])

zone_list=$(ovn-appctl -t ovn-controller ct-zone-list)

check_zones_in_ovsdb "$zone_list" lr0
check_zones_in_ovsdb "$zone_list" sw0

# Check that we did just the initial zone flush
AT_CHECK([grep -c "NXT_CT_FLUSH_ZONE" hv1/ovs-vswitchd.log], [0], [dnl
8
])

AS_BOX([Check conversion from UUID - restart])
ovn-appctl -t ovn-controller exit --restart
# Make sure ovn-controller stopped before restarting it
OVS_WAIT_UNTIL([test "$(ovn-appctl -t ovn-controller debug/status)" != "running"])

replace_with_uuid lr0
replace_with_uuid sw0

start_daemon ovn-controller --verbose="main:dbg"

OVS_WAIT_UNTIL([test "$(grep -c 'ct zone .* replace uuid name' hv1/ovn-controller.log)" = "8"])

AT_CHECK([ovn-appctl -t ovn-controller ct-zone-list | sed "s/ [[0-9]]*/ ??/" | sort], [0], [dnl
lr0-sw0 ??
lr0-sw1 ??
lr0_dnat ??
lr0_snat ??
sw0-lr0 ??
sw0-port1 ??
sw0_dnat ??
sw0_snat ??
])

zone_list=$(ovn-appctl -t ovn-controller ct-zone-list)

check_zones_in_ovsdb "$zone_list" lr0
check_zones_in_ovsdb "$zone_list" sw0

# Check that we did just the initial zone flush
AT_CHECK([grep -c "NXT_CT_FLUSH_ZONE" hv1/ovs-vswitchd.log], [0], [dnl
8
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multicast group buffer split])
AT_KEYWORDS([ovn-mc-split])
AT_SKIP_IF([test $HAVE_SCAPY = no])
ovn_start

net_add n
sim_add hv1

as hv1
check ovs-vsctl add-br br-phys
ovn_attach n br-phys 192.168.0.1
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=phys:br-phys

for i in $(seq 1 320); do
    check ovs-vsctl -- add-port br-int hv1-vif$i -- \
        set interface hv1-vif$i external-ids:iface-id=sw0-port$i \
        options:tx_pcap=hv1/vif$i-tx.pcap \
        options:rxq_pcap=hv1/vif$i-rx.pcap
done

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 10.0.0.2"
for i in $(seq 2 320); do
    check ovn-nbctl lsp-add sw0 sw0-port$i -- lsp-set-addresses sw0-port$i "unknown"
done

check ovn-nbctl --wait=hv sync
wait_for_ports_up
OVN_POPULATE_ARP

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int table=40 | grep -c controller], [0],[dnl
9
])

arp_req=$(fmt_pkt "Ether(dst='ff:ff:ff:ff:ff:ff', src='50:54:00:00:00:01')/ARP(pdst='10.0.0.254', psrc='10.0.0.1')")
echo $arp_req > expected
as hv1 ovs-appctl netdev-dummy/receive hv1-vif1 $arp_req

OVS_WAIT_UNTIL([test $($PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif2-tx.pcap | wc -l) -ge 1])
OVN_CHECK_PACKETS([hv1/vif2-tx.pcap], [expected])

OVS_WAIT_UNTIL([test $($PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif100-tx.pcap | wc -l) -ge 1])
OVN_CHECK_PACKETS([hv1/vif100-tx.pcap], [expected])

OVS_WAIT_UNTIL([test $($PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif150-tx.pcap | wc -l) -ge 1])
OVN_CHECK_PACKETS([hv1/vif150-tx.pcap], [expected])

OVS_WAIT_UNTIL([test $($PYTHON "$ovs_srcdir/utilities/ovs-pcap.in" hv1/vif300-tx.pcap | wc -l) -ge 1])
OVN_CHECK_PACKETS([hv1/vif150-tx.pcap], [expected])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([virtual port claim race condition])
AT_KEYWORDS([virtual ports])
ovn_start

send_garp() {
    local hv=$1 inport=$2 eth_src=$3 eth_dst=$4 spa=$5 tpa=$6
    local request=${eth_dst}${eth_src}08060001080006040001${eth_src}${spa}${eth_dst}${tpa}
    as hv$hv ovs-appctl netdev-dummy/receive hv${hv}-vif$inport $request
}

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovn-appctl vlog/set dbg
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1
ovs-vsctl -- add-port br-int hv1-vif3 -- \
    set interface hv1-vif3 \
    options:tx_pcap=hv1/vif3-tx.pcap \
    options:rxq_pcap=hv1/vif3-rx.pcap \
    ofport-request=3

ovs-appctl -t ovn-controller vlog/set dbg

ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-vir
check ovn-nbctl lsp-set-addresses sw0-vir "50:54:00:00:00:10 10.0.0.10"
check ovn-nbctl lsp-set-port-security sw0-vir "50:54:00:00:00:10 10.0.0.10"
check ovn-nbctl lsp-set-type sw0-vir virtual
check ovn-nbctl set logical_switch_port sw0-vir options:virtual-ip=10.0.0.10
check ovn-nbctl set logical_switch_port sw0-vir options:virtual-parents=sw0-p1

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3 1000::3"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03 10.0.0.3 10.0.0.10 1000::3"

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

wait_for_ports_up
ovn-nbctl --wait=hv sync
hv1_ch_uuid=`ovn-sbctl --bare --columns _uuid find chassis name="hv1"`

# Try to bind sw0-vir directly to an OVS port. This should be ignored by
# ovn-controller.
as hv1 ovs-vsctl set interface hv1-vif3 external-ids:iface-id=sw0-vir

# Make sb to sleep, so that claim of sw0-vir (through pinctrl) and hv1-vif3 can be handled within same idl by controller
sleep_sb

# From sw0-p0 send GARP for 10.0.0.10. hv1 should claim sw0-vir
# and sw0-p1 should be its virtual_parent.
eth_src=505400000003
eth_dst=ffffffffffff
spa=$(ip_to_hex 10 0 0 10)
tpa=$(ip_to_hex 10 0 0 10)
send_garp 1 1 $eth_src $eth_dst $spa $tpa

OVS_WAIT_UNTIL([test 1 = `cat hv1/ovn-controller.log | grep "pinctrl received  packet-in" | \
grep opcode=BIND_VPORT | grep OF_Table_ID=29 | wc -l`])

sleep_controller hv1

# Cleanup hv1-vif3. This should not interfere with sw0-vir claim
as hv1 ovs-vsctl del-port hv1-vif3

wake_up_sb
ovn-nbctl --wait=sb sync
wake_up_controller hv1
check ovn-nbctl --wait=hv sync

wait_row_count Port_Binding 1 logical_port=sw0-vir chassis=$hv1_ch_uuid
check_row_count Port_Binding 1 logical_port=sw0-vir virtual_parent=sw0-p1
wait_for_ports_up sw0-vir
check ovn-nbctl --wait=hv sync

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([pod to pod with localnet_learn_fdb])
AT_SKIP_IF([test $HAVE_SCAPY = no])

# 6 VIFs, 3 per HV: vif11, vif12, vif13 on hv1.
# vif11 will exchange packets with vif21, vif12 w/ vif22 and so on.
#
ovn_start
net_add n1

check ovn-nbctl ls-add ls0

check ovn-nbctl lsp-add ls0 ln_port -- \
      lsp-set-addresses ln_port unknown -- \
      lsp-set-type ln_port localnet -- \
      lsp-set-options ln_port network_name=physnet1

for i in $(seq 1 3); do
    check ovn-nbctl lsp-add ls0 vif1$i -- \
          lsp-set-addresses vif1$i unknown
    check ovn-nbctl lsp-add ls0 vif2$i -- \
          lsp-set-addresses vif2$i unknown
done

n_pkt=(0 0 0 0 0 0)

for hv in 1 2; do
    sim_add hv${hv}
    as hv${hv}
    ovs-vsctl add-br br-phys
    ovn_attach n1 br-phys 192.168.0.${hv}

    for i in $(seq 1 3); do
        ovs-vsctl -- add-port br-int vif${hv}${i} -- \
            set interface vif${hv}${i} external-ids:iface-id=vif${hv}${i} \
            options:tx_pcap=hv${hv}/vif${hv}${i}-tx.pcap \
            options:rxq_pcap=hv${hv}/vif${hv}${i}-rx.pcap \
            ofport-request=$i
    done
    ovs-vsctl -- add-port br-phys ext0 -- \
        set interface ext0 \
        options:tx_pcap=hv${hv}/ext0-tx.pcap \
        options:rxq_pcap=hv${hv}/ext0-rx.pcap \
        ofport-request=4
    ovs-vsctl set open . external_ids:ovn-bridge-mappings=physnet1:br-phys
done

OVN_POPULATE_ARP
wait_for_ports_up
check ovn-nbctl --wait=hv sync

ln_port_key=$(fetch_column port_binding tunnel_key logical_port=ln_port)
vif11_key=$(fetch_column port_binding tunnel_key logical_port=vif11)
vif12_key=$(fetch_column port_binding tunnel_key logical_port=vif12)
vif13_key=$(fetch_column port_binding tunnel_key logical_port=vif13)
vif21_key=$(fetch_column port_binding tunnel_key logical_port=vif21)
vif22_key=$(fetch_column port_binding tunnel_key logical_port=vif22)
vif23_key=$(fetch_column port_binding tunnel_key logical_port=vif23)

ensure_controller_run() {
# We want to make sure controller could run at least one full loop.
# We can't use wait=hv as sb might be sleeping.
# Use 2 ovn-appctl to guarentee that ovn-controller run the full loop, and not just the unixctl handling
  hv=$1
  OVS_WAIT_UNTIL([test x$(as $hv ovn-appctl -t ovn-controller debug/status) = "xrunning"])
  OVS_WAIT_UNTIL([test x$(as $hv ovn-appctl -t ovn-controller debug/status) = "xrunning"])
}

wait_for_packets() {
    local hv=$1
    local vif=$2
    counter=$(((${hv:2} - 1) * 3 + ${vif:4} - 1))
    n_pkt[[$counter]]=$((${n_pkt[[$counter]]} + 1))
    echo "waiting for ${n_pkt[[$counter]]} packets on ${hv}/${vif} using counter $counter"
    OVS_WAIT_UNTIL([test $(tcpdump ip -nnner ${hv}/${vif}-tx.pcap | wc -l) -eq ${n_pkt[[$counter]]}])
}

check_no_packets() {
    local hv=$1
    local vif=$2
    counter=$(((${hv:2} - 1) * 3 + ${vif:4} - 1))
    echo "waiting for ${n_pkt[[$counter]]} packets on ${hv}/${vif} using counter $counter"
    OVS_WAIT_UNTIL([test $(tcpdump ip -nnner ${hv}/${vif}-tx.pcap | wc -l) -eq ${n_pkt[[$counter]]}])
}

send_packet() {
    hv=$1
    a_src=$2
    a_dst=$3
    dev=vif$2
    AS_BOX([$(date +%H:%M:%S.%03N) sending packet from $dev in $hv $a_src to $a_dst])
    packet=$(fmt_pkt "
            Ether(dst='00:00:00:00:10:${a_dst}', src='00:00:00:00:10:${a_src}') /
            IP(src='192.168.10.${a_src}', dst='192.168.10.${a_dst}') /
            UDP(sport=1234, dport=1235)
           ")
    as $hv ovs-appctl netdev-dummy/receive $dev $packet
}

check_flow_count() {
    hv=$1
    count=$2
    echo "Checking flow count for $hv is $count"
    OVS_WAIT_UNTIL([test $count = $(as $hv ovs-ofctl dump-flows br-int table=72 | grep -v "NXST_FLOW reply" | wc -l)])
}

# Sending packet in both direction. Should create FDB entries for vifs
# No localnet_learn_fdb yet
AS_BOX([$(date +%H:%M:%S.%03N) vif11 <=> vif21])
send_packet hv1 11 21
for i in 1 2 3; do
    wait_for_packets hv2 vif2${i}
done
for i in 2 3; do
    wait_for_packets hv1 vif1${i}
done
# vif11 should now own the mac
wait_column "$vif11_key" fdb port_key mac='"00:00:00:00:10:11"'

send_packet hv2 21 11
wait_for_packets hv1 vif11
for i in 2 3; do
    check_no_packets hv1 vif1${i}
done
wait_column "$vif21_key" fdb port_key mac='"00:00:00:00:10:21"'

check_flow_count hv1 2
check_flow_count hv2 2

# We now enable localnet_learn_fdb
# We check how it behaves with existing vif entries in fdb
check ovn-nbctl --wait=hv set logical_switch_port ln_port options:localnet_learn_fdb=true

AS_BOX([$(date +%H:%M:%S.%03N) vif11 <=> vif21 after learn_fdb])
send_packet hv1 11 21

wait_for_packets hv2 vif21
for i in 2 3; do
    check_no_packets hv2 vif2${i}
done
wait_column "$vif11_key" fdb port_key mac='"00:00:00:00:10:11"'

send_packet hv2 21 11
wait_for_packets hv1 vif11
for i in 2 3; do
    check_no_packets hv1 vif1${i}
done
wait_column "$vif21_key" fdb port_key mac='"00:00:00:00:10:21"'

# In both controllers,
# - 1st packet (in both dir) should have reached controller for the vif, not for localnet (as learn_fdb disabled for localnet)
# - 2nd packet should not cause any upcall to controller as vif already owns the mac.
AT_CHECK([test 1 = `cat hv1/ovs-vswitchd.log | grep NXT_PACKET_IN2 | wc -l`])
AT_CHECK([test 1 = `cat hv2/ovs-vswitchd.log | grep NXT_PACKET_IN2 | wc -l`])

check_flow_count hv1 4
check_flow_count hv2 4

# Send a few more packets
send_packet hv1 11 21
send_packet hv2 21 11

for hv in 1 2; do
    wait_for_packets hv${hv} vif${hv}1
    for i in 2 3; do
        echo CHECK
        check_no_packets hv${hv} vif${hv}${i}
    done
done

# The last packets should have gone through the fast path
AT_CHECK([test 1 = `cat hv1/ovs-vswitchd.log | grep NXT_PACKET_IN2 | wc -l`])
AT_CHECK([test 1 = `cat hv2/ovs-vswitchd.log | grep NXT_PACKET_IN2 | wc -l`])

# Check that there are no bad surprises
wait_column "$vif11_key" fdb port_key mac='"00:00:00:00:10:11"'
wait_column "$vif21_key" fdb port_key mac='"00:00:00:00:10:21"'

# We will now create fdb entries AFTER enabing localnet_learn_fdb
# We make ovn_controller (hv1 or hv2) to sleep to control who writes first to fdb
# as otherwise no guarentee.
AS_BOX([$(date +%H:%M:%S.%03N) vif12 <=> vif22])
# We make sure that the fdb update by the vif is done after the localnet update
sleep_controller hv1
send_packet hv1 12 22
for i in 1 3; do
    wait_for_packets hv1 vif1${i}
done
for i in 1 2 3; do
    wait_for_packets hv2 vif2${i}
done

# ln_port should own the mac as vif not written yet
wait_column "$ln_port_key" fdb port_key mac='"00:00:00:00:10:12"'

wake_up_controller hv1
# vif1 should now own the mac
wait_column "$vif12_key" fdb port_key mac='"00:00:00:00:10:12"'

sleep_controller hv2
send_packet hv2 22 12
wait_for_packets hv1 vif12
for i in 1 3; do
    check_no_packets hv1 vif1${i}
done
wait_column "$ln_port_key" fdb port_key mac='"00:00:00:00:10:22"'

wake_up_controller hv2
wait_column "$vif22_key" fdb port_key mac='"00:00:00:00:10:22"'

check_flow_count hv1 8
check_flow_count hv2 8

AS_BOX([$(date +%H:%M:%S.%03N) vif13 <=> vif23 ])
# Now we do the other way around: we make sure that the localnet update is done after the vif update.
# So, when packet is sent from vif1 to vif2, vif1 will be learnt (by hv1) and written in sb
# Then, when we wake up ovn-controller on hv2, it will learn on localnet.
# This used to cause localnet entry to overwrite vif entry in sb
sleep_controller hv2
send_packet hv1 13 23
for i in 1 2; do
    wait_for_packets hv1 vif1${i}
done
for i in 1 2 3; do
    wait_for_packets hv2 vif2${i}
done

wait_column "$vif13_key" fdb port_key mac='"00:00:00:00:10:13"'


# At this point, FDB contains vif1 entry for mac 00:00:00:00:10:13.
# However, as hv2 controller is sleeping, the flows in hv2 do not
# contain the flows related to that fdb entry.
# Hence, the packet which went through still failed the lookup.
wake_up_controller hv2

# FDB shoud not have changed. Just make sure controller has run and check fdb
ensure_controller_run hv2
wait_column "$vif13_key" fdb port_key mac='"00:00:00:00:10:13"'

sleep_controller hv1
send_packet hv2 23 13
wait_for_packets hv1 vif13
for i in 1 2; do
    check_no_packets hv2 vif2${i}
done
for i in 1 2; do
    check_no_packets hv1 vif1${i}
done
wait_column "$vif23_key" fdb port_key mac='"00:00:00:00:10:23"'

wake_up_controller hv1
ensure_controller_run hv1
wait_column "$vif23_key" fdb port_key mac='"00:00:00:00:10:23"'

# In both controllers
# - vif11 <=> vif21: 1 PACKET_IN
# - vif12 <=> vif22: 2 PACKET_IN
# - vif13 <=> vif23: 2 PACKET_IN
# controller + .
AT_CHECK([test 5 = `cat hv1/ovs-vswitchd.log | grep NXT_PACKET_IN2 | wc -l`])
AT_CHECK([test 5 = `cat hv2/ovs-vswitchd.log | grep NXT_PACKET_IN2 | wc -l`])

# Send a few more packets
send_packet hv1 13 23
send_packet hv2 23 13
wait_for_packets hv2 vif23
wait_for_packets hv1 vif13
for i in 1 2; do
    check_no_packets hv1 vif1${i}
    check_no_packets hv2 vif2${i}
done
send_packet hv1 13 23
send_packet hv2 23 13
wait_for_packets hv2 vif23
wait_for_packets hv1 vif13
for i in 1 2; do
    check_no_packets hv1 vif1${i}
    check_no_packets hv2 vif2${i}
done

# The last packets should have gone through the fast path
AT_CHECK([test 5 = `cat hv1/ovs-vswitchd.log | grep NXT_PACKET_IN2 | wc -l`])
AT_CHECK([test 5 = `cat hv2/ovs-vswitchd.log | grep NXT_PACKET_IN2 | wc -l`])

# Check that there are no bad surprises
wait_column "$vif11_key" fdb port_key mac='"00:00:00:00:10:11"'
wait_column "$vif12_key" fdb port_key mac='"00:00:00:00:10:12"'
wait_column "$vif13_key" fdb port_key mac='"00:00:00:00:10:13"'
wait_column "$vif21_key" fdb port_key mac='"00:00:00:00:10:21"'
wait_column "$vif22_key" fdb port_key mac='"00:00:00:00:10:22"'
wait_column "$vif23_key" fdb port_key mac='"00:00:00:00:10:23"'

check_flow_count hv1 12
check_flow_count hv2 12

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([port up with slow northd])
ovn_start

sleep_northd() {
  echo northd going to sleep
  AT_CHECK([kill -STOP $(cat northd/ovn-northd.pid)])
}

wake_up_northd() {
  echo northd going to sleep
  AT_CHECK([kill -CONT $(cat northd/ovn-northd.pid)])
}

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11

check ovn-nbctl --wait=hv ls-add ls0
# Create a pilot port and wait it up to make sure we are ready for the real
# tests, so that the counters measured are accurate.
check ovn-nbctl --wait=hv lsp-add ls0 lsp-pilot -- lsp-set-addresses lsp-pilot "unknown"
ovs-vsctl add-port br-int lsp-pilot -- set interface lsp-pilot external_ids:iface-id=lsp-pilot
wait_for_ports_up
check ovn-nbctl --wait=hv sync

check ovn-nbctl --wait=hv lsp-add ls0 lsp0-2 -- lsp-set-addresses lsp0-2 "aa:aa:aa:00:00:02 192.168.0.12"
ovs-vsctl add-port br-int lsp0-2 -- set interface lsp0-2 external_ids:iface-id=lsp0-2
wait_for_ports_up
check ovn-nbctl --wait=hv sync

sleep_northd
check ovn-nbctl lsp-del lsp0-2
check ovn-nbctl lsp-add ls0 lsp0-2 -- lsp-set-addresses lsp0-2 "aa:aa:aa:00:00:02 192.168.0.12"
wake_up_northd

check ovn-nbctl --wait=sb sync
wait_for_ports_up

OVN_CLEANUP([hv1])
AT_CLEANUP
])
