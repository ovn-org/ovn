AT_BANNER([system-ovn])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 LRs connected via LS, gateway router, SNAT and DNAT])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switches foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected
# to it.  R2 is a gateway router on which we add NAT rules.
#
#    foo -- R1 -- join - R2 -- alice
#           |
#    bar ----

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Add a DNAT rule.
ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.2 -- add logical_router R2 nat @nat

# Add a SNAT rule
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.2.2 \
    external_ip=30.0.0.1 -- add logical_router R2 nat @nat

# wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.1)'])

# 'alice1' should be able to ping 'foo1' directly.
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 192.168.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# North-South DNAT: 'alice1' should also be able to ping 'foo1' via 30.0.0.2
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=172.16.1.2,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic
# from 30.0.0.1
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

# Add static routes to handle east-west NAT.
ovn-nbctl lr-route-add R1 30.0.0.0/24 20.0.0.2

# wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync

# Flush conntrack entries for easier output parsing of next test.
AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# East-west DNAT and SNAT: 'bar1' pings 30.0.0.2. 'foo1' receives it.
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# As we have a static route that sends all packets with destination
# 30.0.0.2 to R2, it hits the DNAT rule and converts 30.0.0.2 to 192.168.1.2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

# As we have a SNAT rule that converts 192.168.2.2 to 30.0.0.1, the source is
# SNATted and 'foo1' receives it.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 LRs connected via LS, gateway router, SNAT and DNAT - IPv6])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in fd00::/64 network. R1 has switchess foo (fd11::/64) and
# bar (fd12::/64) connected to it. R2 has alice (fd21::/64) connected
# to it.  R2 is a gateway router on which we add NAT rules.
#
#    foo -- R1 -- join - R2 -- alice
#           |
#    bar ----

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd21::1/64
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd00::1/64
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd00::2/64
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
ovn-nbctl lr-route-add R1 fd21::/64 fd00::2
ovn-nbctl lr-route-add R2 fd11::/64 fd00::1
ovn-nbctl lr-route-add R2 fd12::/64 fd00::1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1")
OVS_WAIT_UNTIL([test "$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)" = ""])
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd21::2/64", "f0:00:00:01:02:04", \
         "fd21::1")
OVS_WAIT_UNTIL([test "$(ip netns exec alice1 ip a | grep fd21::2 | grep tentative)" = ""])
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd21::2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:05", \
         "fd12::1")
OVS_WAIT_UNTIL([test "$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)" = ""])
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 fd12::2"

# Add a DNAT rule.
ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=\"fd11::2\" \
    external_ip=\"fd30::2\" -- add logical_router R2 nat @nat

# Add a SNAT rule
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=\"fd12::2\" \
    external_ip=\"fd30::1\" -- add logical_router R2 nat @nat

# wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd30::1)'])

# 'alice1' should be able to ping 'foo1' directly.
NS_CHECK_EXEC([alice1], [ping6 -v -q -c 3 -i 0.3 -w 2 fd11::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# North-South DNAT: 'alice1' should also be able to ping 'foo1' via fd30::2
NS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd21::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd21::2,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd21::2,id=<cleared>,type=129,code=0),zone=<cleared>
icmpv6,orig=(src=fd21::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd21::2,id=<cleared>,type=129,code=0),zone=<cleared>
])

# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic
# from fd30::1
NS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd21::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd21::2,id=<cleared>,type=128,code=0),reply=(src=fd21::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

# Add static routes to handle east-west NAT.
ovn-nbctl lr-route-add R1 fd30::/64 fd00::2

# wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync

# Flush conntrack entries for easier output parsing of next test.
AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# East-west DNAT and SNAT: 'bar1' pings fd30::2. 'foo1' receives it.
NS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# As we have a static route that sends all packets with destination
# fd30::2 to R2, it hits the DNAT rule and converts fd30::2 to fd11::2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd12::2,id=<cleared>,type=129,code=0),zone=<cleared>
])

# As we have a SNAT rule that converts fd12::2 to fd30::1, the source is
# SNATted and 'foo1' receives it.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 LRs connected via LS, gateway router, easy SNAT])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) connected
# to it.  R2 has alice (172.16.1.0/24) connected to it.
# R2 is a gateway router on which we add NAT rules.
#
#    foo -- R1 -- join - R2 -- alice

ovn-nbctl lr-add R1
ovn-nbctl lr-add R2 -- set Logical_Router R2 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice
ovn-nbctl ls-add join

ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24

# Connect foo to R1
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect alice to R2
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Add a SNAT rule
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.1.2 \
    external_ip=172.16.1.1 -- add logical_router R2 nat @nat

ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])

# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic
# from 172.16.1.1
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 LRs connected via LS, gateway router, easy SNAT - IPv6])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in fd20::/64 network. R1 has switchess foo (fd10::/64) connected
# to it.  R2 has alice (fd30::/64) connected to it.
# R2 is a gateway router on which we add NAT rules.
#
#    foo -- R1 -- join - R2 -- alice

ovn-nbctl lr-add R1
ovn-nbctl lr-add R2 -- set Logical_Router R2 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add alice
ovn-nbctl ls-add join

ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd10::1/64
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd30::1/64
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64

# Connect foo to R1
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect alice to R2
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
ovn-nbctl lr-route-add R1 fd30::/64 fd20::2
ovn-nbctl lr-route-add R2 fd10::/64 fd20::1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd10::2/64", "f0:00:00:01:02:03", \
         "fd10::1")
OVS_WAIT_UNTIL([test "$(ip netns exec foo1 ip a | grep fd10::2 | grep tentative)" = ""])
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd10::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd30::2/64", "f0:00:00:01:02:04", \
         "fd30::1")
OVS_WAIT_UNTIL([test "$(ip netns exec alice1 ip a | grep fd30::2 | grep tentative)" = ""])
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd30::2"

# Add a SNAT rule
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=\"fd10::2\" \
    external_ip=\"fd30::1\" -- add logical_router R2 nat @nat

ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd30::1)'])

# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic
# from fd30::1
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd30::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd10::2,dst=fd30::2,id=<cleared>,type=128,code=0),reply=(src=fd30::2,dst=fd30::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, SNAT and DNAT])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected
# to it.  R3 has bob (172.16.1.0/24) connected to it. Note how both alice and
# bob have the same subnet behind it.  We are trying to simulate external
# network via those 2 switches. In real world the switch ports of these
# switches will have addresses set as "unknown" to make them learning switches.
# Or those switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24
ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.1.0/24 20.0.0.2
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.2.0/24 20.0.0.3

# Static routes.
ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1
ovn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1

# For gateway routers R2 and R3, set a force SNAT rule.
ovn-nbctl set logical_router R2 options:dnat_force_snat_ip=20.0.0.2
ovn-nbctl set logical_router R3 options:dnat_force_snat_ip=20.0.0.3

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.3/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "172.16.1.4/24", "f0:00:00:01:02:06", \
         "172.16.1.2")
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.1.4"

# Router R2
# Add a DNAT rule.
ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.2 -- add logical_router R2 nat @nat

# Add a SNAT rule
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.1 -- add logical_router R2 nat @nat

# Router R3
# Add a DNAT rule.
ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.3 -- add logical_router R3 nat @nat

# Add a SNAT rule
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.2.2 \
    external_ip=30.0.0.4 -- add logical_router R3 nat @nat

# wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.4)'])

# North-South DNAT: 'alice1' should be able to ping 'foo1' via 30.0.0.2
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.3,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

# But foo1 should receive traffic from 20.0.0.2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.3,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

# North-South DNAT: 'bob1' should be able to ping 'foo1' via 30.0.0.3
NS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.4,dst=30.0.0.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>
])

# But foo1 should receive traffic from 20.0.0.3
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.4,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic
# from 30.0.0.4
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=30.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>
])

# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic
# from 30.0.0.1
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=172.16.1.3,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, SNAT and DNAT - IPv6])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in fd20::/64 network. R1 has switchess foo (fd11::/64) and
# bar (fd12::/64) connected to it. R2 has alice (fd30::/64) connected
# to it.  R3 has bob (fd30::/64) connected to it. Note how both alice and
# bob have the same subnet behind it.  We are trying to simulate external
# network via those 2 switches. In real world the switch ports of these
# switches will have addresses set as "unknown" to make them learning switches.
# Or those switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd30::1/64
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 fd30::2/64
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 fd20::3/64
ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
ovn-nbctl --policy="src-ip" lr-route-add R1 fd11::/64 fd20::2
ovn-nbctl --policy="src-ip" lr-route-add R1 fd12::/64 fd20::3

# Static routes.
ovn-nbctl lr-route-add R2 fd11::/64 fd20::1
ovn-nbctl lr-route-add R2 fd12::/64 fd20::1
ovn-nbctl lr-route-add R3 fd11::/64 fd20::1
ovn-nbctl lr-route-add R3 fd12::/64 fd20::1

# For gateway routers R2 and R3, set a force SNAT rule.
ovn-nbctl set logical_router R2 options:dnat_force_snat_ip=fd20::2
ovn-nbctl set logical_router R3 options:dnat_force_snat_ip=fd20::3

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1")
OVS_WAIT_UNTIL([test "$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)" = ""])
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd30::3/64", "f0:00:00:01:02:04", \
         "fd30::1")
OVS_WAIT_UNTIL([test "$(ip netns exec alice1 ip a | grep fd30::3 | grep tentative)" = ""])
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd30::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:05", \
         "fd12::1")
OVS_WAIT_UNTIL([test "$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)" = ""])
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 fd12::2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "fd30::4/64", "f0:00:00:01:02:06", \
         "fd30::2")
OVS_WAIT_UNTIL([test "$(ip netns exec bob1 ip a | grep fd30::4 | grep tentative)" = ""])
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 fd30::4"

# External IPs -- 30.0.0.N --> fd40::N (from IPv4 version of test case)

# Router R2
# Add a DNAT rule.
ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip='"fd11::2"' \
    external_ip='"fd40::2"' -- add logical_router R2 nat @nat

# Add a SNAT rule
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip='"fd11::2"' \
    external_ip='"fd40::1"' -- add logical_router R2 nat @nat

# Router R3
# Add a DNAT rule.
ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip='"fd11::2"' \
    external_ip='"fd40::3"' -- add logical_router R3 nat @nat

# Add a SNAT rule
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip='"fd12::2"' \
    external_ip='"fd40::4"' -- add logical_router R3 nat @nat

# wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd40::4)'])

# North-South DNAT: 'alice1' should be able to ping 'foo1' via fd30::2
NS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd40::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::3,dst=fd40::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::3,id=<cleared>,type=129,code=0),zone=<cleared>
])

# But foo1 should receive traffic from fd20::2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::3,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>
])

# North-South DNAT: 'bob1' should be able to ping 'foo1' via fd40::3
NS_CHECK_EXEC([bob1], [ping6 -q -c 3 -i 0.3 -w 2 fd40::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::4,dst=fd40::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::4,id=<cleared>,type=129,code=0),zone=<cleared>
])

# But foo1 should receive traffic from fd20::3
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::4,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>
])

# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic
# from fd40::4
NS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd30::4,id=<cleared>,type=128,code=0),reply=(src=fd30::4,dst=fd40::4,id=<cleared>,type=129,code=0),zone=<cleared>
])

# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic
# from fd40::1
NS_CHECK_EXEC([foo1], [ping6 -q -c 3 -i 0.3 -w 2 fd30::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd11::2,dst=fd30::3,id=<cleared>,type=128,code=0),reply=(src=fd30::3,dst=fd40::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, SNAT and DNAT - Dual Stack])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 and fd20::/64 networks. R1 has switches foo (192.168.1.0/24
# and fd11::/64) and bar (192.168.2.0/24 and fd12::/64) connected to it. R2
# has alice (172.16.1.0/24 and fd30::/64) connected to it.  R3 has bob
# (172.16.1.0/24 andfd30::/64) connected to it. Note how both alice and bob
# have the same subnets behind them.  We are trying to simulate external network
# via those 2 switches. In real world the switch ports of these switches will
# have addresses set as "unknown" to make them learning switches. Or those
# switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 fd11::1/64
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 fd12::1/64
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24 fd30::1/64
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24 fd30::2/64
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24 fd20::1/64
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24 fd20::2/64
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24 fd20::3/64
ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
ovn-nbctl --policy="src-ip" lr-route-add R1 fd11::/64 fd20::2
ovn-nbctl --policy="src-ip" lr-route-add R1 fd12::/64 fd20::3
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.1.0/24 20.0.0.2
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.2.0/24 20.0.0.3

# Static routes.
ovn-nbctl lr-route-add R2 fd11::/64 fd20::1
ovn-nbctl lr-route-add R2 fd12::/64 fd20::1
ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1
ovn-nbctl lr-route-add R3 fd11::/64 fd20::1
ovn-nbctl lr-route-add R3 fd12::/64 fd20::1
ovn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1

# For gateway routers R2 and R3, set a force SNAT rule.
ovn-nbctl set logical_router R2 options:dnat_force_snat_ip="20.0.0.2 fd20::2"
ovn-nbctl set logical_router R3 options:dnat_force_snat_ip="20.0.0.3 fd20::3"

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(foo16)
ADD_VETH(foo16, foo16, br-int, "fd11::2/64", "f0:00:00:02:02:03", \
         "fd11::1")
OVS_WAIT_UNTIL([test "$(ip netns exec foo16 ip a | grep fd11::2 | grep tentative)" = ""])
ovn-nbctl lsp-add foo foo16 \
-- lsp-set-addresses foo16 "f0:00:00:02:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.3/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.3"

ADD_NAMESPACES(alice16)
ADD_VETH(alice16, alice16, br-int, "fd30::3/64", "f0:00:00:02:02:04", \
         "fd30::1")
OVS_WAIT_UNTIL([test "$(ip netns exec alice16 ip a | grep fd30::3 | grep tentative)" = ""])
ovn-nbctl lsp-add alice alice16 \
-- lsp-set-addresses alice16 "f0:00:00:02:02:04 fd30::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

ADD_NAMESPACES(bar16)
ADD_VETH(bar16, bar16, br-int, "fd12::2/64", "f0:00:00:02:02:05", \
         "fd12::1")
OVS_WAIT_UNTIL([test "$(ip netns exec bar16 ip a | grep fd12::2 | grep tentative)" = ""])
ovn-nbctl lsp-add bar bar16 \
-- lsp-set-addresses bar16 "f0:00:00:02:02:05 fd12::2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "172.16.1.4/24", "f0:00:00:01:02:06", \
         "172.16.1.2")
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.1.4"

ADD_NAMESPACES(bob16)
ADD_VETH(bob16, bob16, br-int, "fd30::4/64", "f0:00:00:02:02:06", \
         "fd30::2")
OVS_WAIT_UNTIL([test "$(ip netns exec bob16 ip a | grep fd30::4 | grep tentative)" = ""])
ovn-nbctl lsp-add bob bob16 \
-- lsp-set-addresses bob16 "f0:00:00:02:02:06 fd30::4"

# Router R2
# Add a DNAT rule.
ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.2 -- add logical_router R2 nat @nat
ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip='"fd11::2"' \
    external_ip='"fd40::2"' -- add logical_router R2 nat @nat

# Add a SNAT rule
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.1 -- add logical_router R2 nat @nat
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip='"fd11::2"' \
    external_ip='"fd40::1"' -- add logical_router R2 nat @nat

# Router R3
# Add a DNAT rule.
ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip=192.168.1.2 \
    external_ip=30.0.0.3 -- add logical_router R3 nat @nat
ovn-nbctl -- --id=@nat create nat type="dnat" logical_ip='"fd11::2"' \
    external_ip='"fd40::3"' -- add logical_router R3 nat @nat

# Add a SNAT rule
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.2.2 \
    external_ip=30.0.0.4 -- add logical_router R3 nat @nat
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip='"fd12::2"' \
    external_ip='"fd40::4"' -- add logical_router R3 nat @nat

# wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd40::4)'])
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=30.0.0.4)'])

# North-South DNAT: 'alice1' should be able to ping 'foo1' via 30.0.0.2
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# North-South DNAT: 'alice16' should be able to ping 'foo16' via fd30::2
NS_CHECK_EXEC([alice16], [ping6 -q -c 3 -i 0.3 -w 2 fd40::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.3,dst=30.0.0.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::3,dst=fd40::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::3,id=<cleared>,type=129,code=0),zone=<cleared>
])

# But foo1 should receive traffic from 20.0.0.2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.3,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])
# But foo16 should receive traffic from fd20::2
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::3,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>
])

# North-South DNAT: 'bob1' should be able to ping 'foo1' via 30.0.0.3
NS_CHECK_EXEC([bob1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# North-South DNAT: 'bob16' should be able to ping 'foo16' via fd40::3
NS_CHECK_EXEC([bob16], [ping6 -q -c 3 -i 0.3 -w 2 fd40::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.4,dst=30.0.0.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::4,dst=fd40::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd30::4,id=<cleared>,type=129,code=0),zone=<cleared>
])

# But foo1 should receive traffic from 20.0.0.3
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.4,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=20.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

# But foo16 should receive traffic from fd20::3
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd30::4,dst=fd11::2,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>
])

# South-North SNAT: 'bar1' pings 'bob1'. But 'bob1' receives traffic
# from 30.0.0.4
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
# South-North SNAT: 'bar16' pings 'bob16'. But 'bob16' receives traffic
# from fd40::4
NS_CHECK_EXEC([bar16], [ping6 -q -c 3 -i 0.3 -w 2 fd30::4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=30.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd30::4,id=<cleared>,type=128,code=0),reply=(src=fd30::4,dst=fd40::4,id=<cleared>,type=129,code=0),zone=<cleared>
])

# South-North SNAT: 'foo1' pings 'alice1'. But 'alice1' receives traffic
# from 30.0.0.1
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# South-North SNAT: 'foo16' pings 'alice16'. But 'alice16' receives traffic
# from fd40::1
NS_CHECK_EXEC([foo16], [ping6 -q -c 3 -i 0.3 -w 2 fd30::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=172.16.1.3,dst=30.0.0.1,id=<cleared>,type=0,code=0),zone=<cleared>
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd40::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd11::2,dst=fd30::3,id=<cleared>,type=128,code=0),reply=(src=fd30::3,dst=fd40::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancing])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 2 logical switches "foo" (192.168.1.0/24) and "bar" (172.16.1.0/24)
# connected to a router R1.
# foo has foo1 to act as a client.
# bar has bar1, bar2, bar3 to act as servers.
#
# Loadbalancer VIPs in 30.0.0.0/24 network.

ovn-nbctl create Logical_Router name=R1
ovn-nbctl ls-add foo
ovn-nbctl ls-add bar

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 172.16.1.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Create logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "172.16.1.2/24", "f0:00:0f:01:02:03", \
         "172.16.1.1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:0f:01:02:03 172.16.1.2"

ADD_NAMESPACES(bar2)
ADD_VETH(bar2, bar2, br-int, "172.16.1.3/24", "f0:00:0f:01:02:04", \
         "172.16.1.1")
ovn-nbctl lsp-add bar bar2 \
-- lsp-set-addresses bar2 "f0:00:0f:01:02:04 172.16.1.3"

ADD_NAMESPACES(bar3)
ADD_VETH(bar3, bar3, br-int, "172.16.1.4/24", "f0:00:0f:01:02:05", \
         "172.16.1.1")
ovn-nbctl lsp-add bar bar3 \
-- lsp-set-addresses bar3 "f0:00:0f:01:02:05 172.16.1.4"

# Config OVN load-balancer with a VIP.
ovn-nbctl lb-add lb1 30.0.0.1 "172.16.1.2,172.16.1.3,172.16.1.4"
ovn-nbctl ls-lb-add foo lb1

# Create another load-balancer with another VIP.
lb2_uuid=`ovn-nbctl create load_balancer name=lb2 vips:30.0.0.3="172.16.1.2,172.16.1.3,172.16.1.4"`
ovn-nbctl ls-lb-add foo lb2

# Config OVN load-balancer with another VIP (this time with ports).
ovn-nbctl set load_balancer $lb2_uuid vips:'"30.0.0.2:8000"'='"172.16.1.2:80,172.16.1.3:80,172.16.1.4:80"'

# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=172.16.1.4:80)'])

# Start webservers in 'bar1', 'bar2' and 'bar3'.
OVS_START_L7([bar1], [http])
OVS_START_L7([bar2], [http])
OVS_START_L7([bar3], [http])

# Add ACLs (after lb) to drop the traffic if destined to backend  ips.
check ovn-nbctl --apply-after-lb acl-add foo from-lport 1002 "ip4 && ip4.dst == {172.16.1.2,172.16.1.3,172.16.1.4} && ct.new" drop
check ovn-nbctl --wait=hv sync

AT_CHECK([ip netns exec foo1 wget 30.0.0.1 -t 3 -T 1], [4], [ignore], [ignore])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# Clear the apply-after-lb option.  The traffic will be allowed.
check ovn-nbctl clear acl . options
ovn-nbctl --wait=hv sync

OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

ovn-nbctl acl-del foo from-lport 1002 "ip4 && ip4.dst == {172.16.1.2,172.16.1.3,172.16.1.4} && ct.new"
ovn-nbctl --wait=hv sync

dnl Should work with the virtual IP 30.0.0.1 address through NAT
dnl Each server should have at least one connection.
dnl With 20 requests, one server might not receive any connection
dnl in 0.3% of cases, so run a few times.

OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Should work with the virtual IP 30.0.0.3 address through NAT
dnl Each server should have at least one connection.
OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.3 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.3) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.3,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
dnl Each server should have at least one connection.
OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Configure selection_fields.
ovn-nbctl set load_balancer $lb2_uuid selection_fields="ip_src,ip_dst,tp_src,tp_dst"
OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)" -c) -eq 2
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

dnl Test load-balancing that includes L4 ports in NAT.
dnl Each server should have at least one connection.
OVS_WAIT_FOR_OUTPUT([
    for i in `seq 1 20`; do
        ip netns exec foo1 wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log;
    done
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=172.16.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

echo "foo" > foo
for i in `seq 1 20`; do
    echo Request $i
    ip netns exec foo1 nc -p 30000 30.0.0.2 8000 < foo
done

dnl Only one backend should be chosen.
AT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 -c) -eq 1])

ovn-nbctl set load_balancer $lb2_uuid selection_fields="ip_src"
OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields=ip_src" -c) -eq 2
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
for i in `seq 1 20`; do
    echo Request $i
    ip netns exec foo1 nc 30.0.0.2 8000 < foo
done

dnl Only one backend should be chosen as eth_src and ip_src is fixed.
bar1_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.2 -c)
bar2_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.3 -c)
bar3_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1.4 -c)

AT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep 172.16.1 -c) -ne 0])

if [[ "$bar1_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 20])
    AT_CHECK([test $bar2_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar1_ct -eq 0])
fi

if [[ "$bar2_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 20])
    AT_CHECK([test $bar2_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar2_ct -eq 0])
fi

if [[ "$bar3_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 20])
    AT_CHECK([test $bar2_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar3_ct -eq 0])
fi

# Change the protocol of lb2 to udp and set tp_src and tp_dst.
ovn-nbctl set load_balancer $lb2_uuid selection_fields="ip_src,ip_dst,tp_src,tp_dst"

OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)" -c) -eq 2
])

ovn-nbctl set load_balancer $lb2_uuid protocol=udp

OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,udp_src,udp_dst)" -c) -eq 2
])

# Change the protocol of lb2 to sctp.
ovn-nbctl set load_balancer $lb2_uuid protocol=sctp

OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,sctp_src,sctp_dst)" -c) -eq 2
])

ovn-nbctl --reject lb-add lb3 30.0.0.10:80 ""
ovn-nbctl ls-lb-add foo lb3
# Filter reset segments
NS_CHECK_EXEC([foo1], [tcpdump -c 1 -neei foo1 ip[[33:1]]=0x14 > rst.pcap 2>/dev/null &])
sleep 1
NS_CHECK_EXEC([foo1], [wget -q 30.0.0.10],[4])

OVS_WAIT_UNTIL([
    n_reset=$(cat rst.pcap | wc -l)
    test "${n_reset}" = "1"
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancing - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 2 logical switches "foo" (fd01::/64) and "bar" (fd02::/64)
# connected to a router R1.
# foo has foo1 to act as a client.
# bar has bar1, bar2, bar3 to act as servers.
#
# Loadbalancer VIPs in fd03::/64 network.

ovn-nbctl create Logical_Router name=R1
ovn-nbctl ls-add foo
ovn-nbctl ls-add bar

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd02::1/64
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Create logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd01::2/64", "f0:00:00:01:02:03", \
         "fd01::1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd01::2"

# Create logical ports 'bar1', 'bar2', 'bar3' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd02::2/64", "f0:00:0f:01:02:03", \
         "fd02::1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:0f:01:02:03 fd02::2"

ADD_NAMESPACES(bar2)
ADD_VETH(bar2, bar2, br-int, "fd02::3/64", "f0:00:0f:01:02:04", \
         "fd02::1")
ovn-nbctl lsp-add bar bar2 \
-- lsp-set-addresses bar2 "f0:00:0f:01:02:04 fd02::3"

ADD_NAMESPACES(bar3)
ADD_VETH(bar3, bar3, br-int, "fd02::4/64", "f0:00:0f:01:02:05", \
         "fd02::1")
ovn-nbctl lsp-add bar bar3 \
-- lsp-set-addresses bar3 "f0:00:0f:01:02:05 fd02::4"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:\"fd03::1\"=\"fd02::2,fd02::3,fd02::4\"`
ovn-nbctl set logical_switch foo load_balancer=$uuid

# Create another load-balancer with another VIP.
lb2_uuid=`ovn-nbctl create load_balancer vips:\"fd03::3\"=\"fd02::2,fd02::3,fd02::4\"`
ovn-nbctl add logical_switch foo load_balancer $lb2_uuid

# Config OVN load-balancer with another VIP (this time with ports).
ovn-nbctl set load_balancer $lb2_uuid vips:'"[[fd03::2]]:8000"'='"@<:@fd02::2@:>@:80,@<:@fd02::3@:>@:80,@<:@fd02::4@:>@:80"'

# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=\[[fd02::4\]]:80)'])

# Start webservers in 'bar1', 'bar2' and 'bar3'.
OVS_START_L7([bar1], [http6])
OVS_START_L7([bar2], [http6])
OVS_START_L7([bar3], [http6])

dnl Should work with the virtual IP fd03::1 address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([foo1], [wget http://[[fd03::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log || (ovs-ofctl -O OpenFlow13 dump-flows br-int && false)])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::1) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Should work with the virtual IP fd03::3 address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([foo1], [wget http://[[fd03::3]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::3) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::3,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Configure selection_fields.
ovn-nbctl set load_balancer $lb2_uuid selection_fields="ip_src,ip_dst,tp_src,tp_dst"
OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(ip_src,ip_dst,tcp_src,tcp_dst)" -c) -eq 2
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd02::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

echo "foo" > foo
for i in `seq 1 20`; do
    echo Request $i
    ip netns exec foo1 nc -6 -p 30000 fd03::2 8000 < foo
done

# Only one backend should be chosen. Since the source port is fixed,
# there should be only one conntrack entry.
AT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep fd03::2 -c) -eq 1])

ovn-nbctl set load_balancer $lb2_uuid selection_fields="eth_src,ip_src"
OVS_WAIT_UNTIL([
    test $(ovs-ofctl dump-groups br-int | \
    grep "selection_method=hash,fields(eth_src,ip_src)" -c) -eq 2
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
for i in `seq 1 20`; do
    echo Request $i
    ip netns exec foo1 nc -6 fd03::2 8000 < foo
done

dnl Only one backend should be chosen as eth_src and ip_src is fixed.
bar1_ct=$(ovs-appctl dpctl/dump-conntrack | grep fd03::2 | grep fd02::2 -c)
bar2_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep fd02::3 -c)
bar3_ct=$(ovs-appctl dpctl/dump-conntrack | grep 30.0.0.2 | grep fd02::4 -c)

AT_CHECK([test $(ovs-appctl dpctl/dump-conntrack | grep fd03::2 | grep fd02 -c) -ne 0])

if [[ "$bar1_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 20])
    AT_CHECK([test $bar2_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar1_ct -eq 0])
fi

if [[ "$bar2_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 20])
    AT_CHECK([test $bar2_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar2_ct -eq 0])
fi

if [[ "$bar3_ct" == "20" ]]; then
    AT_CHECK([test $bar1_ct -eq 20])
    AT_CHECK([test $bar2_ct -eq 0])
    AT_CHECK([test $bar3_ct -eq 0])
else
    AT_CHECK([test $bar3_ct -eq 0])
fi
OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancing - same subnet.])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 1 logical switch "foo" (192.168.1.0/24) connected to router R1.
# foo has foo1, foo2, foo3, foo4 as logical ports.
#
# Loadbalancer VIPs in 30.0.0.0/24 network. Router is needed for default
# gateway. We will test load-balancing with foo1 as a client and foo2, foo3 and
# foo4 as servers.

ovn-nbctl create Logical_Router name=R1
ovn-nbctl ls-add foo

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Create logical port 'foo1', 'foo2', 'foo3' and 'foo4' in switch 'foo'.
ADD_NAMESPACES(foo1, foo2, foo3, foo4)
for i in `seq 1 4`; do
    j=`expr $i + 1`
    ADD_VETH(foo$i, foo$i, br-int, "192.168.1.$j/24", "f0:00:00:01:02:0$j", \
             "192.168.1.1")
    ovn-nbctl lsp-add foo foo$i \
        -- lsp-set-addresses foo$i "f0:00:00:01:02:0$j 192.168.1.$j"
done

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.3,192.168.1.4,192.168.1.5"`
ovn-nbctl set logical_switch foo load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
ovn-nbctl set load_balancer $uuid vips:'"30.0.0.2:8000"'='"192.168.1.3:80,192.168.1.4:80,192.168.1.5:80"'

# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.1.5:80)'])

# Start webservers in 'foo2', 'foo3' and 'foo4'.
OVS_START_L7([foo2], [http])
OVS_START_L7([foo3], [http])
OVS_START_L7([foo4], [http])

dnl Should work with the virtual IP address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([foo1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.5,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([foo1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.4,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=192.168.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.5,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])


OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancing - same subnet. - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 1 logical switch "foo" (fd01::/64) connected to router R1.
# foo has foo1, foo2, foo3, foo4 as logical ports.
#
# Loadbalancer VIPs in fd03::/64 network. Router is needed for default
# gateway. We will test load-balancing with foo1 as a client and foo2, foo3 and
# foo4 as servers.

ovn-nbctl create Logical_Router name=R1
ovn-nbctl ls-add foo

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Create logical port 'foo1', 'foo2', 'foo3' and 'foo4' in switch 'foo'.
ADD_NAMESPACES(foo1, foo2, foo3, foo4)
for i in `seq 1 4`; do
    j=`expr $i + 1`
    ADD_VETH(foo$i, foo$i, br-int, "fd01::$j/64", "f0:00:00:01:02:0$j", \
             "fd01::1")
    ovn-nbctl lsp-add foo foo$i \
        -- lsp-set-addresses foo$i "f0:00:00:01:02:0$j fd01::$j"
done

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:\"fd03::1\"=\"fd01::3,fd01::4,fd01::5\"`
ovn-nbctl set logical_switch foo load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
ovn-nbctl set load_balancer $uuid vips:'"[[fd03::2]]:8000"'='"@<:@fd01::3@:>@:80,@<:@fd01::4@:>@:80,@<:@fd01::5@:>@:80"'

ovn-nbctl list load_balancer

# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=\[[fd01::5\]]:80)'])

# Start webservers in 'foo2', 'foo3' and 'foo4'.
OVS_START_L7([foo2], [http6])
OVS_START_L7([foo3], [http6])
OVS_START_L7([foo4], [http6])

dnl Should work with the virtual IP address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([foo1], [wget http://[[fd03::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::1) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::1,sport=<cleared>,dport=<cleared>),reply=(src=fd01::5,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([foo1], [wget http://[[fd03::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd03::2) | grep -v fe80 | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::3,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::4,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd01::2,dst=fd03::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::5,dst=fd01::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])


OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in gateway router])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected
# to it.  R2 is a gateway router on which we add load-balancing rules.
#
#    foo -- R1 -- join - R2 -- alice
#           |
#    bar ----

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
ovn-nbctl lr-route-add R1 172.16.1.0/24 20.0.0.2
ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.2,192.168.2.2"`
ovn-nbctl set logical_router R2 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
ovn-nbctl set load_balancer $uuid vips:'"30.0.0.2:8000"'='"192.168.1.2:80,192.168.2.2:80"'

# Add SNAT rule to make sure that Load-balancing still works with a SNAT rule.
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=192.168.2.2 \
    external_ip=30.0.0.2 -- add logical_router R2 nat @nat

# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2:80)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http])
OVS_START_L7([bar1], [http])

dnl Should work with the virtual IP address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

check_est_flows () {
    n=$(ovs-ofctl dump-flows br-int table=13 | grep \
"priority=100,tcp,metadata=0x2,nw_dst=30.0.0.2" | grep nat |
sed -n 's/.*n_packets=\([[0-9]]\{1,\}\).*/\1/p')

    echo "n_packets=$n"
    test ! -z $n
    test "$n" != 0
}

OVS_WAIT_UNTIL([check_est_flows], [check established flows])


ovn-nbctl set logical_router R2 options:lb_force_snat_ip="20.0.0.2"

# Destroy the load balancer and create again. ovn-controller will
# clear the OF flows and re add again and clears the n_packets
# for these flows.
ovn-nbctl destroy load_balancer $uuid
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.2,192.168.2.2"`
ovn-nbctl set logical_router R2 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
ovn-nbctl set load_balancer $uuid vips:'"30.0.0.2:8000"'='"192.168.1.2:80,192.168.2.2:80"'

ovn-nbctl list load_balancer
ovn-sbctl dump-flows R2
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-flows br-int table=43 | \
grep 'nat(src=20.0.0.2)'])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

OVS_WAIT_UNTIL([check_est_flows], [check established flows])

ovn-nbctl set logical_router R2 options:lb_force_snat_ip=router_ip

# Destroy the load balancer and create again. ovn-controller will
# clear the OF flows and re add again and clears the n_packets
# for these flows.
ovn-nbctl destroy load_balancer $uuid
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.2,192.168.2.2"`
ovn-nbctl set logical_router R2 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
ovn-nbctl set load_balancer $uuid vips:'"30.0.0.2:8000"'='"192.168.1.2:80,192.168.2.2:80"'

ovn-nbctl list load_balancer
ovn-sbctl dump-flows R2
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-flows br-int table=43 | \
grep 'nat(src=20.0.0.2)'])

rm -f wget*.log

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget 30.0.0.2:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.2) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=30.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0.2) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

OVS_WAIT_UNTIL([check_est_flows], [check established flows])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in gateway router hairpin scenario])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext], [set Bridge br-ext fail-mode=standalone])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24

check ovn-nbctl set logical_router R1 options:chassis=hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

check ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext

check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

ADD_NAMESPACES(server)
ADD_VETH(s1, server, br-ext, "172.16.1.100/24", "1a:00:00:00:00:01", \
         "172.16.1.1")

OVS_WAIT_UNTIL([test "$(ip netns exec server ip a | grep fe80 | grep tentative)" = ""])

ADD_NAMESPACES(client)
ADD_VETH(c1, client, br-ext, "172.16.1.110/24", "1a:00:00:00:00:02", \
         "172.16.1.1")

OVS_WAIT_UNTIL([test "$(ip netns exec client ip a | grep fe80 | grep tentative)" = ""])

# Start webservers in 'server'.
OVS_START_L7([server], [http])

# Create a load balancer and associate to R1
check ovn-nbctl lb-add lb1 172.16.1.150:80 172.16.1.100:80
check ovn-nbctl lr-lb-add R1 lb1

check ovn-nbctl --wait=hv sync

for i in $(seq 1 5); do
    echo Request $i
    NS_CHECK_EXEC([client], [wget 172.16.1.100 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

# Now send the traffic from client to the VIP - 172.16.1.150
check ovn-nbctl set logical_router R1 options:lb_force_snat_ip=router_ip
check ovn-nbctl --wait=hv sync

for i in $(seq 1 5); do
    echo Request $i
    NS_CHECK_EXEC([client], [wget 172.16.1.150 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/Failed to acquire.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in gateway router - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two LRs - R1 and R2 that are connected to each other via LS "join"
# in fd20::/64 network. R1 has switchess foo (fd11::/64) and
# bar (fd12::/64) connected to it. R2 has alice (fd72::/64) connected
# to it.  R2 is a gateway router on which we add load-balancing rules.
#
#    foo -- R1 -- join - R2 -- alice
#           |
#    bar ----

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd72::1/64
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Static routes.
ovn-nbctl lr-route-add R1 fd72::/64 fd20::2
ovn-nbctl lr-route-add R2 fd11::/64 fd20::1
ovn-nbctl lr-route-add R2 fd12::/64 fd20::1

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd72::2/64", "f0:00:00:01:02:04", \
         "fd72::1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd72::2"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:05", \
"fd12::1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 fd12::2"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:\"fd30::1\"=\"fd11::2,fd12::2\"`
ovn-nbctl set logical_router R2 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
ovn-nbctl set load_balancer $uuid vips:'"[[fd30::2]]:8000"'='"@<:@fd11::2@:>@:80,@<:@fd12::2@:>@:80"'

ovn-nbctl list load_balancer

# Add SNAT rule to make sure that Load-balancing still works with a SNAT rule.
ovn-nbctl -- --id=@nat create nat type="snat" logical_ip=\"fd12::2\" \
    external_ip=\"fd30::2\" -- add logical_router R2 nat @nat


# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=\[[fd12::2\]]:80)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http6])
OVS_START_L7([bar1], [http6])

dnl Should work with the virtual IP address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::2,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget http://[[fd30::2]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::2) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::2,dst=fd30::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, load-balancing])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 network. R1 has switchess foo (192.168.1.0/24) and
# bar (192.168.2.0/24) connected to it. R2 has alice (172.16.1.0/24) connected
# to it.  R3 has bob (172.16.1.0/24) connected to it. Note how both alice and
# bob have the same subnet behind it.  We are trying to simulate external
# network via those 2 switches. In real world the switch ports of these
# switches will have addresses set as "unknown" to make them learning switches.
# Or those switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24
ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.1.0/24 20.0.0.2
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.2.0/24 20.0.0.3

# Static routes.
ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1
ovn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1

# For gateway routers R2 and R3, set a force SNAT rule.
ovn-nbctl set logical_router R2 options:lb_force_snat_ip=20.0.0.2
ovn-nbctl set logical_router R3 options:lb_force_snat_ip=20.0.0.3

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.3/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "172.16.1.4/24", "f0:00:00:01:02:06", \
         "172.16.1.2")
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.1.4"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.2,192.168.2.2"`
ovn-nbctl set logical_router R2 load_balancer=$uuid
ovn-nbctl set logical_router R3 load_balancer=$uuid

# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http])
OVS_START_L7([bar1], [http])

dnl Should work with the virtual IP address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Force SNAT should have worked.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.3,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])
OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, load-balancing - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in fd20::/64 network. R1 has switchess foo (fd11::/64) and
# bar (fd12::/64) connected to it. R2 has alice (fd72::/64) connected
# to it.  R3 has bob (fd72::/64) connected to it. Note how both alice and
# bob have the same subnet behind it.  We are trying to simulate external
# network via those 2 switches. In real world the switch ports of these
# switches will have addresses set as "unknown" to make them learning switches.
# Or those switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 fd72::1/64
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 fd72::2/64
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 fd20::1/64
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 fd20::2/64
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 fd20::3/64
ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
ovn-nbctl --policy="src-ip" lr-route-add R1 fd11::/64 fd20::2
ovn-nbctl --policy="src-ip" lr-route-add R1 fd12::/64 fd20::3

# Static routes.
ovn-nbctl lr-route-add R2 fd11::/64 fd20::1
ovn-nbctl lr-route-add R2 fd12::/64 fd20::1
ovn-nbctl lr-route-add R3 fd11::/64 fd20::1
ovn-nbctl lr-route-add R3 fd12::/64 fd20::1

# For gateway routers R2 and R3, set a force SNAT rule.
ovn-nbctl set logical_router R2 options:lb_force_snat_ip=fd20::2
ovn-nbctl set logical_router R3 options:lb_force_snat_ip=fd20::3

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd72::3/64", "f0:00:00:01:02:04", \
         "fd72::1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd72::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:05", \
"fd12::1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 fd12::2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "fd72::4/64", "f0:00:00:01:02:06", \
         "fd72::2")
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 fd72::4"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl create load_balancer vips:\"fd30::1\"=\"fd11::2,fd12::2\"`
ovn-nbctl set logical_router R2 load_balancer=$uuid
ovn-nbctl set logical_router R3 load_balancer=$uuid

# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=fd12::2)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http6])
OVS_START_L7([bar1], [http6])

dnl Should work with the virtual IP address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Force SNAT should have worked.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::3,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::3,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])
OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([multiple gateway routers, load-balancing - Dual Stack])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Three LRs - R1, R2 and R3 that are connected to each other via LS "join"
# in 20.0.0.0/24 and fd20::/64 networks. R1 has switches foo (192.168.1.0/24
# and fd11::/64) and bar (192.168.2.0/24 and fd12::/64) connected to it. R2
# has alice (172.16.1.0/24 and fd72::/64) connected to it.  R3 has bob
# (172.16.1.0/24 and fd72::/64) connected to it. Note how both alice and
# bob have the same subnets behind them.  We are trying to simulate external
# network via those 2 switches. In real world the switch ports of these
# switches will have addresses set as "unknown" to make them learning switches.
# Or those switches will be "localnet" ones.
#
#    foo -- R1 -- join - R2 -- alice
#           |          |
#    bar ----          - R3 --- bob

ovn-nbctl create Logical_Router name=R1
ovn-nbctl create Logical_Router name=R2 options:chassis=hv1
ovn-nbctl create Logical_Router name=R3 options:chassis=hv1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add join

# Connect foo to R1
ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24 fd11::1/64
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo addresses=\"00:00:01:01:02:03\"

# Connect bar to R1
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24 fd12::1/64
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar addresses=\"00:00:01:01:02:04\"

# Connect alice to R2
ovn-nbctl lrp-add R2 alice 00:00:02:01:02:03 172.16.1.1/24 fd72::1/64
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses=\"00:00:02:01:02:03\"

# Connect bob to R3
ovn-nbctl lrp-add R3 bob 00:00:03:01:02:03 172.16.1.2/24 fd72::2/64
ovn-nbctl lsp-add bob rp-bob -- set Logical_Switch_Port rp-bob \
    type=router options:router-port=bob addresses=\"00:00:03:01:02:03\"

# Connect R1 to join
ovn-nbctl lrp-add R1 R1_join 00:00:04:01:02:03 20.0.0.1/24 fd20::1/64
ovn-nbctl lsp-add join r1-join -- set Logical_Switch_Port r1-join \
    type=router options:router-port=R1_join addresses='"00:00:04:01:02:03"'

# Connect R2 to join
ovn-nbctl lrp-add R2 R2_join 00:00:04:01:02:04 20.0.0.2/24 fd20::2/64
ovn-nbctl lsp-add join r2-join -- set Logical_Switch_Port r2-join \
    type=router options:router-port=R2_join addresses='"00:00:04:01:02:04"'

# Connect R3 to join
ovn-nbctl lrp-add R3 R3_join 00:00:04:01:02:05 20.0.0.3/24 fd20::3/64
ovn-nbctl lsp-add join r3-join -- set Logical_Switch_Port r3-join \
    type=router options:router-port=R3_join addresses='"00:00:04:01:02:05"'

# Install static routes with source ip address as the policy for routing.
# We want traffic from 'foo' to go via R2 and traffic of 'bar' to go via R3.
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.1.0/24 20.0.0.2
ovn-nbctl --policy="src-ip" lr-route-add R1 192.168.2.0/24 20.0.0.3
ovn-nbctl --policy="src-ip" lr-route-add R1 fd11::/64 fd20::2
ovn-nbctl --policy="src-ip" lr-route-add R1 fd12::/64 fd20::3

# Static routes.
ovn-nbctl lr-route-add R2 192.168.0.0/16 20.0.0.1
ovn-nbctl lr-route-add R3 192.168.0.0/16 20.0.0.1
ovn-nbctl lr-route-add R2 fd11::/64 fd20::1
ovn-nbctl lr-route-add R2 fd12::/64 fd20::1
ovn-nbctl lr-route-add R3 fd11::/64 fd20::1
ovn-nbctl lr-route-add R3 fd12::/64 fd20::1

# For gateway routers R2 and R3, set a force SNAT rule.
ovn-nbctl set logical_router R2 options:lb_force_snat_ip="20.0.0.2 fd20::2"
ovn-nbctl set logical_router R3 options:lb_force_snat_ip="20.0.0.3 fd20::3"

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'foo16' in switch 'foo'.
ADD_NAMESPACES(foo16)
ADD_VETH(foo16, foo16, br-int, "fd11::2/64", "f0:00:06:01:02:03", \
         "fd11::1")
ovn-nbctl lsp-add foo foo16 \
-- lsp-set-addresses foo16 "f0:00:06:01:02:03 fd11::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.3/24", "f0:00:00:01:02:04", \
         "172.16.1.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 172.16.1.3"

# Logical port 'alice16' in switch 'alice'.
ADD_NAMESPACES(alice16)
ADD_VETH(alice16, alice16, br-int, "fd72::3/64", "f0:00:06:01:02:04", \
         "fd72::1")
ovn-nbctl lsp-add alice alice16 \
-- lsp-set-addresses alice16 "f0:00:06:01:02:04 fd72::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:05", \
"192.168.2.1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:05 192.168.2.2"

# Logical port 'bar16' in switch 'bar'.
ADD_NAMESPACES(bar16)
ADD_VETH(bar16, bar16, br-int, "fd12::2/64", "f0:00:06:01:02:05", \
"fd12::1")
ovn-nbctl lsp-add bar bar16 \
-- lsp-set-addresses bar16 "f0:00:06:01:02:05 fd12::2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "172.16.1.4/24", "f0:00:00:01:02:06", \
         "172.16.1.2")
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.1.4"

# Logical port 'bob16' in switch 'bob'.
ADD_NAMESPACES(bob16)
ADD_VETH(bob16, bob16, br-int, "fd72::4/64", "f0:00:06:01:02:06", \
         "fd72::2")
ovn-nbctl lsp-add bob bob16 \
-- lsp-set-addresses bob16 "f0:00:06:01:02:06 fd72::4"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:30.0.0.1="192.168.1.2,192.168.2.2" \
vips:\"fd30::1\"=\"fd11::2,fd12::2\"`
ovn-nbctl set logical_router R2 load_balancer=$uuid
ovn-nbctl set logical_router R3 load_balancer=$uuid

# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2)'])
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=fd12::2)'])

# Start webservers in 'foo1', 'foo16, 'bar1', and 'bar16'.
OVS_START_L7([foo1], [http])
OVS_START_L7([bar1], [http])
OVS_START_L7([foo16], [http6])
OVS_START_L7([bar16], [http6])

dnl Should work with the virtual IP address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget 30.0.0.1 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

for i in `seq 1 20`; do
    echo Request ${i}_6
    NS_CHECK_EXEC([alice16], [wget http://[[fd30::1]] -t 5 -T 1 --retry-connrefused -v -o wget${i}_6.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.3,dst=30.0.0.1,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd30::1) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::3,dst=fd30::1,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd72::3,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Force SNAT should have worked.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(20.0.0) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.3,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.3,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=20.0.0.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::2) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::3,dst=fd11::2,sport=<cleared>,dport=<cleared>),reply=(src=fd11::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::3,dst=fd12::2,sport=<cleared>,dport=<cleared>),reply=(src=fd12::2,dst=fd20::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])
OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in router with gateway router port])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),
# and alice (172.16.1.0/24) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 LB rules are applied.
#
#    foo -- R1 -- bar
#           |
#    alice ----

ovn-nbctl lr-add R1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice

ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "192.168.1.3/24", "f0:00:00:01:02:06", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 192.168.1.3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:04", \
         "192.168.2.1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 192.168.2.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:05", \
         "172.16.1.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 172.16.1.2"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:172.16.1.10="192.168.1.2,192.168.2.2"`
ovn-nbctl set logical_router R1 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
ovn-nbctl set load_balancer $uuid vips:'"172.16.1.11:8000"'='"192.168.1.2:80,192.168.2.2:80"'

# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=192.168.2.2:80)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http])
OVS_START_L7([bar1], [http])

dnl Should work with the virtual IP address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget 172.16.1.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.10) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=172.16.1.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=172.16.1.10,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget 172.16.1.11:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.11) |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.1.2,dst=172.16.1.11,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=172.16.1.2,dst=172.16.1.11,sport=<cleared>,dport=<cleared>),reply=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load balancing in router with gateway router port - IPv6])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (fd01::/64), bar (fd02::/64),
# and alice (fd72::/64) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 LB rules are applied.
#
#    foo -- R1 -- bar
#           |
#    alice ----

ovn-nbctl lr-add R1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice

ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd01::1/64
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd02::1/64
ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd72::1/64 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd01::2/64", "f0:00:00:01:02:03", \
         "fd01::1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd01::2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "fd01::3/64", "f0:00:00:01:02:06", \
         "fd01::1")
ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 fd01::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd02::2/64", "f0:00:00:01:02:04", \
         "fd02::1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 fd02::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd72::2/64", "f0:00:00:01:02:05", \
         "fd72::1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 fd72::2"

# Config OVN load-balancer with a VIP.
uuid=`ovn-nbctl  create load_balancer vips:\"fd72::10\"=\"fd01::2,fd02::2\"`
ovn-nbctl set logical_router R1 load_balancer=$uuid

# Config OVN load-balancer with another VIP (this time with ports).
ovn-nbctl set load_balancer $uuid vips:'"[[fd72::11]]:8000"'='"@<:@fd01::2@:>@:80,@<:@fd02::2@:>@:80"'

# Wait for ovn-controller to catch up.
ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl -O OpenFlow13 dump-groups br-int | \
grep 'nat(dst=\[[fd02::2\]]:80)'])

# Start webservers in 'foo1', 'bar1'.
OVS_START_L7([foo1], [http6])
OVS_START_L7([bar1], [http6])

dnl Should work with the virtual IP address through NAT
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget http://[[fd72::10]] -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd72::10) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::2,dst=fd72::10,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::2,dst=fd72::10,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

dnl Test load-balancing that includes L4 ports in NAT.
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([alice1], [wget http://[[fd72::11]]:8000 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd72::11) | grep -v fe80 |
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=fd72::2,dst=fd72::11,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=fd72::2,dst=fd72::11,sport=<cleared>,dport=<cleared>),reply=(src=fd02::2,dst=fd72::2,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT and SNAT on distributed router - N/S])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),
# and alice (172.16.1.0/24) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 NAT rules are applied.
#
#    foo -- R1 -- alice
#           |
#    bar ----

ovn-nbctl lr-add R1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice

ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "192.168.1.3/24", "f0:00:00:01:02:06", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 192.168.1.3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:04", \
         "192.168.2.1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 192.168.2.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:05", \
         "172.16.1.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 172.16.1.2"

# Add external network
ADD_NAMESPACES(ext-net)
AT_CHECK([ip link add alice-ext netns alice1 type veth peer name ext-veth netns ext-net])
NS_CHECK_EXEC([ext-net], [ip link set dev ext-veth up], [0], [])
NS_CHECK_EXEC([ext-net], [ip addr add 10.0.0.1/24 dev ext-veth], [0], [])
NS_CHECK_EXEC([ext-net], [ip route add default via 10.0.0.2], [0], [])

NS_CHECK_EXEC([alice1], [ip link set dev alice-ext up], [0], [])
NS_CHECK_EXEC([alice1], [ip addr add 10.0.0.2/24 dev alice-ext], [0], [])
NS_CHECK_EXEC([alice1], [sysctl -w net.ipv4.conf.all.forwarding=1],[0], [dnl
net.ipv4.conf.all.forwarding = 1
])

# Add DNAT rules
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.1.2 foo1 00:00:02:02:03:04])
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.4 192.168.1.3 foo2 00:00:02:02:03:05])

# Add a SNAT rule
AT_CHECK([ovn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.0.0/16])

# Add default route to ext-net
AT_CHECK([ovn-nbctl lr-route-add R1 10.0.0.0/24 172.16.1.2])

ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])

# North-South DNAT: 'alice1' pings 'foo1' using 172.16.1.3.
NS_CHECK_EXEC([alice1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that DNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.2,dst=172.16.1.3,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=172.16.1.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

# South-North SNAT: 'foo2' pings 'alice1'. But 'alice1' receives traffic
# from 172.16.1.4
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.3,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.4,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic
# from 172.16.1.1
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=172.16.1.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

# Try to ping external network
NS_CHECK_EXEC([ext-net], [tcpdump -n -c 3 -i ext-veth dst 172.16.1.3 and icmp > ext-net.pcap &])
sleep 1
AT_CHECK([ovn-nbctl lr-nat-del R1 snat])
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVS_WAIT_UNTIL([
    total_pkts=$(cat ext-net.pcap | wc -l)
    test "${total_pkts}" = "3"
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT and SNAT on distributed router - N/S - IPv6])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (fd11::/64), bar (fd12::/64),
# and alice (fd20::/64) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 NAT rules are applied.
#
#    foo -- R1 -- alice
#           |
#    bar ----

ovn-nbctl lr-add R1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice

ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd20::1/64 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1")
OVS_WAIT_UNTIL([test "$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)" = ""])
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "fd11::3/64", "f0:00:00:01:02:06", \
         "fd11::1")
OVS_WAIT_UNTIL([test "$(ip netns exec foo2 ip a | grep fd11::3 | grep tentative)" = ""])
ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 fd11::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:04", \
         "fd12::1")
OVS_WAIT_UNTIL([test "$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)" = ""])
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 fd12::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd20::2/64", "f0:00:00:01:02:05", \
         "fd20::1")
OVS_WAIT_UNTIL([test "$(ip netns exec alice1 ip a | grep fd20::2 | grep tentative)" = ""])
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 fd20::2"

ovn-nbctl --wait=hv sync

# Add DNAT rules
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::3 fd11::2 foo1 00:00:02:02:03:04])
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::4 fd11::3 foo2 00:00:02:02:03:05])

# Add a SNAT rule
AT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd11::/64])
AT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd12::/64])

ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd20::1)'])

# North-South DNAT: 'alice1' pings 'foo1' using fd20::3
NS_CHECK_EXEC([alice1], [ping6 -q -c 3 -i 0.3 -w 2 fd20::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that DNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd20::2,dst=fd20::3,id=<cleared>,type=128,code=0),reply=(src=fd11::2,dst=fd20::2,id=<cleared>,type=129,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# South-North SNAT: 'foo2' pings 'alice1'. But 'alice1' receives traffic
# from fd20::4
NS_CHECK_EXEC([foo2], [ping6 -q -c 3 -i 0.3 -w 2 fd20::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

ovs-appctl dpctl/dump-conntrack | grep icmpv6
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd11::3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd11::3,dst=fd20::2,id=<cleared>,type=128,code=0),reply=(src=fd20::2,dst=fd20::4,id=<cleared>,type=129,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# South-North SNAT: 'bar1' pings 'alice1'. But 'alice1' receives traffic
# from fd20::1
NS_CHECK_EXEC([bar1], [ping6 -q -c 3 -i 0.3 -w 2 fd20::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that SNAT indeed happened via 'dump-conntrack' command.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd12::2,dst=fd20::2,id=<cleared>,type=128,code=0),reply=(src=fd20::2,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT and SNAT on distributed router - E/W])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (192.168.1.0/24), bar (192.168.2.0/24),
# and alice (172.16.1.0/24) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 NAT rules are applied.
#
#    foo -- R1 -- alice
#           |
#    bar ----

ovn-nbctl lr-add R1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice

ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 192.168.1.2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "192.168.1.3/24", "f0:00:00:01:02:06", \
         "192.168.1.1")
ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 192.168.1.3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "192.168.2.2/24", "f0:00:00:01:02:04", \
         "192.168.2.1")
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 192.168.2.2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "172.16.1.2/24", "f0:00:00:01:02:05", \
         "172.16.1.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 172.16.1.2"

# Add DNAT rules
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.3 192.168.1.2 foo1 00:00:02:02:03:04])
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.1.4 192.168.2.2 bar1 00:00:02:02:03:05])

# Add a SNAT rule
AT_CHECK([ovn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.0.0/16])

ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=172.16.1.1)'])

echo "------ hv dump ------"
ovs-ofctl show br-int
ovs-ofctl dump-flows br-int
echo "---------------------"

# East-West No NAT: 'foo1' pings 'bar1' using 192.168.2.2.
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that the connection is not tracked.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# East-West No NAT: 'foo2' pings 'bar1' using 192.168.2.2.
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 192.168.2.2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that the connection is not tracked.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# East-West No NAT: 'bar1' pings 'foo2' using 192.168.1.3.
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 192.168.1.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# We verify that the connection is not tracked.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(192.168.2.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# East-West NAT: 'foo1' pings 'bar1' using 172.16.1.4.
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.  First SNAT of 'foo1' address happens.
# Then DNAT of 'bar1' address happens (listed first below).
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(172.16.1.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.3,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=192.168.1.2,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=172.16.1.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# East-West NAT: 'foo2' pings 'bar1' using 172.16.1.4.
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 172.16.1.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.  First SNAT of 'foo2' address happens.
# Then DNAT of 'bar1' address happens (listed first below).
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep icmp | FORMAT_CT(172.16.1.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.1.1,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=192.168.2.2,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=192.168.1.3,dst=172.16.1.4,id=<cleared>,type=8,code=0),reply=(src=172.16.1.4,dst=172.16.1.1,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT and SNAT on distributed router - E/W - IPv6])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LR R1 with switches foo (fd11::/64), bar (fd12::/64),
# and alice (fd20::/64) connected to it.  The port between R1 and
# alice is the router gateway port where the R1 NAT rules are applied.
#
#    foo -- R1 -- alice
#           |
#    bar ----

ovn-nbctl lr-add R1

ovn-nbctl ls-add foo
ovn-nbctl ls-add bar
ovn-nbctl ls-add alice

ovn-nbctl lrp-add R1 foo 00:00:01:01:02:03 fd11::1/64
ovn-nbctl lrp-add R1 bar 00:00:01:01:02:04 fd12::1/64
ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 fd20::1/64 \
    -- lrp-set-gateway-chassis alice hv1

# Connect foo to R1
ovn-nbctl lsp-add foo rp-foo -- set Logical_Switch_Port rp-foo \
    type=router options:router-port=foo \
    -- lsp-set-addresses rp-foo router

# Connect bar to R1
ovn-nbctl lsp-add bar rp-bar -- set Logical_Switch_Port rp-bar \
    type=router options:router-port=bar \
    -- lsp-set-addresses rp-bar router

# Connect alice to R1
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice \
    -- lsp-set-addresses rp-alice router

# Logical port 'foo1' in switch 'foo'.
ADD_NAMESPACES(foo1)
ADD_VETH(foo1, foo1, br-int, "fd11::2/64", "f0:00:00:01:02:03", \
         "fd11::1")
OVS_WAIT_UNTIL([test "$(ip netns exec foo1 ip a | grep fd11::2 | grep tentative)" = ""])
ovn-nbctl lsp-add foo foo1 \
-- lsp-set-addresses foo1 "f0:00:00:01:02:03 fd11::2"

# Logical port 'foo2' in switch 'foo'.
ADD_NAMESPACES(foo2)
ADD_VETH(foo2, foo2, br-int, "fd11::3/64", "f0:00:00:01:02:06", \
         "fd11::1")
OVS_WAIT_UNTIL([test "$(ip netns exec foo2 ip a | grep fd11::3 | grep tentative)" = ""])
ovn-nbctl lsp-add foo foo2 \
-- lsp-set-addresses foo2 "f0:00:00:01:02:06 fd11::3"

# Logical port 'bar1' in switch 'bar'.
ADD_NAMESPACES(bar1)
ADD_VETH(bar1, bar1, br-int, "fd12::2/64", "f0:00:00:01:02:04", \
         "fd12::1")
OVS_WAIT_UNTIL([test "$(ip netns exec bar1 ip a | grep fd12::2 | grep tentative)" = ""])
ovn-nbctl lsp-add bar bar1 \
-- lsp-set-addresses bar1 "f0:00:00:01:02:04 fd12::2"

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "fd20::2/64", "f0:00:00:01:02:05", \
         "fd20::1")
OVS_WAIT_UNTIL([test "$(ip netns exec alice1 ip a | grep fd20::2 | grep tentative)" = ""])
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:05 fd20::2"

# Add DNAT rules
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::3 fd11::2 foo1 00:00:02:02:03:04])
AT_CHECK([ovn-nbctl lr-nat-add R1 dnat_and_snat fd20::4 fd12::2 bar1 00:00:02:02:03:05])

# Add a SNAT rule
AT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd11::/64])
AT_CHECK([ovn-nbctl lr-nat-add R1 snat fd20::1 fd12::/64])

ovn-nbctl --wait=hv sync
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep 'nat(src=fd20::1)'])

echo "------ hv dump ------"
ovs-ofctl show br-int
ovs-ofctl dump-flows br-int
echo "---------------------"

# East-West No NAT: 'foo1' pings 'bar1' using fd12::2.
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# East-West No NAT: 'foo2' pings 'bar1' using fd12::2.
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 fd12::2 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# East-West No NAT: 'bar1' pings 'foo2' using fd11::3.
NS_CHECK_EXEC([bar1], [ping -q -c 3 -i 0.3 -w 2 fd11::3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# East-West NAT: 'foo1' pings 'bar1' using fd20::4.
NS_CHECK_EXEC([foo1], [ping -q -c 3 -i 0.3 -w 2 fd20::4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.  First SNAT of 'foo1' address happens.
# Then DNAT of 'bar1' address happens (listed first below).
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd11::2,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd20::4,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>
icmpv6,orig=(src=fd20::3,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd12::2,dst=fd20::3,id=<cleared>,type=129,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# East-West NAT: 'foo2' pings 'bar1' using fd20::4.
NS_CHECK_EXEC([foo2], [ping -q -c 3 -i 0.3 -w 2 fd20::4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.  First SNAT of 'foo2' address happens.
# Then DNAT of 'bar1' address happens (listed first below).
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd20::1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmpv6,orig=(src=fd11::3,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd20::4,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>
icmpv6,orig=(src=fd20::1,dst=fd20::4,id=<cleared>,type=128,code=0),reply=(src=fd12::2,dst=fd20::1,id=<cleared>,type=129,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([conntrack zone flush after port binding release])

CHECK_CONNTRACK()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One LS ls1 with two lports p1 and p2.
# Stateful ACL is added to ls1.
#
#    foo -- R1 -- alice
#           |
#    bar ----

check ovn-nbctl ls-add ls1
check ovn-nbctl acl-add ls1 from-lport 1 1 allow-related

# Logical port 'p1' in switch 'ls1'.
ADD_NAMESPACES(p1)
ADD_VETH(p1, p1, br-int, "192.168.1.10/24", "00:00:00:00:00:10")
ovn-nbctl lsp-add ls1 p1 \
-- lsp-set-addresses p1 "00:00:00:00:00:10 192.168.1.10"

# Logical port 'p2' in switch 'ls1'.
ovn-nbctl lsp-add ls1 p2 \
-- lsp-set-addresses p2 "00:00:00:00:00:20 192.168.1.20"

ovn-nbctl --wait=hv sync

zone_id=$(ovn-appctl -t ovn-controller ct-zone-list | grep p1 | cut -d ' ' -f2)

# ping from p1 to p2
NS_CHECK_EXEC([p1], [ping -q -c 1 -w1 192.168.1.20 > /dev/null], [1])

# check conntrack zone has icmp entry
AT_CHECK([ovs-appctl dpctl/dump-conntrack zone=$zone_id | \
FORMAT_CT(192.168.1.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.10,dst=192.168.1.20,id=<cleared>,type=8,code=0),reply=(src=192.168.1.20,dst=192.168.1.10,id=<cleared>,type=0,code=0),zone=<cleared>
])

# release port binding
check ovs-vsctl clear interface ovs-p1 external_ids

# check conntrack zone is flushed
check ovs-appctl dpctl/dump-conntrack zone=$zone_id

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([2 LSs IGMP and MLD])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([ovnigmp IP-multicast])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Two independent logical switches (sw1 and sw2).
# sw1:
#   - subnet 10.0.0.0/8
#   - 2 ports (sw1-p1 - sw1-p2)
# sw2:
#   - subnet 20.0.0.0/8
#   - 2 port (sw2-p1 - sw2-p2)
#   - IGMP Querier from 20.0.0.254
ovn-nbctl ls-add sw1
ovn-nbctl ls-add sw2

for i in `seq 1 2`
do
    ADD_NAMESPACES(sw1-p$i)
# Only send 1 membership report as second one might be received after flushing IGMP groups
# causing test to fail
    NS_CHECK_EXEC([sw1-p$i], [sysctl -w net.ipv4.igmp_qrv=1], [0], [dnl
net.ipv4.igmp_qrv = 1
])
    ADD_VETH(sw1-p$i, sw1-p$i, br-int, "10.0.0.$i/24", "00:00:00:00:01:0$i", \
            "10.0.0.254")
    ovn-nbctl lsp-add sw1 sw1-p$i \
        -- lsp-set-addresses sw1-p$i "00:00:00:00:01:0$i 10.0.0.$i"
done

for i in `seq 1 2`
do
    ADD_NAMESPACES(sw2-p$i)
    ADD_VETH(sw2-p$i, sw2-p$i, br-int, "20.0.0.$i/24", "00:00:00:00:02:0$i", \
            "20.0.0.254")
    ovn-nbctl lsp-add sw2 sw2-p$i \
        -- lsp-set-addresses sw2-p$i "00:00:00:00:02:0$i 20.0.0.$i"
done

# Enable IGMP snooping on sw1.
ovn-nbctl set Logical_Switch sw1 other_config:mcast_querier="false"
ovn-nbctl set Logical_Switch sw1 other_config:mcast_snoop="true"


group_v4="239.0.1.68"
# Inject IGMP Join for v4 group on sw1-p1.
NS_CHECK_EXEC([sw1-p1], [ip addr add dev sw1-p1 ${group_v4}/32 autojoin], [0])

# Inject IGMP Join for v4 group on sw1-p2
NS_CHECK_EXEC([sw1-p2], [ip addr add dev sw1-p2 ${group_v4}/32 autojoin], [0])

# Check that the IGMP Group is learned.
OVS_WAIT_UNTIL([
    total_entries=`ovn-sbctl find IGMP_Group address="${group_v4}" | grep _uuid -c`
    ports=`ovn-sbctl find IGMP_Group address="${group_v4}" | grep ports | cut -f 2 -d ":" | wc -w`
    test "${total_entries}" = "1"
    test "${ports}" = "2"
])

# Inject IGMP Leave for v4 group on sw1-p2.
NS_CHECK_EXEC([sw1-p2], [ip addr del dev sw1-p2 ${group_v4}/32], [0])

# Check that only one port is left in the group.
OVS_WAIT_UNTIL([
    total_entries=`ovn-sbctl find IGMP_Group address="${group_v4}" | grep _uuid -c`
    ports=`ovn-sbctl find IGMP_Group address="${group_v4}" | grep ports | cut -f 2 -d ":" | wc -w`
    test "${total_entries}" = "1"
    test "${ports}" = "1"
])

# Flush IGMP groups.
ovn-sbctl ip-multicast-flush sw1
ovn-nbctl --wait=hv -t 3 sync
OVS_WAIT_UNTIL([
    total_entries=`ovn-sbctl find IGMP_Group address="${group_v4}" | grep _uuid -c`
    test "${total_entries}" = "0"
])

group_v6="ff0a:dead:beef::1"
group_v6_str="ff0a\:dead\:beef\:\:1"
# Inject MLD Join for ff0a:dead:beef::1 on sw1-p1
NS_CHECK_EXEC([sw1-p1], [ip addr add dev sw1-p1 ${group_v6}/64 autojoin], [0])

# Inject MLD Join for ff0a:dead:beef::1 on sw1-p2
NS_CHECK_EXEC([sw1-p2], [ip addr add dev sw1-p2 ${group_v6}/64 autojoin], [0])

# Check that the MLD Group is learned.
OVS_WAIT_UNTIL([
    total_entries=`ovn-sbctl find IGMP_Group address="${group_v6_str}" | grep _uuid -c`
    ports=`ovn-sbctl find IGMP_Group address="${group_v6_str}" | grep ports | cut -f 2 -d ":" | wc -w`
    test "${total_entries}" = "1"
    test "${ports}" = "2"
])

# Inject IGMP Leave for v6 group on sw1-p2.
NS_CHECK_EXEC([sw1-p2], [ip addr del dev sw1-p2 ${group_v6}/64 autojoin], [0])

# Check that only one port is left in the group.
OVS_WAIT_UNTIL([
    total_entries=`ovn-sbctl find IGMP_Group address="${group_v6_str}" | grep _uuid -c`
    ports=`ovn-sbctl find IGMP_Group address="${group_v6_str}" | grep ports | cut -f 2 -d ":" | wc -w`
    test "${total_entries}" = "1"
    test "${ports}" = "1"
])

# Enable IGMP & MLD snooping and querier on sw2 and set query interval to
# minimum.
ovn-nbctl set Logical_Switch sw2 \
    other_config:mcast_snoop="true" \
    other_config:mcast_querier="true" \
    other_config:mcast_query_interval=1 \
    other_config:mcast_eth_src="00:00:00:00:02:fe" \
    other_config:mcast_ip4_src="20.0.0.254" \
    other_config:mcast_ip6_src="2000::fe"

# Check that v4 queries are generated.
NS_CHECK_EXEC([sw2-p1], [tcpdump -n -c 2 -i sw2-p1 igmp > sw2-p1-v4.pcap &])

OVS_WAIT_UNTIL([
    total_queries=`grep "igmp query" -c sw2-p1-v4.pcap`
    test "${total_queries}" = "2"
])

# Check that v6 queries are generated (ip6 next header == Hop-By-Hop and
# icmpv6 type == MLD Query).
NS_CHECK_EXEC([sw2-p1], [tcpdump -n -c 2 -i sw2-p1 ip6[[6]]==0 and ip6[[48]]==0x82 > sw2-p1-v6.pcap &])

OVS_WAIT_UNTIL([
    total_queries=`grep "multicast listener query" -c sw2-p1-v6.pcap`
    test "${total_queries}" = "2"
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load balancer health checks])
AT_KEYWORDS([lb])
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03"
ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03"

ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"

# Create port group and ACLs for sw0 ports.
ovn-nbctl pg-add pg0_drop sw0-p1 sw0-p2
ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

ovn-nbctl pg-add pg0 sw0-p1 sw0-p2
ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip4" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create the second logical switch with one port
ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-set-addresses sw1-p1 "40:54:00:00:00:03 20.0.0.3"
ovn-nbctl lsp-set-port-security sw1-p1 "40:54:00:00:00:03 20.0.0.3"

# Create port group and ACLs for sw1 ports.
ovn-nbctl pg-add pg1_drop sw1-p1
ovn-nbctl acl-add pg1_drop from-lport 1001 "inport == @pg1_drop && ip" drop
ovn-nbctl acl-add pg1_drop to-lport 1001 "outport == @pg1_drop && ip" drop

ovn-nbctl pg-add pg1 sw1-p1
ovn-nbctl acl-add pg1 from-lport 1002 "inport == @pg1 && ip4" allow-related
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
ovn-nbctl acl-add pg1 to-lport 1002 "outport == @pg1 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create a logical router and attach both logical switches
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 router
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

ovn-nbctl --reject lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80

ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2

ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer . \
health_check @hc

ovn-nbctl --wait=sb ls-lb-add sw0 lb1
ovn-nbctl --wait=sb ls-lb-add sw1 lb1
ovn-nbctl --wait=sb lr-lb-add lr0 lb1

OVN_POPULATE_ARP
ovn-nbctl --wait=hv sync

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(sw1-p1)
ADD_VETH(sw1-p1, sw1-p1, br-int, "20.0.0.3/24", "40:54:00:00:00:03", \
         "20.0.0.1")

ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

# Wait until all the services are set to offline.
OVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \
service_monitor | sed '/^$/d' | grep offline | wc -l`])

# Start webservers in 'sw0-p1' and 'sw1-p1'.
OVS_START_L7([sw0-p1], [http])
sw0_p1_pid_file=`cat l7_pid_file`
OVS_START_L7([sw1-p1], [http])

# Wait until the services are set to online.
OVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \
service_monitor | sed '/^$/d' | grep online | wc -l`])

OVS_WAIT_UNTIL(
    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep "ip4.dst == 10.0.0.10" > lflows.txt
     test 1 = `cat lflows.txt | grep "ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80)" | wc -l`]
)

# From sw0-p2 send traffic to vip - 10.0.0.10
for i in `seq 1 20`; do
    echo Request $i
    ovn-sbctl list service_monitor
    NS_CHECK_EXEC([sw0-p2], [wget 10.0.0.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

dnl Each server should have at least one connection.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
tcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=20.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Stop webserver in sw0-p1
kill `cat $sw0_p1_pid_file`

# Wait until service_monitor for sw0-p1 is set to offline
OVS_WAIT_UNTIL([test 1 = `ovn-sbctl --bare --columns status find \
service_monitor logical_port=sw0-p1 | sed '/^$/d' | grep offline | wc -l`])

OVS_WAIT_UNTIL(
    [ovn-sbctl dump-flows sw0 | grep ct_lb_mark | grep priority=120 | grep "ip4.dst == 10.0.0.10" > lflows.txt
     test 1 = `cat lflows.txt | grep "ct_lb_mark(backends=20.0.0.3:80)" | wc -l`]
)

ovs-appctl dpctl/flush-conntrack
# From sw0-p2 send traffic to vip - 10.0.0.10
for i in `seq 1 20`; do
    echo Request $i
    NS_CHECK_EXEC([sw0-p2], [wget 10.0.0.10 -t 5 -T 1 --retry-connrefused -v -o wget$i.log])
done

AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.10) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
tcp,orig=(src=10.0.0.4,dst=10.0.0.10,sport=<cleared>,dport=<cleared>),reply=(src=20.0.0.3,dst=10.0.0.4,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# trigger port binding release and check if status changed to offline
ovs-vsctl remove interface ovs-sw1-p1 external_ids iface-id
wait_row_count Service_Monitor 2
wait_row_count Service_Monitor 2 status=offline

ovs-vsctl set interface ovs-sw1-p1 external_ids:iface-id=sw1-p1
wait_row_count Service_Monitor 2
wait_row_count Service_Monitor 1 status=online

# Create udp load balancer.
ovn-nbctl lb-add lb2 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80 udp
lb_udp=`ovn-nbctl lb-list | grep udp | awk '{print $1}'`

echo "lb udp uuid = $lb_udp"

ovn-nbctl list load_balancer

ovn-nbctl --wait=sb set load_balancer $lb_udp ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
ovn-nbctl --wait=sb set load_balancer $lb_udp ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2

ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer $lb_udp \
health_check @hc

ovn-nbctl --wait=sb ls-lb-add sw0 lb2
ovn-nbctl --wait=sb ls-lb-add sw1 lb2
ovn-nbctl --wait=sb lr-lb-add lr0 lb2

sleep 10

ovn-nbctl list load_balancer
echo "*******Next is health check*******"
ovn-nbctl list Load_Balancer_Health_Check
echo "********************"
ovn-sbctl list service_monitor

# Wait until udp service_monitor are set to offline
OVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \
service_monitor protocol=udp | sed '/^$/d' | grep offline | wc -l`])

# Stop webserver in sw1-p1
pid_file=$(cat l7_pid_file)
NS_CHECK_EXEC([sw1-p1], [kill $(cat $pid_file)])

NS_CHECK_EXEC([sw0-p2], [tcpdump -c 1 -neei sw0-p2 ip[[33:1]]=0x14 > rst.pcap &])
OVS_WAIT_UNTIL([test 2 = `ovn-sbctl --bare --columns status find \
service_monitor protocol=tcp | sed '/^$/d' | grep offline | wc -l`])
NS_CHECK_EXEC([sw0-p2], [wget 10.0.0.10 -v -o wget$i.log],[4])

OVS_WAIT_UNTIL([
    n_reset=$(cat rst.pcap | wc -l)
    test "${n_reset}" = "1"
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/Service monitor not found.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load Balancer LS hairpin IPv4])
AT_SKIP_IF([test $HAVE_NC = no])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One logical switch with IPv4 load balancers that hairpin the traffic.
ovn-nbctl ls-add sw
ovn-nbctl lsp-add sw lsp -- lsp-set-addresses lsp 00:00:00:00:00:01
ovn-nbctl lb-add lb-ipv4-tcp     88.88.88.88:8080 42.42.42.1:4041 tcp
ovn-nbctl lb-add lb-ipv4-tcp-dup 88.88.88.89:8080 42.42.42.1:4041 tcp
ovn-nbctl lb-add lb-ipv4-udp     88.88.88.88:4040 42.42.42.1:2021 udp
ovn-nbctl lb-add lb-ipv4-udp-dup 88.88.88.89:4040 42.42.42.1:2021 udp
ovn-nbctl ls-lb-add sw lb-ipv4-tcp
ovn-nbctl ls-lb-add sw lb-ipv4-tcp-dup
ovn-nbctl ls-lb-add sw lb-ipv4-udp
ovn-nbctl ls-lb-add sw lb-ipv4-udp-dup

ovn-nbctl lr-add rtr
ovn-nbctl lrp-add rtr rtr-sw 00:00:00:00:01:00 42.42.42.254/24
ovn-nbctl lsp-add sw sw-rtr                       \
    -- lsp-set-type sw-rtr router                 \
    -- lsp-set-addresses sw-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw-rtr router-port=rtr-sw

ADD_NAMESPACES(lsp)
ADD_VETH(lsp, lsp, br-int, "42.42.42.1/24", "00:00:00:00:00:01", \
         "42.42.42.254")

ovn-nbctl --wait=hv -t 3 sync

# Start IPv4 TCP server on lsp.
NS_CHECK_EXEC([lsp], [timeout 2s nc -k -l 42.42.42.1 4041 &], [0])

# Check that IPv4 TCP hairpin connection succeeds on both VIPs.
NS_CHECK_EXEC([lsp], [nc 88.88.88.88 8080 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [nc 88.88.88.89 8080 -z], [0], [ignore], [ignore])

# Capture IPv4 UDP hairpinned packets.
filter="dst 42.42.42.1 and dst port 2021 and udp"
NS_CHECK_EXEC([lsp], [tcpdump -nn -c 2 -i lsp ${filter} > lsp.pcap &])

sleep 1

# Generate IPv4 UDP hairpin traffic.
NS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.88 4040 &], [0])
NS_CHECK_EXEC([lsp], [echo a | nc -u 88.88.88.89 4040 &], [0])

# Check hairpin traffic.
OVS_WAIT_UNTIL([
    total_pkts=$(cat lsp.pcap | wc -l)
    test "${total_pkts}" = "2"
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load Balancer LS hairpin IPv6])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# One logical switch with IPv6 load balancers that hairpin the traffic.
ovn-nbctl ls-add sw
ovn-nbctl lsp-add sw lsp -- lsp-set-addresses lsp 00:00:00:00:00:01
ovn-nbctl lb-add lb-ipv6-tcp     [[8800::0088]]:8080 [[4200::1]]:4041 tcp
ovn-nbctl lb-add lb-ipv6-tcp-dup [[8800::0089]]:8080 [[4200::1]]:4041 tcp
ovn-nbctl lb-add lb-ipv6-udp     [[8800::0088]]:4040 [[4200::1]]:2021 udp
ovn-nbctl lb-add lb-ipv6-udp-dup [[8800::0089]]:4040 [[4200::1]]:2021 udp
ovn-nbctl ls-lb-add sw lb-ipv6-tcp
ovn-nbctl ls-lb-add sw lb-ipv6-tcp-dup
ovn-nbctl ls-lb-add sw lb-ipv6-udp
ovn-nbctl ls-lb-add sw lb-ipv6-udp-dup

ovn-nbctl lr-add rtr
ovn-nbctl lrp-add rtr rtr-sw 00:00:00:00:01:00 4200::00ff/64
ovn-nbctl lsp-add sw sw-rtr                       \
    -- lsp-set-type sw-rtr router                 \
    -- lsp-set-addresses sw-rtr 00:00:00:00:01:00 \
    -- lsp-set-options sw-rtr router-port=rtr-sw

ADD_NAMESPACES(lsp)
ADD_VETH(lsp, lsp, br-int, "4200::1/64", "00:00:00:00:00:01", "4200::00ff")
OVS_WAIT_UNTIL([test "$(ip netns exec lsp ip a | grep 4200::1 | grep tentative)" = ""])
ovn-nbctl --wait=hv -t 3 sync

# Start IPv6 TCP server on lsp.
NS_CHECK_EXEC([lsp], [timeout 2s nc -k -l 4200::1 4041 &], [0])

# Check that IPv6 TCP hairpin connection succeeds on both VIPs.
NS_CHECK_EXEC([lsp], [nc 8800::0088 8080 -z], [0], [ignore], [ignore])
NS_CHECK_EXEC([lsp], [nc 8800::0089 8080 -z], [0], [ignore], [ignore])

# Capture IPv6 UDP hairpinned packets.
filter="dst 4200::1 and dst port 2021 and udp"
NS_CHECK_EXEC([lsp], [tcpdump -nn -c 2 -i lsp $filter > lsp.pcap &])

sleep 1

# Generate IPv6 UDP hairpin traffic.
NS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0088 4040 &], [0])
NS_CHECK_EXEC([lsp], [echo a | nc -u 8800::0089 4040 &], [0])

# Check hairpin traffic.
OVS_WAIT_UNTIL([
    total_pkts=$(cat lsp.pcap | wc -l)
    test "${total_pkts}" = "2"
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL reject])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1-rej
ovn-nbctl lsp-set-addresses sw0-p1-rej "50:54:00:00:00:03 10.0.0.3 aef0::3"
ovn-nbctl lsp-set-port-security sw0-p1-rej "50:54:00:00:00:03 10.0.0.3 aef0::3"

ovn-nbctl lsp-add sw0 sw0-p2-rej
ovn-nbctl lsp-set-addresses sw0-p2-rej "50:54:00:00:00:04 10.0.0.4 aef0::4"
ovn-nbctl lsp-set-port-security sw0-p2-rej "50:54:00:00:00:04 10.0.0.4 aef0::4"

# Create port group and ACLs for sw0 ports.
ovn-nbctl pg-add pg0_drop sw0-p1-rej sw0-p2-rej
ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

ovn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej
ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip" allow-related
ovn-nbctl --log acl-add pg0 from-lport 1004 "inport == @pg0 && ip && tcp && tcp.dst == 80" reject
ovn-nbctl --log acl-add pg0 from-lport 1004 "inport == @pg0 && ip && udp && udp.dst == 90" reject

ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 82" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 82" allow-related
ovn-nbctl --log acl-add pg0 to-lport 1004 "inport == @pg0 && ip && tcp && tcp.dst == 84" reject
ovn-nbctl --log acl-add pg0 to-lport 1004 "inport == @pg0 && ip && udp && udp.dst == 94" reject

ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1-rej
ovn-nbctl lsp-set-addresses sw1-p1-rej "40:54:00:00:00:03 20.0.0.3"
ovn-nbctl lsp-set-port-security sw1-p1-rej "40:54:00:00:00:03 20.0.0.3"

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 router
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

OVN_POPULATE_ARP
ovn-nbctl --wait=hv sync

ADD_NAMESPACES(sw0-p1-rej)
ADD_VETH(sw0-p1-rej, sw0-p1-rej, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(sw0-p2-rej)
ADD_VETH(sw0-p2-rej, sw0-p2-rej, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

NS_CHECK_EXEC([sw0-p1-rej], [ip a a aef0::3/64 dev sw0-p1-rej], [0])
NS_CHECK_EXEC([sw0-p2-rej], [ip a a aef0::4/64 dev sw0-p2-rej], [0])

ADD_NAMESPACES(sw1-p1-rej)
ADD_VETH(sw1-p1-rej, sw1-p1-rej, br-int, "20.0.0.3/24", "40:54:00:00:00:03", \
         "20.0.0.1")

sleep 1

# Capture packets in sw0-p1-rej.
NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 4 -i sw0-p1-rej tcp > sw0-p1-rej-ip4.pcap &], [0])

sleep 1

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'
])

# Now send traffic to port 84
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'
])

OVS_WAIT_UNTIL([
    n_pkt=$(ovs-ofctl dump-flows br-int table=44 | grep -v n_packets=0 | \
grep controller | grep tp_dst=84 -c)
    test $n_pkt -eq 1
])

OVS_WAIT_UNTIL([
    total=`cat sw0-p1-rej-ip4.pcap |  wc -l`
    echo "total = $total"
    test "${total}" = "4"
])

# Without this sleep, test case fails intermittently.
sleep 3

NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 2 -i sw0-p2-rej tcp port 80 > sw0-p2-rej-ip6.pcap &], [0])

sleep 1

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'
])


OVS_WAIT_UNTIL([
    total=`cat sw0-p2-rej-ip6.pcap |  wc -l`
    echo "total = $total"
    test "${total}" = "2"
])

ovn-nbctl acl-add sw1 from-lport 1004 "ip" allow-related
ovn-nbctl acl-add sw1 to-lport 1004 "ip" allow-related
ovn-nbctl --log acl-add pg0 to-lport 1004 "outport == @pg0 && ip && tcp && tcp.dst == 84" reject

OVS_WAIT_UNTIL([
    ip netns exec sw1-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'
])

# Now test for IPv4 UDP.
NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 1 -i sw0-p1-rej udp port 90 > sw0-p1-rej-udp.pcap &], [0])
NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 1 -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap &], [0])

printf '.%.0s' {1..100} > foo
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo
    c=$(cat sw0-p1-rej-icmp.pcap | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable" | uniq | wc -l)
    test $c -eq 1
])

rm -f *.pcap

NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 1 -i sw0-p1-rej udp port 94 > sw0-p1-rej-udp.pcap &], [0])
NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 1 -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap &], [0])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 94 < foo
    c=$(cat sw0-p1-rej-icmp.pcap | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 94 unreachable" | uniq | wc -l)
    test $c -eq 1
])

# Now test for IPv6 UDP.
NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 1 -i sw0-p2-rej udp port 90 > sw0-p2-rej-ip6-udp.pcap &], [0])
NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 1 -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap &], [0])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo
    c=$(cat sw0-p2-rej-icmp6.pcap | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 90" | uniq | wc -l)
    test $c -eq 1
])

rm -f *.pcap

NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 1 -i sw0-p2-rej udp port 94 > sw0-p2-rej-ip6-udp.pcap &], [0])
NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 1 -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap &], [0])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 94 < foo
    c=$(cat sw0-p2-rej-icmp6.pcap | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 94" | uniq | wc -l)
    test $c -eq 1
])

# Delete all the ACLs of pg0 and add the ACL with a generic match with reject action.
ovn-nbctl pg-del pg0
ovn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej
ovn-nbctl --log acl-add pg0 from-lport 1004 "inport == @pg0 && ip && (tcp || udp)" reject

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'
])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'
])

rm -f *.pcap

NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 1 -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap &], [0])

printf '.%.0s' {1..100} > foo
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo
    c=$(cat sw0-p1-rej-icmp.pcap | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable" | uniq | wc -l)
    test $c -eq 1
])

rm -f *.pcap
# Now test for IPv6 UDP.
NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 1 -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap &], [0])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo
    c=$(cat sw0-p2-rej-icmp6.pcap | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 90" | uniq | wc -l)
    test $c -eq 1
])


OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL after lb - reject])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 sw0-p1-rej
ovn-nbctl lsp-set-addresses sw0-p1-rej "50:54:00:00:00:03 10.0.0.3 aef0::3"
ovn-nbctl lsp-set-port-security sw0-p1-rej "50:54:00:00:00:03 10.0.0.3 aef0::3"

ovn-nbctl lsp-add sw0 sw0-p2-rej
ovn-nbctl lsp-set-addresses sw0-p2-rej "50:54:00:00:00:04 10.0.0.4 aef0::4"
ovn-nbctl lsp-set-port-security sw0-p2-rej "50:54:00:00:00:04 10.0.0.4 aef0::4"

# Create port group and ACLs for sw0 ports.
ovn-nbctl pg-add pg0_drop sw0-p1-rej sw0-p2-rej
ovn-nbctl --apply-after-lb acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

ovn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej
ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 "inport == @pg0 && ip" allow-related
ovn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 "inport == @pg0 && ip && tcp && tcp.dst == 80" reject
ovn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 "inport == @pg0 && ip && udp && udp.dst == 90" reject

ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 82" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 82" allow-related
ovn-nbctl --log acl-add pg0 to-lport 1004 "inport == @pg0 && ip && tcp && tcp.dst == 84" reject
ovn-nbctl --log acl-add pg0 to-lport 1004 "inport == @pg0 && ip && udp && udp.dst == 94" reject

ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1-rej
ovn-nbctl lsp-set-addresses sw1-p1-rej "40:54:00:00:00:03 20.0.0.3"
ovn-nbctl lsp-set-port-security sw1-p1-rej "40:54:00:00:00:03 20.0.0.3"

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 router
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

OVN_POPULATE_ARP
ovn-nbctl --wait=hv sync

ADD_NAMESPACES(sw0-p1-rej)
ADD_VETH(sw0-p1-rej, sw0-p1-rej, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(sw0-p2-rej)
ADD_VETH(sw0-p2-rej, sw0-p2-rej, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

NS_CHECK_EXEC([sw0-p1-rej], [ip a a aef0::3/64 dev sw0-p1-rej], [0])
NS_CHECK_EXEC([sw0-p2-rej], [ip a a aef0::4/64 dev sw0-p2-rej], [0])

ADD_NAMESPACES(sw1-p1-rej)
ADD_VETH(sw1-p1-rej, sw1-p1-rej, br-int, "20.0.0.3/24", "40:54:00:00:00:03", \
         "20.0.0.1")

sleep 1

# Capture packets in sw0-p1-rej.
NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 4 -i sw0-p1-rej tcp > sw0-p1-rej-ip4.pcap &], [0])

sleep 1

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'
])

# Now send traffic to port 84
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'
])

OVS_WAIT_UNTIL([
    n_pkt=$(ovs-ofctl dump-flows br-int table=44 | grep -v n_packets=0 | \
grep controller | grep tp_dst=84 -c)
    test $n_pkt -eq 1
])

OVS_WAIT_UNTIL([
    total=`cat sw0-p1-rej-ip4.pcap |  wc -l`
    echo "total = $total"
    test "${total}" = "4"
])

# Without this sleep, test case fails intermittently.
sleep 3

NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 2 -i sw0-p2-rej tcp port 80 > sw0-p2-rej-ip6.pcap &], [0])

sleep 1

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'
])


OVS_WAIT_UNTIL([
    total=`cat sw0-p2-rej-ip6.pcap |  wc -l`
    echo "total = $total"
    test "${total}" = "2"
])

ovn-nbctl --apply-after-lb acl-add sw1 from-lport 1004 "ip" allow-related
ovn-nbctl acl-add sw1 to-lport 1004 "ip" allow-related
ovn-nbctl --log acl-add pg0 to-lport 1004 "outport == @pg0 && ip && tcp && tcp.dst == 84" reject

OVS_WAIT_UNTIL([
    ip netns exec sw1-p1-rej nc -vz 10.0.0.4 84 2>&1 | grep -i 'connection refused'
])

# Now test for IPv4 UDP.
NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 1 -i sw0-p1-rej udp port 90 > sw0-p1-rej-udp.pcap &], [0])
NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 1 -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap &], [0])

printf '.%.0s' {1..100} > foo
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo
    c=$(cat sw0-p1-rej-icmp.pcap | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable" | uniq | wc -l)
    test $c -eq 1
])

rm -f *.pcap

NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 1 -i sw0-p1-rej udp port 94 > sw0-p1-rej-udp.pcap &], [0])
NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 1 -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap &], [0])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 94 < foo
    c=$(cat sw0-p1-rej-icmp.pcap | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 94 unreachable" | uniq | wc -l)
    test $c -eq 1
])

# Now test for IPv6 UDP.
NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 1 -i sw0-p2-rej udp port 90 > sw0-p2-rej-ip6-udp.pcap &], [0])
NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 1 -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap &], [0])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo
    c=$(cat sw0-p2-rej-icmp6.pcap | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 90" | uniq | wc -l)
    test $c -eq 1
])

rm -f *.pcap

NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 1 -i sw0-p2-rej udp port 94 > sw0-p2-rej-ip6-udp.pcap &], [0])
NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 1 -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap &], [0])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 94 < foo
    c=$(cat sw0-p2-rej-icmp6.pcap | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 94" | uniq | wc -l)
    test $c -eq 1
])

# Delete all the ACLs of pg0 and add the ACL with a generic match with reject action.
ovn-nbctl pg-del pg0
ovn-nbctl pg-add pg0 sw0-p1-rej sw0-p2-rej
ovn-nbctl --log --apply-after-lb acl-add pg0 from-lport 1004 "inport == @pg0 && ip && (tcp || udp)" reject

OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -vz 10.0.0.4 80 2>&1 | grep -i 'connection refused'
])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -vz6 aef0::3 80 2>&1 | grep -i 'connection refused'
])

rm -f *.pcap

NS_CHECK_EXEC([sw0-p1-rej], [tcpdump -nn -c 1 -i sw0-p1-rej icmp > sw0-p1-rej-icmp.pcap &], [0])

printf '.%.0s' {1..100} > foo
OVS_WAIT_UNTIL([
    ip netns exec sw0-p1-rej nc -u 10.0.0.4 90 < foo
    c=$(cat sw0-p1-rej-icmp.pcap | grep \
"10.0.0.4 > 10.0.0.3: ICMP 10.0.0.4 udp port 90 unreachable" | uniq | wc -l)
    test $c -eq 1
])

rm -f *.pcap
# Now test for IPv6 UDP.
NS_CHECK_EXEC([sw0-p2-rej], [tcpdump -nn -c 1 -i sw0-p2-rej icmp6 > sw0-p2-rej-icmp6.pcap &], [0])

OVS_WAIT_UNTIL([
    ip netns exec sw0-p2-rej nc -u -6 aef0::3 90 < foo
    c=$(cat sw0-p2-rej-icmp6.pcap | grep \
"IP6 aef0::3 > aef0::4: ICMP6, destination unreachable, unreachable port, \
aef0::3 udp port 90" | uniq | wc -l)
    test $c -eq 1
])


OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IPv6 prefix delegation - distributed router])
AT_SKIP_IF([test $HAVE_DHCPD = no])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([ovn-ipv6-prefix_d])

OVN_TEST_IPV6_PREFIX_DELEGATION(DGP)
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([IPv6 prefix delegation - gw router])
AT_SKIP_IF([test $HAVE_DHCPD = no])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([ovn-ipv6-prefix_d])

OVN_TEST_IPV6_PREFIX_DELEGATION(GR)
AT_CLEANUP
])

# Tests that when an established connection sends TCP reset,
# the conntrack entry is not in established state.
OVN_FOR_EACH_NORTHD([
AT_SETUP([conntrack TCP reset])
AT_KEYWORDS([conntrack])
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovn-nbctl ls-add sw0

ovn-nbctl lsp-add sw0 rst-p1
ovn-nbctl lsp-set-addresses rst-p1 "50:54:00:00:00:03"
ovn-nbctl lsp-set-port-security rst-p1 "50:54:00:00:00:03"

ovn-nbctl lsp-add sw0 rst-p2
ovn-nbctl lsp-set-addresses rst-p2 "50:54:00:00:00:04 10.0.0.4"
ovn-nbctl lsp-set-port-security rst-p2 "50:54:00:00:00:04 10.0.0.4"

# Create port group and ACLs for sw0 ports.
ovn-nbctl pg-add pg0_drop rst-p1 rst-p2
ovn-nbctl acl-add pg0_drop from-lport 1001 "inport == @pg0_drop && ip" drop
ovn-nbctl acl-add pg0_drop to-lport 1001 "outport == @pg0_drop && ip" drop

ovn-nbctl pg-add pg0 rst-p1 rst-p2
ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip4" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && icmp4" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && tcp && tcp.dst == 80" allow-related
ovn-nbctl acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && ip4.src == 0.0.0.0/0 && udp && udp.dst == 80" allow-related

# Create a logical router and attach to logical switch.
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 router
ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80
ovn-nbctl --wait=sb ls-lb-add sw0 lb1
ovn-nbctl --wait=sb lr-lb-add lr0 lb1

OVN_POPULATE_ARP
ovn-nbctl --wait=hv sync

ADD_NAMESPACES(rst-p1)
ADD_VETH(rst-p1, rst-p1, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(rst-p2)
ADD_VETH(rst-p2, rst-p2, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up rst-p1) = xup])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up rst-p2) = xup])

# Start webservers in 'rst-p1'.
OVS_START_L7([rst-p1], [http])

NS_CHECK_EXEC([rst-p2], [$PYTHON $srcdir/test-tcp-rst.py --dst-port 80 --dst-ip 10.0.0.10])

# When tcp reset is sent, conntrack entry should be in the state - CLOSED or CLOSING.
# But there is a bug where tcp reset packet was not sent to the conntrack.
# This test case checks that the tcp reset packet is sent to conntrack
# and the state is not in established state.
AT_CHECK([
    ct_est_count=$(ovs-appctl dpctl/dump-conntrack | grep 10.0.0.10 | grep state=ESTABLISHED -c)
    test $ct_est_count -eq 0

    ct_est_count=$(ovs-appctl dpctl/dump-conntrack | grep 10.0.0.10 | grep state='CLOS\|TIME_WAIT' -c)
    test $ct_est_count -eq 1
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/Service monitor not found.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Load balancer for container ports])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1-lbc
ovn-nbctl lsp-set-addresses sw0-port1 "10:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2-lbc
ovn-nbctl lsp-set-addresses sw0-port2 "10:54:00:00:00:04 10.0.0.4"

ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-port1 sw0-p1-lbc 10
ovn-nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3"

ovn-nbctl lsp-add sw1 sw1-port2 sw0-p2-lbc 20
ovn-nbctl lsp-set-addresses sw1-port2 "40:54:00:00:00:04 20.0.0.4"


ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr0
ovn-nbctl lsp-set-type sw1-lr0 router
ovn-nbctl lsp-set-addresses sw1-lr0 router
ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1


ovn-nbctl ls-add sw2
ovn-nbctl lsp-add sw2 sw2-port1
ovn-nbctl lsp-set-addresses sw2-port1 "50:54:00:00:00:03 30.0.0.3"

ovn-nbctl lrp-add lr0 lr0-sw2 00:00:00:00:ff:03 30.0.0.1/24
ovn-nbctl lsp-add sw2 sw2-lr0
ovn-nbctl lsp-set-type sw2-lr0 router
ovn-nbctl lsp-set-addresses sw2-lr0 router
ovn-nbctl lsp-set-options sw2-lr0 router-port=lr0-sw2


ovn-nbctl lb-add lb0 "30.0.0.10:80" "20.0.0.4:80"

ovn-nbctl ls-lb-add sw1 lb0
ovn-nbctl ls-lb-add sw2 lb0

ADD_NAMESPACES(sw0-p1-lbc)
ADD_VETH(sw0-p1-lbc, sw0-p1-lbc, br-int, "10.0.0.3/24", "10:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(sw0-p2-lbc)
ADD_VETH(sw0-p2-lbc, sw0-p2-lbc, br-int, "10.0.0.4/24", "10:54:00:00:00:04", \
         "10.0.0.1")

# Create the interface for lport sw1-port1
NS_CHECK_EXEC([sw0-p1-lbc], [ip link add link sw0-p1-lbc name sw1p1 type vlan id 10], [0])
NS_CHECK_EXEC([sw0-p1-lbc], [ip link set sw1p1 address 40:54:00:00:00:03], [0])
NS_CHECK_EXEC([sw0-p1-lbc], [ip link set sw1p1 up], [0])
NS_CHECK_EXEC([sw0-p1-lbc], [ip addr add 20.0.0.3/24 dev sw1p1], [0])
NS_CHECK_EXEC([sw0-p1-lbc], [ip route delete default via 10.0.0.1 dev sw0-p1-lbc], [0])
NS_CHECK_EXEC([sw0-p1-lbc], [ip route add default via 20.0.0.1 dev sw1p1], [0])

# Create the interface for lport sw1-port2
NS_CHECK_EXEC([sw0-p2-lbc], [ip link add link sw0-p2-lbc name sw1p2 type vlan id 20], [0])
NS_CHECK_EXEC([sw0-p2-lbc], [ip link set sw1p2 address 40:54:00:00:00:04], [0])
NS_CHECK_EXEC([sw0-p2-lbc], [ip link set sw1p2 up], [0])
NS_CHECK_EXEC([sw0-p2-lbc], [ip addr add 20.0.0.4/24 dev sw1p2], [0])
NS_CHECK_EXEC([sw0-p2-lbc], [ip route delete default via 10.0.0.1 dev sw0-p2-lbc], [0])
NS_CHECK_EXEC([sw0-p2-lbc], [ip route add default via 20.0.0.1 dev sw1p2], [0])

# Start nc server on sw1p2 (sw0-p2-lbc is the parent)
NETNS_DAEMONIZE([sw0-p2-lbc], [nc -l -k 20.0.0.4 80], [nc0.pid])

# Send the packet to backend
NS_CHECK_EXEC([sw0-p1-lbc], [nc -z 20.0.0.4 80], [0], [ignore], [ignore])

# Send the packet to VIP.
NS_CHECK_EXEC([sw0-p1-lbc], [nc -z 30.0.0.10 80], [0], [ignore], [ignore])

# Now add an ACL in sw1.
ovn-nbctl --wait=hv acl-add sw1 to-lport 2002 "ip" allow-related
# Send the packet to backend
NS_CHECK_EXEC([sw0-p1-lbc], [nc -z 20.0.0.4 80], [0], [ignore], [ignore])

# Send the packet to VIP.
NS_CHECK_EXEC([sw0-p1-lbc], [nc -z 30.0.0.10 80], [0], [ignore], [ignore])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancer and firewall tuple conflict IPv4])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
OVS_CHECK_CT_ZERO_SNAT()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 1 logical switch connetected to one logical router.
# 2 VMs, one used as backend for a load balancer.

check ovn-nbctl                                                  \
    -- lr-add rtr                                                \
    -- lrp-add rtr rtr-ls 00:00:00:00:01:00 42.42.42.1/24        \
    -- ls-add ls                                                 \
    -- lsp-add ls ls-rtr                                         \
    -- lsp-set-addresses ls-rtr 00:00:00:00:01:00                \
    -- lsp-set-type ls-rtr router                                \
    -- lsp-set-options ls-rtr router-port=rtr-ls                 \
    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \
    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \
    -- lb-add lb-test 66.66.66.66:666 42.42.42.2:4242 tcp        \
    -- ls-lb-add ls lb-test

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "42.42.42.2/24", "00:00:00:00:00:01", "42.42.42.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "42.42.42.3/24", "00:00:00:00:00:02", "42.42.42.1")

# Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Start IPv4 TCP server on vm1.
NETNS_DAEMONIZE([vm1], [nc -k -l 42.42.42.2 4242], [nc-vm1.pid])

# Make sure connecting to the VIP works.
NS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -p 2000 -z], [0], [ignore], [ignore])

# Start IPv4 TCP connection to VIP from vm2.
NS_CHECK_EXEC([vm2], [nc 66.66.66.66 666 -p 2001 -z], [0], [ignore], [ignore])

# Check conntrack.  We expect two entries:
# - one in vm1's zone (firewall)
# - one in vm2's zone (dnat)
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \
grep "orig=.src=42\.42\.42\.3" |                                    \
sed -e 's/port=2001/port=<clnt_s_port>/g'                           \
    -e 's/sport=4242,dport=[[0-9]]\+/sport=4242,dport=<rnd_port>/g' \
    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \
    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=42.42.42.3,dst=66.66.66.66,sport=<clnt_s_port>,dport=666),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Start IPv4 TCP connection to backend IP from vm2 which would require
# additional source port translation to avoid a tuple conflict.
NS_CHECK_EXEC([vm2], [nc 42.42.42.2 4242 -p 2001 -z], [0], [ignore], [ignore])

# Check conntrack.  We expect three entries:
# - one in vm1's zone (firewall) - reused from the previous connection.
# - one in vm2's zone (dnat) - still in TIME_WAIT after the previous connection.
# - one in vm2's zone (firewall + additional all-zero SNAT)
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \
grep "orig=.src=42\.42\.42\.3" |                                    \
sed -e 's/port=2001/port=<clnt_s_port>/g'                           \
    -e 's/sport=4242,dport=[[0-9]]\+/sport=4242,dport=<rnd_port>/g' \
    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \
    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=42.42.42.3,dst=42.42.42.2,sport=<clnt_s_port>,dport=4242),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<rnd_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=42.42.42.3,dst=66.66.66.66,sport=<clnt_s_port>,dport=666),reply=(src=42.42.42.2,dst=42.42.42.3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([load-balancer and firewall tuple conflict IPv6])
AT_SKIP_IF([test $HAVE_NC = no])
AT_KEYWORDS([ovnlb])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
OVS_CHECK_CT_ZERO_SNAT()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# 1 logical switch connetected to one logical router.
# 2 VMs, one used as backend for a load balancer.

check ovn-nbctl                                                  \
    -- lr-add rtr                                                \
    -- lrp-add rtr rtr-ls 00:00:00:00:01:00 4242::1/64           \
    -- ls-add ls                                                 \
    -- lsp-add ls ls-rtr                                         \
    -- lsp-set-addresses ls-rtr 00:00:00:00:01:00                \
    -- lsp-set-type ls-rtr router                                \
    -- lsp-set-options ls-rtr router-port=rtr-ls                 \
    -- lsp-add ls vm1 -- lsp-set-addresses vm1 00:00:00:00:00:01 \
    -- lsp-add ls vm2 -- lsp-set-addresses vm2 00:00:00:00:00:02 \
    -- lb-add lb-test [[6666::1]]:666 [[4242::2]]:4242 tcp       \
    -- ls-lb-add ls lb-test

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "4242::2/64", "00:00:00:00:00:01", "4242::1")
OVS_WAIT_UNTIL([test "$(ip netns exec vm1 ip a | grep 4242::2 | grep tentative)" = ""])

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "4242::3/64", "00:00:00:00:00:02", "4242::1")
OVS_WAIT_UNTIL([test "$(ip netns exec vm2 ip a | grep 4242::3 | grep tentative)" = ""])

# Wait for ovn-controller to catch up.
wait_for_ports_up
check ovn-nbctl --wait=hv sync

# Start IPv6 TCP server on vm1.
NETNS_DAEMONIZE([vm1], [nc -k -l 4242::2 4242], [nc-vm1.pid])

# Make sure connecting to the VIP works.
NS_CHECK_EXEC([vm2], [nc 6666::1 666 -p 2000 -z], [0], [ignore], [ignore])

# Start IPv6 TCP connection to VIP from vm2.
NS_CHECK_EXEC([vm2], [nc 6666::1 666 -p 2001 -z], [0], [ignore], [ignore])

# Check conntrack.  We expect two entries:
# - one in vm1's zone (firewall)
# - one in vm2's zone (dnat)
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \
grep "orig=.src=4242::3" |                                         \
sed -e 's/port=2001/port=<clnt_s_port>/g'                           \
    -e 's/sport=4242,dport=[[0-9]]\+/sport=4242,dport=<rnd_port>/g' \
    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \
    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=4242::3,dst=6666::1,sport=<clnt_s_port>,dport=666),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

# Start IPv6 TCP connection to backend IP from vm2 which would require
# additional source port translation to avoid a tuple conflict.
NS_CHECK_EXEC([vm2], [nc 4242::2 4242 -p 2001 -z], [0], [ignore], [ignore])

# Check conntrack.  We expect three entries:
# - one in vm1's zone (firewall) - reused from the previous connection.
# - one in vm2's zone (dnat) - still in TIME_WAIT after the previous connection.
# - one in vm2's zone (firewall + additional all-zero SNAT)
AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 2001 |             \
grep "orig=.src=4242::3" |                                          \
sed -e 's/port=2001/port=<clnt_s_port>/g'                           \
    -e 's/sport=4242,dport=[[0-9]]\+/sport=4242,dport=<rnd_port>/g' \
    -e 's/state=[[0-9_A-Z]]*/state=<cleared>/g'                     \
    -e 's/zone=[[0-9]]*/zone=<cleared>/' | sort], [0], [dnl
tcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=4242::3,dst=4242::2,sport=<clnt_s_port>,dport=4242),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<rnd_port>),zone=<cleared>,protoinfo=(state=<cleared>)
tcp,orig=(src=4242::3,dst=6666::1,sport=<clnt_s_port>,dport=666),reply=(src=4242::2,dst=4242::3,sport=4242,dport=<clnt_s_port>),zone=<cleared>,mark=2,protoinfo=(state=<cleared>)
])

AT_CLEANUP
])

# When a lport is released on a chassis, ovn-controller was
# not clearing some of the flowss in the table 33 leading
# to packet drops if ct() is hit.
# Make sure that those flows are cleared properly.
OVN_FOR_EACH_NORTHD([
AT_SETUP([Test packet drops due to incorrect flows in physical table 33])
AT_KEYWORDS([lb])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1-f
ovn-nbctl lsp-set-addresses sw0-p1-f "10:54:00:00:00:03 10.0.0.3"

ovn-nbctl lsp-add sw0 sw0-p2-f
ovn-nbctl lsp-set-addresses sw0-p2-f "10:54:00:00:00:04 10.0.0.4"

ovn-nbctl lsp-add sw0 sw0-p3-f
ovn-nbctl lsp-set-addresses sw0-p3-f "10:54:00:00:00:05 10.0.0.5"

# Add ACL with allow-ralated so that conntrack is hit.

ovn-nbctl acl-add sw0 from-lport 1002 "ip" allow-related
ovn-nbctl acl-add sw0 to-lport 1002 "ip" allow-related

ADD_NAMESPACES(sw0-p1-f)
ADD_VETH(sw0-p1-f, sw0-p1-f, br-int, "10.0.0.3/24", "10:54:00:00:00:03", \
         "10.0.0.1")

ADD_NAMESPACES(sw0-p2-f)
ADD_VETH(sw0-p2-f, sw0-p2-f, br-int, "10.0.0.4/24", "10:54:00:00:00:04", \
         "10.0.0.1")

ADD_NAMESPACES(sw0-p3-f)
ADD_VETH(sw0-p3-f, sw0-p3-f, br-int, "10.0.0.5/24", "10:54:00:00:00:05", \
         "10.0.0.1")

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p1-f) = xup])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2-f) = xup])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xup])

# Send ping from sw0-p1-f to sw0-p3-f
NS_CHECK_EXEC([sw0-p1-f], [ping -q -c 3 -i 0.3 -w 2 10.0.0.5 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

ovs-vsctl remove interface ovs-sw0-p2-f external_ids iface-id
ovs-vsctl remove interface ovs-sw0-p3-f external_ids iface-id

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p2-f) = xdown])
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xdown])

ovs-vsctl set interface ovs-sw0-p3-f external_ids:iface-id=sw0-p3-f
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-p3-f) = xup])

# Send ping from sw0-p1-f to sw0-p3-f again and it should work.
NS_CHECK_EXEC([sw0-p1-f], [ping -q -c 3 -i 0.3 -w 2 10.0.0.5 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ECMP symmetric reply])
AT_KEYWORDS([ecmp])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Alice is connected to gateway router R1. R1 is connected to two "external"
# routers, R2 and R3 via an "ext" switch.
# Bob is connected to both R2 and R3. R1 contains two ECMP routes, one through R2
# and one through R3, to Bob.
#
#     alice -- R1 -- ext ---- R2
#                     |         \
#                     |           bob
#                     |         /
#                     + ----- R3
#
# For this test, Bob sends request traffic through R2 to Alice. We want to ensure that
# all response traffic from Alice is routed through R2 as well.

ovn-nbctl create Logical_Router name=R1 options:chassis=hv1
ovn-nbctl create Logical_Router name=R2
ovn-nbctl create Logical_Router name=R3

ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add ext

# connect alice to R1
ovn-nbctl lrp-add R1 alice 00:00:01:01:02:03 10.0.0.1/24
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses='"00:00:01:01:02:03"'

# connect bob to R2
ovn-nbctl lrp-add R2 R2_bob 00:00:02:01:02:03 172.16.0.2/16
ovn-nbctl lsp-add bob rp2-bob -- set Logical_Switch_Port rp2-bob \
    type=router options:router-port=R2_bob addresses='"00:00:02:01:02:03"'

# connect bob to R3
ovn-nbctl lrp-add R3 R3_bob 00:00:02:01:02:04 172.16.0.3/16
ovn-nbctl lsp-add bob rp3-bob -- set Logical_Switch_Port rp3-bob \
    type=router options:router-port=R3_bob addresses='"00:00:02:01:02:04"'

# Connect R1 to ext
ovn-nbctl lrp-add R1 R1_ext 00:00:04:01:02:03 20.0.0.1/24
ovn-nbctl lsp-add ext r1-ext -- set Logical_Switch_Port r1-ext \
    type=router options:router-port=R1_ext addresses='"00:00:04:01:02:03"'

# Connect R2 to ext
ovn-nbctl lrp-add R2 R2_ext 00:00:04:01:02:04 20.0.0.2/24
ovn-nbctl lsp-add ext r2-ext -- set Logical_Switch_Port r2-ext \
    type=router options:router-port=R2_ext addresses='"00:00:04:01:02:04"'

# Connect R3 to ext
ovn-nbctl lrp-add R3 R3_ext 00:00:04:01:02:05 20.0.0.3/24
ovn-nbctl lsp-add ext r3-ext -- set Logical_Switch_Port r3-ext \
    type=router options:router-port=R3_ext addresses='"00:00:04:01:02:05"'

# Install ECMP routes for alice.
ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add R1 10.0.0.0/24 20.0.0.2
ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add R1 10.0.0.0/24 20.0.0.3

# Static Routes
ovn-nbctl lr-route-add R2 10.0.0.0/24 20.0.0.1
ovn-nbctl lr-route-add R3 10.0.0.0/24 20.0.0.1

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
ADD_VETH(alice1, alice1, br-int, "10.0.0.2/24", "f0:00:00:01:02:04", \
         "10.0.0.1")
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 10.0.0.2"

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
ADD_VETH(bob1, bob1, br-int, "172.16.0.1/16", "f0:00:00:01:02:06", \
         "172.16.0.2")
ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 172.16.0.1"

# Ensure ovn-controller is caught up
ovn-nbctl --wait=hv sync

on_exit 'ovs-ofctl dump-flows br-int'

NETNS_DAEMONIZE([alice1], [nc -l -k 80], [alice1.pid])
NS_CHECK_EXEC([bob1], [nc -z 10.0.0.2 80], [0])

# Ensure conntrack entry is present. We should not try to predict
# the tunnel key for the output port, so we strip it from the labels
# and just ensure that the known ethernet address is present.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.0.1,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x401020400000000,protoinfo=(state=<cleared>)
])

# Ensure datapaths show conntrack states as expected
# Like with conntrack entries, we shouldn't try to predict
# port binding tunnel keys. So omit them from expected labels.
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x401020400000000/.*)' -c], [0], [dnl
1
])
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x401020400000000)' -c], [0], [dnl
1
])

# Flush conntrack entries for easier output parsing of next test.
AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# Change bob1 L2 address anche check the reply is properly updated.
ovn-nbctl set Logical_Router_Port R2_ext mac='"00:00:10:01:02:04"'
ovn-nbctl set Logical_Switch_Port r2-ext \
     type=router options:router-port=R2_ext addresses='"00:00:10:01:02:04"'

NS_CHECK_EXEC([bob1], [nc -z 10.0.0.2 80], [0])
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x1001020400000000/.*)' -c], [0], [dnl
1
])
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x1001020400000000)' -c], [0], [dnl
1
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x1001020400000000 | FORMAT_CT(172.16.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl
tcp,orig=(src=172.16.0.1,dst=10.0.0.2,sport=<cleared>,dport=<cleared>),reply=(src=10.0.0.2,dst=172.16.0.1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000,protoinfo=(state=<cleared>)
])

# Check entries in table 76 and 77 expires w/o traffic
OVS_WAIT_UNTIL([
test $(ovs-ofctl dump-flows br-int | grep -c 'table=76, n_packets') -eq 0
])
OVS_WAIT_UNTIL([
test $(ovs-ofctl dump-flows br-int | grep -c 'table=77, n_packets') -eq 0
])

ovs-ofctl dump-flows br-int

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ECMP IPv6 symmetric reply])
AT_KEYWORDS([ecmp])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

# Logical network:
# Alice is connected to gateway router R1. R1 is connected to two "external"
# routers, R2 and R3 via an "ext" switch.
# Bob is connected to both R2 and R3. R1 contains two ECMP routes, one through R2
# and one through R3, to Bob.
#
#     alice -- R1 -- ext ---- R2
#                     |         \
#                     |           bob
#                     |         /
#                     + ----- R3
#
# For this test, Bob sends request traffic through R2 to Alice. We want to ensure that
# all response traffic from Alice is routed through R2 as well.

ovn-nbctl create Logical_Router name=R1 options:chassis=hv1
ovn-nbctl create Logical_Router name=R2
ovn-nbctl create Logical_Router name=R3

ovn-nbctl ls-add alice
ovn-nbctl ls-add bob
ovn-nbctl ls-add ext

# connect alice to R1
ovn-nbctl lrp-add R1 alice 00:00:01:01:02:03 fd01::1/64
ovn-nbctl lsp-add alice rp-alice -- set Logical_Switch_Port rp-alice \
    type=router options:router-port=alice addresses='"00:00:01:01:02:03"'

# connect bob to R2
ovn-nbctl lrp-add R2 R2_bob 00:00:02:01:02:03 fd07::2/64
ovn-nbctl lsp-add bob rp2-bob -- set Logical_Switch_Port rp2-bob \
    type=router options:router-port=R2_bob addresses='"00:00:02:01:02:03"'

# connect bob to R3
ovn-nbctl lrp-add R3 R3_bob 00:00:02:01:02:04 fd07::3/64
ovn-nbctl lsp-add bob rp3-bob -- set Logical_Switch_Port rp3-bob \
    type=router options:router-port=R3_bob addresses='"00:00:02:01:02:04"'

# Connect R1 to ext
ovn-nbctl lrp-add R1 R1_ext 00:00:04:01:02:03 fd02::1/64
ovn-nbctl lsp-add ext r1-ext -- set Logical_Switch_Port r1-ext \
    type=router options:router-port=R1_ext addresses='"00:00:04:01:02:03"'

# Connect R2 to ext
ovn-nbctl lrp-add R2 R2_ext 00:00:04:01:02:04 fd02::2/64
ovn-nbctl lsp-add ext r2-ext -- set Logical_Switch_Port r2-ext \
    type=router options:router-port=R2_ext addresses='"00:00:04:01:02:04"'

# Connect R3 to ext
ovn-nbctl lrp-add R3 R3_ext 00:00:04:01:02:05 fd02::3/64
ovn-nbctl lsp-add ext r3-ext -- set Logical_Switch_Port r3-ext \
    type=router options:router-port=R3_ext addresses='"00:00:04:01:02:05"'

# Install ECMP routes for alice.
ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add R1 fd01::/126 fd02::2
ovn-nbctl --ecmp-symmetric-reply --policy="src-ip" lr-route-add R1 fd01::/126 fd02::3

# Static Routes
ovn-nbctl lr-route-add R2 fd01::/64 fd02::1
ovn-nbctl lr-route-add R3 fd01::/64 fd02::1

# Logical port 'alice1' in switch 'alice'.
ADD_NAMESPACES(alice1)
# Only send 1 router solicitation as any additional ones can cause datapath
# flows to get evicted, causing unexpected failures below.
NS_CHECK_EXEC([alice1], [sysctl -w net.ipv6.conf.default.router_solicitations=1], [0], [dnl
net.ipv6.conf.default.router_solicitations = 1
])
ADD_VETH(alice1, alice1, br-int, "fd01::2/64", "f0:00:00:01:02:04", \
         "fd01::1")
OVS_WAIT_UNTIL([test "$(ip netns exec alice1 ip a | grep fd01::2 | grep tentative)" = ""])
ovn-nbctl lsp-add alice alice1 \
-- lsp-set-addresses alice1 "f0:00:00:01:02:04 fd01::2"
# Add neighbour MAC address to avoid sending IPv6 NS messages which could
# cause datapath flows to be evicted
NS_CHECK_EXEC([alice1], [ip -6 neigh add fd01::1 lladdr 00:00:01:01:02:03 dev alice1], [0])

# Logical port 'bob1' in switch 'bob'.
ADD_NAMESPACES(bob1)
# Only send 1 router solicitation as any additional ones can cause datapath
# flows to get evicted, causing unexpected failures below.
NS_CHECK_EXEC([bob1], [sysctl -w net.ipv6.conf.default.router_solicitations=1], [0], [dnl
net.ipv6.conf.default.router_solicitations = 1
])
ADD_VETH(bob1, bob1, br-int, "fd07::1/64", "f0:00:00:01:02:06", \
         "fd07::2")
OVS_WAIT_UNTIL([test "$(ip netns exec bob1 ip a | grep fd07::1 | grep tentative)" = ""])
# Add neighbour MAC addresses to avoid sending IPv6 NS messages which could
# cause datapath flows to be evicted
NS_CHECK_EXEC([bob1], [ip -6 neigh add fd07::2 lladdr 00:00:02:01:02:03 dev bob1], [0])
NS_CHECK_EXEC([bob1], [ip -6 neigh add fd07::3 lladdr 00:00:01:01:02:04 dev bob1], [0])

ovn-nbctl lsp-add bob bob1 \
-- lsp-set-addresses bob1 "f0:00:00:01:02:06 fd07::1"

# Ensure ovn-controller is caught up
ovn-nbctl --wait=hv sync

on_exit 'ovs-ofctl dump-flows br-int'

NETNS_DAEMONIZE([alice1], [nc -6 -l -k 80], [alice1.pid])
NS_CHECK_EXEC([bob1], [nc -6 -z fd01::2 80], [0])

# Ensure datapaths show conntrack states as expected
# Like with conntrack entries, we shouldn't try to predict
# port binding tunnel keys. So omit them from expected labels.
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x401020400000000/.*)' -c], [0], [dnl
1
])

AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x401020400000000)' -c], [0], [dnl
1
])

# Ensure conntrack entry is present. We should not try to predict
# the tunnel key for the output port, so we strip it from the labels
# and just ensure that the known ethernet address is present.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(fd01::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl
tcp,orig=(src=fd07::1,dst=fd01::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd07::1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x401020400000000,protoinfo=(state=<cleared>)
])

# Flush conntrack entries for easier output parsing of next test.
AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# Change bob1 L2 address anche check the reply is properly updated.
ovn-nbctl set Logical_Router_Port R2_ext mac='"00:00:10:01:02:04"'
ovn-nbctl set Logical_Switch_Port r2-ext \
     type=router options:router-port=R2_ext addresses='"00:00:10:01:02:04"'

NS_CHECK_EXEC([bob1], [nc -6 -z fd01::2 80], [0])

AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(+new-est-rpl+trk).*ct(.*label=0x1001020400000000/.*)' -c], [0], [dnl
1
])
AT_CHECK([ovs-appctl dpctl/dump-flows | grep 'ct_state(-new+est+rpl+trk).*ct_label(0x1001020400000000)' -c], [0], [dnl
1
])

AT_CHECK([ovs-appctl dpctl/dump-conntrack | grep 0x1001020400000000 | FORMAT_CT(fd01::2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' |
sed -e 's/mark=[[0-9]]*/mark=<cleared>/'], [0], [dnl
tcp,orig=(src=fd07::1,dst=fd01::2,sport=<cleared>,dport=<cleared>),reply=(src=fd01::2,dst=fd07::1,sport=<cleared>,dport=<cleared>),zone=<cleared>,mark=<cleared>,labels=0x1001020400000000,protoinfo=(state=<cleared>)
])

# Check entries in table 76 and 77 expires w/o traffic
OVS_WAIT_UNTIL([
test $(ovs-ofctl dump-flows br-int | grep -c 'table=76, n_packets') -eq 0
])
OVS_WAIT_UNTIL([
test $(ovs-ofctl dump-flows br-int | grep -c 'table=77, n_packets') -eq 0
])

ovs-ofctl dump-flows br-int

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([controller I-P handling when ovs iface ofport is -1])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-port1
ovn-nbctl lsp-set-addresses sw0-port1 "10:54:00:00:00:03 10.0.0.3"

ovs-vsctl add-port br-int p1 -- \
    set Interface p1 external_ids:iface-id=sw0-port1 -- \
    set Interface p1 type=internal

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-port1) = xup])
ovs-vsctl set interface p1 type=\"\"
OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw0-port1) = xdown])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/could not open network device p1*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ARP resolution for SNAT IP])
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovn-nbctl lr-add R1

ovn-nbctl ls-add sw0
ovn-nbctl ls-add public

ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 \
    -- lrp-set-gateway-chassis rp-public hv1

ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

ovn-nbctl lr-nat-add R1 snat 172.16.1.1 192.168.1.0/24
ovn-nbctl lr-nat-add R1 snat 172.16.1.20 192.168.1.2

ADD_NAMESPACES(sw01-x)
ADD_VETH(sw01-x, sw01-x, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
ovn-nbctl lsp-add sw0 sw01-x \
    -- lsp-set-addresses sw01-x "f0:00:00:01:02:03 192.168.1.2"

OVS_WAIT_UNTIL([test x$(ovn-nbctl lsp-get-up sw01-x) = xup])

ADD_NAMESPACES(ext-foo)
ADD_VETH(ext-foo, ext-foo, br-ext, "172.16.1.100/24", "00:10:10:01:02:13", \
         "172.16.1.1")

OVS_WAIT_UNTIL([test "$(ip netns exec ext-foo ip a | grep fe80 | grep tentative)" = ""])

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])
ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

ovn-nbctl --wait=hv sync

# Send ping from sw01-x to ext-foo.
NS_CHECK_EXEC([sw01-x], [ping -q -c 3 -i 0.3 -w 2 172.16.1.100 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Check conntrack entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.1.100) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.1.2,dst=172.16.1.100,id=<cleared>,type=8,code=0),reply=(src=172.16.1.100,dst=172.16.1.20,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([egress qos])
AT_KEYWORDS([ovn-egress-qos])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovn-nbctl ls-add sw0

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.2/24", "f0:00:00:01:02:03")
ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(public)
ADD_VETH(public, public, br-ext, "192.168.2.2/24", "f0:00:00:01:02:05")

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])
ovn-nbctl lsp-add sw0 public \
        -- lsp-set-addresses public unknown \
        -- lsp-set-type public localnet \
        -- lsp-set-options public network_name=phynet

AT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_min_rate=200000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_max_rate=300000])
AT_CHECK([ovn-nbctl set Logical_Switch_Port public options:qos_burst=3000000])
AT_CHECK([ovs-vsctl set interface ovs-public external-ids:ovn-egress-iface=true])
OVS_WAIT_UNTIL([tc qdisc show | grep -q 'htb 1: dev ovs-public'])
OVS_WAIT_UNTIL([tc class show dev ovs-public | \
                grep -q 'class htb .* rate 200Kbit ceil 300Kbit burst 375000b cburst 375000b'])

AT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_min_rate=200000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_max_rate=300000])
AT_CHECK([ovn-nbctl remove Logical_Switch_Port public options qos_burst=3000000])
OVS_WAIT_UNTIL([test "$(tc qdisc show | grep 'htb 1: dev ovs-public')" = ""])

kill $(pidof ovn-controller)

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([BFD])
AT_SKIP_IF([test $HAVE_BFDD_BEACON = no])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_KEYWORDS([ovn-bfd])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add R1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24
check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 1000::a/64 \
    -- lrp-set-gateway-chassis rp-public hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router
check ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \
    type=router options:router-port=rp-sw1 \
    -- lsp-set-addresses sw1-rp router

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(sw11)
ADD_VETH(sw11, sw11, br-int, "192.168.2.2/24", "f0:00:00:02:02:03", \
         "192.168.2.1")
check ovn-nbctl lsp-add sw1 sw11 \
    -- lsp-set-addresses sw11 "f0:00:00:02:02:03 192.168.2.2"

ADD_NAMESPACES(server)
NS_CHECK_EXEC([server], [ip link set dev lo up])
ADD_VETH(s1, server, br-ext, "172.16.1.50/24", "f0:00:00:01:02:05", \
         "172.16.1.1")
NS_CHECK_EXEC([server], [ip addr add 1000::b/64 dev s1])

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])
check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

NS_CHECK_EXEC([server], [bfdd-beacon --listen=172.16.1.50], [0])
NS_CHECK_EXEC([server], [bfdd-control allow 172.16.1.1], [0], [dnl
Allowing connections from 172.16.1.1
])

check ovn-nbctl --bfd lr-route-add R1 100.0.0.0/8 172.16.1.50 rp-public
uuid=$(fetch_column nb:bfd _uuid logical_port="rp-public")
route_uuid=$(fetch_column nb:logical_router_static_route _uuid ip_prefix="100.0.0.0/8")
check ovn-nbctl --wait=hv sync

wait_column "up" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 | grep 'match=(ip4.dst == 100.0.0.0/8)' | grep -q 172.16.1.50])

# un-associate the bfd connection and the static route
check ovn-nbctl clear logical_router_static_route $route_uuid bfd
wait_column "admin_down" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([ip netns exec server bfdd-control status | grep -qi state=Down])
NS_CHECK_EXEC([server], [tcpdump -nni s1 udp port 3784 -Q in > bfd.pcap &])
sleep 5
kill $(pidof tcpdump)
AT_CHECK([grep -qi bfd bfd.pcap],[1])

# restart the connection
check ovn-nbctl set logical_router_static_route $route_uuid bfd=$uuid
wait_column "up" nb:bfd status logical_port=rp-public

# switch to gw router configuration
check ovn-nbctl clear logical_router_static_route $route_uuid bfd
wait_column "admin_down" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([ip netns exec server bfdd-control status | grep -qi state=Down])
check ovn-nbctl clear logical_router_port rp-public gateway_chassis
check ovn-nbctl set logical_router R1 options:chassis=hv1
check ovn-nbctl set logical_router_static_route $route_uuid bfd=$uuid
wait_column "up" nb:bfd status logical_port=rp-public

# stop bfd endpoint
NS_CHECK_EXEC([server], [bfdd-control stop], [0], [dnl
stopping
])

wait_column "down" nb:bfd status logical_port=rp-public
OVS_WAIT_UNTIL([test "$(ovn-sbctl dump-flows R1 | grep 'match=(ip4.dst == 100.0.0.0/8)' | grep 172.16.1.50)" = ""])

# remove bfd entry
ovn-nbctl destroy bfd $uuid
check_row_count bfd 0
NS_CHECK_EXEC([server], [tcpdump -nni s1 udp port 3784 -Q in > bfd.pcap &])
sleep 5
kill $(pidof tcpdump)
AT_CHECK([grep -qi bfd bfd.pcap],[1])

uuid_v6=$(ovn-nbctl create bfd logical_port=rp-public dst_ip=\"1000::b\")
check ovn-nbctl lr-route-add R1 2000::/64 1000::b
route_uuid_v6=$(fetch_column nb:logical_router_static_route _uuid ip_prefix=\"2000::/64\")
ovn-nbctl set logical_router_static_route $route_uuid_v6 bfd=$uuid_v6
check ovn-nbctl --wait=hv sync
NS_CHECK_EXEC([server], [bfdd-beacon --listen=1000::b], [0])
NS_CHECK_EXEC([server], [bfdd-control allow 1000::a], [0], [dnl
Allowing connections from 1000::a
])

wait_column "up" nb:bfd status logical_port=rp-public
ovn-nbctl destroy bfd $uuid_v6

kill $(pidof ovn-controller)

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([No ct_state matches in dp flows when no ACLs in an LS])
AT_KEYWORDS([no ct_state match])
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:03"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:04 10.0.0.4"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:04 10.0.0.4"


# Create the second logical switch with one port and configure some ACLs.
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1

# Create port group and ACLs for sw1 ports.
check ovn-nbctl pg-add pg1 sw1-p1
check ovn-nbctl acl-add pg1 from-lport 1002 "ip" allow-related
check ovn-nbctl acl-add pg1 to-lport 1002 "ip" allow-related

OVN_POPULATE_ARP
ovn-nbctl --wait=hv sync

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")


ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

ADD_NAMESPACES(sw1-p1)
ADD_VETH(sw1-p1, sw1-p1, br-int, "20.0.0.4/24", "30:54:00:00:00:04", \
         "20.0.0.1")

wait_for_ports_up

NS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

ovs-appctl dpctl/dump-flows

# sw1-p1 may send IPv6 traffic.  So filter this out.  Since sw1-p1 has
# ACLs configured, the datapath flows for the packets from sw1-p1 will have
# matches on ct_state and ct_label fields.
# Since sw0 doesn't have any ACLs, there should be no match on ct fields.
AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [1], [dnl
0
])

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [1], [dnl
0
])

# Add an ACL to sw0.
check ovn-nbctl --wait=hv acl-add sw0 to-lport 1002 ip allow-related

NS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

ovs-appctl dpctl/dump-flows

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [0], [ignore])

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [0], [ignore])

# Clear ACL for sw0
check ovn-nbctl --wait=hv clear logical_switch sw0 acls

check ovs-appctl dpctl/del-flows

check ovn-nbctl --wait=hv sync

NS_CHECK_EXEC([sw0-p1], [ping -q -c 3 -i 0.3 -w 2 10.0.0.4 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

ovs-appctl dpctl/dump-flows

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_state | grep -v ipv6 -c], [1], [dnl
0
])

AT_CHECK([ovs-appctl dpctl/dump-flows | grep ct_mark | grep -v ipv6 -c], [1], [dnl
0
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DNAT LR hairpin IPv4])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

# Logical network:
# Two VMs
#   * VM1 with IP address 192.168.100.5
#   * VM2 with IP address 192.168.100.6
# The VMs connect to logical switch ls1.
#
# An external router with IP address 172.18.1.2. We simulate this with a network namespace.
# There will be no traffic going here in this test.
# The external router connects to logical switch ls-pub
#
# One logical router (lr1) connects to ls1 and ls-pub. The router port connected to ls-pub is
# a gateway port.
#   * The subnet connected to ls1 is 192.168.100.0/24. The Router IP address is 192.168.100.1
#   * The subnet connected to ls-pub is 172.18.1.0/24. The Router IP address is 172.168.1.1
# lr1 has the following attributes:
#   * It has a "default" static route that sends traffic out the gateway router port.
#   * It has a DNAT rule that translates 172.18.2.10 to 192.168.100.6 (VM2)
#
# In this test, we want to ensure that a ping from VM1 to IP address 172.18.2.10 reaches VM2.

ovn-nbctl ls-add ls1
ovn-nbctl lsp-add ls1 vm1 -- lsp-set-addresses vm1 "00:00:00:00:00:05 192.168.100.5"
ovn-nbctl lsp-add ls1 vm2 -- lsp-set-addresses vm2 "00:00:00:00:00:06 192.168.100.6"

ovn-nbctl ls-add ls-pub
ovn-nbctl lsp-add ls-pub ext-router -- lsp-set-addresses ext-router "00:00:00:00:01:02 172.18.1.2"

ovn-nbctl lr-add lr1
ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:00:01 192.168.100.1/24
ovn-nbctl lsp-add ls1 ls1-lr1                      \
    -- lsp-set-type ls1-lr1 router                 \
    -- lsp-set-addresses ls1-lr1 00:00:00:00:00:01 \
    -- lsp-set-options ls1-lr1 router-port=lr1-ls1

ovn-nbctl lrp-add lr1 lr1-ls-pub 00:00:00:00:01:01 172.18.1.1/24
ovn-nbctl lrp-set-gateway-chassis lr1-ls-pub hv1
ovn-nbctl lsp-add ls-pub ls-pub-lr1                      \
    -- lsp-set-type ls-pub-lr1 router                    \
    -- lsp-set-addresses ls-pub-lr1 00:00:00:00:01:01    \
    -- lsp-set-options ls-pub-lr1 router-port=lr1-ls-pub

ovn-nbctl lr-nat-add lr1 snat 172.18.1.1 192.168.100.0/24
ovn-nbctl lr-nat-add lr1 dnat_and_snat 172.18.2.10 192.168.100.6
ovn-nbctl lr-route-add lr1 0.0.0.0/0 172.18.1.2

#ls1_uuid=$(fetch_column Port_Binding datapath logical_port=vm1)
#ovn-sbctl create MAC_Binding ip=172.18.2.10 datapath=$ls1_uuid logical_port=vm2 mac="00:00:00:00:00:06"

OVN_POPULATE_ARP
ovn-nbctl --wait=hv sync

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "192.168.100.5/24", "00:00:00:00:00:05", \
         "192.168.100.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "192.168.100.6/24", "00:00:00:00:00:06", \
         "192.168.100.1")

ADD_NAMESPACES(ext-router)
ADD_VETH(ext-router, ext-router, br-int, "172.18.1.2/24", "00:00:00:00:01:02", \
         "172.18.1.1")

# Let's take a quick look at the logical flows
ovn-sbctl lflow-list

# Let's check what ovn-trace says...
ovn-trace ls1 'inport == "vm1" && eth.src == 00:00:00:00:00:05 && ip4.src == 192.168.100.5 && eth.dst == 00:00:00:00:00:01 && ip4.dst == 172.18.2.10 && ip.ttl == 32'

# A ping from vm1 should hairpin in lr1 and successfully DNAT to vm2
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

dnat_and_snat_uuid=$(fetch_column nb:NAT _uuid external_ip=172.18.2.10)
ovn-nbctl set NAT $dnat_and_snat_uuid options:stateless=true

# A ping from vm1 should hairpin in lr1 and successfully DNAT to vm2
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])
# A ping from vm2 should hairpin in lr1 and successfully DNAT to vm2
NS_CHECK_EXEC([vm2], [ping -q -c 3 -i 0.3 -w 2 172.18.2.10 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

kill $(pidof ovn-controller)

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- Floating IP outside router subnet IPv4])
AT_KEYWORDS(NAT)

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

start_daemon ovn-controller

# Logical network:
# Two VMs
#   * VM1 with IP address 192.168.100.5
#   * VM2 with IP address 192.168.200.5
#
# VM1 connects to logical switch ls1. ls1 connects to logical router lr1.
# VM2 connects to logical switch ls2. ls2 connects to logical router lr2.
# lr1 and lr2 both connect to logical switch ls-pub.
# * lr1's interface that connects to ls-pub has IP address 172.18.2.110/24
# * lr2's interface that connects to ls-pub has IP address 172.18.1.173/24
#
# lr1 has the following attributes:
#   * It has a DNAT rule that translates 172.18.2.11 to 192.168.100.5 (VM1)
#
# lr2 has the following attributes:
#   * It has a DNAT rule that translates 172.18.2.12 to 192.168.200.5 (VM2)
#
# In this test, we want to ensure that a ping from VM1 to IP address 172.18.2.12 reaches VM2.
# When the NAT rules are set up, there should be MAC_Bindings created that allow for traffic
# to exit lr1, go through ls-pub, and reach the NAT external IP configured on lr2.

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 vm1 -- lsp-set-addresses vm1 "00:00:00:00:01:05 192.168.100.5"

check ovn-nbctl ls-add ls2
check ovn-nbctl lsp-add ls2 vm2 -- lsp-set-addresses vm2 "00:00:00:00:02:05 192.168.200.5"

check ovn-nbctl ls-add ls-pub

check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:01:01 192.168.100.1/24
check ovn-nbctl lsp-add ls1 ls1-lr1                      \
    -- lsp-set-type ls1-lr1 router                 \
    -- lsp-set-addresses ls1-lr1 router            \
    -- lsp-set-options ls1-lr1 router-port=lr1-ls1

check ovn-nbctl lr-add lr2
check ovn-nbctl lrp-add lr2 lr2-ls2 00:00:00:00:02:01 192.168.200.1/24
check ovn-nbctl lsp-add ls2 ls2-lr2                      \
    -- lsp-set-type ls2-lr2 router                 \
    -- lsp-set-addresses ls2-lr2 router            \
    -- lsp-set-options ls2-lr2 router-port=lr2-ls2

check ovn-nbctl lrp-add lr1 lr1-ls-pub 00:00:00:00:03:01 172.18.2.110/24
check ovn-nbctl lrp-set-gateway-chassis lr1-ls-pub hv1
check ovn-nbctl lsp-add ls-pub ls-pub-lr1                      \
    -- lsp-set-type ls-pub-lr1 router                    \
    -- lsp-set-addresses ls-pub-lr1 router               \
    -- lsp-set-options ls-pub-lr1 router-port=lr1-ls-pub

check ovn-nbctl lrp-add lr2 lr2-ls-pub 00:00:00:00:03:02 172.18.1.173/24
check ovn-nbctl lrp-set-gateway-chassis lr2-ls-pub hv1
check ovn-nbctl lsp-add ls-pub ls-pub-lr2                      \
    -- lsp-set-type ls-pub-lr2 router                    \
    -- lsp-set-addresses ls-pub-lr2 router               \
    -- lsp-set-options ls-pub-lr2 router-port=lr2-ls-pub

# Putting --add-route on these NAT rules means there is no need to
# add any static routes.
check ovn-nbctl --add-route lr-nat-add lr1 dnat_and_snat 172.18.2.11 192.168.100.5 vm1 00:00:00:00:03:01
check ovn-nbctl --add-route lr-nat-add lr2 dnat_and_snat 172.18.2.12 192.168.200.5 vm2 00:00:00:00:03:02

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "192.168.100.5/24", "00:00:00:00:01:05", \
         "192.168.100.1")

ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "192.168.200.5/24", "00:00:00:00:02:05", \
         "192.168.200.1")

OVN_POPULATE_ARP
check ovn-nbctl --wait=hv sync

AS_BOX([Testing a ping])

NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 172.18.2.12 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn -- CoPP])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
AT_SKIP_IF([test $HAVE_SCAPY = no])
AT_KEYWORDS([ovn-copp])

ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
check ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl lr-add R1
check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add public

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-public 00:00:02:01:02:03 172.16.1.1/24 1000::a/64 \
    -- lrp-set-gateway-chassis rp-public hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router

check ovn-nbctl lsp-add public public-rp -- set Logical_Switch_Port public-rp \
    type=router options:router-port=rp-public \
    -- lsp-set-addresses public-rp router

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
         "192.168.1.1")
check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(server)
NS_CHECK_EXEC([server], [ip link set dev lo up])
ADD_VETH(s1, server, br-ext, "172.16.1.50/24", "f0:00:00:01:02:05", \
         "172.16.1.1")

AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=phynet:br-ext])
check ovn-nbctl lsp-add public public1 \
        -- lsp-set-addresses public1 unknown \
        -- lsp-set-type public1 localnet \
        -- lsp-set-options public1 network_name=phynet

NS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp -Q in > reject.pcap &])
check ovn-nbctl meter-add acl-meter drop 1 pktps 0
check ovn-nbctl --wait=hv copp-add copp0 reject acl-meter
check ovn-nbctl --wait=hv ls-copp-add copp0 sw0
check ovn-nbctl acl-add sw0 from-lport 1002 'inport == "sw01" && ip && udp' reject

AT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl
reject: acl-meter
])

ip netns exec sw01 scapy -H <<-EOF
p = IP(src="192.168.1.2", dst="192.168.1.1") / UDP(dport = 12345) / Raw(b"X"*64)
send (p, iface='sw01', loop = 0, verbose = 0, count = 20)
EOF

# 1pps
OVS_WAIT_UNTIL([
    n_reject=$(grep unreachable reject.pcap | wc -l)
    test "${n_reject}" = "1"
])
kill $(pidof tcpdump)
rm -f reject.pcap

# Let's update the meter
NS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp -Q in > reject.pcap &])
check ovn-nbctl --may-exist meter-add acl-meter drop 10 pktps 0
ip netns exec sw01 scapy -H <<-EOF
p = IP(src="192.168.1.2", dst="192.168.1.1") / UDP(dport = 12345) / Raw(b"X"*64)
send (p, iface='sw01', loop = 0, verbose = 0, count = 100)
EOF

# 10pps
OVS_WAIT_UNTIL([
    n_reject=$(grep unreachable reject.pcap | wc -l)
    test "${n_reject}" = "10"
])

kill $(pidof tcpdump)
rm -f reject.pcap

NS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp -Q in > reject.pcap &])
check ovn-nbctl --wait=hv copp-del copp0 reject

ip netns exec sw01 scapy -H <<-EOF
p = IP(src="192.168.1.2", dst="192.168.1.1") / UDP(dport = 12345) / Raw(b"X"*64)
send (p, iface='sw01', loop = 0, verbose = 0, count = 20)
EOF

OVS_WAIT_UNTIL([
    n_reject=$(grep unreachable reject.pcap | wc -l)
    test "${n_reject}" = "20"
])
kill $(pidof tcpdump)

NS_EXEC([server], [tcpdump -l -n -i s1 arp[[24:4]]=0xac100164 > arp.pcap &])
check ovn-nbctl meter-add arp-meter drop 1 pktps 0
check ovn-nbctl --wait=hv copp-add copp1 arp-resolve arp-meter
check ovn-nbctl --wait=hv lr-copp-add copp1 R1
AT_CHECK([ovn-nbctl copp-list copp1], [0], [dnl
arp-resolve: arp-meter
])

ip netns exec sw01 scapy -H <<-EOF
p = IP(src="192.168.1.2", dst="172.16.1.100") / TCP(dport = 80, flags="S") / Raw(b"X"*64)
send (p, iface='sw01', loop = 0, verbose = 0, count = 100)
EOF

# 1pps
OVS_WAIT_UNTIL([
    n_arp=$(grep ARP arp.pcap | wc -l)
    test "${n_arp}" = "1"
])
kill $(pidof tcpdump)

check ovn-nbctl meter-add icmp-meter drop 1 pktps 0
check ovn-nbctl --wait=hv copp-add copp2 icmp4-error icmp-meter
check ovn-nbctl --wait=hv lr-copp-add copp2 R1
AT_CHECK([ovn-nbctl copp-list copp2 |grep icmp4-error], [0], [dnl
icmp4-error: icmp-meter
])

NS_EXEC([sw01], [tcpdump -l -n -i sw01 icmp > icmp.pcap &])
ip netns exec sw01 scapy -H <<-EOF
p = IP(src="192.168.1.2", dst="172.16.1.100", ttl=1) / TCP(dport = 8080, flags="S") / Raw(b"X"*64)
send (p, iface='sw01', loop = 0, verbose = 0, count = 100)
EOF

# 1pps
OVS_WAIT_UNTIL([
    n_icmp=$(grep ICMP icmp.pcap | wc -l)
    test "${n_icmp}" = "1"
])
kill $(pidof tcpdump)

check ovn-nbctl meter-add bfd-meter drop 1 pktps 0
check ovn-nbctl --wait=hv copp-add copp3 bfd bfd-meter
check ovn-nbctl --wait=hv lr-copp-add copp3 R1
AT_CHECK([ovn-nbctl copp-list copp3 |grep bfd], [0], [dnl
bfd: bfd-meter
])

check ovn-nbctl --bfd lr-route-add R1 240.0.0.0/8 172.16.1.50 rp-public
printf "%08x" $(ovn-sbctl get bfd . disc) > /tmp/disc
NS_EXEC([server], [tcpdump -l -nn -i s1 udp port 3784 and ip[[29]]==0x90 -Q in > bfd.pcap &])
ip netns exec server scapy -H <<-EOF
import binascii
f = open("/tmp/disc", "r")
# scapy does not support BFD protocol
# let's hardcode a BFD payload with the proper my-disc field read from the db
bfd = binascii.unhexlify("20600518a899e77b" + f.readline().strip() + "000f4240000f424000000000")
p = IP(src="172.16.1.50", dst="172.16.1.1") / UDP(dport = 3784, sport = 49152) / Raw(load = bfd)
send (p, iface='s1', loop = 0, verbose = 0, count = 100)
f.close()
EOF
rm /tmp/disc

# 1pps
OVS_WAIT_UNTIL([
    n_bfd=$(grep 3784 bfd.pcap | wc -l)
    test "${n_bfd}" = "1"
])
kill $(pidof tcpdump)

kill $(pidof ovn-controller)

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/.*error receiving.*/d
/.*terminating with signal 15.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL label - conntrack ct_label])
AT_KEYWORDS([acl label ct_commit])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:02 10.0.0.2"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:03 10.0.0.3"

check ovn-nbctl lsp-add sw0 sw0-p3
check ovn-nbctl lsp-set-addresses sw0-p3 "50:54:00:00:00:04 10.0.0.4"
check ovn-nbctl lsp-set-port-security sw0-p3 "50:54:00:00:00:04 10.0.0.4"

# ACLs
# Case 1: sw0-p1 ---> sw0-p3 allowed, label=1234
# Case 2: sw0-p3 ---> sw0-p1 allowed, label=1235
# Case 3: sw0-p1 ---> sw0-p2 allowed, no label
# Case 4: sw0-p2 ---> sw0-p1 allowed, no label

check ovn-nbctl --label=1234 acl-add sw0 from-lport 1002 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.4' allow-related
check ovn-nbctl --label=1235 acl-add sw0 to-lport 1002 'ip4 && outport == "sw0-p1" && ip4.src == 10.0.0.4' allow-related
check ovn-nbctl acl-add sw0 from-lport 1001 "ip" allow-related
check ovn-nbctl acl-add sw0 to-lport 1001 "ip" allow-related


ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.2/24", "50:54:00:00:00:02", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p3)
ADD_VETH(sw0-p3, sw0-p3, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

# Ensure ovn-controller is caught up
ovn-nbctl --wait=hv sync

on_exit 'ovn-nbctl acl-list sw0'
on_exit 'ovn-sbctl lflow-list'
on_exit 'ovs-ofctl dump-flows br-int'

wait_for_ports_up

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p1' should be able to ping 'sw0-p3'.
NS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.4 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000
icmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p3' should be able to ping 'sw0-p1'.
NS_CHECK_EXEC([sw0-p3], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000
icmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p1' should be able to ping 'sw0-p2'.
NS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.3 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is not set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p2' should be able to ping 'sw0-p1'.
NS_CHECK_EXEC([sw0-p2], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is not set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL label - conntrack ct_label - acl after lb])
AT_KEYWORDS([acl label ct_commit])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:02 10.0.0.2"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:03 10.0.0.3"

check ovn-nbctl lsp-add sw0 sw0-p3
check ovn-nbctl lsp-set-addresses sw0-p3 "50:54:00:00:00:04 10.0.0.4"
check ovn-nbctl lsp-set-port-security sw0-p3 "50:54:00:00:00:04 10.0.0.4"

# ACLs
# Case 1: sw0-p1 ---> sw0-p3 allowed, label=1234
# Case 2: sw0-p3 ---> sw0-p1 allowed, label=1235
# Case 3: sw0-p1 ---> sw0-p2 allowed, no label
# Case 4: sw0-p2 ---> sw0-p1 allowed, no label

check ovn-nbctl --label=1234 --apply-after-lb acl-add sw0 from-lport 1002 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.4' allow-related
check ovn-nbctl --label=1235 acl-add sw0 to-lport 1002 'ip4 && outport == "sw0-p1" && ip4.src == 10.0.0.4' allow-related
check ovn-nbctl --apply-after-lb acl-add sw0 from-lport 1001 "ip" allow-related
check ovn-nbctl acl-add sw0 to-lport 1001 "ip" allow-related


ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.2/24", "50:54:00:00:00:02", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p3)
ADD_VETH(sw0-p3, sw0-p3, br-int, "10.0.0.4/24", "50:54:00:00:00:04", \
         "10.0.0.1")

# Ensure ovn-controller is caught up
ovn-nbctl --wait=hv sync

on_exit 'ovn-nbctl acl-list sw0'
on_exit 'ovn-sbctl lflow-list'
on_exit 'ovs-ofctl dump-flows br-int'

wait_for_ports_up

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p1' should be able to ping 'sw0-p3'.
NS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.4 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.4) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000
icmp,orig=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=8,code=0),reply=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p3' should be able to ping 'sw0-p1'.
NS_CHECK_EXEC([sw0-p3], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000
icmp,orig=(src=10.0.0.4,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.4,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p1' should be able to ping 'sw0-p2'.
NS_CHECK_EXEC([sw0-p1], [ping -q -c 10 -i 0.3 -w 15 10.0.0.3 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is not set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])
# 'sw0-p2' should be able to ping 'sw0-p1'.
NS_CHECK_EXEC([sw0-p2], [ping -q -c 10 -i 0.3 -w 15 10.0.0.2 | FORMAT_PING], \
[0], [dnl
10 packets transmitted, 10 received, 0% packet loss, time 0ms
])

# Ensure conntrack entry is present and ct_label is not set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.2) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=8,code=0),reply=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL label - conntrack label change])
AT_KEYWORDS([acl label ct_commit label change])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:02 10.0.0.2"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:03 10.0.0.3"

# ACLs
# sw0-p1 ---> sw0-p2 allowed, label=1234

check ovn-nbctl --label=1234 acl-add sw0 from-lport 1002 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.3' allow-related

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.2/24", "50:54:00:00:00:02", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

# Ensure ovn-controller is caught up
ovn-nbctl --wait=hv sync

on_exit 'ovn-nbctl acl-list sw0'
on_exit 'ovn-sbctl lflow-list'
on_exit 'ovs-ofctl dump-flows br-int'

wait_for_ports_up

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# start a background ping for ~30 secs.
NETNS_DAEMONIZE([sw0-p1], [[ping -q -c 100 -i 0.3 -w 15 10.0.0.3]], [ns-sw0-p1.pid])

sleep 3s

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

# Add a higher priority ACL with different label.
# This ACL also allows the ping running in background.

check ovn-nbctl --label=1235 acl-add sw0 from-lport 1003 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.3' allow-related
ovn-nbctl --wait=hv sync

sleep 3s

# Ensure conntrack entry is updated with new ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL label - conntrack label change - acl after lb])
AT_KEYWORDS([acl label ct_commit label change])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:02 10.0.0.2"
check ovn-nbctl lsp-set-port-security sw0-p1 "50:54:00:00:00:02 10.0.0.2"

check ovn-nbctl lsp-add sw0 sw0-p2
check ovn-nbctl lsp-set-addresses sw0-p2 "50:54:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-port-security sw0-p2 "50:54:00:00:00:03 10.0.0.3"

# ACLs
# sw0-p1 ---> sw0-p2 allowed, label=1234

check ovn-nbctl --label=1234 --apply-after-lb acl-add sw0 from-lport 1002 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.3' allow-related

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.2/24", "50:54:00:00:00:02", \
         "10.0.0.1")
ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.3/24", "50:54:00:00:00:03", \
         "10.0.0.1")

# Ensure ovn-controller is caught up
ovn-nbctl --wait=hv sync

on_exit 'ovn-nbctl acl-list sw0'
on_exit 'ovn-sbctl lflow-list'
on_exit 'ovs-ofctl dump-flows br-int'

wait_for_ports_up

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# start a background ping for ~30 secs.
NETNS_DAEMONIZE([sw0-p1], [[ping -q -c 100 -i 0.3 -w 15 10.0.0.3]], [ns-sw0-p1.pid])

sleep 3s

# Ensure conntrack entry is present and ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d2[[0-9a-f]]*/labels=0x4d2000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d2000000000000000000000000
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

# Add a higher priority ACL with different label.
# This ACL also allows the ping running in background.

check ovn-nbctl --label=1235 --apply-after-lb acl-add sw0 from-lport 1003 'ip4 && inport == "sw0-p1" && ip4.dst == 10.0.0.3' allow-related
ovn-nbctl --wait=hv sync

sleep 3s

# Ensure conntrack entry is updated with new ct_label is set.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(10.0.0.3) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/' | \
sed -e 's/labels=0x4d3[[0-9a-f]]*/labels=0x4d3000000000000000000000000/'], [0], [dnl
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>,labels=0x4d3000000000000000000000000
icmp,orig=(src=10.0.0.2,dst=10.0.0.3,id=<cleared>,type=8,code=0),reply=(src=10.0.0.3,dst=10.0.0.2,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL all drop and allow related - acl after lb])
AT_KEYWORDS([ACL all drop and allow related])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller


# No ACLs in sw0.
check ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0p1
check ovn-nbctl lsp-set-addresses sw0p1 "50:54:00:00:00:02 10.0.0.3"

# ACLs to drop every thing and just allow-related.
check ovn-nbctl ls-add sw1

check ovn-nbctl lsp-add sw1 sw1p1
check ovn-nbctl lsp-set-addresses sw1p1 "50:54:00:00:00:03 20.0.0.3"

check ovn-nbctl --apply-after-lb acl-add sw1 from-lport 1001 'inport == "sw1p1" && ip4' drop

check ovn-nbctl acl-add sw1 to-lport 1002 'ip4 && tcp && tcp.dst == 80' allow-related
check ovn-nbctl acl-add sw1 to-lport 1001 'ip4' drop

ADD_NAMESPACES(sw0p1)
ADD_VETH(sw0p1, sw0p1, br-int, "10.0.0.3/24", "50:54:00:00:00:02", \
         "10.0.0.1")
ADD_NAMESPACES(sw1p1)
ADD_VETH(sw1p1, sw1p1, br-int, "20.0.0.3/24", "50:54:00:00:00:03", \
         "20.0.0.1")

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

# Ensure ovn-controller is caught up
ovn-nbctl --wait=hv sync

on_exit 'ovn-nbctl acl-list sw0'
on_exit 'ovn-sbctl lflow-list'
on_exit 'ovs-ofctl dump-flows br-int'

wait_for_ports_up

# Start webservers in 'sw1-p1'
OVS_START_L7([sw1p1], [http])

AT_CHECK([ip netns exec sw0p1 wget 20.0.0.3 -t 3 -T 1], [0], [ignore], [ignore])

# Clear the apply-after-lb option for the ACL
check ovn-nbctl acl-del sw1 from-lport 1001 'inport == "sw1p1" && ip4'
check ovn-nbctl acl-add sw1 from-lport 1001 'inport == "sw1p1" && ip4' drop

check ovn-nbctl --wait=hv sync

AT_CHECK([ip netns exec sw0p1 wget 20.0.0.3 -t 3 -T 1], [0], [ignore], [ignore])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ACL log_related])

CHECK_CONNTRACK()
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

set_acl_options() {
    local acl_name=$1; shift

    local acl_uuid=$(fetch_column nb:ACL _uuid name=$acl_name)
    check ovn-nbctl set ACL $acl_uuid "$@"
}

clear_log() {
    ovn-appctl -t ovn-controller vlog/close
    rm ovn-controller.log
    ovn-appctl -t ovn-controller vlog/reopen
}

test_ping() {
    NS_CHECK_EXEC([sw0-p1],  [ping -q -c 1 -i 0.3 -w 2 10.0.0.2 | FORMAT_PING], \
[0], [dnl
1 packets transmitted, 1 received, 0% packet loss, time 0ms
])
}

check_acl_log_count() {
    local expected_count=$1

    AT_CHECK_UNQUOTED([grep -c acl_log ovn-controller.log], [0], [dnl
$expected_count
])
}

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 "00:00:00:00:00:01 10.0.0.1"
check ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 "00:00:00:00:00:02 10.0.0.2"

check ovn-nbctl pg-add pg1 sw0-p1 sw0-p2

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.1/24", "00:00:00:00:00:01")
ADD_NAMESPACES(sw0-p2)
ADD_VETH(sw0-p2, sw0-p2, br-int, "10.0.0.2/24", "00:00:00:00:00:02")

wait_for_ports_up

check ovn-nbctl --log --name=allow_acl acl-add pg1 from-lport 100 'inport == @pg1 && ip4' allow

check ovn-nbctl --wait=hv sync

test_ping

# The allow ACL should match on the request and reply traffic, resulting in 2 logs.
check_acl_log_count 2

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=2 \
    --name=allow_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:02 \
    --dl_dst=00:00:00:00:00:01 \
    --nw_src=10.0.0.2 \
    --nw_dst=10.0.0.1 \
    --icmp_type=0 \
    --icmp_code=0

# Now add a higher-priority stateful ACL that matches on the same
# parameters. Don't enable reply logging.
check ovn-nbctl --log --name=allow_related_acl acl-add pg1 from-lport 200 'inport == @pg1 && ip4' allow-related
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# Since reply logging is not enabled, the allow-related ACL should match on the
# request, but the reply will not be logged.
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# As a control, set a label on the allow-related ACL, but still don't enable
# reply traffic logging.
set_acl_options allow_related_acl label=1 options:log-related=false
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# This should have the same result as the previous ping
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# As another control, remove the label but enable reply logging.
set_acl_options allow_related_acl label=0 options:log-related=true
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# This should have the same result as the previous ping
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# This time, add a label and enable reply logging on the allow_related ACL.
set_acl_options allow_related_acl label=1 options:log-related=true
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# Now we should have the request and reply logged.
check_acl_log_count 2

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=2 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:02 \
    --dl_dst=00:00:00:00:00:01 \
    --nw_src=10.0.0.2 \
    --nw_dst=10.0.0.1 \
    --icmp_type=0 \
    --icmp_code=0


# And now, let's start from scratch but make sure everything works when
# using egress ACLs.
check ovn-nbctl acl-del pg1
check_row_count nb:ACL 0

check ovn-nbctl --log --name=allow_acl acl-add pg1 to-lport 100 'outport == @pg1 && ip4' allow

check ovn-nbctl --wait=hv sync

clear_log
test_ping

# The allow ACL should match on the request and reply traffic, resulting in 2 logs.
check_acl_log_count 2

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=2 \
    --name=allow_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:02 \
    --dl_dst=00:00:00:00:00:01 \
    --nw_src=10.0.0.2 \
    --nw_dst=10.0.0.1 \
    --icmp_type=0 \
    --icmp_code=0

# Now add a higher-priority stateful ACL that matches on the same
# parameters. Don't enable reply logging.
check ovn-nbctl --log --name=allow_related_acl acl-add pg1 to-lport 200 'outport == @pg1 && ip4' allow-related
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# Since reply logging is not enabled, the allow-related ACL should match on the
# request, but the reply will not be logged.
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# As a control, set a label on the allow-related ACL, but still don't enable
# reply traffic logging.
set_acl_options allow_related_acl label=1 options:log-related=false
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# This should have the same result as the previous ping
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# As another control, remove the label but enable reply logging.
set_acl_options allow_related_acl label=0 options:log-related=true
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# This should have the same result as the previous ping
check_acl_log_count 1

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

# This time, add a label and enable reply logging on the allow_related ACL.
set_acl_options allow_related_acl label=1 options:log-related=true
check ovn-nbctl --wait=hv sync

clear_log
test_ping

# Now we should have the request and reply logged.
check_acl_log_count 2

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=1 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:01 \
    --dl_dst=00:00:00:00:00:02 \
    --nw_src=10.0.0.1 \
    --nw_dst=10.0.0.2 \
    --icmp_type=8 \
    --icmp_code=0

check $PYTHON $srcdir/check_acl_log.py \
    --entry-num=2 \
    --name=allow_related_acl \
    --verdict=allow \
    --protocol=icmp \
    --dl_src=00:00:00:00:00:02 \
    --dl_dst=00:00:00:00:00:01 \
    --nw_src=10.0.0.2 \
    --nw_dst=10.0.0.1 \
    --icmp_type=0 \
    --icmp_code=0


OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([East-West traffic with gateway router if DNAT configured])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller
# Logical network:
# One LR - R1  has two switches: sw0 and sw1
#    sw0 -- R1 -- sw1
# Logical port 'sw01' in switch 'sw0'.
# Logical port 'sw11' in switch 'sw1'.
# nc server running in sw01
# nc client running on sw11

check ovn-nbctl lr-add R1
check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1

check ovn-nbctl lrp-add R1 rp-sw0 00:00:01:01:02:03 192.168.1.1/24
check ovn-nbctl lrp-add R1 rp-sw1 00:00:03:01:02:03 192.168.2.1/24
check ovn-nbctl set logical_router R1 options:chassis=hv1

check ovn-nbctl lsp-add sw0 sw0-rp -- set Logical_Switch_Port sw0-rp \
    type=router options:router-port=rp-sw0 \
    -- lsp-set-addresses sw0-rp router
check ovn-nbctl lsp-add sw1 sw1-rp -- set Logical_Switch_Port sw1-rp \
    type=router options:router-port=rp-sw1 \
    -- lsp-set-addresses sw1-rp router

ADD_NAMESPACES(sw01)
ADD_VETH(sw01, sw01, br-int, "192.168.1.2/24", "f0:00:00:01:02:03", \
       "192.168.1.1")
check ovn-nbctl lsp-add sw0 sw01 \
    -- lsp-set-addresses sw01 "f0:00:00:01:02:03 192.168.1.2"

ADD_NAMESPACES(sw11)
ADD_VETH(sw11, sw11, br-int, "192.168.2.2/24", "f0:00:00:02:02:03", \
       "192.168.2.1")
check ovn-nbctl lsp-add sw1 sw11 \
    -- lsp-set-addresses sw11 "f0:00:00:02:02:03 192.168.2.2"

NETNS_DAEMONIZE([sw01], [nc -k -l 8000], [nc-sw01.pid])

test_ping() {
    NS_CHECK_EXEC([$1],  [ping -q -c 1 $2 -w 2 | FORMAT_PING], \
[0], [dnl
1 packets transmitted, 1 received, 0% packet loss, time 0ms
])
}

# Only SNAT
check ovn-nbctl --wait=hv lr-nat-add R1 snat 172.16.1.21 192.168.2.0/24

echo "foo" > foo
NS_CHECK_EXEC([sw11], [nc 192.168.1.2 8000 -z], [0], [ignore], [ignore])
test_ping sw11 192.168.1.2

# Ensure nat has been hit
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep -v "n_packets=0" | grep 'nat(src=172.16.1.21)'])
# Ensure conntrack entry is present
OVS_WAIT_FOR_OUTPUT([
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>
tcp,orig=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# SNAT and DNAT. using Logical IP
ovn-nbctl --wait=hv lr-nat-add R1 dnat_and_snat 172.16.1.2 192.168.1.2
NS_CHECK_EXEC([sw11], [nc 192.168.1.2 8000 -z], [0], [ignore], [ignore])
test_ping sw11 192.168.1.2

# Ensure conntrack entry is present
OVS_WAIT_FOR_OUTPUT([
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=192.168.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>
tcp,orig=(src=192.168.2.2,dst=192.168.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

# SNAT and DNAT. using floating IP
NS_CHECK_EXEC([sw11], [nc 172.16.1.2 8000 -z], [0], [ignore], [ignore])
test_ping sw11 172.16.1.2

# Ensure conntrack entry is present
OVS_WAIT_FOR_OUTPUT([
    ovs-appctl dpctl/dump-conntrack | FORMAT_CT(192.168.2.2) | \
      sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=192.168.2.2,dst=172.16.1.2,id=<cleared>,type=8,code=0),reply=(src=192.168.1.2,dst=192.168.2.2,id=<cleared>,type=0,code=0),zone=<cleared>
tcp,orig=(src=192.168.2.2,dst=172.16.1.2,sport=<cleared>,dport=<cleared>),reply=(src=192.168.1.2,dst=192.168.2.2,sport=<cleared>,dport=<cleared>),zone=<cleared>,protoinfo=(state=<cleared>)
])

AT_CHECK([ovs-appctl dpctl/flush-conntrack])

OVS_APP_EXIT_AND_WAIT([ovn-controller])
as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Container ping parent port])
AT_KEYWORDS([container-parent-port])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-set-addresses sw0-p1 "00:54:00:00:00:03 10.0.0.3"

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1.2 sw0-p1 2
ovn-nbctl lsp-set-addresses sw0-p1.2 "00:54:00:00:00:04 10.0.0.4"

ADD_NAMESPACES(sw0-p1)
ADD_VETH(sw0-p1, sw0-p1, br-int, "10.0.0.3/24", "00:54:00:00:00:03", \
         "10.0.0.1")

NS_CHECK_EXEC([sw0-p1], [ip link add link sw0-p1 name sw0-p1.2 type vlan id 2], [0])
ADD_NAMESPACES(sw0-p1.2)
NS_CHECK_EXEC([sw0-p1], [ip link set sw0-p1.2 netns sw0-p1.2], [0])
NS_CHECK_EXEC([sw0-p1.2], [ip link set sw0-p1.2 address 00:54:00:00:00:04], [0])
NS_CHECK_EXEC([sw0-p1.2], [ip link set sw0-p1.2 up], [0])
NS_CHECK_EXEC([sw0-p1.2], [ip addr add 10.0.0.4/24 dev sw0-p1.2], [0])
NS_CHECK_EXEC([sw0-p1.2], [ip route add default via 10.0.0.1 dev sw0-p1.2], [0])

NS_CHECK_EXEC([sw0-p1.2], [ping -q -c 3 -i 0.3 -w 2 10.0.0.3 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([SNAT in gateway router mode])
AT_KEYWORDS([ovnnat])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()

ADD_BR([br-int])
check ovs-ofctl add-flow br0 action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ip link set br0 up
check ovs-vsctl set open . external-ids:ovn-bridge-mappings=provider:br0

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 ls1p1
check ovn-nbctl lsp-set-addresses ls1p1 "00:00:00:01:01:01 192.168.1.1 2001::1"
check ovn-nbctl lsp-add ls1 ls1p2
check ovn-nbctl lsp-set-addresses ls1p2 "00:00:00:01:01:02 192.168.1.2 2001::2"

check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lr1-ls1 00:00:00:00:00:01 192.168.1.254/24 2001::a/64
check ovn-nbctl lsp-add ls1 ls1-lr1
check ovn-nbctl lsp-set-addresses ls1-lr1 "00:00:00:00:00:01 192.168.1.254 2001::a"
check ovn-nbctl lsp-set-type ls1-lr1 router
check ovn-nbctl lsp-set-options ls1-lr1 router-port=lr1-ls1

check ovn-nbctl set logical_router lr1 options:chassis=hv1

check ovn-nbctl lrp-add lr1 lr1-pub 00:00:00:00:0f:01 172.16.1.254/24 1711::a/64
check ovn-nbctl ls-add pub
check ovn-nbctl lsp-add pub pub-lr1
check ovn-nbctl lsp-set-type pub-lr1 router
check ovn-nbctl lsp-set-options pub-lr1 router-port=lr1-pub
check ovn-nbctl lsp-set-addresses pub-lr1 router

check ovn-nbctl lsp-add pub ln -- lsp-set-options ln network_name=provider
check ovn-nbctl lsp-set-type ln localnet
check ovn-nbctl lsp-set-addresses ln unknown

check ovn-nbctl lr-nat-add lr1 snat 172.16.1.10 192.168.1.0/24
check ovn-nbctl lr-nat-add lr1 snat 1711::10 2001::/64

NS_ADD_INT(ls1p1, ls1p1, br-int, "192.168.1.1/24", "00:00:00:01:01:01", "2001::1/64", "192.168.1.254", "2001::a" )
NS_ADD_INT(ls1p2, ls1p2, br-int, "192.168.1.2/24", "00:00:00:01:01:02", "2001::2/64", "192.168.1.254", "2001::a" )

ADD_NAMESPACES(ext1)
ADD_INT(ext1, ext1, br0, 172.16.1.1/24, 1711::1/64)
check ovn-nbctl --wait=hv sync
wait_for_ports_up
OVS_WAIT_UNTIL([test "$(ip netns exec ls1p1 ip a | grep 2001::1 | grep tentative)" = ""])
OVS_WAIT_UNTIL([test "$(ip netns exec ls1p2 ip a | grep 2002::1 | grep tentative)" = ""])

NS_CHECK_EXEC([ls1p1], [ping -q -c 3 -i 0.3 -w 2  172.16.1.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

NS_CHECK_EXEC([ls1p1], [ping6 -v -q -c 3 -i 0.3 -w 2 1711::1  | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])
as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/removing policing failed: No such device/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([mcast flow count])
AT_KEYWORDS([ovnigmp IP-multicast])
AT_SKIP_IF([test $HAVE_TCPDUMP = no])
ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls vm1
check ovn-nbctl lsp-set-addresses vm1 00:00:00:00:00:01
check ovn-nbctl lsp-add ls vm2
check ovn-nbctl lsp-set-addresses vm2 00:00:00:00:00:02
check ovn-nbctl lsp-add ls vm3
check ovn-nbctl lsp-set-addresses vm3 00:00:00:00:00:03

check ovn-nbctl set logical_switch ls other_config:mcast_querier=false other_config:mcast_snoop=true other_config:mcast_query_interval=30 other_config:mcast_eth_src=00:00:00:00:00:05 other_config:mcast_ip4_src=42.42.42.5 other_config:mcast_ip6_src=fe80::1 other_config:mcast_idle_timeout=3000
ovn-sbctl list ip_multicast

wait_igmp_flows_installed()
{
    OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int table=31 | \
    grep 'priority=90' | grep "nw_dst=$1"])
}

ADD_NAMESPACES(vm1)
ADD_INT([vm1], [vm1], [br-int], [42.42.42.1/24])
NS_CHECK_EXEC([vm1], [ip link set vm1 address 00:00:00:00:00:01], [0])
NS_CHECK_EXEC([vm1], [ip route add default via 42.42.42.5], [0])
check ovs-vsctl set Interface vm1 external_ids:iface-id=vm1

ADD_NAMESPACES(vm2)
ADD_INT([vm2], [vm2], [br-int], [42.42.42.2/24])
NS_CHECK_EXEC([vm2], [ip link set vm2 address 00:00:00:00:00:02], [0])
NS_CHECK_EXEC([vm2], [ip link set lo up], [0])
check ovs-vsctl set Interface vm2 external_ids:iface-id=vm2

ADD_NAMESPACES(vm3)
NETNS_DAEMONIZE([vm3], [tcpdump -n -i any -nnleX > vm3.pcap 2>/dev/null], [tcpdump3.pid])

ADD_INT([vm3], [vm3], [br-int], [42.42.42.3/24])
NS_CHECK_EXEC([vm3], [ip link set vm3 address 00:00:00:00:00:03], [0])
NS_CHECK_EXEC([vm3], [ip link set lo up], [0])
NS_CHECK_EXEC([vm3], [ip route add default via 42.42.42.5], [0])
check ovs-vsctl set Interface vm3 external_ids:iface-id=vm3

NS_CHECK_EXEC([vm2], [sysctl -w net.ipv4.igmp_max_memberships=100], [ignore], [ignore])
NS_CHECK_EXEC([vm3], [sysctl -w net.ipv4.igmp_max_memberships=100], [ignore], [ignore])
wait_for_ports_up

NS_CHECK_EXEC([vm3], [ip addr add 228.0.0.1 dev vm3 autojoin], [0])
wait_igmp_flows_installed 228.0.0.1

NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 228.0.0.1], [ignore], [ignore])

OVS_WAIT_UNTIL([
    requests=`grep "ICMP echo request" -c vm3.pcap`
    test "${requests}" -ge "3"
])

NETNS_DAEMONIZE([vm2], [tcpdump -n -i any -nnleX > vm2.pcap 2>/dev/null], [tcpdump2.pid])

for i in `seq 1 40`;do
    NS_CHECK_EXEC([vm2], [ip addr add 228.1.$i.1 dev vm2 autojoin &], [0])
    NS_CHECK_EXEC([vm3], [ip addr add 229.1.$i.1 dev vm3 autojoin &], [0])
    # Do not go too fast. If going fast, there is a higher chance of sb being busy, causing full recompute (engine has not run)
    # In this test, we do not want too many recomputes as they might hide I+I related errors
    sleep 0.2
done

for i in `seq 1 40`;do
    wait_igmp_flows_installed 228.1.$i.1
    wait_igmp_flows_installed 229.1.$i.1
done
ovn-sbctl list multicast_group

NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 228.1.1.1], [ignore], [ignore])

OVS_WAIT_UNTIL([
    requests=`grep "ICMP echo request" -c vm2.pcap`
    test "${requests}" -ge "3"
])

# The test could succeed thanks to a lucky northd recompute...after hitting too any flows
# Double check we never hit error condition
AT_CHECK([grep -qE 'Too many active mcast flows' northd/ovn-northd.log], [1])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d
/removing policing failed: No such device/d"])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([DVR ping router port])
AT_KEYWORDS([dvr])

ovn_start

OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])
ADD_BR([br-ext])

check ovs-ofctl add-flow br-ext action=normal
# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# Start ovn-controller
start_daemon ovn-controller

check ovs-vsctl set open . external_ids:ovn-bridge-mappings=phys:br-ext
check ovs-vsctl set open . external-ids:ovn-chassis-mac-mappings="phys:ee:00:00:00:00:10"


check ovn-nbctl ls-add internal

check ovn-nbctl lsp-add internal ln_internal "" 100
check ovn-nbctl lsp-set-addresses ln_internal unknown
check ovn-nbctl lsp-set-type ln_internal localnet
check ovn-nbctl lsp-set-options ln_internal network_name=phys

check ovn-nbctl lsp-add internal internal-gw
check ovn-nbctl lsp-set-type internal-gw router
check ovn-nbctl lsp-set-addresses internal-gw router
check ovn-nbctl lsp-set-options internal-gw router-port=gw-internal

check ovn-nbctl lsp-add internal vif0
# Set address as unknown so that LRP has to generate ARP request
check ovn-nbctl lsp-set-addresses vif0 unknown

check ovn-nbctl lr-add gw
check ovn-nbctl lrp-add gw gw-internal 00:00:00:00:20:00 192.168.20.1/24

ADD_NAMESPACES(vif0)
ADD_VETH(vif0, vif0, br-int, "192.168.20.10/24", "00:00:00:00:20:10", "192.168.20.1")

check ovn-nbctl --wait=sb sync
check ovn-nbctl --wait=hv sync

NS_CHECK_EXEC([vif0], [ping -q -c 3 -i 0.3 -w 1 192.168.20.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([SNAT in separate zone from DNAT])

CHECK_CONNTRACK()
CHECK_CONNTRACK_NAT()
ovn_start
OVS_TRAFFIC_VSWITCHD_START()
ADD_BR([br-int])

# Set external-ids in br-int needed for ovn-controller
ovs-vsctl \
        -- set Open_vSwitch . external-ids:system-id=hv1 \
        -- set Open_vSwitch . external-ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock \
        -- set Open_vSwitch . external-ids:ovn-encap-type=geneve \
        -- set Open_vSwitch . external-ids:ovn-encap-ip=169.0.0.1 \
        -- set bridge br-int fail-mode=secure other-config:disable-in-band=true

# The goal of this test is to ensure that when traffic is first DNATted
# (by way of a load balancer), and then SNATted, the SNAT happens in a
# separate conntrack zone from the DNAT.

start_daemon ovn-controller

check ovn-nbctl ls-add public

check ovn-nbctl lr-add r1
check ovn-nbctl lrp-add r1 r1_public 00:de:ad:ff:00:01 172.16.0.1/16
check ovn-nbctl lrp-add r1 r1_s1 00:de:ad:fe:00:01 173.0.1.1/24
check ovn-nbctl lrp-set-gateway-chassis r1_public hv1

check ovn-nbctl lb-add r1_lb 30.0.0.1 172.16.0.102
check ovn-nbctl lr-lb-add r1 r1_lb

check ovn-nbctl ls-add s1
check ovn-nbctl lsp-add s1 s1_r1
check ovn-nbctl lsp-set-type s1_r1 router
check ovn-nbctl lsp-set-addresses s1_r1 router
check ovn-nbctl lsp-set-options s1_r1 router-port=r1_s1

check ovn-nbctl lsp-add s1 vm1
check ovn-nbctl lsp-set-addresses vm1 "00:de:ad:01:00:01 173.0.1.2"

check ovn-nbctl lsp-add public public_r1
check ovn-nbctl lsp-set-type public_r1 router
check ovn-nbctl lsp-set-addresses public_r1 router
check ovn-nbctl lsp-set-options public_r1 router-port=r1_public nat-addresses=router

check ovn-nbctl lr-add r2
check ovn-nbctl lrp-add r2 r2_public 00:de:ad:ff:00:02 172.16.0.2/16
check ovn-nbctl lrp-add r2 r2_s2 00:de:ad:fe:00:02 173.0.2.1/24
check ovn-nbctl lr-nat-add r2 dnat_and_snat 172.16.0.102 173.0.2.2
check ovn-nbctl lrp-set-gateway-chassis r2_public hv1

check ovn-nbctl ls-add s2
check ovn-nbctl lsp-add s2 s2_r2
check ovn-nbctl lsp-set-type s2_r2 router
check ovn-nbctl lsp-set-addresses s2_r2 router
check ovn-nbctl lsp-set-options s2_r2 router-port=r2_s2

check ovn-nbctl lsp-add s2 vm2
check ovn-nbctl lsp-set-addresses vm2 "00:de:ad:01:00:02 173.0.2.2"

check ovn-nbctl lsp-add public public_r2
check ovn-nbctl lsp-set-type public_r2 router
check ovn-nbctl lsp-set-addresses public_r2 router
check ovn-nbctl lsp-set-options public_r2 router-port=r2_public nat-addresses=router

ADD_NAMESPACES(vm1)
ADD_VETH(vm1, vm1, br-int, "173.0.1.2/24", "00:de:ad:01:00:01", \
         "173.0.1.1")
ADD_NAMESPACES(vm2)
ADD_VETH(vm2, vm2, br-int, "173.0.2.2/24", "00:de:ad:01:00:02", \
         "173.0.2.1")

check ovn-nbctl lr-nat-add r1 dnat_and_snat 172.16.0.101 173.0.1.2 vm1 00:00:00:01:02:03
check ovn-nbctl --wait=hv sync

# Next, make sure that a ping works as expected
NS_CHECK_EXEC([vm1], [ping -q -c 3 -i 0.3 -w 2 30.0.0.1 | FORMAT_PING], \
[0], [dnl
3 packets transmitted, 3 received, 0% packet loss, time 0ms
])

# Finally, make sure that conntrack shows two separate zones being used for
# DNAT and SNAT
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(30.0.0.1) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=173.0.1.2,dst=30.0.0.1,id=<cleared>,type=8,code=0),reply=(src=172.16.0.102,dst=173.0.1.2,id=<cleared>,type=0,code=0),zone=<cleared>,mark=2
])

# The final two entries appear identical here. That is because FORMAT_CT
# scrubs the zone numbers. In actuality, the zone numbers are different,
# which is why there are two entries.
AT_CHECK([ovs-appctl dpctl/dump-conntrack | FORMAT_CT(172.16.0.102) | \
sed -e 's/zone=[[0-9]]*/zone=<cleared>/'], [0], [dnl
icmp,orig=(src=172.16.0.101,dst=172.16.0.102,id=<cleared>,type=8,code=0),reply=(src=173.0.2.2,dst=172.16.0.101,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=173.0.1.2,dst=172.16.0.102,id=<cleared>,type=8,code=0),reply=(src=172.16.0.102,dst=172.16.0.101,id=<cleared>,type=0,code=0),zone=<cleared>
icmp,orig=(src=173.0.1.2,dst=172.16.0.102,id=<cleared>,type=8,code=0),reply=(src=172.16.0.102,dst=172.16.0.101,id=<cleared>,type=0,code=0),zone=<cleared>
])

OVS_APP_EXIT_AND_WAIT([ovn-controller])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as
OVS_TRAFFIC_VSWITCHD_STOP(["/failed to query port patch-.*/d
/connection dropped.*/d"])
AT_CLEANUP
])
