AT_BANNER([OVN northd])
AT_SETUP([ovn -- check from NBDB to SBDB])
ovn_start

ovn-nbctl create Logical_Router name=R1
ovn-sbctl chassis-add gw1 geneve 127.0.0.1
ovn-sbctl chassis-add gw2 geneve 1.2.4.8

# Connect alice to R1 as distributed router gateway port on hv2
ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24

ovn-nbctl --wait=sb \
    --id=@gc0 create Gateway_Chassis name=alice_gw1 \
                                     chassis_name=gw1 \
                                     priority=20 -- \
    --id=@gc1 create Gateway_Chassis name=alice_gw2 \
                                     chassis_name=gw2 \
                                     priority=10 -- \
    set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]'

nb_gwc1_uuid=`ovn-nbctl --bare --columns _uuid find Gateway_Chassis name="alice_gw1"`

# With the new ha_chassis_group table added, there should be no rows in
# gateway_chassis table in SB DB.
check_row_count Gateway_Chassis 0

# There should be one ha_chassis_group with the name "alice"
check_row_count HA_Chassis_Group 1 name=alice
ha_chgrp_uuid=$(fetch_column HA_Chassis_Group _uuid name=alice)
check_row_count Port_Binding 1 logical_port=cr-alice ha_chassis_group=$ha_chgrp_uuid

ha_ch=$(fetch_column HA_Chassis_Group ha_chassis name=alice)
check_column "$ha_ch" HA_Chassis _uuid

# Delete chassis - gw2 in SB DB.
# ovn-northd should not recreate ha_chassis rows
# repeatedly when gw2 is deleted.
ovn-sbctl chassis-del gw2

ha_ch_list=$(fetch_column HA_Chassis _uuid)
check_column "$ha_ch_list" HA_Chassis _uuid

# Add back the gw2 chassis
ovn-sbctl chassis-add gw2 geneve 1.2.4.8

# delete the 2nd Gateway_Chassis on NBDB for alice port
check_column '' Port_Binding gateway_chassis logical_port=cr-alice

ha_ch=$(fetch_column HA_Chassis_Group ha_chassis)
check_column "$ha_ch" HA_Chassis _uuid

# delete the 2nd Gateway_Chassis on NBDB for alice port
ovn-nbctl --wait=sb set Logical_Router_Port alice gateway_chassis=${nb_gwc1_uuid}

# There should be only 1 row in ha_chassis SB DB table.
check_row_count HA_Chassis 1
check_row_count Gateway_Chassis 0

# delete all the gateway_chassis on NBDB for alice port
ovn-nbctl --wait=sb clear Logical_Router_Port alice gateway_chassis

# expect that the ha_chassis doesn't exist anymore
check_row_count HA_Chassis 0
check_row_count Gateway_Chassis 0
check_row_count Ha_Chassis_Group 0

AT_CLEANUP

AT_SETUP([ovn -- check up state of VIF LSP])
ovn_start

ovn-nbctl ls-add S1
ovn-nbctl --wait=sb lsp-add S1 S1-vm1
wait_row_count nb:Logical_Switch_Port 1 name=S1-vm1 'up!=true'

ovn-sbctl chassis-add hv1 geneve 127.0.0.1
ovn-sbctl lsp-bind S1-vm1 hv1
wait_row_count nb:Logical_Switch_Port 1 name=S1-vm1 'up=true'

AT_CLEANUP

AT_SETUP([ovn -- check up state of router LSP linked to a distributed LR])
ovn_start

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01
ovn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1
AT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])

AT_CLEANUP

AT_SETUP([ovn -- check up state of router LSP linked to a gateway LR])
ovn_start

ovn-sbctl chassis-add gw1 geneve 127.0.0.1

ovn-nbctl create Logical_Router name=R1 options:chassis=gw1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01
ovn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1

ovn-sbctl lsp-bind S1-R1 gw1
AT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])

AT_CLEANUP

AT_SETUP([ovn -- check up state of router LSP linked to an LRP with set Gateway Chassis])
ovn_start

ovn-sbctl chassis-add gw1 geneve 127.0.0.1

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24
ovn-nbctl lrp-set-gateway-chassis R1-S1 gw1

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 router
ovn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1
AT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])

AT_CLEANUP

AT_SETUP([ovn -- check IPv6 RA config propagation to SBDB])
ovn_start

ovn-nbctl lr-add ro
ovn-nbctl lrp-add ro ro-sw 00:00:00:00:00:01 aef0:0:0:0:0:0:0:1/64
ovn-nbctl ls-add sw
ovn-nbctl lsp-add sw sw-ro
ovn-nbctl lsp-set-type sw-ro router
ovn-nbctl lsp-set-options sw-ro router-port=ro-sw
ovn-nbctl lsp-set-addresses sw-ro 00:00:00:00:00:01
ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:send_periodic=true
ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=slaac
ovn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:mtu=1280

uuid=$(ovn-sbctl --columns=_uuid --bare find Port_Binding logical_port=ro-sw)

AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_send_periodic],
[0], ["true"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_address_mode],
[0], [slaac
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[0], ["600"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[0], ["200"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_mtu],
[0], ["1280"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_eth],
[0], ["00:00:00:00:00:01"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_addr],
[0], ["fe80::200:ff:fe00:1"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_prefixes],
[0], ["aef0::/64"
])

ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=300
ovn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=600

AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[0], ["300"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[0], ["225"
])

ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=300
ovn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=250

AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[0], ["300"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[0], ["225"
])

ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=0
ovn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=0

AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[0], ["4"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[0], ["3"
])

ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=3600
ovn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=2400

AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[0], ["1800"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[0], ["1350"
])

ovn-nbctl --wait=sb set Logical_Router_port ro-sw ipv6_ra_configs:send_periodic=false

AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_send_periodic],
[1], [], [ovn-sbctl: no key "ipv6_ra_send_periodic" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[1], [], [ovn-sbctl: no key "ipv6_ra_max_interval" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[1], [], [ovn-sbctl: no key "ipv6_ra_min_interval" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_mtu],
[1], [], [ovn-sbctl: no key "ipv6_ra_mtu" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_address_mode],
[1], [], [ovn-sbctl: no key "ipv6_ra_address_mode" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_eth],
[1], [], [ovn-sbctl: no key "ipv6_ra_src_eth" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_addr],
[1], [], [ovn-sbctl: no key "ipv6_ra_src_addr" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_prefixes],
[1], [], [ovn-sbctl: no key "ipv6_ra_prefixes" in Port_Binding record "${uuid}" column options
])

AT_CLEANUP

AT_SETUP([ovn -- test unixctl])
ovn_init_db ovn-sb; ovn-sbctl init
ovn_init_db ovn-nb; ovn-nbctl init

# test unixctl option
mkdir "$ovs_base"/northd
as northd start_daemon ovn-northd --unixctl="$ovs_base"/northd/ovn-northd.ctl --ovnnb-db=unix:"$ovs_base"/ovn-nb/ovn-nb.sock --ovnsb-db=unix:"$ovs_base"/ovn-sb/ovn-sb.sock
ovn-nbctl ls-add sw
ovn-nbctl --wait=sb lsp-add sw p1
# northd created with unixctl option successfully created port_binding entry
check_row_count Port_Binding 1 logical_port=p1
AT_CHECK([ovn-nbctl --wait=sb lsp-del p1])

# ovs-appctl exit with unixctl option
OVS_APP_EXIT_AND_WAIT_BY_TARGET(["$ovs_base"/northd/ovn-northd.ctl], ["$ovs_base"/northd/ovn-northd.pid])

# Check no port_binding entry for new port as ovn-northd is not running
#
# 142 is 128+14, the exit status that the shell reports when a
# process exits due to SIGARLM (signal 14).
ovn-nbctl lsp-add sw p2
AT_CHECK([ovn-nbctl --timeout=10 --wait=sb sync], [142], [], [ignore])
check_row_count Port_Binding 0 logical_port=p2

# test default unixctl path
as northd start_daemon ovn-northd --ovnnb-db=unix:"$ovs_base"/ovn-nb/ovn-nb.sock --ovnsb-db=unix:"$ovs_base"/ovn-sb/ovn-sb.sock
ovn-nbctl --wait=sb lsp-add sw p3
# northd created with default unixctl path successfully created port_binding entry
check_row_count Port_Binding 1 logical_port=p3

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])
as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])
as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

AT_CLEANUP

AT_SETUP([ovn -- check HA_Chassis_Group propagation from NBDB to SBDB])
ovn_start

check ovn-nbctl --wait=sb ha-chassis-group-add hagrp1

# ovn-northd should not create HA chassis group and HA chassis rows
# unless the HA chassis group in OVN NB DB is associated to
# a logical router port or logical port of type external.
check_row_count HA_Chassis_Group 0 name=hagrp1

check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 30
check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 20
check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch3 10

# There should be no HA_Chassis rows in SB DB.
check_row_count HA_Chassis 0

# Add chassis ch1.
check ovn-sbctl chassis-add ch1 geneve 127.0.0.2

wait_row_count Chassis 1 name=ch1

# There should be no HA_Chassis rows
check_row_count HA_Chassis 0

# Create a logical router port and attach ha chassis group.
check ovn-nbctl lr-add lr0
check ovn-nbctl --wait=sb lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24

hagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp1`
echo "hagrp1_uuid=$hagrp1_uuid"
check ovn-nbctl --wait=sb set logical_router_port lr0-public ha_chassis_group=$hagrp1_uuid

wait_row_count HA_Chassis_Group 1 name=hagrp1

check_row_count HA_Chassis 3

# ovn-northd has a weird history regarding HA_Chassis and missing
# Chassis records, see commit f879850b5f2c ("ovn-northd: Fix the
# HA_Chassis sync issue in OVN SB DB").
#
# Make sure that ovn-northd doesn't recreate the ha_chassis
# records if the chassis record is missing in SB DB.
ha_ch_list=$(fetch_column HA_Chassis _uuid)
check_column "$ha_ch_list" HA_Chassis _uuid

# 2 HA chassis should be created with 'chassis' column empty because
# we have not added hv1 and hv2 chassis to the SB DB.
check_row_count HA_Chassis 2 'chassis=[[]]'

# We should have 1 ha chassis with 'chassis' column set for hv1
check_row_count HA_Chassis 1 'chassis!=[[]]'

# Create another logical router port and associate to the same ha_chasis_group
check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lr1-public 00:00:20:20:12:14 182.168.0.100/24

check ovn-nbctl set logical_router_port lr1-public ha_chassis_group=$hagrp1_uuid

# We should still have 1 HA chassis group and 3 HA chassis in SB DB.
wait_row_count HA_Chassis_Group 1 name=hagrp1
check_row_count HA_Chassis 3

# Change the priority of ch1 - ha chassis in NB DB. It should get
# reflected in SB DB.
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 100

wait_row_count HA_Chassis 1 priority=100

# Delete ch1 HA chassis in NB DB.
ovn-nbctl --wait=sb ha-chassis-group-remove-chassis hagrp1 ch1

wait_row_count HA_Chassis 2

# Add back the ha chassis
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 40
wait_row_count HA_Chassis 3

# Delete lr0-public. We should still have 1 HA chassis group and
# 3 HA chassis in SB DB.
ovn-nbctl --wait=sb lrp-del lr0-public

wait_row_count HA_Chassis_Group 1 name=hagrp1
wait_row_count HA_Chassis 3

# Delete lr1-public. There should be no HA chassis group in SB DB.
ovn-nbctl --wait=sb lrp-del lr1-public

wait_row_count HA_Chassis_Group 0 name=hagrp1
wait_row_count HA_Chassis 0

# Add lr0-public again
ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24
ovn-nbctl set logical_router_port lr0-public ha_chassis_group=$hagrp1_uuid

wait_row_count HA_Chassis_Group 1 name=hagrp1
wait_row_count HA_Chassis 3

# Create a Gateway chassis. ovn-northd should ignore this.
check ovn-nbctl --wait=sb lrp-set-gateway-chassis lr0-public ch1 20

# There should be only 1 HA chassis group in SB DB with the
# name hagrp1.
wait_row_count HA_Chassis_Group 1
wait_row_count HA_Chassis_Group 1 name=hagrp1
wait_row_count HA_Chassis 3

# Now delete HA chassis group. ovn-northd should create HA chassis group
# with the Gateway chassis name
ovn-nbctl clear logical_router_port lr0-public ha_chassis_group
ovn-nbctl ha-chassis-group-del hagrp1

wait_row_count HA_Chassis_Group 0 name=hagrp1
wait_row_count HA_Chassis_Group 1 name=lr0-public
wait_row_count HA_Chassis 1

ovn-nbctl lrp-set-gateway-chassis lr0-public ch2 10

wait_row_count HA_Chassis_Group 1 name=lr0-public

ovn-sbctl --bare --columns _uuid find ha_chassis
wait_row_count HA_Chassis 2

# Test if 'ref_chassis' column is properly set or not in
# SB DB ha_chassis_group.
check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1

check ovn-sbctl chassis-add ch2 geneve 127.0.0.3
check ovn-sbctl chassis-add ch3 geneve 127.0.0.4
check ovn-sbctl chassis-add comp1 geneve 127.0.0.5
check ovn-sbctl chassis-add comp2 geneve 127.0.0.6

check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:20:20:12:14 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl --wait=sb lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-sbctl lsp-bind sw0-p1 comp1
wait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 up=true

comp1_ch_uuid=$(fetch_column Chassis _uuid name=comp1)
comp2_ch_uuid=$(fetch_column Chassis _uuid name=comp2)
ch2_ch_uuid=$comp1_ch_uuid

# Check ref_chassis.
echo "comp1_ch_uuid = $comp1_ch_uuid"
wait_column "$comp1_ch_uuid" HA_Chassis_Group ref_chassis

# unbind sw0-p1
ovn-sbctl lsp-unbind sw0-p1
wait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 up=false
wait_column "" HA_Chassis_Group ref_chassis

# Bind sw0-p1 in comp2
ovn-sbctl lsp-bind sw0-p1 comp2
wait_column "$comp2_ch_uuid" HA_Chassis_Group ref_chassis

ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lr-add lr1
ovn-nbctl lrp-add lr1 lr1-sw1 00:00:20:20:12:15 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr1
ovn-nbctl lsp-set-type sw1-lr1 router
ovn-nbctl lsp-set-addresses sw1-lr1 router
check ovn-nbctl --wait=sb lsp-set-options sw1-lr1 router-port=lr1-sw1

# Bind sw1-p1 in comp1.
check ovn-sbctl lsp-bind sw1-p1 comp1
# Wait until sw1-p1 is up
wait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 up=true

# sw1-p1 is not connected to lr0. So comp1 should not be in 'ref_chassis'
wait_column "$comp2_ch_uuid" HA_Chassis_Group ref_chassis

# Now attach sw0 to lr1
check ovn-nbctl lrp-add lr1 lr1-sw0 00:00:20:20:12:16 10.0.0.10/24
check ovn-nbctl lsp-add sw0 sw0-lr1
check ovn-nbctl lsp-set-type sw0-lr1 router
check ovn-nbctl lsp-set-addresses sw0-lr1 router
check ovn-nbctl --wait=sb lsp-set-options sw0-lr1 router-port=lr1-sw0

# Both comp1 and comp2 should be in 'ref_chassis' as sw1 is indirectly
# connected to lr0
exp_ref_ch_list="$comp1_ch_uuid $comp2_ch_uuid"

wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis 

# Unind sw1-p1. comp2 should not be in the ref_chassis.
ovn-sbctl lsp-unbind sw1-p1
wait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 up=false
wait_column "$comp2_ch_uuid" HA_Chassis_Group ref_chassis

# Create sw2 and attach it to lr2
check ovn-nbctl ls-add sw2
check ovn-nbctl lsp-add sw2 sw2-p1
check ovn-nbctl lr-add lr2
check ovn-nbctl lrp-add lr2 lr2-sw2 00:00:20:20:12:17 30.0.0.1/24
check ovn-nbctl lsp-add sw2 sw2-lr2
check ovn-nbctl lsp-set-type sw2-lr2 router
check ovn-nbctl lsp-set-addresses sw2-lr2 router
check ovn-nbctl --wait=sb lsp-set-options sw2-lr2 router-port=lr2-sw2

# Bind sw2-p1 to comp1
check ovn-sbctl lsp-bind sw2-p1 comp1
# Wait until sw2-p1 is up
wait_row_count nb:Logical_Switch_Port 1 name=sw2-p1 up=true

# sw2-p1 is not connected to lr0. So comp1 should not be in 'ref_chassis'
wait_column "$comp2_ch_uuid" HA_Chassis_Group ref_chassis

# Now attach sw1 to lr2. With this sw2-p1 is indirectly connected to lr0.
check ovn-nbctl lrp-add lr2 lr2-sw1 00:00:20:20:12:18 20.0.0.10/24
check ovn-nbctl lsp-add sw1 sw1-lr2
check ovn-nbctl lsp-set-type sw1-lr2 router
check ovn-nbctl lsp-set-addresses sw1-lr2 router
check ovn-nbctl --wait=sb lsp-set-options sw1-lr2 router-port=lr2-sw1

# sw2-p1 is indirectly connected to lr0. So comp1 (and comp2) should be in
# 'ref_chassis'
wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# Create sw0-p2 and bind it to comp1
check ovn-nbctl --wait=sb lsp-add sw0 sw0-p2
ovn-sbctl lsp-bind sw0-p2 comp1
wait_row_count nb:Logical_Switch_Port 1 name=sw0-p2 up=true
wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# unbind sw0-p2
ovn-sbctl lsp-unbind sw0-p2
wait_row_count nb:Logical_Switch_Port 1 name=sw0-p2 up=false
wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# Delete lr1-sw0. comp1 should be deleted from ref_chassis as there is no link
# from sw1 and sw2 to lr0.
check ovn-nbctl lrp-del lr1-sw0

wait_column "$comp2_ch_uuid" HA_Chassis_Group ref_chassis

# Set redirect-chassis option to lr0-public. It should be ignored
# (because redirect-chassis is obsolete).
check ovn-nbctl set logical_router_port lr0-public options:redirect-chassis=ch1

wait_row_count HA_Chassis_Group 1
wait_row_count HA_Chassis_Group 1 name=lr0-public

wait_row_count HA_Chassis 2

# Delete the gateway chassis.
check ovn-nbctl clear logical_router_port lr0-public gateway_chassis

wait_row_count HA_Chassis_Group 0
check_row_count HA_Chassis 0

# Delete old sw0.
check ovn-nbctl --wait=sb ls-del sw0

# Create external logical ports and associate ha_chassis_group
check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-pext1
check ovn-nbctl lsp-add sw0 sw0-pext2
check ovn-nbctl lsp-add sw0 sw0-p1

check ovn-nbctl lsp-set-addresses sw0-pext1 "00:00:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-addresses sw0-pext2 "00:00:00:00:00:03 10.0.0.4"
check ovn-nbctl lsp-set-addresses sw0-p1 "00:00:00:00:00:03 10.0.0.5"

check ovn-nbctl --wait=sb ha-chassis-group-add hagrp1

check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 30
check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 20
check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch3 10

# ovn-northd should not create HA chassis group and HA chassis rows
# unless the HA chassis group in OVN NB DB is associated to
# a logical router port or logical port of type external.
wait_row_count HA_Chassis_Group 0
check_row_count HA_Chassis 0

hagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group \
name=hagrp1`

# The type of the lsp - sw0-pext1 is still not set to external.
# So ha_chassis_group should be ignored.
ovn-nbctl set logical_switch_port sw0-pext1 ha_chassis_group=$hagrp1_uuid

wait_row_count HA_Chassis_Group 0 name=hagrp1
check_row_count HA_Chassis 0

# Set the type of sw0-pext1 to external
ovn-nbctl lsp-set-type sw0-pext1 external

wait_row_count HA_Chassis_Group 1 name=hagrp1
check_row_count HA_Chassis 3

sb_hagrp1_uuid=`ovn-sbctl --bare --columns _uuid find ha_chassis_group \
name=hagrp1`

check_row_count Port_Binding 1 logical_port=sw0-pext1 ha_chassis_group=$sb_hagrp1_uuid

# Set the type of sw0-pext2 to external and associate ha_chassis_group
ovn-nbctl lsp-set-type sw0-pext2 external
ovn-nbctl set logical_switch_port sw0-pext2 ha_chassis_group=$hagrp1_uuid

wait_row_count HA_Chassis_Group 1 name=hagrp1
check_row_count HA_Chassis 3
check_row_count Port_Binding 1 logical_port=sw0-pext1 ha_chassis_group=$sb_hagrp1_uuid
wait_row_count Port_Binding 1 logical_port=sw0-pext2 ha_chassis_group=$sb_hagrp1_uuid

# sw0-p1 is a normal port. So ha_chassis_group should not be set
# in port_binding.
ovn-nbctl --wait=sb set logical_switch_port sw0-p1 \
ha_chassis_group=$hagrp1_uuid

wait_row_count Port_Binding 0 logical_port=sw0-p1 'chassis!=[[]]'

# Clear ha_chassis_group for sw0-pext1
check ovn-nbctl --wait=sb clear logical_switch_port sw0-pext1 ha_chassis_group

wait_row_count Port_Binding 0 logical_port=sw0-pext1 'chassis!=[[]]'

wait_row_count HA_Chassis_Group 1 name=hagrp1
wait_row_count HA_Chassis 3

# Clear ha_chassis_group for sw0-pext2
ovn-nbctl --wait=sb clear logical_switch_port sw0-pext2 ha_chassis_group

wait_row_count Port_Binding 0 logical_port=sw0-pext2 'chassis!=[[]]'
wait_row_count HA_Chassis_Group 0
check_row_count HA_Chassis 0

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])
as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])
as northd
OVS_APP_EXIT_AND_WAIT([ovn-northd])

AT_CLEANUP

AT_SETUP([ovn -- ovn-northd pause and resume])
ovn_start

AT_CHECK([test xfalse = x`as northd ovn-appctl -t ovn-northd is-paused`])
AT_CHECK([as northd ovn-appctl -t ovn-northd status], [0], [Status: active
])
AT_CHECK([test xfalse = x`as northd-backup ovn-appctl -t ovn-northd \
is-paused`])
AT_CHECK([as northd-backup ovn-appctl -t ovn-northd status], [0],
[Status: standby
])

ovn-nbctl ls-add sw0

OVS_WAIT_UNTIL([
    ovn-sbctl lflow-list sw0
    test 0 = $?])

ovn-nbctl ls-del sw0
OVS_WAIT_UNTIL([
    ovn-sbctl lflow-list sw0
    test 1 = $?])

# Now pause the ovn-northd
as northd ovs-appctl -t ovn-northd pause
as northd-backup ovs-appctl -t ovn-northd pause
AT_CHECK([test xtrue = x`as northd ovn-appctl -t ovn-northd is-paused`])
AT_CHECK([as northd ovn-appctl -t ovn-northd status], [0], [Status: paused
])
AT_CHECK([test xtrue = x`as northd-backup ovn-appctl -t ovn-northd is-paused`])
AT_CHECK([as northd-backup ovn-appctl -t ovn-northd status], [0],
[Status: paused
])

ovn-nbctl ls-add sw0

# There should be no logical flows for sw0 datapath.
OVS_WAIT_UNTIL([
    ovn-sbctl lflow-list sw0
    test 1 = $?])

# Now resume ovn-northd
as northd ovs-appctl -t ovn-northd resume
AT_CHECK([test xfalse = x`as northd ovn-appctl -t ovn-northd is-paused`])
OVS_WAIT_UNTIL([as northd ovn-appctl -t ovn-northd status], [0],
[Status: active
])

as northd-backup ovs-appctl -t ovn-northd resume
AT_CHECK([test xfalse = x`as northd-backup ovn-appctl -t ovn-northd \
is-paused`])
AT_CHECK([as northd-backup ovn-appctl -t ovn-northd status], [0],
[Status: standby
])

OVS_WAIT_UNTIL([
    ovn-sbctl lflow-list sw0
    test 0 = $?])

AT_CLEANUP

AT_SETUP([ovn -- check Redirect Chassis propagation from NB to SB])
ovn_start

ovn-sbctl chassis-add gw1 geneve 127.0.0.1

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 router
ovn-nbctl lsp-set-options S1-R1 router-port=R1-S1

check ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1

ovn-nbctl lrp-set-redirect-type R1-S1 bridged
wait_row_count Port_Binding 1 logical_port=cr-R1-S1 options:redirect-type=bridged

ovn-nbctl lrp-set-redirect-type R1-S1 overlay
wait_row_count Port_Binding 1 logical_port=cr-R1-S1 options:redirect-type=overlay
AT_CLEANUP

AT_SETUP([ovn -- check stateless dnat_and_snat rule])
ovn_start

ovn-sbctl chassis-add gw1 geneve 127.0.0.1

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 router
ovn-nbctl lsp-set-options S1-R1 router-port=R1-S1

check ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1

check_flow_matches() {
    local regex=$1 count=$2
    local found=$(grep -c "$1" r1-flows)
    echo "checking for $count flows matching $regex... found $found"
    AT_FAIL_IF([test $found != $count])
}

check_flow_match_sets() {
    ovn-sbctl dump-flows R1 > r1-flows
    AT_CAPTURE_FILE([r1-flows])

    for regex in lr_in_unsnat ct_snat ct_dnat ip4.dst= ip4.src= ip6.dst= ip6.src=; do
        check_flow_matches $regex $1
        shift
    done
}

echo
echo "IPv4: stateful"
ovn-nbctl --wait=sb lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11
check_flow_match_sets 2 2 2 0 0 0 0
ovn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1

echo
echo "IPv4: stateless"
ovn-nbctl --wait=sb --stateless lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11
check_flow_match_sets 2 0 0 2 2 0 0
ovn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1

echo
echo "IPv6: stateful"
ovn-nbctl --wait=sb lr-nat-add R1 dnat_and_snat fd01::1 fd11::2
check_flow_match_sets 2 2 2 0 0 0 0
ovn-nbctl lr-nat-del R1 dnat_and_snat  fd01::1

echo
echo "IPv6: stateless"
ovn-nbctl --wait=sb --stateless lr-nat-add R1 dnat_and_snat fd01::1 fd11::2
check_flow_match_sets 2 0 0 0 0 2 2

AT_CLEANUP

AT_SETUP([ovn -- check portrange dnat, snat and dnat_and_snat rules])
ovn_start

ovn-sbctl chassis-add gw1 geneve 127.0.0.1

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 router
ovn-nbctl lsp-set-options S1-R1 router-port=R1-S1

check ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1

uuid=`ovn-sbctl --columns=_uuid --bare find Port_Binding logical_port=cr-R1-S1`
echo "CR-LRP UUID is: " $uuid

# IPV4
ovn-nbctl --portrange lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11 1-3000

AT_CAPTURE_FILE([sbflows])
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows && test 2 = `grep -c lr_in_unsnat sbflows`])
AT_CHECK([grep -c 'ct_snat.*3000' sbflows && grep -c 'ct_dnat.*3000' sbflows],
  [0], [1
1
])

ovn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1
ovn-nbctl --wait=sb --portrange lr-nat-add R1 snat  172.16.1.1 50.0.0.11 1-3000

AT_CAPTURE_FILE([sbflows2])
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows2 && test 2 = `grep -c lr_in_unsnat sbflows`])
AT_CHECK([grep -c 'ct_snat.*3000' sbflows2 && grep -c 'ct_dnat.*3000' sbflows2],
  [1], [1
0
])

ovn-nbctl lr-nat-del R1 snat  172.16.1.1
ovn-nbctl --wait=sb --portrange --stateless lr-nat-add R1 dnat_and_snat  172.16.1.2 50.0.0.12 1-3000

AT_CAPTURE_FILE([sbflows3])
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows3 && test 3 = `grep -c lr_in_unsnat sbflows3`])
AT_CHECK([grep 'ct_[s]dnat.*172\.16\.1\.2.*3000' sbflows3], [1])

ovn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1

AT_CLEANUP

AT_SETUP([ovn -- check allowed/disallowed external dnat, snat and dnat_and_snat rules])
ovn_start

# Logical network:
# 2 LRs - CR and DR
# CR ==> Centralized router
# DR ==> Distributed router
#
# DR is connected to S1 and CR is connected to S2

check ovn-sbctl chassis-add gw1 geneve 127.0.0.1

check ovn-nbctl lr-add DR
check ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24

cr_uuid=$(ovn-nbctl create Logical_Router name=CR)
check ovn-nbctl lrp-add CR CR-S2 02:ac:10:01:00:01 172.16.1.1/24

check ovn-nbctl ls-add S1
check ovn-nbctl lsp-add S1 S1-DR
check ovn-nbctl lsp-set-type S1-DR router
check ovn-nbctl lsp-set-addresses S1-DR router
check ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1

check ovn-nbctl ls-add S2
check ovn-nbctl lsp-add S2 S2-CR
check ovn-nbctl lsp-set-type S2-CR router
check ovn-nbctl lsp-set-addresses S2-CR router
check ovn-nbctl --wait=sb lsp-set-options S2-CR router-port=CR-S2

check ovn-nbctl lrp-set-gateway-chassis DR-S1 gw1

uuid=$(fetch_column Port_Binding _uuid logical_port=cr-DR-S1)
echo "CR-LRP UUID is: " $uuid

check ovn-nbctl set Logical_Router $cr_uuid options:chassis=gw1
check ovn-nbctl --wait=hv sync

ovn-nbctl create Address_Set name=allowed_range addresses=\"1.1.1.1\"
ovn-nbctl create Address_Set name=disallowed_range addresses=\"2.2.2.2\"

# SNAT with ALLOWED_IPs
check ovn-nbctl lr-nat-add DR snat  172.16.1.1 50.0.0.11
check ovn-nbctl lr-nat-update-ext-ip DR snat 50.0.0.11 allowed_range

check ovn-nbctl lr-nat-add CR snat  172.16.1.1 50.0.0.11
check ovn-nbctl lr-nat-update-ext-ip CR snat 50.0.0.11 allowed_range

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows DR > drflows
AT_CAPTURE_FILE([drflows])
ovn-sbctl dump-flows CR > crflows
AT_CAPTURE_FILE([crflows])

AT_CHECK([
  grep -c lr_out_snat drflows
  grep -c lr_out_snat crflows
  grep lr_out_snat drflows | grep "ip4.src == 50.0.0.11" | grep -c "ip4.dst == $allowed_range"
  grep lr_out_snat crflows | grep "ip4.src == 50.0.0.11" | grep -c "ip4.dst == $allowed_range"], [0], [dnl
3
3
1
1
])

# SNAT with DISALLOWED_IPs
check ovn-nbctl lr-nat-del DR snat  50.0.0.11
check ovn-nbctl lr-nat-del CR snat  50.0.0.11

check ovn-nbctl lr-nat-add DR snat  172.16.1.1 50.0.0.11
check ovn-nbctl lr-nat-add CR snat  172.16.1.1 50.0.0.11

check ovn-nbctl --is-exempted lr-nat-update-ext-ip DR snat 50.0.0.11 disallowed_range
check ovn-nbctl --is-exempted lr-nat-update-ext-ip CR snat 50.0.0.11 disallowed_range

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows DR > drflows2
AT_CAPTURE_FILE([drflows2])
ovn-sbctl dump-flows CR > crflows2
AT_CAPTURE_FILE([crflows2])

AT_CHECK([
  grep -c lr_out_snat drflows2
  grep -c lr_out_snat crflows2
  grep lr_out_snat drflows2 | grep "ip4.src == 50.0.0.11" | grep "ip4.dst == $disallowed_range" | grep -c "priority=162"
  grep lr_out_snat drflows2 | grep "ip4.src == 50.0.0.11" | grep -c "priority=161"
  grep lr_out_snat crflows2 | grep "ip4.src == 50.0.0.11" | grep "ip4.dst == $disallowed_range" | grep -c "priority=34"
  grep lr_out_snat crflows2 | grep "ip4.src == 50.0.0.11" | grep -c "priority=33"], [0], [dnl
4
4
1
1
1
1
])

# Stateful FIP with ALLOWED_IPs
check ovn-nbctl lr-nat-del DR snat  50.0.0.11
check ovn-nbctl lr-nat-del CR snat  50.0.0.11

check ovn-nbctl lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11
check ovn-nbctl lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11

check ovn-nbctl lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 allowed_range
check ovn-nbctl lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 allowed_range

ovn-nbctl show DR
ovn-sbctl dump-flows DR
ovn-nbctl show CR
ovn-sbctl dump-flows CR

OVS_WAIT_UNTIL([test 3 = `ovn-sbctl dump-flows DR | grep lr_out_snat | \
wc -l`])
OVS_WAIT_UNTIL([test 3 = `ovn-sbctl dump-flows CR | grep lr_out_snat | \
wc -l`])

AT_CHECK([ovn-sbctl dump-flows DR | grep lr_out_snat | grep "ip4.src == 50.0.0.11" | grep "ip4.dst == $allowed_range" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows DR | grep lr_in_dnat | grep "ip4.dst == 172.16.1.2" | grep "ip4.src == $allowed_range" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows CR | grep lr_out_snat | grep "ip4.src == 50.0.0.11" | grep "ip4.dst == $allowed_range" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows CR | grep lr_in_dnat | grep "ip4.dst == 172.16.1.2" | grep "ip4.src == $allowed_range" | wc -l], [0], [1
])

# Stateful FIP with DISALLOWED_IPs
ovn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2
ovn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2

ovn-nbctl lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11
ovn-nbctl lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11

ovn-nbctl --is-exempted lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 disallowed_range
ovn-nbctl --is-exempted lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 disallowed_range

ovn-nbctl show DR
ovn-sbctl dump-flows DR
ovn-nbctl show CR
ovn-sbctl dump-flows CR

OVS_WAIT_UNTIL([test 4 = `ovn-sbctl dump-flows DR | grep lr_out_snat | \
wc -l`])
OVS_WAIT_UNTIL([test 4 = `ovn-sbctl dump-flows CR | grep lr_out_snat | \
wc -l`])

AT_CHECK([ovn-sbctl dump-flows DR | grep lr_out_snat | grep "ip4.src == 50.0.0.11" | grep "ip4.dst == $disallowed_range" | grep "priority=162" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows DR | grep lr_in_dnat | grep "ip4.dst == 172.16.1.2" | grep "ip4.src == $disallowed_range" | grep "priority=101" | wc -l], [0], [1
])

AT_CHECK([ovn-sbctl dump-flows CR | grep lr_out_snat | grep "ip4.src == 50.0.0.11" | grep "ip4.dst == $disallowed_range" | grep "priority=34" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows CR | grep lr_in_dnat | grep "ip4.dst == 172.16.1.2" | grep "ip4.src == $disallowed_range" | grep "priority=101" | wc -l], [0], [1
])

# Stateless FIP with DISALLOWED_IPs
ovn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2
ovn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2

ovn-nbctl --stateless lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11
ovn-nbctl --stateless lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11

ovn-nbctl lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 allowed_range
ovn-nbctl lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 allowed_range

ovn-nbctl show DR
ovn-sbctl dump-flows DR

ovn-nbctl show CR
ovn-sbctl dump-flows CR

OVS_WAIT_UNTIL([test 3 = `ovn-sbctl dump-flows DR | grep lr_out_snat | \
wc -l`])
OVS_WAIT_UNTIL([test 3 = `ovn-sbctl dump-flows CR | grep lr_out_snat | \
wc -l`])

AT_CHECK([ovn-sbctl dump-flows DR | grep lr_out_snat | grep "ip4.src == 50.0.0.11" | grep "ip4.dst == $allowed_range" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows DR | grep lr_in_dnat | grep "ip4.dst == 172.16.1.2" | grep "ip4.src == $allowed_range" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows CR | grep lr_out_snat | grep "ip4.src == 50.0.0.11" | grep "ip4.dst == $allowed_range" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows CR | grep lr_in_dnat | grep "ip4.dst == 172.16.1.2" | grep "ip4.src == $allowed_range" | wc -l], [0], [1
])

# Stateful FIP with DISALLOWED_IPs
ovn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2
ovn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2

ovn-nbctl --stateless lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11
ovn-nbctl --stateless lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11

ovn-nbctl --is-exempted lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 disallowed_range
ovn-nbctl --is-exempted lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 disallowed_range

ovn-nbctl show DR
ovn-sbctl dump-flows DR
ovn-nbctl show CR
ovn-sbctl dump-flows CR

OVS_WAIT_UNTIL([test 4 = `ovn-sbctl dump-flows DR | grep lr_out_snat | \
wc -l`])
OVS_WAIT_UNTIL([test 4 = `ovn-sbctl dump-flows CR | grep lr_out_snat | \
wc -l`])

AT_CHECK([ovn-sbctl dump-flows DR | grep lr_out_snat | grep "ip4.src == 50.0.0.11" | grep "ip4.dst == $disallowed_range" | grep "priority=162" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows DR | grep lr_in_dnat | grep "ip4.dst == 172.16.1.2" | grep "ip4.src == $disallowed_range" | grep "priority=101" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows CR | grep lr_out_snat | grep "ip4.src == 50.0.0.11" | grep "ip4.dst == $disallowed_range" | grep "priority=34" | wc -l], [0], [1
])
AT_CHECK([ovn-sbctl dump-flows CR | grep lr_in_dnat | grep "ip4.dst == 172.16.1.2" | grep "ip4.src == $disallowed_range" | grep "priority=101" | wc -l], [0], [1
])

AT_CLEANUP

AT_SETUP([ovn -- check Load balancer health check and Service Monitor sync])
ovn_start

check ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80

check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1
check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1

wait_row_count Service_Monitor 0

AT_CHECK([ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer . \
health_check @hc | uuidfilt], [0], [<0>
])

wait_row_count Service_Monitor 0

# create logical switches and ports
ovn-nbctl ls-add sw0
ovn-nbctl --wait=sb lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \
"00:00:00:00:00:03 10.0.0.3"

wait_row_count Service_Monitor 0

ovn-nbctl ls-add sw1
ovn-nbctl --wait=sb lsp-add sw1 sw1-p1 -- lsp-set-addresses sw1-p1 \
"02:00:00:00:00:03 20.0.0.3"

wait_row_count Service_Monitor 0

ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
wait_row_count Service_Monitor 1

ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2
wait_row_count Service_Monitor 2

check ovn-nbctl --wait=sb ls-lb-add sw0 lb1

AT_CAPTURE_FILE([sbflows])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows | grep 'priority=120.*ct_lb' | sed 's/table=..//'], 0, [dnl
  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)
])

# Delete the Load_Balancer_Health_Check
ovn-nbctl --wait=sb clear load_balancer . health_check
wait_row_count Service_Monitor 0

AT_CAPTURE_FILE([sbflows2])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows2 | grep 'priority=120.*ct_lb' | sed 's/table=..//'], [0],
[  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)
])

# Create the Load_Balancer_Health_Check again.
ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer . \
health_check @hc
wait_row_count Service_Monitor 2

ovn-sbctl dump-flows sw0 | grep ct_lb | grep priority=120 > lflows.txt
AT_CHECK([cat lflows.txt | sed 's/table=..//'], [0], [dnl
  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)
])

# Get the uuid of both the service_monitor
sm_sw0_p1=$(fetch_column Service_Monitor _uuid logical_port=sw0-p1)
sm_sw1_p1=$(fetch_column Service_Monitor _uuid logical_port=sw1-p1)

AT_CAPTURE_FILE([sbflows3])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows 3 | grep 'priority=120.*ct_lb' | sed 's/table=..//'], [0],
[  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)
])

# Set the service monitor for sw1-p1 to offline
check ovn-sbctl set service_monitor sw1-p1 status=offline
wait_row_count Service_Monitor 1 logical_port=sw1-p1 status=offline

AT_CAPTURE_FILE([sbflows4])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows4 | grep 'priority=120.*ct_lb' | sed 's/table=..//'], [0],
[  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(ct_lb(backends=10.0.0.3:80);)
])

# Set the service monitor for sw0-p1 to offline
ovn-sbctl set service_monitor $sm_sw0_p1 status=offline

wait_row_count Service_Monitor 1 logical_port=sw0-p1 status=offline

AT_CAPTURE_FILE([sbflows5])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows5 | grep 'priority=120.*ct_lb'], 1)

AT_CAPTURE_FILE([sbflows6])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows6 | grep "ip4.dst == 10.0.0.10 && tcp.dst == 80" | grep priority=120 | sed 's/table=..//'], [0], [dnl
  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(drop;)
])

# Set the service monitor for sw0-p1 and sw1-p1 to online
ovn-sbctl set service_monitor $sm_sw0_p1 status=online
ovn-sbctl set service_monitor $sm_sw1_p1 status=online

wait_row_count Service_Monitor 1 logical_port=sw1-p1 status=online

AT_CAPTURE_FILE([sbflows7])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows7 | grep ct_lb | grep priority=120 | sed 's/table=..//'], 0,
[  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)
])

# Set the service monitor for sw1-p1 to error
ovn-sbctl set service_monitor $sm_sw1_p1 status=error
wait_row_count Service_Monitor 1 logical_port=sw1-p1 status=error

ovn-sbctl dump-flows sw0 | grep "ip4.dst == 10.0.0.10 && tcp.dst == 80" \
| grep priority=120 > lflows.txt
AT_CHECK([cat lflows.txt | sed 's/table=..//'], [0], [dnl
  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(ct_lb(backends=10.0.0.3:80);)
])

# Add one more vip to lb1
check ovn-nbctl set load_balancer . vip:10.0.0.40\\:1000=10.0.0.3:1000,20.0.0.3:80

# create health_check for new vip - 10.0.0.40
AT_CHECK(
  [ovn-nbctl --wait=sb \
          -- --id=@hc create Load_Balancer_Health_Check vip=10.0.0.40\\:1000 \
          -- add Load_Balancer . health_check @hc | uuidfilt], [0], [<0>
])

# There should be totally 3 rows in service_monitor for -
#    * 10.0.0.3:80
#    * 10.0.0.3:1000
#    * 20.0.0.3:80

wait_row_count Service_Monitor 3
wait_row_count Service_Monitor 2 logical_port=sw0-p1
wait_row_count Service_Monitor 1 port=1000

AT_CAPTURE_FILE([sbflows9])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows9 | grep ct_lb | grep priority=120 | sed 's/table=..//'],
  0,
[  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(ct_lb(backends=10.0.0.3:80);)
  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(ct_lb(backends=10.0.0.3:1000);)
])

# Set the service monitor for sw1-p1 to online
check ovn-sbctl set service_monitor sw1-p1 status=online

wait_row_count Service_Monitor 1 logical_port=sw1-p1 status=online

AT_CAPTURE_FILE([sbflows10])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows10 | grep ct_lb | grep priority=120 | sed 's/table=..//'],
  0,
[  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)
  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(ct_lb(backends=10.0.0.3:1000,20.0.0.3:80);)
])

# Associate lb1 to sw1
check ovn-nbctl --wait=sb ls-lb-add sw1 lb1
AT_CAPTURE_FILE([sbflows11])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw1 | tee sbflows11 | grep ct_lb | grep priority=120 | sed 's/table=..//'],
  0, [dnl
  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(ct_lb(backends=10.0.0.3:80,20.0.0.3:80);)
  (ls_in_stateful     ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(ct_lb(backends=10.0.0.3:1000,20.0.0.3:80);)
])

# Now create lb2 same as lb1 but udp protocol.
check ovn-nbctl lb-add lb2 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80 udp
check ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
check ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2

AT_CHECK([ovn-nbctl -- --id=@hc create Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer lb2 health_check @hc | uuidfilt],
         [0], [<0>
])

check ovn-nbctl ls-lb-add sw0 lb2
check ovn-nbctl ls-lb-add sw1 lb2

wait_row_count Service_Monitor 5

# Change the svc_monitor_mac. This should get reflected in service_monitor table rows.
check ovn-nbctl set NB_Global . options:svc_monitor_mac="fe:a0:65:a2:01:03"

wait_row_count Service_Monitor 5 src_mac='"fe:a0:65:a2:01:03"'

# Change the source ip for 10.0.0.3 backend ip in lb2
check ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.100

wait_row_count Service_Monitor 1 logical_port=sw0-p1 src_ip=10.0.0.100

ovn-nbctl --wait=sb lb-del lb1
wait_row_count Service_Monitor 2

ovn-nbctl --wait=sb lb-del lb2
wait_row_count Service_Monitor 0

AT_CLEANUP

AT_SETUP([ovn -- Load balancer VIP in NAT entries])
AT_SKIP_IF([test $HAVE_PYTHON = no])
ovn_start

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-public 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lrp-add lr0 lr0-join 00:00:01:01:02:04 10.10.0.1/24

ovn-nbctl set logical_router lr0 options:chassis=ch1

ovn-nbctl lb-add lb1 "192.168.2.1:8080" "10.0.0.4:8080"
ovn-nbctl lb-add lb2 "192.168.2.4:8080" "10.0.0.5:8080" udp
ovn-nbctl lb-add lb3 "192.168.2.5:8080" "10.0.0.6:8080"
ovn-nbctl lb-add lb4 "192.168.2.6:8080" "10.0.0.7:8080"

ovn-nbctl lr-lb-add lr0 lb1
ovn-nbctl lr-lb-add lr0 lb2
ovn-nbctl lr-lb-add lr0 lb3
ovn-nbctl lr-lb-add lr0 lb4

ovn-nbctl lr-nat-add lr0 snat 192.168.2.1 10.0.0.0/24
ovn-nbctl lr-nat-add lr0 dnat_and_snat 192.168.2.4 10.0.0.4
check ovn-nbctl --wait=sb lr-nat-add lr0 dnat 192.168.2.5 10.0.0.5

ovn-sbctl dump-flows lr0 > sbflows
AT_CAPTURE_FILE([sbflows])

OVS_WAIT_UNTIL([test 1 = $(grep lr_in_unsnat sbflows | \
grep "ip4 && ip4.dst == 192.168.2.1 && tcp && tcp.dst == 8080" -c) ])

AT_CHECK([test 1 = $(grep lr_in_unsnat sbflows | \
grep "ip4 && ip4.dst == 192.168.2.4 && udp && udp.dst == 8080" -c) ])

AT_CHECK([test 1 = $(grep lr_in_unsnat sbflows | \
grep "ip4 && ip4.dst == 192.168.2.5 && tcp && tcp.dst == 8080" -c) ])

AT_CHECK([test 0 = $(grep lr_in_unsnat sbflows | \
grep "ip4 && ip4.dst == 192.168.2.6 && tcp && tcp.dst == 8080" -c) ])

AT_CLEANUP

AT_SETUP([ovn -- DNAT force snat IP])
ovn_start

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-public 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lrp-add lr0 lr0-join 00:00:01:01:02:04 10.10.0.1/24

ovn-nbctl set logical_router lr0 options:chassis=ch1
ovn-nbctl lr-nat-add lr0 dnat 192.168.2.2 10.0.0.5
ovn-nbctl set logical_router lr0 options:dnat_force_snat_ip=192.168.2.3
ovn-nbctl --wait=sb sync

AT_CHECK([ovn-sbctl lflow-list lr0 | grep lr_in_unsnat], [0], [dnl
  table=5 (lr_in_unsnat       ), priority=110  , match=(ip4 && ip4.dst == 192.168.2.3), action=(ct_snat;)
  table=5 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
])

AT_CLEANUP

AT_SETUP([ovn -- check reconcile stale Datapath_Binding])
ovn_start

check ovn-nbctl lr-add lr
check ovn-nbctl lrp-add lr p 00:00:00:00:00:01 1.1.1.1/24
check ovn-nbctl --wait=sb sync

# Create a MAC_Binding referring the router datapath.
AT_CHECK([ovn-sbctl --id=@dp get datapath . -- create mac_binding logical_port=p ip=1.1.1.2 datapath=@dp | uuidfilt], [0], [<0>
])

check ovn-nbctl --wait=sb \
             -- lrp-del p \
             -- lr-del lr \
             -- lr-add lr \
             -- lrp-add lr p 00:00:00:00:00:01 1.1.1.1/24

check_row_count Datapath_Binding 1

nb_uuid=$(ovn-sbctl get Datapath_Binding . external_ids:logical-router)
lr_uuid=\"$(ovn-nbctl get Logical_Router . _uuid)\"
echo nb_uuid="$nb_uuid" lr_uuid="$lr_uuid"
AT_CHECK([test "${nb_uuid}" = "${lr_uuid}"])

AT_CLEANUP

AT_SETUP([ovn -- check reconcile stale tunnel keys])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl lsp-add ls1 lsp1
ovn-nbctl lsp-add ls2 lsp2
AT_CHECK([ovn-nbctl --wait=sb sync], [0])

# Ports are bound on different datapaths so it's expected that they both
# get tunnel_key == 1.
check_column 1 Port_Binding tunnel_key logical_port=lsp1
check_column 1 Port_Binding tunnel_key logical_port=lsp2

ovn-nbctl lsp-del lsp2 -- lsp-add ls1 lsp2
AT_CHECK([ovn-nbctl --wait=sb sync], [0])

check_column 1 Port_Binding tunnel_key logical_port=lsp1
check_column 2 Port_Binding tunnel_key logical_port=lsp2

AT_CLEANUP

AT_SETUP([ovn -- check reconcile stale Ha_Chassis_Group])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl lsp-add ls1 lsp1
ovn-nbctl lsp-add ls2 lsp2

ovn-nbctl lsp-set-type lsp2 external

ovn-nbctl ha-chassis-group-add chg1
ovn-nbctl ha-chassis-group-add-chassis chg1 chassis-1 30

chg1_uuid=$(ovn-nbctl --bare --columns _uuid list Ha_Chassis_Group .)
ovn-nbctl set logical_switch_port lsp2 ha_chassis_group=${chg1_uuid}
AT_CHECK([ovn-nbctl --wait=sb sync], [0])

# Move lsp2 from ls2 to ls1. This should also remove the SB HA_Chassis_Group
# record.
ovn-nbctl lsp-del lsp2 -- lsp-add ls1 lsp2
AT_CHECK([ovn-nbctl --wait=sb sync], [0])

check_row_count HA_Chassis_Group 0

AT_CLEANUP

AT_SETUP([ovn -- check NB/SB Port_Group translation (lsp add/del)])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl lsp-add ls1 lsp1
ovn-nbctl lsp-add ls2 lsp2
ovn-nbctl --wait=sb sync
ls1_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls1)
ls2_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls2)

# Add an empty port group. This should generate no entry in the SB.
ovn-nbctl --wait=sb pg-add pg_test
AT_CHECK([test 0 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])

# Add lsp1 to the port group. This should generate an entry in the SB only
# for ls1.
ovn-nbctl --wait=sb pg-set-ports pg_test lsp1
AT_CHECK([test 1 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])
AT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls1_key}_pg_test], [0], [dnl
lsp1
])

# Add lsp2 to the port group. This should generate a new entry in the SB, for
# ls2.
ovn-nbctl --wait=sb pg-set-ports pg_test lsp1 lsp2
AT_CHECK([test 2 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])
AT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls1_key}_pg_test], [0], [dnl
lsp1
])
AT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls2_key}_pg_test], [0], [dnl
lsp2
])

# Remove lsp1 from the port group. The SB Port_Group for ls1 should be
# removed.
ovn-nbctl --wait=sb pg-set-ports pg_test lsp2
AT_CHECK([test 1 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])
AT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls2_key}_pg_test], [0], [dnl
lsp2
])

# Remove lsp2 from the port group. All SB Port_Groups should be purged.
ovn-nbctl --wait=sb clear Port_Group pg_test ports
AT_CHECK([test 0 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])

AT_CLEANUP

AT_SETUP([ovn -- check NB/SB Port_Group translation (ls del)])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl lsp-add ls1 lsp1
ovn-nbctl lsp-add ls2 lsp2
ovn-nbctl --wait=sb sync
ls1_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls1)
ls2_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls2)

# Add lsp1 & lsp2 to a port group. This should generate two entries in the
# SB (one per logical switch).
ovn-nbctl --wait=sb pg-add pg_test lsp1 lsp2
wait_row_count Port_Group 2
check_row_count Port_Group 1 name=${ls1_key}_pg_test
check_row_count Port_Group 1 name=${ls2_key}_pg_test

# Delete logical switch ls1. This should remove the associated SB Port_Group.
ovn-nbctl --wait=sb ls-del ls1
wait_row_count Port_Group 1
check_row_count Port_Group 1 name=${ls2_key}_pg_test

AT_CLEANUP

AT_SETUP([ovn -- check router ARP/NS responder])
ovn_start

ovn-sbctl chassis-add ch geneve 127.0.0.1

ovn-nbctl lr-add lr
ovn-nbctl lrp-add lr lrp-public 00:00:00:00:01:00 43.43.43.1/24
ovn-nbctl lrp-add lr lrp 00:00:00:00:00:01 42.42.42.1/24

ovn-nbctl ls-add ls
ovn-nbctl lsp-add ls ls-rp
ovn-nbctl lsp-set-type ls-rp router
ovn-nbctl lsp-set-addresses ls-rp router
ovn-nbctl lsp-set-options ls-rp router-port=lrp
ovn-nbctl lsp-add ls ls-vm

ovn-nbctl set logical_router lr options:chassis=ch
ovn-nbctl lr-nat-add lr dnat_and_snat 43.43.43.2 42.42.42.2
ovn-nbctl lr-nat-add lr dnat 43.43.43.3 42.42.42.3
ovn-nbctl lr-nat-add lr dnat_and_snat 43.43.43.4 42.42.42.4 ls-vm 00:00:00:00:00:02
ovn-nbctl lr-nat-add lr snat 43.43.43.150 43.43.43.50
ovn-nbctl lr-nat-add lr snat 43.43.43.150 43.43.43.51

ovn-nbctl --wait=sb sync

# Ingress router port ETH address is stored in lr_in_admission.
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_admission.*xreg0\[[0..47\]]" | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.dst == 00:00:00:00:00:01 && inport == "lrp"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.dst == 00:00:00:00:01:00 && inport == "lrp-public"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.mcast && inport == "lrp"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.mcast && inport == "lrp-public"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)
])

# Ingress router port ETH address is used for ARP reply/NA in lr_in_ip_input.
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_ip_input.*priority=90" | grep "arp\|nd" | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.150), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.150; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.2), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.2; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.3), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.3; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.4), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.4; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && arp.op == 1 && arp.tpa == 42.42.42.1 && arp.spa == 42.42.42.0/24), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 42.42.42.1; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && ip6.dst == {fe80::200:ff:fe00:1, ff02::1:ff00:1} && nd_ns && nd.target == fe80::200:ff:fe00:1), dnl
action=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = fe80::200:ff:fe00:1; nd.target = fe80::200:ff:fe00:1; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.1 && arp.spa == 43.43.43.0/24), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.1; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && ip6.dst == {fe80::200:ff:fe00:100, ff02::1:ff00:100} && nd_ns && nd.target == fe80::200:ff:fe00:100), dnl
action=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = fe80::200:ff:fe00:100; nd.target = fe80::200:ff:fe00:100; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
])

# xreg0[0..47] isn't used anywhere else.
AT_CHECK([ovn-sbctl lflow-list | grep "xreg0\[[0..47\]]" | grep -vE 'lr_in_admission|lr_in_ip_input'], [1], [])

# Test chassis redirect port.
ovn-nbctl remove logical_router lr options chassis
ovn-nbctl lrp-set-gateway-chassis lrp-public ch
ovn-nbctl --wait=sb sync

# Ingress router port ETH address is stored in lr_in_admission.
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_admission.*xreg0\[[0..47\]]" | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.dst == 00:00:00:00:00:01 && inport == "lrp"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.dst == 00:00:00:00:00:02 && inport == "lrp-public" && is_chassis_resident("ls-vm")), dnl
action=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.dst == 00:00:00:00:01:00 && inport == "lrp-public" && is_chassis_resident("cr-lrp-public")), dnl
action=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.mcast && inport == "lrp"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.mcast && inport == "lrp-public"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)
])

# Ingress router port is used for ARP reply/NA in lr_in_ip_input.
# xxreg0[0..47] is used unless external_mac is set.
# Priority 90 flows (per router).
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_ip_input.*priority=90" | grep "arp\|nd" | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.150), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.150; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.2), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.2; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.3), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.3; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.4), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.4; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && arp.op == 1 && arp.tpa == 42.42.42.1 && arp.spa == 42.42.42.0/24), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 42.42.42.1; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && ip6.dst == {fe80::200:ff:fe00:1, ff02::1:ff00:1} && nd_ns && nd.target == fe80::200:ff:fe00:1), dnl
action=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = fe80::200:ff:fe00:1; nd.target = fe80::200:ff:fe00:1; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.1 && arp.spa == 43.43.43.0/24), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.1; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && ip6.dst == {fe80::200:ff:fe00:100, ff02::1:ff00:100} && nd_ns && nd.target == fe80::200:ff:fe00:100 && is_chassis_resident("cr-lrp-public")), dnl
action=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = fe80::200:ff:fe00:100; nd.target = fe80::200:ff:fe00:100; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
])

# Priority 91 drop flows (per distributed gw port), if port is not resident.
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_ip_input.*priority=91" | grep "arp\|nd" | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=91   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.150), action=(drop;)
  table=3 (lr_in_ip_input     ), priority=91   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.2), dnl
action=(drop;)
  table=3 (lr_in_ip_input     ), priority=91   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.3), dnl
action=(drop;)
  table=3 (lr_in_ip_input     ), priority=91   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.4), dnl
action=(drop;)
])

# Priority 92 ARP/NS responders (per distributed gw port), if port is resident.
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_ip_input.*priority=92" | grep "arp\|nd" | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=92   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.150 && is_chassis_resident("cr-lrp-public")), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.150; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=92   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.2 && is_chassis_resident("cr-lrp-public")), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.2; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=92   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.3 && is_chassis_resident("cr-lrp-public")), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa = arp.spa; arp.spa = 43.43.43.3; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=92   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.4 && is_chassis_resident("ls-vm")), dnl
action=(eth.dst = eth.src; eth.src = 00:00:00:00:00:02; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = 00:00:00:00:00:02; arp.tpa = arp.spa; arp.spa = 43.43.43.4; outport = inport; flags.loopback = 1; output;)
])

# xreg0[0..47] isn't used anywhere else.
AT_CHECK([ovn-sbctl lflow-list | grep "xreg0\[[0..47\]]" | grep -vE 'lr_in_admission|lr_in_ip_input'], [1], [])

AT_CLEANUP

# This test case tests that when a logical switch has load balancers associated
# (with VIPs configured), the below logical flow is added by ovn-northd.
# table=0 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
# This test case is added for the BZ -
# https://bugzilla.redhat.com/show_bug.cgi?id=1849162
#
# ovn-northd was not adding the above lflow if the last load balancer associated
# to the logical switch doesn't have the VIP configured even if other load
# balancers before the last one in the last have VIPs configured.
# So make sure that the above lflow is added even if one load balancer has VIP
# associated.

AT_SETUP([ovn -- Load balancer - missing ls_out_pre_lb flows])
ovn_start

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1

ovn-nbctl lb-add lb1 "10.0.0.10" "10.0.0.3"
ovn-nbctl lb-add lb2 "10.0.0.11" "10.0.0.4"

ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
])

ovn-nbctl ls-lb-add sw0 lb1
ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=0 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
])

ovn-nbctl ls-lb-add sw0 lb2
ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=0 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
])

lb1_uuid=$(ovn-nbctl --bare --columns _uuid find load_balancer name=lb1)
lb2_uuid=$(ovn-nbctl --bare --columns _uuid find load_balancer name=lb2)

ovn-nbctl clear load_balancer $lb1_uuid vips
ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=0 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
])

ovn-nbctl clear load_balancer $lb2_uuid vips
ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
])

ovn-nbctl set load_balancer $lb1_uuid vips:"10.0.0.10"="10.0.0.3"
ovn-nbctl set load_balancer $lb2_uuid vips:"10.0.0.11"="10.0.0.4"

ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=0 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
])

# Now reverse the order of clearing the vip.
ovn-nbctl clear load_balancer $lb2_uuid vips
ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=0 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
])

ovn-nbctl clear load_balancer $lb1_uuid vips
ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
])

AT_CLEANUP

AT_SETUP([ovn -- ignore_lsp_down])
ovn_start

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 "aa:aa:aa:aa:aa:aa 10.0.0.1"

ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep arp | grep 10\.0\.0\.1], [1], [ignore])

ovn-nbctl --wait=sb set NB_Global . options:ignore_lsp_down=true
AT_CHECK([ovn-sbctl lflow-list | grep arp | grep 10\.0\.0\.1], [0], [ignore])

AT_CLEANUP

AT_SETUP([ovn-northd -- reject ACL])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1

check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1

check ovn-nbctl pg-add pg0 sw0-p1 sw1-p1
check ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip4 && tcp && tcp.dst == 80" reject
check ovn-nbctl acl-add pg0 to-lport 1003 "outport == @pg0 && ip6 && udp" reject

check ovn-nbctl --wait=hv sync

AS_BOX([1])

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])
ovn-sbctl dump-flows sw1 > sw1flows
AT_CAPTURE_FILE([sw1flows])

AT_CHECK([grep "ls_in_acl" sw0flows | grep pg0 | sort], [0], [dnl
  table=7 (ls_in_acl          ), priority=2002 , dnl
match=(inport == @pg0 && ip4 && tcp && tcp.dst == 80), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
])

AT_CHECK([grep "ls_in_acl" sw1flows | grep pg0 | sort], [0], [dnl
  table=7 (ls_in_acl          ), priority=2002 , dnl
match=(inport == @pg0 && ip4 && tcp && tcp.dst == 80), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
])

AT_CHECK([grep "ls_out_acl" sw0flows | grep pg0 | sort], [0], [dnl
  table=5 (ls_out_acl         ), priority=2003 , dnl
match=(outport == @pg0 && ip6 && udp), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
])

AT_CHECK([grep "ls_out_acl" sw1flows | grep pg0 | sort], [0], [dnl
  table=5 (ls_out_acl         ), priority=2003 , dnl
match=(outport == @pg0 && ip6 && udp), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
])

AS_BOX([2])

ovn-nbctl --wait=sb acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && udp" reject

ovn-sbctl dump-flows sw0 > sw0flows2
AT_CAPTURE_FILE([sw0flows2])
ovn-sbctl dump-flows sw1 > sw1flows2
AT_CAPTURE_FILE([sw1flows2])

AT_CHECK([grep "ls_out_acl" sw0flows2 | grep pg0 | sort], [0], [dnl
  table=5 (ls_out_acl         ), priority=2002 , dnl
match=(outport == @pg0 && ip4 && udp), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
  table=5 (ls_out_acl         ), priority=2003 , dnl
match=(outport == @pg0 && ip6 && udp), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
])

AT_CHECK([grep "ls_out_acl" sw1flows2 | grep pg0 | sort], [0], [dnl
  table=5 (ls_out_acl         ), priority=2002 , dnl
match=(outport == @pg0 && ip4 && udp), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
  table=5 (ls_out_acl         ), priority=2003 , dnl
match=(outport == @pg0 && ip6 && udp), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
])

AS_BOX([3])

ovn-nbctl --wait=sb acl-add pg0 to-lport 1001 "outport == @pg0 && ip" allow-related

ovn-sbctl dump-flows sw0 > sw0flows3
AT_CAPTURE_FILE([sw0flows3])
ovn-sbctl dump-flows sw1 > sw1flows3
AT_CAPTURE_FILE([sw1flows3])

AT_CHECK([grep "ls_out_acl" sw0flows3 | grep pg0 | sort], [0], [dnl
  table=5 (ls_out_acl         ), priority=2001 , dnl
match=(reg0[[7]] == 1 && (outport == @pg0 && ip)), action=(reg0[[1]] = 1; next;)
  table=5 (ls_out_acl         ), priority=2001 , dnl
match=(reg0[[8]] == 1 && (outport == @pg0 && ip)), action=(next;)
  table=5 (ls_out_acl         ), priority=2002 , dnl
match=((reg0[[10]] == 1) && outport == @pg0 && ip4 && udp), dnl
action=(ct_commit { ct_label.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
  table=5 (ls_out_acl         ), priority=2002 , dnl
match=((reg0[[9]] == 1) && outport == @pg0 && ip4 && udp), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
  table=5 (ls_out_acl         ), priority=2003 , dnl
match=((reg0[[10]] == 1) && outport == @pg0 && ip6 && udp), dnl
action=(ct_commit { ct_label.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
  table=5 (ls_out_acl         ), priority=2003 , dnl
match=((reg0[[9]] == 1) && outport == @pg0 && ip6 && udp), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
])

AT_CHECK([grep "ls_out_acl" sw1flows3 | grep pg0 | sort], [0], [dnl
  table=5 (ls_out_acl         ), priority=2001 , dnl
match=(reg0[[7]] == 1 && (outport == @pg0 && ip)), action=(reg0[[1]] = 1; next;)
  table=5 (ls_out_acl         ), priority=2001 , dnl
match=(reg0[[8]] == 1 && (outport == @pg0 && ip)), action=(next;)
  table=5 (ls_out_acl         ), priority=2002 , dnl
match=((reg0[[10]] == 1) && outport == @pg0 && ip4 && udp), dnl
action=(ct_commit { ct_label.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
  table=5 (ls_out_acl         ), priority=2002 , dnl
match=((reg0[[9]] == 1) && outport == @pg0 && ip4 && udp), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
  table=5 (ls_out_acl         ), priority=2003 , dnl
match=((reg0[[10]] == 1) && outport == @pg0 && ip6 && udp), dnl
action=(ct_commit { ct_label.blocked = 1; };  reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
  table=5 (ls_out_acl         ), priority=2003 , dnl
match=((reg0[[9]] == 1) && outport == @pg0 && ip6 && udp), dnl
action=(reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=21); };)
])

AT_CLEANUP

AT_SETUP([datapath requested-tnl-key])
AT_KEYWORDS([requested tnl tunnel key keys])
ovn_start

get_tunnel_keys() {
    set $(ovn-sbctl get datapath_binding ls0 tunnel_key \
                 -- get datapath_binding ls1 tunnel_key \
                 -- get datapath_binding ls2 tunnel_key)
    echo "ls0=$ls0 ls1=$ls1 ls2=$ls2"
    ls0=$1 ls1=$2 ls2=$3
    AT_CHECK([test "$ls0" != "$ls1" && \
              test "$ls1" != "$ls2" && \
              test "$ls0" != "$ls2"])
}

echo
echo "__file__:__line__: Add three logical switches, check tunnel ids"
AT_CHECK(
  [ovn-nbctl --wait=sb ls-add ls0
   ovn-nbctl --wait=sb ls-add ls1
   ovn-nbctl --wait=sb ls-add ls2])
get_tunnel_keys
AT_CHECK([test $ls0 = 1 && test $ls1 = 2 && test $ls2 = 3])

echo
echo "__file__:__line__: Assign ls0 new tunnel key, others don't change."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch ls0 other-config:requested-tnl-key=4])
get_tunnel_keys
AT_CHECK([test $ls0 = 4 && test $ls1 = 2 && test $ls2 = 3])

echo
echo "__file__:__line__: Assign ls0 a conflict with ls1, which moves aside."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch ls0 other-config:requested-tnl-key=2])
get_tunnel_keys
AT_CHECK([test $ls0 = 2 && test $ls2 = 3])

echo
echo "__file__:__line__: Assign ls0 and ls1 conflicts and verify that they end up different and ls2 doesn't change."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch ls1 other-config:requested-tnl-key=2])
get_tunnel_keys
AT_CHECK([test $ls2 = 3])
AT_CLEANUP
])

AT_SETUP([port requested-tnl-key])
AT_KEYWORDS([requested tnl tunnel key keys])
ovn_start

get_tunnel_keys() {
    set $(ovn-sbctl get port_binding lsp00 tunnel_key \
                 -- get port_binding lsp01 tunnel_key \
                 -- get port_binding lsp02 tunnel_key \
                 -- get port_binding lsp10 tunnel_key \
                 -- get port_binding lsp11 tunnel_key \
                 -- get port_binding lsp12 tunnel_key)
    lsp00=$1 lsp01=$2 lsp02=$3 lsp10=$4 lsp11=$5 lsp12=$6
    ls0=$1$2$3 ls1=$4$5$6
    echo "ls0=$1$2$3 ls1=$4$5$6"
    AT_CHECK([test "$lsp00" != "$lsp01" && \
              test "$lsp01" != "$lsp02" && \
              test "$lsp00" != "$lsp02"])
    AT_CHECK([test "$lsp10" != "$lsp11" && \
              test "$lsp11" != "$lsp12" && \
              test "$lsp10" != "$lsp12"])
}

echo
echo "__file__:__line__: Add two logical switches with three ports each, check tunnel ids"
AT_CHECK(
  [for i in 0 1; do
       ovn-nbctl --wait=sb ls-add ls$i || exit $?
       for j in 0 1 2; do
           ovn-nbctl --wait=sb lsp-add ls$i lsp$i$j || exit $?
       done
   done])
get_tunnel_keys
AT_CHECK([test $ls0 = 123 && test $ls1 = 123])

echo
echo "__file__:__line__: Assign lsp00 new tunnel key, others don't change."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch-port lsp00 options:requested-tnl-key=4])
get_tunnel_keys
AT_CHECK([test $ls0 = 423 && test $ls1 = 123])

echo
echo "__file__:__line__: Assign lsp00 a conflict with lsp01, which moves aside."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch-port lsp00 options:requested-tnl-key=2])
get_tunnel_keys
AT_CHECK([test $lsp00 = 2 && test $lsp02 = 3 && test $ls1 = 123])

echo
echo "__file__:__line__: Assign lsp00 and lsp01 conflicts and verify that they end up different and lsp02 doesn't change."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch-port lsp01 options:requested-tnl-key=2])
get_tunnel_keys
AT_CHECK([test $lsp02 = 3 && test $ls1 = 123])

AT_CLEANUP

AT_SETUP([ovn -- NB to SB load balancer sync])
ovn_start

check ovn-nbctl --wait=sb lb-add lb0 10.0.0.10:80 10.0.0.4:8080
check_row_count nb:load_balancer 1

echo
echo "__file__:__line__: Check that there are no SB load balancer rows."
check_row_count sb:load_balancer 0

check ovn-nbctl ls-add sw0
check ovn-nbctl --wait=sb ls-lb-add sw0 lb0
sw0_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw0)

echo
echo "__file__:__line__: Check that there is one SB load balancer row for lb0."
check_row_count sb:load_balancer 1
check_column "10.0.0.10:80=10.0.0.4:8080 tcp" sb:load_balancer vips,protocol name=lb0

lb0_uuid=$(fetch_column sb:load_balancer _uuid name=lb0)

echo
echo "__file__:__line__: Check that SB lb0 has sw0 in datapaths column."

check_column "$sw0_sb_uuid" sb:load_balancer datapaths name=lb0
check_column "$lb0_uuid" sb:datapath_binding load_balancers external_ids:name=sw0

check ovn-nbctl --wait=sb set load_balancer . vips:"10.0.0.20\:90"="20.0.0.4:8080,30.0.0.4:8080"

echo
echo "__file__:__line__: Check that SB lb0 has vips and protocol columns are set properly."

check_column "10.0.0.10:80=10.0.0.4:8080 10.0.0.20:90=20.0.0.4:8080,30.0.0.4:8080 tcp" \
sb:load_balancer vips,protocol name=lb0

check ovn-nbctl lr-add lr0
check ovn-nbctl --wait=sb lr-lb-add lr0 lb0

echo
echo "__file__:__line__: Check that SB lb0 has only sw0 in datapaths column."
check_column "$sw0_sb_uuid" sb:load_balancer datapaths name=lb0

check ovn-nbctl ls-add sw1
check ovn-nbctl --wait=sb ls-lb-add sw1 lb0
sw1_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw1)

echo
echo "__file__:__line__: Check that SB lb0 has sw0 and sw1 in datapaths column."
check_column "$sw0_sb_uuid $sw1_sb_uuid" sb:load_balancer datapaths name=lb0
check_column "$lb0_uuid" sb:datapath_binding load_balancers external_ids:name=sw1

check ovn-nbctl --wait=sb lb-add lb1 10.0.0.30:80 20.0.0.50:8080 udp
check_row_count sb:load_balancer 1

check ovn-nbctl --wait=sb lr-lb-add lr0 lb1
check_row_count sb:load_balancer 1

echo
echo "__file__:__line__: Associate lb1 to sw1 and check that lb1 is created in SB DB."

check ovn-nbctl --wait=sb ls-lb-add sw1 lb1
check_row_count sb:load_balancer 2

echo
echo "__file__:__line__: Check that SB lb1 has vips and protocol columns are set properly."
check_column "10.0.0.30:80=20.0.0.50:8080 udp" sb:load_balancer vips,protocol name=lb1

lb1_uuid=$(fetch_column sb:load_balancer _uuid name=lb1)

echo
echo "__file__:__line__: Check that SB lb1 has sw1 in datapaths column."

check_column "$sw1_sb_uuid" sb:load_balancer datapaths name=lb1

echo
echo "__file__:__line__: check that datapath sw1 has lb0 and lb1 set in the load_balancers column."
check_column "$lb0_uuid $lb1_uuid" sb:datapath_binding load_balancers external_ids:name=sw1

echo
echo "__file__:__line__: Delete load balancer lb1 an check that datapath sw1's load_balancers are updated accordingly."

ovn-nbctl --wait=sb lb-del lb1
check_column "$lb0_uuid" sb:datapath_binding load_balancers external_ids:name=sw1

AT_CLEANUP
