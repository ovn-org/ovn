AT_BANNER([OVN northd])

# _DUMP_DB_TABLES FILENAME
# Dumps important incremental processing related tables to FILENAME.
# More tables can be added based on CHECK_NO_CHANGE_AFTER_RECOMPUTE's needs.
m4_define([_DUMP_DB_TABLES], [
    ovn-nbctl list logical_switch_port > $1
    echo ======= >> $1
    ovn-sbctl list logical_flow >> $1
    ovn-sbctl list port_binding >> $1
    ovn-sbctl list address_set >> $1
    ovn-sbctl list meter >> $1
    ovn-sbctl list meter_band >> $1
    ovn-sbctl list port_group_set >> $1
])

# CHECK_NO_CHANGE_AFTER_RECOMPUTE
# Triggers a northd recompute and compares the DB content of certain tables
# related to incremental processing before and after the recompute, to make
# sure nothing is changed by the recompute. It is used for ensuring the
# correctness of incremental processing.
m4_define([CHECK_NO_CHANGE_AFTER_RECOMPUTE], [
    _DUMP_DB_TABLES(before)
    check as northd ovn-appctl -t NORTHD_TYPE inc-engine/recompute
    check ovn-nbctl --wait=sb sync
    _DUMP_DB_TABLES(after)
    AT_CHECK([as northd diff before after], [0], [dnl
])
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check from NBDB to SBDB])
ovn_start

ovn-nbctl create Logical_Router name=R1
ovn-sbctl chassis-add gw1 geneve 127.0.0.1
ovn-sbctl chassis-add gw2 geneve 1.2.4.8

# Connect alice to R1 as distributed router gateway port on hv2
ovn-nbctl lrp-add R1 alice 00:00:02:01:02:03 172.16.1.1/24

ovn-nbctl --wait=sb \
    --id=@gc0 create Gateway_Chassis name=alice_gw1 \
                                     chassis_name=gw1 \
                                     priority=20 -- \
    --id=@gc1 create Gateway_Chassis name=alice_gw2 \
                                     chassis_name=gw2 \
                                     priority=10 -- \
    set Logical_Router_Port alice 'gateway_chassis=[@gc0,@gc1]'

nb_gwc1_uuid=`ovn-nbctl --bare --columns _uuid find Gateway_Chassis name="alice_gw1"`

# With the new ha_chassis_group table added, there should be no rows in
# gateway_chassis table in SB DB.
check_row_count Gateway_Chassis 0

# There should be one ha_chassis_group with the name "alice"
check_row_count HA_Chassis_Group 1 name=alice
ha_chgrp_uuid=$(fetch_column HA_Chassis_Group _uuid name=alice)
check_row_count Port_Binding 1 logical_port=cr-alice ha_chassis_group=$ha_chgrp_uuid

ha_ch=$(fetch_column HA_Chassis_Group ha_chassis name=alice)
check_column "$ha_ch" HA_Chassis _uuid

ovn-sbctl list ha_chassis_group

# Delete chassis - gw2 in SB DB.
# ovn-northd should not recreate ha_chassis rows
# repeatedly when gw2 is deleted.
ovn-sbctl chassis-del gw2

ha_ch_list=$(fetch_column HA_Chassis _uuid)
check_column "$ha_ch_list" HA_Chassis _uuid

# Add back the gw2 chassis
ovn-sbctl chassis-add gw2 geneve 1.2.4.8

# delete the 2nd Gateway_Chassis on NBDB for alice port
check_column '' Port_Binding gateway_chassis logical_port=cr-alice

ha_ch=$(fetch_column HA_Chassis_Group ha_chassis)
check_column "$ha_ch" HA_Chassis _uuid

# delete the 2nd Gateway_Chassis on NBDB for alice port
ovn-nbctl --wait=sb set Logical_Router_Port alice gateway_chassis=${nb_gwc1_uuid}

# There should be only 1 row in ha_chassis SB DB table.
check_row_count HA_Chassis 1
check_row_count Gateway_Chassis 0

# delete all the gateway_chassis on NBDB for alice port
ovn-nbctl --wait=sb clear Logical_Router_Port alice gateway_chassis

# expect that the ha_chassis doesn't exist anymore
check_row_count HA_Chassis 0
check_row_count Gateway_Chassis 0
check_row_count Ha_Chassis_Group 0

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check up state of VIF LSP])
ovn_start

ovn-nbctl ls-add S1
ovn-nbctl --wait=sb lsp-add S1 S1-vm1
wait_row_count nb:Logical_Switch_Port 1 name=S1-vm1 'up!=true'

ovn-sbctl chassis-add hv1 geneve 127.0.0.1
ovn-sbctl lsp-bind S1-vm1 hv1
wait_row_count nb:Logical_Switch_Port 1 name=S1-vm1 'up=true'

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check up state of router LSP linked to a distributed LR])
ovn_start

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01
ovn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1
AT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check up state of router LSP linked to a gateway LR])
ovn_start

ovn-sbctl chassis-add gw1 geneve 127.0.0.1

ovn-nbctl create Logical_Router name=R1 options:chassis=gw1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01
ovn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1

ovn-sbctl lsp-bind S1-R1 gw1
AT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check up state of router LSP linked to an LRP with set Gateway Chassis])
ovn_start

ovn-sbctl chassis-add gw1 geneve 127.0.0.1

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24
ovn-nbctl lrp-set-gateway-chassis R1-S1 gw1

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 router
ovn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1
AT_CHECK([test x`ovn-nbctl lsp-get-up S1-R1` = xup])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check Logical Router Port hosting-chassis status])
ovn_start

check ovn-sbctl chassis-add ch1 geneve 127.0.0.2

check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lrp1 00:00:00:00:00:01 10.0.0.1/24
check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 lsp1 -- \
    lsp-set-addresses lsp1 router -- \
    lsp-set-type lsp1 router -- \
    lsp-set-options lsp1 router-port=lrp1

# Make lrp a cr-port
check ovn-nbctl lrp-set-gateway-chassis lrp1 ch1

check ovn-nbctl --wait=sb sync

wait_row_count Port_Binding 1 logical_port=cr-lrp1 \
    options:always-redirect="true" options:distributed-port="lrp1"

# Simulate cr-port being bound to ch1
ch1_uuid=`ovn-sbctl --bare --columns _uuid find Chassis name="ch1"`
check ovn-sbctl set Port_Binding cr-lrp1 chassis=${ch1_uuid}

check ovn-nbctl --wait=sb sync

# Check for the hosting-chassis status being set by northd
wait_row_count nb:Logical_Router_Port 1 name=lrp1 status:hosting-chassis=ch1

# Clear the hosting-chassis status from LRP and assert northd repopulates it
check ovn-nbctl remove logical_router_port lrp1 status hosting-chassis
check ovn-nbctl --wait=sb sync
wait_row_count nb:Logical_Router_Port 1 name=lrp1 status:hosting-chassis=ch1

# Now remove the chassis from the port binding record and assert that the
# hosting-chassis status was removed by northd
check ovn-sbctl clear Port_Binding cr-lrp1 chassis
check ovn-nbctl --wait=sb sync

wait_row_count nb:Logical_Router_Port 0 name=lrp1 status:hosting-chassis=ch1

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check LRP external id propagation to SBDB])
ovn_start

ovn-nbctl lr-add ro
ovn-nbctl lrp-add ro lrp0 00:00:00:00:00:01 192.168.1.1/24
ovn-nbctl --wait=sb set logical_router_port lrp0 external_ids=test=123
check_column "test=123" sb:Port_Binding external_ids logical_port=lrp0

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check IPv6 RA config propagation to SBDB])
ovn_start

ovn-nbctl lr-add ro
ovn-nbctl lrp-add ro ro-sw 00:00:00:00:00:01 aef0:0:0:0:0:0:0:1/64
ovn-nbctl ls-add sw
ovn-nbctl lsp-add sw sw-ro
ovn-nbctl lsp-set-type sw-ro router
ovn-nbctl lsp-set-options sw-ro router-port=ro-sw
ovn-nbctl lsp-set-addresses sw-ro 00:00:00:00:00:01
ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:send_periodic=true
ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:address_mode=slaac
ovn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:mtu=1280

uuid=$(ovn-sbctl --columns=_uuid --bare find Port_Binding logical_port=ro-sw)

AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_send_periodic],
[0], ["true"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_address_mode],
[0], [slaac
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[0], ["600"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[0], ["200"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_mtu],
[0], ["1280"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_eth],
[0], ["00:00:00:00:00:01"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_addr],
[0], ["fe80::200:ff:fe00:1"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_prefixes],
[0], ["aef0::/64"
])

ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=300
ovn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=600

AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[0], ["300"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[0], ["225"
])

ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=300
ovn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=250

AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[0], ["300"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[0], ["225"
])

ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=0
ovn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=0

AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[0], ["4"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[0], ["3"
])

ovn-nbctl set Logical_Router_Port ro-sw ipv6_ra_configs:max_interval=3600
ovn-nbctl --wait=sb set Logical_Router_Port ro-sw ipv6_ra_configs:min_interval=2400

AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[0], ["1800"
])
AT_CHECK([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[0], ["1350"
])

ovn-nbctl --wait=sb set Logical_Router_port ro-sw ipv6_ra_configs:send_periodic=false

AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_send_periodic],
[1], [], [ovn-sbctl: no key "ipv6_ra_send_periodic" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_max_interval],
[1], [], [ovn-sbctl: no key "ipv6_ra_max_interval" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_min_interval],
[1], [], [ovn-sbctl: no key "ipv6_ra_min_interval" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_mtu],
[1], [], [ovn-sbctl: no key "ipv6_ra_mtu" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_address_mode],
[1], [], [ovn-sbctl: no key "ipv6_ra_address_mode" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_eth],
[1], [], [ovn-sbctl: no key "ipv6_ra_src_eth" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_src_addr],
[1], [], [ovn-sbctl: no key "ipv6_ra_src_addr" in Port_Binding record "${uuid}" column options
])
AT_CHECK_UNQUOTED([ovn-sbctl get Port_Binding ${uuid} options:ipv6_ra_prefixes],
[1], [], [ovn-sbctl: no key "ipv6_ra_prefixes" in Port_Binding record "${uuid}" column options
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([test unixctl])
ovn_init_db ovn-sb; ovn-sbctl init
ovn_init_db ovn-nb; ovn-nbctl init

# test unixctl option
mkdir "$ovs_base"/northd
as northd start_daemon NORTHD_TYPE --unixctl="$ovs_base"/northd/NORTHD_TYPE[].ctl --ovnnb-db=unix:"$ovs_base"/ovn-nb/ovn-nb.sock --ovnsb-db=unix:"$ovs_base"/ovn-sb/ovn-sb.sock
ovn-nbctl ls-add sw
ovn-nbctl --wait=sb lsp-add sw p1
# northd created with unixctl option successfully created port_binding entry
check_row_count Port_Binding 1 logical_port=p1
AT_CHECK([ovn-nbctl --wait=sb lsp-del p1])

# ovs-appctl exit with unixctl option
OVS_APP_EXIT_AND_WAIT_BY_TARGET(["$ovs_base"/northd/]NORTHD_TYPE[.ctl], ["$ovs_base"/northd/]NORTHD_TYPE[.pid])

# Check no port_binding entry for new port as ovn-northd is not running
#
# 142 is 128+14, the exit status that the shell reports when a
# process exits due to SIGARLM (signal 14).
ovn-nbctl lsp-add sw p2
AT_CHECK([ovn-nbctl --timeout=10 --wait=sb sync], [142], [], [ignore])
check_row_count Port_Binding 0 logical_port=p2

# test default unixctl path
as northd start_daemon NORTHD_TYPE --ovnnb-db=unix:"$ovs_base"/ovn-nb/ovn-nb.sock --ovnsb-db=unix:"$ovs_base"/ovn-sb/ovn-sb.sock
ovn-nbctl --wait=sb lsp-add sw p3
# northd created with default unixctl path successfully created port_binding entry
check_row_count Port_Binding 1 logical_port=p3

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])
as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])
as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check HA_Chassis_Group propagation from NBDB to SBDB])
ovn_start

check ovn-nbctl --wait=sb ha-chassis-group-add hagrp1

# ovn-northd should not create HA chassis group and HA chassis rows
# unless the HA chassis group in OVN NB DB is associated to
# a logical router port or logical port of type external.
check_row_count HA_Chassis_Group 0 name=hagrp1

check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 30
check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 20
check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch3 10

# There should be no HA_Chassis rows in SB DB.
check_row_count HA_Chassis 0

# Add chassis ch1.
check ovn-sbctl chassis-add ch1 geneve 127.0.0.2

wait_row_count Chassis 1 name=ch1

# There should be no HA_Chassis rows
check_row_count HA_Chassis 0

# Create a logical router port and attach ha chassis group.
check ovn-nbctl lr-add lr0
check ovn-nbctl --wait=sb lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24

hagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group name=hagrp1`
echo "hagrp1_uuid=$hagrp1_uuid"
check ovn-nbctl --wait=sb set logical_router_port lr0-public ha_chassis_group=$hagrp1_uuid

wait_row_count HA_Chassis_Group 1 name=hagrp1

check_row_count HA_Chassis 3

# ovn-northd has a weird history regarding HA_Chassis and missing
# Chassis records, see commit f879850b5f2c ("ovn-northd: Fix the
# HA_Chassis sync issue in OVN SB DB").
#
# Make sure that ovn-northd doesn't recreate the ha_chassis
# records if the chassis record is missing in SB DB.
ha_ch_list=$(fetch_column HA_Chassis _uuid)
check_column "$ha_ch_list" HA_Chassis _uuid

# 2 HA chassis should be created with 'chassis' column empty because
# we have not added hv1 and hv2 chassis to the SB DB.
check_row_count HA_Chassis 2 'chassis=[[]]'

# We should have 1 ha chassis with 'chassis' column set for hv1
check_row_count HA_Chassis 1 'chassis!=[[]]'

# Create another logical router port and associate to the same ha_chasis_group
check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lr1-public 00:00:20:20:12:14 182.168.0.100/24

check ovn-nbctl set logical_router_port lr1-public ha_chassis_group=$hagrp1_uuid

# We should still have 1 HA chassis group and 3 HA chassis in SB DB.
wait_row_count HA_Chassis_Group 1 name=hagrp1
check_row_count HA_Chassis 3

# Change the priority of ch1 - ha chassis in NB DB. It should get
# reflected in SB DB.
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 100

wait_row_count HA_Chassis 1 priority=100

# Delete ch1 HA chassis in NB DB.
ovn-nbctl --wait=sb ha-chassis-group-remove-chassis hagrp1 ch1

wait_row_count HA_Chassis 2

# Add back the ha chassis
ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 40
wait_row_count HA_Chassis 3

# Delete lr0-public. We should still have 1 HA chassis group and
# 3 HA chassis in SB DB.
ovn-nbctl --wait=sb lrp-del lr0-public

wait_row_count HA_Chassis_Group 1 name=hagrp1
wait_row_count HA_Chassis 3

# Delete lr1-public. There should be no HA chassis group in SB DB.
ovn-nbctl --wait=sb lrp-del lr1-public

wait_row_count HA_Chassis_Group 0 name=hagrp1
wait_row_count HA_Chassis 0

# Add lr0-public again
ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24
ovn-nbctl set logical_router_port lr0-public ha_chassis_group=$hagrp1_uuid

wait_row_count HA_Chassis_Group 1 name=hagrp1
wait_row_count HA_Chassis 3

# Create a Gateway chassis. ovn-northd should ignore this.
check ovn-nbctl --wait=sb lrp-set-gateway-chassis lr0-public ch1 20

# There should be only 1 HA chassis group in SB DB with the
# name hagrp1.
wait_row_count HA_Chassis_Group 1
wait_row_count HA_Chassis_Group 1 name=hagrp1
wait_row_count HA_Chassis 3

# Now delete HA chassis group. ovn-northd should create HA chassis group
# with the Gateway chassis name
ovn-nbctl clear logical_router_port lr0-public ha_chassis_group
ovn-nbctl ha-chassis-group-del hagrp1

wait_row_count HA_Chassis_Group 0 name=hagrp1
wait_row_count HA_Chassis_Group 1 name=lr0-public
wait_row_count HA_Chassis 1

ovn-nbctl lrp-set-gateway-chassis lr0-public ch2 10

wait_row_count HA_Chassis_Group 1 name=lr0-public

ovn-sbctl --bare --columns _uuid find ha_chassis
wait_row_count HA_Chassis 2

# Test if 'ref_chassis' column is properly set or not in
# SB DB ha_chassis_group.
check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1

check ovn-sbctl chassis-add ch2 geneve 127.0.0.3
check ovn-sbctl chassis-add ch3 geneve 127.0.0.4
check ovn-sbctl chassis-add comp1 geneve 127.0.0.5
check ovn-sbctl chassis-add comp2 geneve 127.0.0.6

check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:20:20:12:14 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 router
check ovn-nbctl --wait=sb lsp-set-options sw0-lr0 router-port=lr0-sw0

ovn-sbctl lsp-bind sw0-p1 comp1
wait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 up=true

comp1_ch_uuid=$(fetch_column Chassis _uuid name=comp1)
comp2_ch_uuid=$(fetch_column Chassis _uuid name=comp2)
ch2_ch_uuid=$comp1_ch_uuid

# Check ref_chassis.
echo "comp1_ch_uuid = $comp1_ch_uuid"
wait_column "$comp1_ch_uuid" HA_Chassis_Group ref_chassis

# unbind sw0-p1
ovn-sbctl lsp-unbind sw0-p1
wait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 up=false
wait_column "" HA_Chassis_Group ref_chassis

# Bind sw0-p1 in comp2
ovn-sbctl lsp-bind sw0-p1 comp2
wait_column "$comp2_ch_uuid" HA_Chassis_Group ref_chassis

ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lr-add lr1
ovn-nbctl lrp-add lr1 lr1-sw1 00:00:20:20:12:15 20.0.0.1/24
ovn-nbctl lsp-add sw1 sw1-lr1
ovn-nbctl lsp-set-type sw1-lr1 router
ovn-nbctl lsp-set-addresses sw1-lr1 router
check ovn-nbctl --wait=sb lsp-set-options sw1-lr1 router-port=lr1-sw1

# Bind sw1-p1 in comp1.
check ovn-sbctl lsp-bind sw1-p1 comp1
# Wait until sw1-p1 is up
wait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 up=true

# sw1-p1 is not connected to lr0. So comp1 should not be in 'ref_chassis'
wait_column "$comp2_ch_uuid" HA_Chassis_Group ref_chassis

# Now attach sw0 to lr1
check ovn-nbctl lrp-add lr1 lr1-sw0 00:00:20:20:12:16 10.0.0.10/24
check ovn-nbctl lsp-add sw0 sw0-lr1
check ovn-nbctl lsp-set-type sw0-lr1 router
check ovn-nbctl lsp-set-addresses sw0-lr1 router
check ovn-nbctl --wait=sb lsp-set-options sw0-lr1 router-port=lr1-sw0

# Both comp1 and comp2 should be in 'ref_chassis' as sw1 is indirectly
# connected to lr0
exp_ref_ch_list="$comp1_ch_uuid $comp2_ch_uuid"

wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# Unind sw1-p1. comp2 should not be in the ref_chassis.
ovn-sbctl lsp-unbind sw1-p1
wait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 up=false
wait_column "$comp2_ch_uuid" HA_Chassis_Group ref_chassis

# Create sw2 and attach it to lr2
check ovn-nbctl ls-add sw2
check ovn-nbctl lsp-add sw2 sw2-p1
check ovn-nbctl lr-add lr2
check ovn-nbctl lrp-add lr2 lr2-sw2 00:00:20:20:12:17 30.0.0.1/24
check ovn-nbctl lsp-add sw2 sw2-lr2
check ovn-nbctl lsp-set-type sw2-lr2 router
check ovn-nbctl lsp-set-addresses sw2-lr2 router
check ovn-nbctl --wait=sb lsp-set-options sw2-lr2 router-port=lr2-sw2

# Bind sw2-p1 to comp1
check ovn-sbctl lsp-bind sw2-p1 comp1
# Wait until sw2-p1 is up
wait_row_count nb:Logical_Switch_Port 1 name=sw2-p1 up=true

# sw2-p1 is not connected to lr0. So comp1 should not be in 'ref_chassis'
wait_column "$comp2_ch_uuid" HA_Chassis_Group ref_chassis

# Now attach sw1 to lr2. With this sw2-p1 is indirectly connected to lr0.
check ovn-nbctl lrp-add lr2 lr2-sw1 00:00:20:20:12:18 20.0.0.10/24
check ovn-nbctl lsp-add sw1 sw1-lr2
check ovn-nbctl lsp-set-type sw1-lr2 router
check ovn-nbctl lsp-set-addresses sw1-lr2 router
check ovn-nbctl --wait=sb lsp-set-options sw1-lr2 router-port=lr2-sw1

# sw2-p1 is indirectly connected to lr0. So comp1 (and comp2) should be in
# 'ref_chassis'
wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# Create sw0-p2 and bind it to comp1
check ovn-nbctl --wait=sb lsp-add sw0 sw0-p2
ovn-sbctl lsp-bind sw0-p2 comp1
wait_row_count nb:Logical_Switch_Port 1 name=sw0-p2 up=true
wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# unbind sw0-p2
ovn-sbctl lsp-unbind sw0-p2
wait_row_count nb:Logical_Switch_Port 1 name=sw0-p2 up=false
wait_column "$exp_ref_ch_list" HA_Chassis_Group ref_chassis

# Delete lr1-sw0. comp1 should be deleted from ref_chassis as there is no link
# from sw1 and sw2 to lr0.
check ovn-nbctl lrp-del lr1-sw0

wait_column "$comp2_ch_uuid" HA_Chassis_Group ref_chassis

# Delete one of the gateway chassises making the ha_chassis_group has only one
# chassis. In this case ref_chassis field should be empty for this
# ha_chassis_group. (ref_chassis is calculated only if there are more than 1
# chassises in the ha_chassis_group.
check ovn-nbctl --wait=sb lrp-del-gateway-chassis lr0-public ch2
wait_column "" HA_Chassis_Group ref_chassis

# Set redirect-chassis option to lr0-public. It should be ignored
# (because redirect-chassis is obsolete).
check ovn-nbctl set logical_router_port lr0-public options:redirect-chassis=ch1

wait_row_count HA_Chassis_Group 1
wait_row_count HA_Chassis_Group 1 name=lr0-public

wait_row_count HA_Chassis 1

# Delete the gateway chassis.
check ovn-nbctl clear logical_router_port lr0-public gateway_chassis

wait_row_count HA_Chassis_Group 0
check_row_count HA_Chassis 0

# Delete old sw0.
check ovn-nbctl --wait=sb ls-del sw0

# Create external logical ports and associate ha_chassis_group
check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-pext1
check ovn-nbctl lsp-add sw0 sw0-pext2
check ovn-nbctl lsp-add sw0 sw0-p1

check ovn-nbctl lsp-set-addresses sw0-pext1 "00:00:00:00:00:03 10.0.0.3"
check ovn-nbctl lsp-set-addresses sw0-pext2 "00:00:00:00:00:03 10.0.0.4"
check ovn-nbctl lsp-set-addresses sw0-p1 "00:00:00:00:00:03 10.0.0.5"

check ovn-nbctl --wait=sb ha-chassis-group-add hagrp1

check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch1 30
check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 20
check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch3 10

# ovn-northd should not create HA chassis group and HA chassis rows
# unless the HA chassis group in OVN NB DB is associated to
# a logical router port or logical port of type external.
wait_row_count HA_Chassis_Group 0
check_row_count HA_Chassis 0

hagrp1_uuid=`ovn-nbctl --bare --columns _uuid find ha_chassis_group \
name=hagrp1`

# The type of the lsp - sw0-pext1 is still not set to external.
# So ha_chassis_group should be ignored.
ovn-nbctl set logical_switch_port sw0-pext1 ha_chassis_group=$hagrp1_uuid

wait_row_count HA_Chassis_Group 0 name=hagrp1
check_row_count HA_Chassis 0

# Set the type of sw0-pext1 to external
ovn-nbctl lsp-set-type sw0-pext1 external

wait_row_count HA_Chassis_Group 1 name=hagrp1
check_row_count HA_Chassis 3

sb_hagrp1_uuid=`ovn-sbctl --bare --columns _uuid find ha_chassis_group \
name=hagrp1`

check_row_count Port_Binding 1 logical_port=sw0-pext1 ha_chassis_group=$sb_hagrp1_uuid

# Set the type of sw0-pext2 to external and associate ha_chassis_group
ovn-nbctl lsp-set-type sw0-pext2 external
ovn-nbctl set logical_switch_port sw0-pext2 ha_chassis_group=$hagrp1_uuid

wait_row_count HA_Chassis_Group 1 name=hagrp1
check_row_count HA_Chassis 3
check_row_count Port_Binding 1 logical_port=sw0-pext1 ha_chassis_group=$sb_hagrp1_uuid
wait_row_count Port_Binding 1 logical_port=sw0-pext2 ha_chassis_group=$sb_hagrp1_uuid

# sw0-p1 is a normal port. So ha_chassis_group should not be set
# in port_binding.
ovn-nbctl --wait=sb set logical_switch_port sw0-p1 \
ha_chassis_group=$hagrp1_uuid

wait_row_count Port_Binding 0 logical_port=sw0-p1 'chassis!=[[]]'

# Clear ha_chassis_group for sw0-pext1
check ovn-nbctl --wait=sb clear logical_switch_port sw0-pext1 ha_chassis_group

wait_row_count Port_Binding 0 logical_port=sw0-pext1 'chassis!=[[]]'

wait_row_count HA_Chassis_Group 1 name=hagrp1
wait_row_count HA_Chassis 3

AS_BOX([Clear ha_chassis_group for sw0-pext2 and reset port type to normal in the same txn])

check ovn-nbctl  --wait=sb clear logical_switch_port sw0-pext2 \
ha_chassis_group -- set logical_switch_port sw0-pext2 'type=""'
wait_row_count HA_Chassis_Group 0
wait_row_count Port_Binding 0 logical_port=sw0-pext2 'chassis!=[[]]'
check_row_count HA_Chassis 0

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])
as ovn-nb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])
as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ovn-northd pause and resume])
# By starting the backup northd paused, we ensure that the primary
# northd is active; otherwise, there's a race.  (We also test that
# the ovn-northd --dry-run option works.)
ovn_start --backup-northd=paused

get_northd_status() {
    as northd ovn-appctl -t NORTHD_TYPE is-paused
    as northd ovn-appctl -t NORTHD_TYPE status
    as northd-backup ovn-appctl -t NORTHD_TYPE is-paused
    as northd-backup ovn-appctl -t NORTHD_TYPE status
}

AS_BOX([Check that the backup is paused])
OVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false
Status: active
true
Status: paused
])

AS_BOX([Resume the backup])
check as northd-backup ovs-appctl -t NORTHD_TYPE resume
OVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false
Status: active
false
Status: standby
])

AS_BOX([Check that ovn-northd is active])
# Check that ovn-northd is active, by verifying that it creates and
# destroys southbound datapaths as one would expect.
check_row_count Datapath_Binding 0
check ovn-nbctl --wait=sb ls-add sw0
check_row_count Datapath_Binding 1
check ovn-nbctl --wait=sb ls-del sw0
check_row_count Datapath_Binding 0

AS_BOX([Pause the main northd])
check as northd ovs-appctl -t NORTHD_TYPE pause
check as northd-backup ovs-appctl -t NORTHD_TYPE pause
AT_CHECK([get_northd_status], [0], [true
Status: paused
true
Status: paused
])

AS_BOX([Verify that ovn-northd is paused])
# Now ovn-northd won't respond by adding a datapath, because it's paused.
check ovn-nbctl ls-add sw0
check sleep 5
check_row_count Datapath_Binding 0

# Do not resume both main and backup right after each other
# as there would be no guarentee of which one would become active
AS_BOX([Resume the main northd])
check as northd ovs-appctl -t NORTHD_TYPE resume
OVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false
Status: active
true
Status: paused
])

AS_BOX([Resume the backup northd])
check as northd-backup ovs-appctl -t NORTHD_TYPE resume
OVS_WAIT_FOR_OUTPUT([get_northd_status], [0], [false
Status: active
false
Status: standby
])

check ovn-nbctl --wait=sb sync
check_row_count Datapath_Binding 1

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ovn-northd restart])
ovn_start --backup-northd=none

# Check that ovn-northd is active, by verifying that it creates and
# destroys southbound datapaths as one would expect.
check_row_count Datapath_Binding 0
check ovn-nbctl --wait=sb ls-add sw0
check_row_count Datapath_Binding 1

# Kill northd.
as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

# With ovn-northd gone, changes to nbdb won't be reflected into sbdb.
# Make sure.
check ovn-nbctl ls-add sw1
sleep 5
check_row_count Datapath_Binding 1

# Now resume ovn-northd.  Changes should catch up.
ovn_start_northd primary
wait_row_count Datapath_Binding 2

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([northbound database reconnection])

ovn_start --backup-northd=none

# Check that ovn-northd is active, by verifying that it creates and
# destroys southbound datapaths as one would expect.
check_row_count Datapath_Binding 0
check ovn-nbctl --wait=sb ls-add sw0
check_row_count Datapath_Binding 1
dp1=$(fetch_column Datapath_Binding _uuid external_ids:name=sw0)

# Make nbdb ovsdb-server drop connection from ovn-northd.
conn=$(as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/list-remotes|grep ^punix)
check as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/remove-remote "$conn"
conn2=punix:`pwd`/special.sock
check as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/add-remote "$conn2"

# ovn-northd won't respond to changes (because the nbdb connection dropped).
check ovn-nbctl --db="${conn2#p}" ls-add sw1
sleep 5
check_row_count Datapath_Binding 1

# Now re-enable the nbdb connection and observe ovn-northd catch up.
check as ovn-nb ovs-appctl -t ovsdb-server ovsdb-server/add-remote "$conn"
wait_row_count Datapath_Binding 2
dp2=$(fetch_column Datapath_Binding _uuid external_ids:name=sw1)
wait_column "$dp1 $dp2" Logical_DP_Group datapaths

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([southbound database reconnection])

ovn_start --backup-northd=none

# Check that ovn-northd is active, by verifying that it creates and
# destroys southbound datapaths as one would expect.
check_row_count Datapath_Binding 0
check ovn-nbctl --wait=sb ls-add sw0
check_row_count Datapath_Binding 1
dp1=$(fetch_column Datapath_Binding _uuid external_ids:name=sw0)

# Make sbdb ovsdb-server drop connection from ovn-northd.
conn=$(as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/list-remotes|grep ^punix)
check as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/remove-remote "$conn"
conn2=punix:`pwd`/special.sock
check as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/add-remote "$conn2"

# ovn-northd can't respond to changes (because the sbdb connection dropped).
check ovn-nbctl ls-add sw1
sleep 5
OVN_SB_DB=${conn2#p} check_row_count Datapath_Binding 1

# Now re-enable the sbdb connection and observe ovn-northd catch up.
#
# It's important to check both Datapath_Binding and Logical_Flow.
check as ovn-sb ovs-appctl -t ovsdb-server ovsdb-server/add-remote "$conn"
wait_row_count Datapath_Binding 2
dp2=$(fetch_column Datapath_Binding _uuid external_ids:name=sw1)
wait_column "$dp1 $dp2" Logical_DP_Group datapaths

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check Redirect Chassis propagation from NB to SB])
ovn_start

ovn-sbctl chassis-add gw1 geneve 127.0.0.1

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 router
ovn-nbctl lsp-set-options S1-R1 router-port=R1-S1

check ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1

ovn-nbctl lrp-set-redirect-type R1-S1 bridged
wait_row_count Port_Binding 1 logical_port=cr-R1-S1 options:redirect-type=bridged

ovn-nbctl lrp-set-redirect-type R1-S1 overlay
wait_row_count Port_Binding 1 logical_port=cr-R1-S1 options:redirect-type=overlay
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check stateless dnat_and_snat rule])
ovn_start

ovn-sbctl chassis-add gw1 geneve 127.0.0.1

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 router
ovn-nbctl lsp-set-options S1-R1 router-port=R1-S1

check ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1

check_flow_matches() {
    local regex=$1 count=$2
    local found=$(grep -c "$1" r1-flows)
    echo "checking for $count flows matching $regex... found $found"
    AT_FAIL_IF([test $found != $count])
}

check_flow_match_sets() {
    ovn-sbctl dump-flows R1 > r1-flows
    AT_CAPTURE_FILE([r1-flows])

    for regex in lr_in_unsnat ct_snat ct_dnat ip4.dst= ip4.src= ip6.dst= ip6.src=; do
        check_flow_matches $regex $1
        shift
    done
}

echo
echo "IPv4: stateful"
ovn-nbctl --wait=sb lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11
check_flow_match_sets 2 2 2 0 0 0 0
ovn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1

echo
echo "IPv4: stateless"
ovn-nbctl --wait=sb --stateless lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11
check_flow_match_sets 2 0 0 1 1 0 0
ovn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1

echo
echo "IPv6: stateful"
ovn-nbctl --wait=sb lr-nat-add R1 dnat_and_snat fd01::1 fd11::2
check_flow_match_sets 2 2 2 0 0 0 0
ovn-nbctl lr-nat-del R1 dnat_and_snat  fd01::1

echo
echo "IPv6: stateless"
ovn-nbctl --wait=sb --stateless lr-nat-add R1 dnat_and_snat fd01::1 fd11::2
check_flow_match_sets 2 0 0 0 0 1 1

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check portrange dnat, snat and dnat_and_snat rules])
ovn_start

ovn-sbctl chassis-add gw1 geneve 127.0.0.1

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 router
ovn-nbctl lsp-set-options S1-R1 router-port=R1-S1

check ovn-nbctl --wait=sb lrp-set-gateway-chassis R1-S1 gw1

uuid=`ovn-sbctl --columns=_uuid --bare find Port_Binding logical_port=cr-R1-S1`
echo "CR-LRP UUID is: " $uuid

# IPV4
ovn-nbctl --portrange lr-nat-add R1 dnat_and_snat  172.16.1.1 50.0.0.11 1-3000

AT_CAPTURE_FILE([sbflows])
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows && test 2 = `grep -c lr_in_unsnat sbflows`])
AT_CHECK([grep -c 'ct_snat.*3000' sbflows && grep -c 'ct_dnat.*3000' sbflows],
  [0], [1
1
])

ovn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1
ovn-nbctl --wait=sb --portrange lr-nat-add R1 snat  172.16.1.1 50.0.0.11 1-3000

AT_CAPTURE_FILE([sbflows2])
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows2 && test 2 = `grep -c lr_in_unsnat sbflows`])
AT_CHECK([grep -c 'ct_snat.*3000' sbflows2 && grep -c 'ct_dnat.*3000' sbflows2],
  [1], [1
0
])

ovn-nbctl lr-nat-del R1 snat  172.16.1.1
ovn-nbctl --wait=sb --portrange --stateless lr-nat-add R1 dnat_and_snat  172.16.1.2 50.0.0.12 1-3000

AT_CAPTURE_FILE([sbflows3])
OVS_WAIT_UNTIL([ovn-sbctl dump-flows R1 > sbflows3 && test 3 = `grep -c lr_in_unsnat sbflows3`])
AT_CHECK([grep 'ct_[s]dnat.*172\.16\.1\.2.*3000' sbflows3], [1])

ovn-nbctl lr-nat-del R1 dnat_and_snat  172.16.1.1

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check allowed/disallowed external dnat, snat and dnat_and_snat rules])
ovn_start

# Logical network:
# 2 LRs - CR and DR
# CR ==> Centralized router
# DR ==> Distributed router
#
# DR is connected to S1 and CR is connected to S2

check ovn-sbctl chassis-add gw1 geneve 127.0.0.1

check ovn-nbctl lr-add DR
check ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24

cr_uuid=$(ovn-nbctl create Logical_Router name=CR)
check ovn-nbctl lrp-add CR CR-S2 02:ac:10:01:00:01 172.16.1.1/24

check ovn-nbctl ls-add S1
check ovn-nbctl lsp-add S1 S1-DR
check ovn-nbctl lsp-set-type S1-DR router
check ovn-nbctl lsp-set-addresses S1-DR router
check ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1

check ovn-nbctl ls-add S2
check ovn-nbctl lsp-add S2 S2-CR
check ovn-nbctl lsp-set-type S2-CR router
check ovn-nbctl lsp-set-addresses S2-CR router
check ovn-nbctl --wait=sb lsp-set-options S2-CR router-port=CR-S2

check ovn-nbctl lrp-set-gateway-chassis DR-S1 gw1

uuid=$(fetch_column Port_Binding _uuid logical_port=cr-DR-S1)
echo "CR-LRP UUID is: " $uuid

check ovn-nbctl set Logical_Router $cr_uuid options:chassis=gw1
check ovn-nbctl --wait=sb sync

ovn-nbctl create Address_Set name=allowed_range addresses=\"1.1.1.1\"
ovn-nbctl create Address_Set name=disallowed_range addresses=\"2.2.2.2\"

# SNAT with ALLOWED_IPs
check ovn-nbctl lr-nat-add DR snat  172.16.1.1 50.0.0.11
check ovn-nbctl lr-nat-update-ext-ip DR snat 50.0.0.11 allowed_range

check ovn-nbctl lr-nat-add CR snat  172.16.1.1 50.0.0.11
check ovn-nbctl lr-nat-update-ext-ip CR snat 50.0.0.11 allowed_range

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows DR > drflows
AT_CAPTURE_FILE([drflows])
ovn-sbctl dump-flows CR > crflows
AT_CAPTURE_FILE([crflows])

AT_CHECK([grep -e "lr_out_snat" drflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1") && ip4.dst == $allowed_range), action=(ct_snat(172.16.1.1);)
])

AT_CHECK([grep -e "lr_out_snat" crflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $allowed_range && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.1);)
])


# SNAT with DISALLOWED_IPs
check ovn-nbctl lr-nat-del DR snat  50.0.0.11
check ovn-nbctl lr-nat-del CR snat  50.0.0.11

check ovn-nbctl lr-nat-add DR snat  172.16.1.1 50.0.0.11
check ovn-nbctl lr-nat-add CR snat  172.16.1.1 50.0.0.11

check ovn-nbctl --is-exempted lr-nat-update-ext-ip DR snat 50.0.0.11 disallowed_range
check ovn-nbctl --is-exempted lr-nat-update-ext-ip CR snat 50.0.0.11 disallowed_range

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows DR > drflows2
AT_CAPTURE_FILE([drflows2])
ovn-sbctl dump-flows CR > crflows2
AT_CAPTURE_FILE([crflows2])

AT_CHECK([grep -e "lr_out_snat" drflows2 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ct_snat(172.16.1.1);)
  table=??(lr_out_snat        ), priority=163  , match=(ip && ip4.src == 50.0.0.11 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1") && ip4.dst == $disallowed_range), action=(next;)
])

AT_CHECK([grep -e "lr_out_snat" crflows2 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.1);)
  table=??(lr_out_snat        ), priority=35   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $disallowed_range), action=(next;)
])

# Stateful FIP with ALLOWED_IPs
check ovn-nbctl lr-nat-del DR snat  50.0.0.11
check ovn-nbctl lr-nat-del CR snat  50.0.0.11

check ovn-nbctl lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11
check ovn-nbctl lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11

check ovn-nbctl lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 allowed_range
check ovn-nbctl --wait=sb lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 allowed_range

ovn-sbctl dump-flows DR > drflows3
AT_CAPTURE_FILE([drflows2])
ovn-sbctl dump-flows CR > crflows3
AT_CAPTURE_FILE([crflows2])

AT_CHECK([grep -e "lr_out_snat" drflows3 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1") && ip4.dst == $allowed_range), action=(ct_snat(172.16.1.2);)
])

AT_CHECK([grep -e "lr_out_snat" crflows3 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $allowed_range && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.2);)
])

# Stateful FIP with DISALLOWED_IPs
ovn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2
ovn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2

ovn-nbctl lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11
ovn-nbctl lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11

ovn-nbctl --is-exempted lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 disallowed_range
check ovn-nbctl --wait=sb --is-exempted lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 disallowed_range

ovn-sbctl dump-flows DR > drflows4
AT_CAPTURE_FILE([drflows2])
ovn-sbctl dump-flows CR > crflows4
AT_CAPTURE_FILE([crflows2])

AT_CHECK([grep -e "lr_out_snat" drflows4 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ct_snat(172.16.1.2);)
  table=??(lr_out_snat        ), priority=163  , match=(ip && ip4.src == 50.0.0.11 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1") && ip4.dst == $disallowed_range), action=(next;)
])

AT_CHECK([grep -e "lr_out_snat" crflows4 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.16.1.2);)
  table=??(lr_out_snat        ), priority=35   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $disallowed_range), action=(next;)
])

# Stateless FIP with DISALLOWED_IPs
ovn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2
ovn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2

ovn-nbctl --stateless lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11
ovn-nbctl --stateless lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11

ovn-nbctl lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 allowed_range
check ovn-nbctl --wait=sb lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 allowed_range

ovn-sbctl dump-flows DR > drflows5
AT_CAPTURE_FILE([drflows2])
ovn-sbctl dump-flows CR > crflows5
AT_CAPTURE_FILE([crflows2])

AT_CHECK([grep -e "lr_out_snat" drflows5 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1") && ip4.dst == $allowed_range), action=(ip4.src=172.16.1.2; next;)
])

AT_CHECK([grep -e "lr_out_snat" crflows5 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $allowed_range), action=(ip4.src=172.16.1.2; next;)
])

# Stateful FIP with DISALLOWED_IPs
ovn-nbctl lr-nat-del DR dnat_and_snat  172.16.1.2
ovn-nbctl lr-nat-del CR dnat_and_snat  172.16.1.2

ovn-nbctl --stateless lr-nat-add DR dnat_and_snat  172.16.1.2 50.0.0.11
ovn-nbctl --stateless lr-nat-add CR dnat_and_snat  172.16.1.2 50.0.0.11

ovn-nbctl --is-exempted lr-nat-update-ext-ip DR dnat_and_snat 172.16.1.2 disallowed_range
ovn-nbctl --is-exempted lr-nat-update-ext-ip CR dnat_and_snat 172.16.1.2 disallowed_range

ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows DR > drflows6
AT_CAPTURE_FILE([drflows2])
ovn-sbctl dump-flows CR > crflows6
AT_CAPTURE_FILE([crflows2])

AT_CHECK([grep -e "lr_out_snat" drflows6 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 50.0.0.11 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ip4.src=172.16.1.2; next;)
  table=??(lr_out_snat        ), priority=163  , match=(ip && ip4.src == 50.0.0.11 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1") && ip4.dst == $disallowed_range), action=(next;)
])

AT_CHECK([grep -e "lr_out_snat" crflows6 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=??(lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=??(lr_out_snat        ), priority=33   , match=(ip && ip4.src == 50.0.0.11), action=(ip4.src=172.16.1.2; next;)
  table=??(lr_out_snat        ), priority=35   , match=(ip && ip4.src == 50.0.0.11 && ip4.dst == $disallowed_range), action=(next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check Load balancer health check and Service Monitor sync])
ovn_start NORTHD_TYPE
check ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80

check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1
check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1

wait_row_count Service_Monitor 0

AT_CHECK([ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer . \
health_check @hc | uuidfilt], [0], [<0>
])

wait_row_count Service_Monitor 0

AS_BOX([create logical switches and ports])
ovn-nbctl ls-add sw0
ovn-nbctl --wait=sb lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 \
"00:00:00:00:00:03 10.0.0.3"

wait_row_count Service_Monitor 0

ovn-nbctl ls-add sw1
ovn-nbctl --wait=sb lsp-add sw1 sw1-p1 -- lsp-set-addresses sw1-p1 \
"02:00:00:00:00:03 20.0.0.3"

# service_monitors state online requires corresponding port_binding to be "up"
ovn-sbctl chassis-add hv1 geneve 127.0.0.1 -- \
    set chassis hv1 other_config:ct-no-masked-label=true
ovn-sbctl lsp-bind sw0-p1 hv1
ovn-sbctl lsp-bind sw1-p1 hv1
wait_row_count nb:Logical_Switch_Port 1 name=sw0-p1 'up=true'
wait_row_count nb:Logical_Switch_Port 1 name=sw1-p1 'up=true'

wait_row_count Service_Monitor 0

ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
wait_row_count Service_Monitor 1

ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2
wait_row_count Service_Monitor 2

check ovn-nbctl --wait=sb ls-lb-add sw0 lb1

AT_CAPTURE_FILE([sbflows])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows | grep 'priority=120.*backends' | sed 's/table=..//'], 0, [dnl
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80);)
])

# disabled LSPs should not be a backend of Load Balancer
check ovn-nbctl lsp-set-enabled sw0-p1 disabled

AT_CAPTURE_FILE([sbflows])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows | grep 'priority=120.*backends' | sed 's/table=..//'], 0, [dnl
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=20.0.0.3:80);)
])
wait_row_count Service_Monitor 1

check ovn-nbctl lsp-set-enabled sw0-p1 enabled

AT_CAPTURE_FILE([sbflows])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows | grep 'priority=120.*backends' | sed 's/table=..//'], 0, [dnl
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80);)
])
wait_row_count Service_Monitor 2

AS_BOX([Delete the Load_Balancer_Health_Check])
ovn-nbctl --wait=sb clear load_balancer . health_check
wait_row_count Service_Monitor 0

AT_CAPTURE_FILE([sbflows2])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows2 | grep 'priority=120.*backends' | sed 's/table=..//'], [0],
[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80);)
])

AS_BOX([Create the Load_Balancer_Health_Check again.])
ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer . \
health_check @hc
wait_row_count Service_Monitor 2
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows sw0 | grep backends | grep priority=120 > lflows.txt
AT_CHECK([cat lflows.txt | sed 's/table=..//'], [0], [dnl
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80);)
])

AS_BOX([Get the uuid of both the service_monitor])
sm_sw0_p1=$(fetch_column Service_Monitor _uuid logical_port=sw0-p1)
sm_sw1_p1=$(fetch_column Service_Monitor _uuid logical_port=sw1-p1)

AT_CAPTURE_FILE([sbflows3])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows 3 | grep 'priority=120.*backends' | sed 's/table=..//'], [0],
[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80);)
])

AS_BOX([Set the service monitor for sw1-p1 to offline])
check ovn-sbctl set service_monitor sw1-p1 status=offline
wait_row_count Service_Monitor 1 logical_port=sw1-p1 status=offline
check ovn-nbctl --wait=sb sync

AT_CAPTURE_FILE([sbflows4])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows4 | grep 'priority=120.*backends' | sed 's/table=..//'], [0],
[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80);)
])

AS_BOX([Set the service monitor for sw0-p1 to offline])
ovn-sbctl set service_monitor $sm_sw0_p1 status=offline

wait_row_count Service_Monitor 1 logical_port=sw0-p1 status=offline
check ovn-nbctl --wait=sb sync

AT_CAPTURE_FILE([sbflows5])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows5 | grep 'priority=120.*backends'], 1)

AT_CAPTURE_FILE([sbflows6])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows6 | grep "ip4.dst == 10.0.0.10 && tcp.dst == 80" | grep priority=120 | grep ls_in_lb | sed 's/table=..//'], [0], [dnl
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(drop;)
])

AS_BOX([Set the service monitor for sw0-p1 and sw1-p1 to online])
ovn-sbctl set service_monitor $sm_sw0_p1 status=online
ovn-sbctl set service_monitor $sm_sw1_p1 status=online

wait_row_count Service_Monitor 1 logical_port=sw1-p1 status=online
check ovn-nbctl --wait=sb sync

AT_CAPTURE_FILE([sbflows7])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows7 | grep backends | grep priority=120 | sed 's/table=..//'], 0,
[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80);)
])

AS_BOX([Set the service monitor for sw1-p1 to error])
ovn-sbctl set service_monitor $sm_sw1_p1 status=error
wait_row_count Service_Monitor 1 logical_port=sw1-p1 status=error
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows sw0 | grep "ip4.dst == 10.0.0.10 && tcp.dst == 80" \
| grep priority=120 > lflows.txt
AT_CHECK([cat lflows.txt | grep ls_in_lb | sed 's/table=..//'], [0], [dnl
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80);)
])

AS_BOX([Add one more vip to lb1])
check ovn-nbctl set load_balancer . vip:10.0.0.40\\:1000=10.0.0.3:1000,20.0.0.3:80

AS_BOX([create health_check for new vip - 10.0.0.40])
AT_CHECK(
  [ovn-nbctl --wait=sb \
          -- --id=@hc create Load_Balancer_Health_Check vip=10.0.0.40\\:1000 \
          -- add Load_Balancer . health_check @hc | uuidfilt], [0], [<0>
])

# There should be totally 3 rows in service_monitor for -
#    * 10.0.0.3:80
#    * 10.0.0.3:1000
#    * 20.0.0.3:80

wait_row_count Service_Monitor 3
wait_row_count Service_Monitor 2 logical_port=sw0-p1
wait_row_count Service_Monitor 1 port=1000

AT_CAPTURE_FILE([sbflows9])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows9 | grep backends | grep priority=120 | sed 's/table=..//' | sort],
  0,
[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80);)
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:1000);)
])

AS_BOX([Set the service monitor for sw1-p1 to online])
check ovn-sbctl set service_monitor sw1-p1 status=online

wait_row_count Service_Monitor 1 logical_port=sw1-p1 status=online
check ovn-nbctl --wait=sb sync

AT_CAPTURE_FILE([sbflows10])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows10 | grep backends | grep priority=120 | sed 's/table=..//' | sort],
  0,
[  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80);)
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:1000,20.0.0.3:80);)
])

AS_BOX([Associate lb1 to sw1])
check ovn-nbctl --wait=sb ls-lb-add sw1 lb1
AT_CAPTURE_FILE([sbflows11])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw1 | tee sbflows11 | grep backends | grep priority=120 | sed 's/table=..//' | sort],
  0, [dnl
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:80,20.0.0.3:80);)
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.40 && tcp.dst == 1000), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.3:1000,20.0.0.3:80);)
])

AS_BOX([Now create lb2 same as lb1 but udp protocol.])
check ovn-nbctl lb-add lb2 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80 udp
check ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
check ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2

AT_CHECK([ovn-nbctl -- --id=@hc create Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer lb2 health_check @hc | uuidfilt],
         [0], [<0>
])

check ovn-nbctl ls-lb-add sw0 lb2
check ovn-nbctl ls-lb-add sw1 lb2
check ovn-nbctl --wait=sb sync

wait_row_count Service_Monitor 5

AS_BOX([Change the svc_monitor_mac.])
# This should get reflected in service_monitor table rows.
check ovn-nbctl set NB_Global . options:svc_monitor_mac="fe:a0:65:a2:01:03"

wait_row_count Service_Monitor 5 src_mac='"fe:a0:65:a2:01:03"'

AS_BOX([Change the source ip for 10.0.0.3 backend ip in lb2])
check ovn-nbctl --wait=sb set load_balancer lb2 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.100

wait_row_count Service_Monitor 1 logical_port=sw0-p1 src_ip=10.0.0.100

ovn-nbctl --wait=sb lb-del lb1
wait_row_count Service_Monitor 2

ovn-nbctl --wait=sb lb-del lb2
wait_row_count Service_Monitor 0

check ovn-nbctl --reject lb-add lb3 10.0.0.10:80 10.0.0.3:80,20.0.0.3:80
check ovn-nbctl --wait=sb set load_balancer lb3 ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
check ovn-nbctl --wait=sb set load_balancer lb3 ip_port_mappings:20.0.0.3=sw1-p1:20.0.0.2
wait_row_count Service_Monitor 0

check ovn-nbctl --wait=sb ls-lb-add sw0 lb3
AT_CHECK([ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="10.0.0.10\:80" -- add Load_Balancer lb3 \
health_check @hc | uuidfilt], [0], [<0>
])
wait_row_count Service_Monitor 2

# Set the service monitor for sw0-p1 and sw1-p1 to online
sm_sw0_p1=$(fetch_column Service_Monitor _uuid logical_port=sw0-p1)
sm_sw1_p1=$(fetch_column Service_Monitor _uuid logical_port=sw1-p1)

ovn-sbctl set service_monitor $sm_sw0_p1 status=offline
ovn-sbctl set service_monitor $sm_sw1_p1 status=offline

AT_CAPTURE_FILE([sbflows12])
OVS_WAIT_FOR_OUTPUT(
  [ovn-sbctl dump-flows sw0 | tee sbflows12 | grep "ip4.dst == 10.0.0.10 && tcp.dst == 80" | grep priority=120 | grep ls_in_lb | sed 's/table=..//'], [0], [dnl
  (ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=6);};)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Load balancer VIP in NAT entries])
AT_SKIP_IF([test $HAVE_PYTHON = no])
ovn_start

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-public 00:00:01:01:02:04 192.168.2.1/24
check ovn-nbctl lrp-add lr0 lr0-join 00:00:01:01:02:04 10.10.0.1/24

check ovn-nbctl set logical_router lr0 options:chassis=ch1

check ovn-nbctl lb-add lb1 "192.168.2.1:8080" "10.0.0.4:8080"
check ovn-nbctl lb-add lb2 "192.168.2.4:8080" "10.0.0.5:8080" udp
check ovn-nbctl lb-add lb3 "192.168.2.5:8080" "10.0.0.6:8080"
check ovn-nbctl lb-add lb4 "192.168.2.6:8080" "10.0.0.7:8080"

check ovn-nbctl lr-lb-add lr0 lb1
check ovn-nbctl lr-lb-add lr0 lb2
check ovn-nbctl lr-lb-add lr0 lb3
check ovn-nbctl lr-lb-add lr0 lb4

check ovn-nbctl lr-nat-add lr0 snat 192.168.2.1 10.0.0.0/24
check ovn-nbctl lr-nat-add lr0 dnat_and_snat 192.168.2.4 10.0.0.4
check ovn-nbctl --wait=sb lr-nat-add lr0 dnat 192.168.2.5 10.0.0.5

ovn-sbctl dump-flows lr0 > sbflows
AT_CAPTURE_FILE([sbflows])

# There should be no flows for LB VIPs in lr_in_unsnat if the VIP is not a
# dnat_and_snat or snat entry.
AT_CHECK([grep "lr_in_unsnat" sbflows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.1 && tcp && tcp.dst == 8080), action=(next;)
  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.4 && udp && udp.dst == 8080), action=(next;)
  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.5 && tcp && tcp.dst == 8080), action=(next;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.4), action=(ct_snat;)
])

AS_BOX([Check behavior with LB Groups])
check ovn-nbctl lr-lb-del lr0 lb1
check ovn-nbctl lr-lb-del lr0 lb2
check ovn-nbctl lr-lb-del lr0 lb3
check ovn-nbctl lr-lb-del lr0 lb4

lb1=$(fetch_column nb:load_balancer _uuid name=lb1)
lb2=$(fetch_column nb:load_balancer _uuid name=lb2)
lb3=$(fetch_column nb:load_balancer _uuid name=lb3)
lb4=$(fetch_column nb:load_balancer _uuid name=lb4)

lbg=$(ovn-nbctl create load_balancer_group name=lbg -- \
  add load_balancer_group lbg load_balancer $lb1 -- \
  add load_balancer_group lbg load_balancer $lb2 -- \
  add load_balancer_group lbg load_balancer $lb3 -- \
  add load_balancer_group lbg load_balancer $lb4)

check ovn-nbctl --wait=sb add logical_router lr0 load_balancer_group $lbg

ovn-sbctl dump-flows lr0 > sbflows
AT_CAPTURE_FILE([sbflows])

# There should be no flows for LB VIPs in lr_in_unsnat if the VIP is not a
# dnat_and_snat or snat entry.
AT_CHECK([grep "lr_in_unsnat" sbflows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.1 && tcp && tcp.dst == 8080), action=(next;)
  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.4 && udp && udp.dst == 8080), action=(next;)
  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 192.168.2.5 && tcp && tcp.dst == 8080), action=(next;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 192.168.2.4), action=(ct_snat;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([LRP same IP as VIP or SNAT])
ovn_start

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-public 00:00:00:00:00:10 192.168.0.1/24 2000::1/64
check ovn-nbctl --wait=sb lrp-add lr0 lr0-join 00:00:00:00:00:20 10.10.0.1/24 192.168.1.1/24

ovn-sbctl dump-flows lr0 > sbflows
AT_CAPTURE_FILE([sbflows])

# There should be drop lflows for all IPs of both LRPs
AT_CHECK([grep "lr_in_ip_input" sbflows | grep 'ip.\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl
  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {2000::1, fe80::200:ff:fe00:10}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)
])

# create SNAT with external IP equal to LRP's IP
check ovn-nbctl --wait=sb lr-nat-add lr0 snat 192.168.0.1 10.10.0.0/24

ovn-sbctl dump-flows lr0 > sbflows
AT_CAPTURE_FILE([sbflows])

# There should be no drop lflow for 192.168.0.1
AT_CHECK([grep "lr_in_ip_input" sbflows | grep 'ip.\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl
  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {2000::1, fe80::200:ff:fe00:10}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)
])

check ovn-nbctl lr-nat-del lr0

# create SNAT with external IPv6 equal to LRP's IPv6
check ovn-nbctl --wait=sb lr-nat-add lr0 snat 2000::1 2aaa::/64
ovn-nbctl show lr0

ovn-sbctl dump-flows lr0 > sbflows
AT_CAPTURE_FILE([sbflows])

# There should be no drop lflow for 2000::1
AT_CHECK([grep "lr_in_ip_input" sbflows | grep 'ip.\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl
  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:10}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)
])

check ovn-nbctl lr-nat-del lr0

# create LB with VIP equal to LRP's IP and assign it to LR
check ovn-nbctl lb-add lb1 "192.168.1.1:8080" "10.0.0.4:8080"
check ovn-nbctl --wait=sb lr-lb-add lr0 lb1

ovn-sbctl dump-flows lr0 > sbflows
AT_CAPTURE_FILE([sbflows])

# There should be no drop lflow for 192.168.1.1
AT_CHECK([grep "lr_in_ip_input" sbflows | grep 'ip.\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl
  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {2000::1, fe80::200:ff:fe00:10}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)
])

check ovn-nbctl lb-del lb1

# create LB with VIP equal to LRP's IPv6 and assign it to LR
check ovn-nbctl lb-add lb1 [[2000::1]]:8080 [[2aaa::10]]:8080
check ovn-nbctl --wait=sb lr-lb-add lr0 lb1

ovn-sbctl dump-flows lr0 > sbflows
AT_CAPTURE_FILE([sbflows])

# There should be no drop lflow for 2000::1
AT_CHECK([grep "lr_in_ip_input" sbflows | grep 'ip.\.dst == {' | grep drop | sed 's/table=../table=??/g' | sort], [0], [dnl
  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {10.10.0.1, 192.168.1.1}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip4.dst == {192.168.0.1}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:10}), action=(drop;)
  table=??(lr_in_ip_input     ), priority=60   , match=(ip6.dst == {fe80::200:ff:fe00:20}), action=(drop;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([DNAT force snat IP])
ovn_start

ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-public 00:00:01:01:02:04 192.168.2.1/24
ovn-nbctl lrp-add lr0 lr0-join 00:00:01:01:02:04 10.10.0.1/24

ovn-nbctl set logical_router lr0 options:chassis=ch1
ovn-nbctl lr-nat-add lr0 dnat 192.168.2.2 10.0.0.5
ovn-nbctl set logical_router lr0 options:dnat_force_snat_ip=192.168.2.3
ovn-nbctl --wait=sb sync

AT_CHECK([ovn-sbctl lflow-list lr0 | grep lr_in_unsnat | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(ip4 && ip4.dst == 192.168.2.3), action=(ct_snat;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check reconcile stale Datapath_Binding])
ovn_start

check ovn-nbctl lr-add lr
check ovn-nbctl lrp-add lr p 00:00:00:00:00:01 1.1.1.1/24
check ovn-nbctl --wait=sb sync

# Create a MAC_Binding referring the router datapath.
AT_CHECK([ovn-sbctl --id=@dp get datapath . -- create mac_binding logical_port=p ip=1.1.1.2 datapath=@dp | uuidfilt], [0], [<0>
])

check ovn-nbctl --wait=sb \
             -- lrp-del p \
             -- lr-del lr \
             -- lr-add lr \
             -- lrp-add lr p 00:00:00:00:00:01 1.1.1.1/24

check_row_count Datapath_Binding 1

nb_uuid=$(ovn-sbctl get Datapath_Binding . external_ids:logical-router)
lr_uuid=\"$(ovn-nbctl get Logical_Router . _uuid)\"
echo nb_uuid="$nb_uuid" lr_uuid="$lr_uuid"
AT_CHECK([test "${nb_uuid}" = "${lr_uuid}"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check reconcile stale tunnel keys])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl lsp-add ls1 lsp1
ovn-nbctl lsp-add ls2 lsp2
AT_CHECK([ovn-nbctl --wait=sb sync], [0])

# Ports are bound on different datapaths so it's expected that they both
# get tunnel_key == 1.
check_column 1 Port_Binding tunnel_key logical_port=lsp1
check_column 1 Port_Binding tunnel_key logical_port=lsp2

ovn-nbctl lsp-del lsp2 -- lsp-add ls1 lsp2
AT_CHECK([ovn-nbctl --wait=sb sync], [0])

check_column 1 Port_Binding tunnel_key logical_port=lsp1
check_column 2 Port_Binding tunnel_key logical_port=lsp2

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check reconcile stale Ha_Chassis_Group])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl lsp-add ls1 lsp1
ovn-nbctl lsp-add ls2 lsp2

ovn-nbctl lsp-set-type lsp2 external

ovn-nbctl ha-chassis-group-add chg1
ovn-nbctl ha-chassis-group-add-chassis chg1 chassis-1 30

chg1_uuid=$(ovn-nbctl --bare --columns _uuid list Ha_Chassis_Group .)
ovn-nbctl set logical_switch_port lsp2 ha_chassis_group=${chg1_uuid}
AT_CHECK([ovn-nbctl --wait=sb sync], [0])

# Move lsp2 from ls2 to ls1. This should also remove the SB HA_Chassis_Group
# record.
ovn-nbctl lsp-del lsp2 -- lsp-add ls1 lsp2
AT_CHECK([ovn-nbctl --wait=sb sync], [0])

check_row_count HA_Chassis_Group 0

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check NB/SB Port_Group translation (lsp add/del)])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl lsp-add ls1 lsp1
ovn-nbctl lsp-add ls2 lsp2
ovn-nbctl --wait=sb sync
ls1_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls1)
ls2_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls2)

# Add an empty port group. This should generate no entry in the SB.
ovn-nbctl --wait=sb pg-add pg_test
AT_CHECK([test 0 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])

# Add lsp1 to the port group. This should generate an entry in the SB only
# for ls1.
ovn-nbctl --wait=sb pg-set-ports pg_test lsp1
AT_CHECK([test 1 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])
AT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls1_key}_pg_test], [0], [dnl
lsp1
])

# Add lsp2 to the port group. This should generate a new entry in the SB, for
# ls2.
ovn-nbctl --wait=sb pg-set-ports pg_test lsp1 lsp2
AT_CHECK([test 2 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])
AT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls1_key}_pg_test], [0], [dnl
lsp1
])
AT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls2_key}_pg_test], [0], [dnl
lsp2
])

# Remove lsp1 from the port group. The SB Port_Group for ls1 should be
# removed.
ovn-nbctl --wait=sb pg-set-ports pg_test lsp2
AT_CHECK([test 1 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])
AT_CHECK([ovn-sbctl --columns ports --bare find Port_Group name=${ls2_key}_pg_test], [0], [dnl
lsp2
])

# Remove lsp2 from the port group. All SB Port_Groups should be purged.
ovn-nbctl --wait=sb clear Port_Group pg_test ports
AT_CHECK([test 0 = $(ovn-sbctl --columns _uuid list Port_Group | grep uuid -c)])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check NB/SB Port_Group translation (ls del)])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl ls-add ls2
ovn-nbctl lsp-add ls1 lsp1
ovn-nbctl lsp-add ls2 lsp2
ovn-nbctl --wait=sb sync
ls1_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls1)
ls2_key=$(ovn-sbctl --columns tunnel_key --bare list Datapath_Binding ls2)

# Add lsp1 & lsp2 to a port group. This should generate two entries in the
# SB (one per logical switch).
ovn-nbctl --wait=sb pg-add pg_test lsp1 lsp2
wait_row_count Port_Group 2
check_row_count Port_Group 1 name=${ls1_key}_pg_test
check_row_count Port_Group 1 name=${ls2_key}_pg_test

# Delete logical switch ls1. This should remove the associated SB Port_Group.
ovn-nbctl --wait=sb ls-del ls1
wait_row_count Port_Group 1
check_row_count Port_Group 1 name=${ls2_key}_pg_test

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check router ARP/NS responder])
ovn_start

ovn-sbctl chassis-add ch geneve 127.0.0.1

ovn-nbctl lr-add lr
ovn-nbctl lrp-add lr lrp-public 00:00:00:00:01:00 43.43.43.1/24 4343::1/64
ovn-nbctl lrp-add lr lrp 00:00:00:00:00:01 42.42.42.1/24

ovn-nbctl ls-add ls
ovn-nbctl lsp-add ls ls-rp
ovn-nbctl lsp-set-type ls-rp router
ovn-nbctl lsp-set-addresses ls-rp router
ovn-nbctl lsp-set-options ls-rp router-port=lrp
ovn-nbctl lsp-add ls ls-vm

ovn-nbctl set logical_router lr options:chassis=ch
ovn-nbctl lr-nat-add lr dnat_and_snat 43.43.43.2 42.42.42.2
ovn-nbctl lr-nat-add lr dnat 43.43.43.3 42.42.42.3
ovn-nbctl lr-nat-add lr dnat_and_snat 43.43.43.4 42.42.42.4 ls-vm 00:00:00:00:00:02
ovn-nbctl lr-nat-add lr snat 43.43.43.150 43.43.43.50
ovn-nbctl lr-nat-add lr snat 43.43.43.150 43.43.43.51

ovn-nbctl lb-add lb1 "192.168.2.1:8080" "10.0.0.4:8080"
ovn-nbctl lb-add lb2 "192.168.2.4:8080" "10.0.0.5:8080" udp
ovn-nbctl lb-add lb3 "192.168.2.5:8080" "10.0.0.6:8080"
ovn-nbctl lb-add lb4 "192.168.2.6:8080" "10.0.0.7:8080"
ovn-nbctl lb-add lb5 "[[fe80::200:ff:fe00:101]]:8080" "[[fe02::200:ff:fe00:101]]:8080"
ovn-nbctl lb-add lb5 "[[fe80::200:ff:fe00:102]]:8080" "[[fe02::200:ff:fe00:102]]:8080"
ovn-nbctl lb-add lb6 "43.43.43.43:8080" "10.0.0.8:8080" udp
ovn-nbctl lb-add lb7 "[[4343::4343]]:8080" "[[10::10]]:8080" udp
ovn-nbctl lb-add lb8 "44.44.44.44:8080" "10.0.0.8:8080" udp
ovn-nbctl set Load_Balancer lb8 options:neighbor_responder=all
ovn-nbctl lb-add lb9 "[[4444::4444]]:8080" "[[10::10]]:8080" udp
ovn-nbctl set Load_Balancer lb9 options:neighbor_responder=all

ovn-nbctl lb-add lb10 "55.55.55.55:8080" "10.0.0.8:8080" udp
ovn-nbctl set Load_Balancer lb10 options:neighbor_responder=none
ovn-nbctl lb-add lb11 "[[5555::5555]]:8080" "[[10::10]]:8080" udp
ovn-nbctl set Load_Balancer lb11 options:neighbor_responder=none

ovn-nbctl lr-lb-add lr lb1
ovn-nbctl lr-lb-add lr lb2
ovn-nbctl lr-lb-add lr lb3
ovn-nbctl lr-lb-add lr lb4
ovn-nbctl lr-lb-add lr lb5
ovn-nbctl lr-lb-add lr lb6
ovn-nbctl lr-lb-add lr lb7
ovn-nbctl lr-lb-add lr lb8
ovn-nbctl lr-lb-add lr lb9
ovn-nbctl lr-lb-add lr lb10
ovn-nbctl lr-lb-add lr lb11

ovn-nbctl --wait=sb sync
lr_key=$(fetch_column sb:datapath_binding tunnel_key external_ids:name=lr)
lb_as_v4="_rtr_lb_${lr_key}_ip4"
lb_as_v6="_rtr_lb_${lr_key}_ip6"

# Check generated VIP address sets (only reachable IPs).
check_column '43.43.43.43 44.44.44.44' Address_Set addresses name=${lb_as_v4}
check_column '4343::4343 4444::4444 fe80::200:ff:fe00:101 fe80::200:ff:fe00:102' Address_Set addresses name=${lb_as_v6}

# Ingress router port ETH address is stored in lr_in_admission.
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_admission.*xreg0\[[0..47\]]" | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.dst == 00:00:00:00:00:01 && inport == "lrp"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.dst == 00:00:00:00:01:00 && inport == "lrp-public"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.mcast && inport == "lrp"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.mcast && inport == "lrp-public"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)
])

# Ingress router port ETH address is used for ARP reply/NA in lr_in_ip_input.
AT_CHECK_UNQUOTED([ovn-sbctl lflow-list | grep -E "lr_in_ip_input.*priority=90" | grep "arp\|nd" | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.150), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.2), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.3), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.4), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && arp.op == 1 && arp.tpa == \$${lb_as_v4}), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && arp.op == 1 && arp.tpa == 42.42.42.1 && arp.spa == 42.42.42.0/24), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && ip6.dst == {fe80::200:ff:fe00:1, ff02::1:ff00:1} && nd_ns && nd.target == fe80::200:ff:fe00:1), dnl
action=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && nd_ns && nd.target == \$${lb_as_v6}), dnl
action=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == \$${lb_as_v4}), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.1 && arp.spa == 43.43.43.0/24), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && ip6.dst == {4343::1, ff02::1:ff00:1} && nd_ns && nd.target == 4343::1), dnl
action=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && ip6.dst == {fe80::200:ff:fe00:100, ff02::1:ff00:100} && nd_ns && nd.target == fe80::200:ff:fe00:100), dnl
action=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && nd_ns && nd.target == \$${lb_as_v6}), dnl
action=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
])

# xreg0[0..47] isn't used anywhere else.
AT_CHECK([ovn-sbctl lflow-list | grep "xreg0\[[0..47\]]" | grep -vE 'lr_in_admission|lr_in_ip_input'], [1], [])

# Test chassis redirect port.
ovn-nbctl remove logical_router lr options chassis
ovn-nbctl lrp-set-gateway-chassis lrp-public ch
ovn-nbctl --wait=sb sync

# Ingress router port ETH address is stored in lr_in_admission.
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_admission.*xreg0\[[0..47\]]" | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.dst == 00:00:00:00:00:01 && inport == "lrp"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.dst == 00:00:00:00:00:02 && inport == "lrp-public" && is_chassis_resident("ls-vm")), dnl
action=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.dst == 00:00:00:00:01:00 && inport == "lrp-public" && is_chassis_resident("cr-lrp-public")), dnl
action=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.mcast && inport == "lrp"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=0 (lr_in_admission    ), priority=50   , dnl
match=(eth.mcast && inport == "lrp-public"), dnl
action=(xreg0[[0..47]] = 00:00:00:00:01:00; next;)
])

# Ingress router port is used for ARP reply/NA in lr_in_ip_input.
# xxreg0[0..47] is used unless external_mac is set.
# Priority 90 flows (per router).
AT_CHECK_UNQUOTED([ovn-sbctl lflow-list | grep -E "lr_in_ip_input.*priority=90" | grep "arp\|nd" | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.150), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.2), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.3), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(arp.op == 1 && arp.tpa == 43.43.43.4), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && arp.op == 1 && arp.tpa == \$${lb_as_v4}), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && arp.op == 1 && arp.tpa == 42.42.42.1 && arp.spa == 42.42.42.0/24), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && ip6.dst == {fe80::200:ff:fe00:1, ff02::1:ff00:1} && nd_ns && nd.target == fe80::200:ff:fe00:1), dnl
action=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp" && nd_ns && nd.target == \$${lb_as_v6}), dnl
action=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == \$${lb_as_v4} && is_chassis_resident("cr-lrp-public")), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.1 && arp.spa == 43.43.43.0/24), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && ip6.dst == {4343::1, ff02::1:ff00:1} && nd_ns && nd.target == 4343::1 && is_chassis_resident("cr-lrp-public")), dnl
action=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && ip6.dst == {fe80::200:ff:fe00:100, ff02::1:ff00:100} && nd_ns && nd.target == fe80::200:ff:fe00:100 && is_chassis_resident("cr-lrp-public")), dnl
action=(nd_na_router { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
  table=3 (lr_in_ip_input     ), priority=90   , dnl
match=(inport == "lrp-public" && nd_ns && nd.target == \$${lb_as_v6} && is_chassis_resident("cr-lrp-public")), dnl
action=(nd_na { eth.src = xreg0[[0..47]]; ip6.src = nd.target; nd.tll = xreg0[[0..47]]; outport = inport; flags.loopback = 1; output; };)
])

# Priority 91 drop flows (per distributed gw port), if port is not resident.
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_ip_input.*priority=91" | grep "arp\|nd" | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=91   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.150), action=(drop;)
  table=3 (lr_in_ip_input     ), priority=91   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.2), dnl
action=(drop;)
  table=3 (lr_in_ip_input     ), priority=91   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.3), dnl
action=(drop;)
  table=3 (lr_in_ip_input     ), priority=91   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.4), dnl
action=(drop;)
])

# Priority 92 ARP/NS responders (per distributed gw port), if port is resident.
AT_CHECK([ovn-sbctl lflow-list | grep -E "lr_in_ip_input.*priority=92" | grep "arp\|nd" | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=92   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.150 && is_chassis_resident("cr-lrp-public")), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=92   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.2 && is_chassis_resident("cr-lrp-public")), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=92   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.3 && is_chassis_resident("cr-lrp-public")), dnl
action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=3 (lr_in_ip_input     ), priority=92   , dnl
match=(inport == "lrp-public" && arp.op == 1 && arp.tpa == 43.43.43.4 && is_chassis_resident("ls-vm")), dnl
action=(eth.dst = eth.src; eth.src = 00:00:00:00:00:02; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = 00:00:00:00:00:02; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
])

# xreg0[0..47] isn't used anywhere else.
AT_CHECK([ovn-sbctl lflow-list | grep "xreg0\[[0..47\]]" | grep -vE 'lr_in_admission|lr_in_ip_input'], [1], [])

AT_CLEANUP
])

# This test case tests that when a logical switch has load balancers associated
# (with VIPs configured), the below logical flow is added by ovn-northd.
# table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
# This test case is added for the BZ -
# https://bugzilla.redhat.com/show_bug.cgi?id=1849162
#
# ovn-northd was not adding the above lflow if the last load balancer associated
# to the logical switch doesn't have the VIP configured even if other load
# balancers before the last one in the last have VIPs configured.
# So make sure that the above lflow is added even if one load balancer has VIP
# associated.

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Load balancer - missing ls_out_pre_lb flows])
ovn_start

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1

ovn-nbctl lb-add lb1 "10.0.0.10" "10.0.0.3"
ovn-nbctl lb-add lb2 "10.0.0.11" "10.0.0.4"

ovn-nbctl lb-add lb3 "10.0.0.12" "10.0.0.5"
ovn-nbctl lb-add lb4 "10.0.0.13" "10.0.0.6"

lb1=$(fetch_column nb:load_balancer _uuid name=lb1)
lb2=$(fetch_column nb:load_balancer _uuid name=lb2)
lb3=$(fetch_column nb:load_balancer _uuid name=lb3)
lb4=$(fetch_column nb:load_balancer _uuid name=lb4)

lbg=$(ovn-nbctl create load_balancer_group name=lbg)
check ovn-nbctl add logical_switch  sw0 load_balancer_group $lbg

ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
])

check ovn-nbctl ls-lb-add sw0 lb1
check ovn-nbctl add load_balancer_group $lbg load_balancer $lb3
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)
])

check ovn-nbctl ls-lb-add sw0 lb2
check ovn-nbctl add load_balancer_group $lbg load_balancer $lb4
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)
])

check ovn-nbctl clear load_balancer $lb1 vips
check ovn-nbctl clear load_balancer $lb3 vips
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)
])

check ovn-nbctl clear load_balancer $lb2 vips
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)
])

check ovn-nbctl clear load_balancer $lb4 vips
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
])

check ovn-nbctl set load_balancer $lb1 vips:"10.0.0.10"="10.0.0.3"
check ovn-nbctl set load_balancer $lb2 vips:"10.0.0.11"="10.0.0.4"
check ovn-nbctl set load_balancer $lb3 vips:"10.0.0.12"="10.0.0.5"
check ovn-nbctl set load_balancer $lb4 vips:"10.0.0.13"="10.0.0.6"

check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)
])

# Now reverse the order of clearing the vip.
check ovn-nbctl clear load_balancer $lb2 vips
check ovn-nbctl clear load_balancer $lb4 vips
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)
])

check ovn-nbctl clear load_balancer $lb1 vips
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)
])

check ovn-nbctl clear load_balancer $lb3 vips
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep "ls_out_pre_lb.*priority=100" | grep reg0 | sort], [0], [dnl
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ignore_lsp_down])
ovn_start

ovn-nbctl set NB_Global . options:ignore_lsp_down=false
ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 "aa:aa:aa:aa:aa:aa 10.0.0.1"

ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep arp | grep 10\.0\.0\.1], [1], [ignore])

ovn-nbctl --wait=sb set NB_Global . options:ignore_lsp_down=true
AT_CHECK([ovn-sbctl lflow-list | grep arp | grep 10\.0\.0\.1], [0], [ignore])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ovn-northd -- reject ACL])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1

check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-p1

check ovn-nbctl pg-add pg0 sw0-p1 sw1-p1
check ovn-nbctl acl-add pg0 from-lport 1002 "inport == @pg0 && ip4 && tcp && tcp.dst == 80" reject
check ovn-nbctl acl-add pg0 to-lport 1003 "outport == @pg0 && ip6 && udp" reject

check ovn-nbctl --wait=sb sync

AS_BOX([1])

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])
ovn-sbctl dump-flows sw1 > sw1flows
AT_CAPTURE_FILE([sw1flows])

AT_CHECK(
  [grep -E 'ls_(in|out)_acl' sw0flows sw1flows | grep pg0 | sort], [0], [dnl
sw0flows:  table=4 (ls_out_acl_eval    ), priority=2003 , match=((outport == @pg0 && ip6 && udp)), action=(reg8[[18]] = 1; next;)
sw0flows:  table=8 (ls_in_acl_eval     ), priority=2002 , match=((inport == @pg0 && ip4 && tcp && tcp.dst == 80)), action=(reg8[[18]] = 1; next;)
sw1flows:  table=4 (ls_out_acl_eval    ), priority=2003 , match=((outport == @pg0 && ip6 && udp)), action=(reg8[[18]] = 1; next;)
sw1flows:  table=8 (ls_in_acl_eval     ), priority=2002 , match=((inport == @pg0 && ip4 && tcp && tcp.dst == 80)), action=(reg8[[18]] = 1; next;)
])

AS_BOX([2])

ovn-nbctl --wait=sb acl-add pg0 to-lport 1002 "outport == @pg0 && ip4 && udp" reject

ovn-sbctl dump-flows sw0 > sw0flows2
AT_CAPTURE_FILE([sw0flows2])
ovn-sbctl dump-flows sw1 > sw1flows2
AT_CAPTURE_FILE([sw1flows2])

AT_CHECK([grep "ls_out_acl" sw0flows2 sw1flows2 | grep pg0 | sort], [0], [dnl
sw0flows2:  table=4 (ls_out_acl_eval    ), priority=2002 , match=((outport == @pg0 && ip4 && udp)), action=(reg8[[18]] = 1; next;)
sw0flows2:  table=4 (ls_out_acl_eval    ), priority=2003 , match=((outport == @pg0 && ip6 && udp)), action=(reg8[[18]] = 1; next;)
sw1flows2:  table=4 (ls_out_acl_eval    ), priority=2002 , match=((outport == @pg0 && ip4 && udp)), action=(reg8[[18]] = 1; next;)
sw1flows2:  table=4 (ls_out_acl_eval    ), priority=2003 , match=((outport == @pg0 && ip6 && udp)), action=(reg8[[18]] = 1; next;)
])

AS_BOX([3])

ovn-nbctl --wait=sb acl-add pg0 to-lport 1001 "outport == @pg0 && ip" allow-related

ovn-sbctl dump-flows sw0 > sw0flows3
AT_CAPTURE_FILE([sw0flows3])
ovn-sbctl dump-flows sw1 > sw1flows3
AT_CAPTURE_FILE([sw1flows3])

AT_CHECK([grep "ls_out_acl" sw0flows3 sw1flows3 | grep pg0 | sort], [0], [dnl
sw0flows3:  table=4 (ls_out_acl_eval    ), priority=2001 , match=(reg0[[7]] == 1 && (outport == @pg0 && ip)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
sw0flows3:  table=4 (ls_out_acl_eval    ), priority=2001 , match=(reg0[[8]] == 1 && (outport == @pg0 && ip)), action=(reg8[[16]] = 1; next;)
sw0flows3:  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[10]] == 1 && (outport == @pg0 && ip4 && udp)), action=(reg8[[18]] = 1; ct_commit { ct_mark.blocked = 1; }; next;)
sw0flows3:  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[9]] == 1 && (outport == @pg0 && ip4 && udp)), action=(reg8[[18]] = 1; next;)
sw0flows3:  table=4 (ls_out_acl_eval    ), priority=2003 , match=(reg0[[10]] == 1 && (outport == @pg0 && ip6 && udp)), action=(reg8[[18]] = 1; ct_commit { ct_mark.blocked = 1; }; next;)
sw0flows3:  table=4 (ls_out_acl_eval    ), priority=2003 , match=(reg0[[9]] == 1 && (outport == @pg0 && ip6 && udp)), action=(reg8[[18]] = 1; next;)
sw1flows3:  table=4 (ls_out_acl_eval    ), priority=2001 , match=(reg0[[7]] == 1 && (outport == @pg0 && ip)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
sw1flows3:  table=4 (ls_out_acl_eval    ), priority=2001 , match=(reg0[[8]] == 1 && (outport == @pg0 && ip)), action=(reg8[[16]] = 1; next;)
sw1flows3:  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[10]] == 1 && (outport == @pg0 && ip4 && udp)), action=(reg8[[18]] = 1; ct_commit { ct_mark.blocked = 1; }; next;)
sw1flows3:  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[9]] == 1 && (outport == @pg0 && ip4 && udp)), action=(reg8[[18]] = 1; next;)
sw1flows3:  table=4 (ls_out_acl_eval    ), priority=2003 , match=(reg0[[10]] == 1 && (outport == @pg0 && ip6 && udp)), action=(reg8[[18]] = 1; ct_commit { ct_mark.blocked = 1; }; next;)
sw1flows3:  table=4 (ls_out_acl_eval    ), priority=2003 , match=(reg0[[9]] == 1 && (outport == @pg0 && ip6 && udp)), action=(reg8[[18]] = 1; next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ACL fair Meters])
AT_KEYWORDS([acl log meter fair])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 "50:54:00:00:00:01 10.0.0.11"
check ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 "50:54:00:00:00:02 10.0.0.12"
check ovn-nbctl lsp-add sw1 sw1-p3 -- lsp-set-addresses sw1-p3 "50:54:00:00:00:03 10.0.0.13"
check ovn-nbctl pg-add pg0 sw0-p1 sw0-p2 sw1-p3

check ovn-nbctl meter-add meter_me drop 1 pktps
nb_meter_uuid=$(fetch_column nb:Meter _uuid name=meter_me)

check ovn-nbctl acl-add sw0 to-lport 1002 'outport == "sw0-p1" && ip4.src == 10.0.0.12' allow
check ovn-nbctl acl-add sw0 to-lport 1002 'outport == "sw0-p1" && ip4.src == 10.0.0.13' allow
check ovn-nbctl acl-add pg0 to-lport 1002 'outport == "pg0" && ip4.src == 10.0.0.11' drop

acl1=$(ovn-nbctl --bare --column _uuid,match find acl | grep -F -B1 '10.0.0.12' | head -1)
acl2=$(ovn-nbctl --bare --column _uuid,match find acl | grep -F -B1 '10.0.0.13' | head -1)
acl3=$(ovn-nbctl --bare --column _uuid,match find acl | grep -F -B1 '10.0.0.11' | head -1)
check ovn-nbctl set acl $acl1 log=true severity=alert meter=meter_me name=acl_one
check ovn-nbctl set acl $acl2 log=true severity=info  meter=meter_me name=acl_two
check ovn-nbctl set acl $acl3 log=true severity=info  meter=meter_me name=acl_three
check ovn-nbctl --wait=sb sync

check_row_count nb:meter 1
check_column meter_me nb:meter name

check_acl_lflow() {
    acl_log_name=$1
    meter_name=$2
    ls=$3
    echo "checking that logical flow for acl log $acl_log_name has $meter_name"
    ovn-sbctl dump-flows $ls > sbflows
    AT_CAPTURE_FILE([sbflows])
    AT_CHECK([grep ls_out_acl sbflows | \
              grep "\"${acl_log_name}\"" | \
              grep -c "meter=\"${meter_name}\""], [0], [1
])
}

check_meter_by_name() {
    [test "$1" = "NOT"] && { expected_count=0; shift; } || expected_count=1
    for meter_name in $* ; do
        # echo checking for $expected_count $meter_name in sb meter table
        check_row_count meter $expected_count name=$meter_name
    done
}

AS_BOX([Make sure 'fair' value properly affects the Meters in SB])
check_meter_by_name meter_me
check_meter_by_name NOT meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}

check ovn-nbctl --wait=sb set Meter $nb_meter_uuid fair=true
check_meter_by_name meter_me meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}

check ovn-nbctl --wait=sb set Meter $nb_meter_uuid fair=false
check_meter_by_name meter_me
check_meter_by_name NOT meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}

check ovn-nbctl --wait=sb set Meter $nb_meter_uuid fair=true
check_meter_by_name meter_me meter_me__${acl1} meter_me__${acl2} meter_me__${acl3}

AS_BOX([Change template meter and make sure that is reflected on acl meters])
template_band=$(fetch_column nb:meter bands name=meter_me)
check ovn-nbctl --wait=sb set meter_band $template_band rate=123
AS_BOX([Make sure that every Meter_Band has the right rate.])
# ovn-northd creates 4 identical Meter_Band rows, all identical;
n_meter_bands=$(count_rows meter_band)
AT_FAIL_IF([test "$n_meter_bands" != 4])
check_row_count meter_band $n_meter_bands rate=123

AS_BOX([Check meter in logical flows for acl logs])
check_acl_lflow acl_one meter_me__${acl1} sw0
check_acl_lflow acl_two meter_me__${acl2} sw0
check_acl_lflow acl_three meter_me__${acl3} sw0
check_acl_lflow acl_three meter_me__${acl3} sw1

AS_BOX([Stop using meter for acl1])
check ovn-nbctl --wait=sb clear acl $acl1 meter
check_meter_by_name meter_me meter_me__${acl2}
check_meter_by_name NOT meter_me__${acl1}
check_acl_lflow acl_two meter_me__${acl2} sw0
check_acl_lflow acl_three meter_me__${acl3} sw0
check_acl_lflow acl_three meter_me__${acl3} sw1

AS_BOX([Remove template Meter should remove all others as well])
check ovn-nbctl --wait=sb meter-del meter_me
check_row_count meter 0
AS_BOX([Check that logical flow remains but uses non-unique meter])
check_acl_lflow acl_two meter_me sw0
check_acl_lflow acl_three meter_me sw0
check_acl_lflow acl_three meter_me sw1

AS_BOX([Re-add template meter and make sure acl2's meter is back in sb])
check ovn-nbctl --wait=sb --fair meter-add meter_me drop 1 pktps
check_meter_by_name meter_me meter_me__${acl2}
check_meter_by_name NOT meter_me__${acl1}
check_acl_lflow acl_two meter_me__${acl2} sw0
check_acl_lflow acl_three meter_me__${acl3} sw0
check_acl_lflow acl_three meter_me__${acl3} sw1

AS_BOX([Remove acl2])
sw0=$(fetch_column nb:logical_switch _uuid name=sw0)
check ovn-nbctl --wait=sb remove logical_switch $sw0 acls $acl2
check_meter_by_name meter_me meter_me__${acl3}
check_meter_by_name NOT meter_me__${acl1} meter_me__${acl2}

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Check NB-SB mirrors sync])
AT_KEYWORDS([mirrors])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-add sw0 sw0-port2
check ovn-nbctl --wait=sb mirror-add mirror1 erspan 1 from-lport 10.10.10.2
check_column mirror1 Mirror name
check_column 10.10.10.2 Mirror sink
check_column erspan Mirror type
check_column 1 Mirror index
check_column from-lport Mirror filter

check ovn-nbctl --wait=sb set mirror . sink=192.168.1.13

check_column 192.168.1.13 Mirror sink
check_column erspan Mirror type
check_column 1 Mirror index
check_column from-lport Mirror filter

check ovn-nbctl --wait=sb set mirror . type=gre

check_column 192.168.1.13 Mirror sink
check_column gre Mirror type
check_column 1 Mirror index
check_column from-lport Mirror filter

check ovn-nbctl --wait=sb set mirror . index=12

check_column 192.168.1.13 Mirror sink
check_column gre Mirror type
check_column 12 Mirror index
check_column from-lport Mirror filter

check ovn-nbctl --wait=sb set mirror . filter=to-lport

check_column 192.168.1.13 Mirror sink
check_column gre Mirror type
check_column 12 Mirror index
check_column to-lport Mirror filter

# Verify mirror attach
check ovn-nbctl --wait=sb lsp-attach-mirror sw0-port1 mirror1

mirror1uuid=$(fetch_column sb:Mirror _uuid name=mirror1)
check_column "$mirror1uuid" sb:Port_Binding mirror_rules logical_port=sw0-port1

check ovn-nbctl --wait=sb mirror-add mirror2 gre 2 from-lport 10.10.10.2
check_row_count sb:Mirror 2

# Verify mirror detach (and another attach)
check ovn-nbctl lsp-attach-mirror sw0-port1 mirror2
check ovn-nbctl lsp-detach-mirror sw0-port1 mirror1
check ovn-nbctl --wait=sb sync

mirror2uuid=$(fetch_column sb:Mirror _uuid name=mirror2)
check_column "$mirror2uuid" sb:Port_Binding mirror_rules logical_port=sw0-port1

# Verify mirror-del (one by one)
check ovn-nbctl --wait=sb mirror-del mirror2
check_row_count sb:Mirror 1
check ovn-nbctl --wait=sb mirror-del mirror1
check_row_count sb:Mirror 0
check_column "" sb:Port_Binding mirror_rules logical_port=sw0-port1

# Verify mirror-add
check ovn-nbctl --wait=sb mirror-add mirror2 gre 2 to-lport 10.10.10.2
check_row_count sb:Mirror 1

check_column 10.10.10.2 Mirror sink
check_column gre Mirror type
check_column 2 Mirror index
check_column to-lport Mirror filter

# Verify same attached to multiple ports
check ovn-nbctl --wait=sb lsp-attach-mirror sw0-port1 mirror2
check ovn-nbctl --wait=sb lsp-attach-mirror sw0-port2 mirror2

mirror2uuid=$(fetch_column sb:Mirror _uuid name=mirror2)
check_column "$mirror2uuid" sb:Port_Binding mirror_rules logical_port=sw0-port1
check_column "$mirror2uuid" sb:Port_Binding mirror_rules logical_port=sw0-port2

# Verify same port attached to multiple mirrors
check ovn-nbctl --wait=sb mirror-add mirror1 erspan 1 to-lport 10.10.10.2
check ovn-nbctl --wait=sb lsp-attach-mirror sw0-port1 mirror1
check_row_count sb:Mirror 2
check_row_count nb:Mirror 2

mirror1uuid=$(fetch_column sb:Mirror _uuid name=mirror1)
check_column "$mirror2uuid $mirror1uuid" sb:Port_Binding mirror_rules logical_port=sw0-port1

# Verify delete (bulk)
check ovn-nbctl --wait=sb mirror-del
check_row_count nb:Mirror 0
check_column "" nb:Logical_Switch_Port mirror_rules name=sw0-port1
check_column "" nb:Logical_Switch_Port mirror_rules name=sw0-port2
check_row_count sb:Mirror 0
check_column "" sb:Port_Binding mirror_rules logical_port=sw0-port1
check_column "" sb:Port_Binding mirror_rules logical_port=sw0-port2

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ACL skip hints for stateless config])
AT_KEYWORDS([acl])
ovn_start

check ovn-nbctl --wait=sb \
    -- ls-add ls \
    -- lsp-add ls lsp \
    -- acl-add ls from-lport 1 "ip" allow \
    -- acl-add ls to-lport 1 "ip" allow

AS_BOX([Check no match on ct_state with stateless ACLs])
AT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl -e ls_out_acl | grep 'ct\.' | sort], [0], [dnl
])

AS_BOX([Check match ct_state with stateful ACLs])
check ovn-nbctl --wait=sb \
    -- acl-add ls from-lport 2 "udp" allow-related \
    -- acl-add ls to-lport 2 "udp" allow-related
AT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl -e ls_out_acl | grep 'ct\.' | sort], [0], [dnl
  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
])

AS_BOX([Check match ct_state with load balancer])
check ovn-nbctl --wait=sb \
    -- acl-del ls from-lport 2 "udp" \
    -- acl-del ls to-lport 2 "udp" \
    -- lb-add lb "10.0.0.1" "10.0.0.2" \
    -- ls-lb-add ls lb

AT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl_eval -e ls_out_acl_eval -e ls_in_acl_after_lb_eval | sort], [0], [dnl
  table=18(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=18(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=18(ls_in_acl_after_lb_eval), priority=65532, match=(reg0[[17]] == 1), action=(reg8[[16]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=4 (ls_out_acl_eval    ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=1001 , match=(reg0[[7]] == 1 && (ip)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=1001 , match=(reg0[[8]] == 1 && (ip)), action=(reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=8 (ls_in_acl_eval     ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=1001 , match=(reg0[[7]] == 1 && (ip)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=1001 , match=(reg0[[8]] == 1 && (ip)), action=(reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
])

ovn-nbctl --wait=sb clear logical_switch ls acls
ovn-nbctl --wait=sb clear logical_switch ls load_balancer

AT_CHECK([ovn-sbctl lflow-list ls | grep -e ls_in_acl_hint -e ls_out_acl_hint -e ls_in_acl_eval -e ls_out_acl_eval -e ls_in_acl_after_lb_eval | sort], [0], [dnl
  table=18(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=18(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65535, match=(1), action=(next;)
  table=7 (ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65535, match=(1), action=(next;)
])


AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([datapath requested-tnl-key])
AT_KEYWORDS([requested tnl tunnel key keys])
ovn_start

get_tunnel_keys() {
    set $(ovn-sbctl get datapath_binding ls0 tunnel_key \
                 -- get datapath_binding ls1 tunnel_key \
                 -- get datapath_binding ls2 tunnel_key)
    echo "ls0=$ls0 ls1=$ls1 ls2=$ls2"
    ls0=$1 ls1=$2 ls2=$3
    AT_CHECK([test "$ls0" != "$ls1" && \
              test "$ls1" != "$ls2" && \
              test "$ls0" != "$ls2"])
}

echo
echo "__file__:__line__: Add three logical switches, check tunnel ids"
AT_CHECK(
  [ovn-nbctl --wait=sb ls-add ls0
   ovn-nbctl --wait=sb ls-add ls1
   ovn-nbctl --wait=sb ls-add ls2])
get_tunnel_keys
AT_CHECK([test $ls0 = 1 && test $ls1 = 2 && test $ls2 = 3])

echo
echo "__file__:__line__: Assign ls0 new tunnel key, others don't change."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch ls0 other-config:requested-tnl-key=4])
get_tunnel_keys
AT_CHECK([test $ls0 = 4 && test $ls1 = 2 && test $ls2 = 3])

echo
echo "__file__:__line__: Assign ls0 a conflict with ls1, which moves aside."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch ls0 other-config:requested-tnl-key=2])
get_tunnel_keys
AT_CHECK([test $ls0 = 2 && test $ls2 = 3])

echo
echo "__file__:__line__: Assign ls0 and ls1 conflicts and verify that they end up different and ls2 doesn't change."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch ls1 other-config:requested-tnl-key=2])
get_tunnel_keys
AT_CHECK([test $ls2 = 3])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([LR requested-tnl-key])
ovn_start

ovn-nbctl --wait=sb lr-add lr0
AT_CHECK([test 1 = $(ovn-sbctl get datapath_binding lr0 tunnel_key)])

ovn-nbctl --wait=sb lr-add lr1
AT_CHECK([test 2 = $(ovn-sbctl get datapath_binding lr1 tunnel_key)])

AT_CHECK(
  [ovn-nbctl --wait=sb set logical-router lr0 options:requested-tnl-key=100])
AT_CHECK([test 100 = $(ovn-sbctl get datapath_binding lr0 tunnel_key)])

AT_CHECK(
  [ovn-nbctl --wait=sb set logical-router lr1 options:requested-tnl-key=100])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([port requested-tnl-key])
AT_KEYWORDS([requested tnl tunnel key keys])
ovn_start

get_tunnel_keys() {
    set $(ovn-sbctl get port_binding lsp00 tunnel_key \
                 -- get port_binding lsp01 tunnel_key \
                 -- get port_binding lsp02 tunnel_key \
                 -- get port_binding lsp10 tunnel_key \
                 -- get port_binding lsp11 tunnel_key \
                 -- get port_binding lsp12 tunnel_key)
    lsp00=$1 lsp01=$2 lsp02=$3 lsp10=$4 lsp11=$5 lsp12=$6
    ls0=$1$2$3 ls1=$4$5$6
    echo "ls0=$1$2$3 ls1=$4$5$6"
    AT_CHECK([test "$lsp00" != "$lsp01" && \
              test "$lsp01" != "$lsp02" && \
              test "$lsp00" != "$lsp02"])
    AT_CHECK([test "$lsp10" != "$lsp11" && \
              test "$lsp11" != "$lsp12" && \
              test "$lsp10" != "$lsp12"])
}

echo
echo "__file__:__line__: Add two logical switches with three ports each, check tunnel ids"
AT_CHECK(
  [for i in 0 1; do
       ovn-nbctl --wait=sb ls-add ls$i || exit $?
       for j in 0 1 2; do
           ovn-nbctl --wait=sb lsp-add ls$i lsp$i$j || exit $?
       done
   done])
get_tunnel_keys
AT_CHECK([test $ls0 = 123 && test $ls1 = 123])

echo
echo "__file__:__line__: Assign lsp00 new tunnel key, others don't change."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch-port lsp00 options:requested-tnl-key=4])
get_tunnel_keys
AT_CHECK([test $ls0 = 423 && test $ls1 = 123])

echo
echo "__file__:__line__: Assign lsp00 a conflict with lsp01, which moves aside."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch-port lsp00 options:requested-tnl-key=2])
get_tunnel_keys
AT_CHECK([test $lsp00 = 2 && test $lsp02 = 3 && test $ls1 = 123])

echo
echo "__file__:__line__: Assign lsp00 and lsp01 conflicts and verify that they end up different and lsp02 doesn't change."
AT_CHECK(
  [ovn-nbctl --wait=sb set logical-switch-port lsp01 options:requested-tnl-key=2])
get_tunnel_keys
AT_CHECK([test $lsp02 = 3 && test $ls1 = 123])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Logical Flow Datapath Groups])
ovn_start

dnl No groups initially.
check_row_count sb:logical_dp_group 0

check ovn-nbctl --wait=sb ls-add sw0
sw0_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw0)

dnl Still no groups after addition of the first datapath (switch).
check_row_count sb:logical_dp_group 0

dnl One group with both datapaths after addition of the second switch.
check ovn-nbctl --wait=sb ls-add sw1
sw1_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw1)
check_row_count sb:logical_dp_group 1

echo "$sw0_sb_uuid" > sw_sb_uuids
echo "$sw1_sb_uuid" >> sw_sb_uuids

ls_dpg_uuid=$(ovn-sbctl --bare --columns _uuid list Logical_DP_Group .)
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $ls_dpg_uuid | tail -1 | tr ' ' '\n' | sort], [0], [dnl
$(cat sw_sb_uuids | sort)
])

dnl The same one group after the third switch, but with 3 datapaths.
check ovn-nbctl --wait=sb ls-add sw2
sw2_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw2)
check_row_count sb:logical_dp_group 1

echo "$sw2_sb_uuid" >> sw_sb_uuids

AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $ls_dpg_uuid | tail -1 | tr ' ' '\n' | sort], [0], [dnl
$(cat sw_sb_uuids | sort)
])

dnl Add two routers and check that they are in their new separate group.
check ovn-nbctl --wait=sb lr-add lr0 -- lr-add lr1
lr0_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=lr0)
lr1_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=lr1)
check_row_count sb:logical_dp_group 2

echo "$lr0_sb_uuid" > lr_sb_uuids
echo "$lr1_sb_uuid" >> lr_sb_uuids

lr_dpg_uuid=$(ovn-sbctl --bare --columns _uuid list Logical_DP_Group dnl
                | grep -v $ls_dpg_uuid)

AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $ls_dpg_uuid | tail -1 | tr ' ' '\n' | sort], [0], [dnl
$(cat sw_sb_uuids | sort)
])
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lr_dpg_uuid | tail -1 | tr ' ' '\n' | sort], [0], [dnl
$(cat lr_sb_uuids | sort)
])

dnl Remove switch sw1 and check that the group was modified correctly.
check ovn-nbctl --wait=sb ls-del sw1
check_row_count sb:logical_dp_group 2

echo "$sw0_sb_uuid" > sw_sb_uuids
echo "$sw2_sb_uuid" >> sw_sb_uuids

AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $ls_dpg_uuid | tail -1 | tr ' ' '\n' | sort], [0], [dnl
$(cat sw_sb_uuids | sort)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([NB to SB load balancer sync])
ovn_start

check ovn-nbctl lb-add lb0 10.0.0.10:80 10.0.0.4:8080
check ovn-nbctl --wait=sb lb-add lbg0 20.0.0.10:80 20.0.0.4:8080
check_row_count nb:load_balancer 2

echo
echo "__file__:__line__: Check that there are no SB load balancer rows."
check_row_count sb:load_balancer 0

lbg0=$(fetch_column nb:load_balancer _uuid name=lbg0)
lbg=$(ovn-nbctl create load_balancer_group name=lbg)
check ovn-nbctl add load_balancer_group $lbg load_balancer $lbg0
check ovn-nbctl ls-add sw0 -- add logical_switch sw0 load_balancer_group $lbg
check ovn-nbctl --wait=sb ls-lb-add sw0 lb0
sw0_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw0)

echo
echo "__file__:__line__: Check that there is one SB load balancer row for lb0 and one for lbg0"
check_row_count sb:load_balancer 2
check_column "10.0.0.10:80=10.0.0.4:8080 tcp" sb:load_balancer vips,protocol name=lb0
check_column "20.0.0.10:80=20.0.0.4:8080 tcp" sb:load_balancer vips,protocol name=lbg0

lb0_uuid=$(fetch_column sb:load_balancer _uuid name=lb0)
lbg0_uuid=$(fetch_column sb:load_balancer _uuid name=lbg0)

echo
echo "__file__:__line__: Check that SB lb0 has sw0 in datapaths column."

lb0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lb0)
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lb0_dp_group | tail -1], [0], [dnl
$sw0_sb_uuid
])

check_column "" sb:datapath_binding load_balancers external_ids:name=sw0

echo
echo "__file__:__line__: Check that SB lbg0 has sw0 in datapaths column."

lbg0_dp_group=$(fetch_column sb:load_balancer datapath_group name=lbg0)
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lbg0_dp_group | tail -1], [0], [dnl
$sw0_sb_uuid
])

check_column "" sb:datapath_binding load_balancers external_ids:name=sw0

check ovn-nbctl --wait=sb set load_balancer lb0 vips:"10.0.0.20\:90"="20.0.0.4:8080,30.0.0.4:8080"

echo
echo "__file__:__line__: Check that SB lb0 has vips and protocol columns are set properly."

check_column "10.0.0.10:80=10.0.0.4:8080 10.0.0.20:90=20.0.0.4:8080,30.0.0.4:8080 tcp" \
sb:load_balancer vips,protocol name=lb0

check ovn-nbctl --wait=sb set load_balancer lbg0 vips:"20.0.0.20\:90"="20.0.0.4:8080,30.0.0.4:8080"

echo
echo "__file__:__line__: Check that SB lbg0 has vips and protocol columns are set properly."

check_column "20.0.0.10:80=20.0.0.4:8080 20.0.0.20:90=20.0.0.4:8080,30.0.0.4:8080 tcp" \
sb:load_balancer vips,protocol name=lbg0

check ovn-nbctl lr-add lr0 -- add logical_router lr0 load_balancer_group $lbg
check ovn-nbctl --wait=sb lr-lb-add lr0 lb0

echo
echo "__file__:__line__: Check that SB lb0 has only sw0 in datapaths column."
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lb0_dp_group | tail -1], [0], [dnl
$sw0_sb_uuid
])

echo
echo "__file__:__line__: Check that SB lbg0 has only sw0 in datapaths column."
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lbg0_dp_group | tail -1], [0], [dnl
$sw0_sb_uuid
])

check ovn-nbctl ls-add sw1 -- add logical_switch sw1 load_balancer_group $lbg
check ovn-nbctl --wait=sb ls-lb-add sw1 lb0
sw1_sb_uuid=$(fetch_column datapath_binding _uuid external_ids:name=sw1)

echo "$sw0_sb_uuid" > sw_sb_uuids
echo "$sw1_sb_uuid" >> sw_sb_uuids

echo
echo "__file__:__line__: Check that SB lb0 has sw0 and sw1 in datapaths column."
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lb0_dp_group | tail -1 | tr ' ' '\n' | sort], [0], [dnl
$(cat sw_sb_uuids | sort)
])

echo
echo "__file__:__line__: Check that SB lbg0 has sw0 and sw1 in datapaths column."
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lbg0_dp_group | tail -1 | tr ' ' '\n' | sort], [0], [dnl
$(cat sw_sb_uuids | sort)
])

check_column "" sb:datapath_binding load_balancers external_ids:name=sw1

check ovn-nbctl --wait=sb lb-add lb1 10.0.0.30:80 20.0.0.50:8080 udp
check ovn-nbctl --wait=sb lb-add lbg1 20.0.0.30:80 20.0.0.50:8080 udp
check_row_count sb:load_balancer 2

lbg1=$(fetch_column nb:load_balancer _uuid name=lbg1)
check ovn-nbctl add load_balancer_group $lbg load_balancer $lbg1
check ovn-nbctl --wait=sb lr-lb-add lr0 lb1
check_row_count sb:load_balancer 3

echo
echo "__file__:__line__: Associate lb1 to sw1 and check that lb1 is created in SB DB."

check ovn-nbctl --wait=sb ls-lb-add sw1 lb1
check_row_count sb:load_balancer 4

echo
echo "__file__:__line__: Check that SB lb1 has vips and protocol columns are set properly."
check_column "10.0.0.30:80=20.0.0.50:8080 udp" sb:load_balancer vips,protocol name=lb1

echo
echo "__file__:__line__: Check that SB lbg1 has vips and protocol columns are set properly."
check_column "20.0.0.30:80=20.0.0.50:8080 udp" sb:load_balancer vips,protocol name=lbg1

lb1_uuid=$(fetch_column sb:load_balancer _uuid name=lb1)
lb1_dp_group=$(fetch_column sb:load_balancer datapath_group name=lb1)

echo
echo "__file__:__line__: Check that SB lb1 has sw1 in datapaths column."

AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lb1_dp_group | tail -1], [0], [dnl
$sw1_sb_uuid
])

lbg1_uuid=$(fetch_column sb:load_balancer _uuid name=lbg1)
lbg1_dp_group=$(fetch_column sb:load_balancer datapath_group name=lbg1)

echo
echo "__file__:__line__: Check that SB lbg1 has sw0 and sw1 in datapaths column."

AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lbg1_dp_group | tail -1 | tr ' ' '\n' | sort], [0], [dnl
$(cat sw_sb_uuids | sort)
])

echo
echo "__file__:__line__: check that datapath sw1 has no entry in the load_balancers column."
check_column "" sb:datapath_binding load_balancers external_ids:name=sw1

echo
echo "__file__:__line__: Set hairpin_snat_ip on lb1 and check that SB DB is updated."
check ovn-nbctl --wait=sb set Load_Balancer lb1 options:hairpin_snat_ip="42.42.42.42 4242::4242"
check_column "$lb1_uuid" sb:load_balancer _uuid name=lb1 options='{hairpin_orig_tuple="true", hairpin_snat_ip="42.42.42.42 4242::4242"}'

echo
echo "__file__:__line__: Delete load balancers lb1 and lbg1 and check that datapath sw1's load_balancers is still empty."

ovn-nbctl --wait=sb lb-del lb1 -- lb-del lbg1
check_column "" sb:datapath_binding load_balancers external_ids:name=sw1

echo
echo "__file__:__line__: Delete switch sw0."
check ovn-nbctl --wait=sb ls-del sw0

echo
echo "__file__:__line__: Check that SB lb0 has only sw1 in datapaths column."
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lb0_dp_group | tail -1], [0], [dnl
$sw1_sb_uuid
])

echo
echo "__file__:__line__: Check that SB lbg0 has only sw1 in datapaths column."
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lbg0_dp_group | tail -1], [0], [dnl
$sw1_sb_uuid
])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([LS load balancer hairpin logical flows])
ovn_start

lbg=$(ovn-nbctl create load_balancer_group name=lbg)

check ovn-nbctl \
    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080

lb0=$(fetch_column nb:load_balancer _uuid name=lb0)

check ovn-nbctl \
    -- ls-add sw0 -- \
    -- add logical_switch sw0 load_balancer_group $lbg \
    -- ls-lb-add sw0 lb0
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_pre_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_pre_hairpin  ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_hairpin  ), priority=100  , match=(ip && ct.trk), action=(reg0[[6]] = chk_lb_hairpin(); reg0[[12]] = chk_lb_hairpin_reply(); next;)
])

AT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_nat_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_nat_hairpin  ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.est && ct.trk && reg0[[6]] == 1), action=(ct_snat;)
  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.new && ct.trk && reg0[[6]] == 1), action=(ct_snat_to_vip; next;)
  table=??(ls_in_nat_hairpin  ), priority=90   , match=(ip && reg0[[12]] == 1), action=(ct_snat;)
])

AT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_hairpin | sort | sed 's/table=../table=??/g'], [0], [dnl
  table=??(ls_in_hairpin      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_hairpin      ), priority=1    , match=((reg0[[6]] == 1 || reg0[[12]] == 1)), action=(eth.dst <-> eth.src; outport = inport; flags.loopback = 1; output;)
])

check ovn-nbctl -- ls-lb-del sw0 lb0
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_pre_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_pre_hairpin  ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_nat_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_nat_hairpin  ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_hairpin | sort | sed 's/table=../table=??/g'], [0], [dnl
  table=??(ls_in_hairpin      ), priority=0    , match=(1), action=(next;)
])

check ovn-nbctl -- add load_balancer_group $lbg load_balancer $lb0
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_pre_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_pre_hairpin  ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_hairpin  ), priority=100  , match=(ip && ct.trk), action=(reg0[[6]] = chk_lb_hairpin(); reg0[[12]] = chk_lb_hairpin_reply(); next;)
])

AT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_nat_hairpin | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_nat_hairpin  ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.est && ct.trk && reg0[[6]] == 1), action=(ct_snat;)
  table=??(ls_in_nat_hairpin  ), priority=100  , match=(ip && ct.new && ct.trk && reg0[[6]] == 1), action=(ct_snat_to_vip; next;)
  table=??(ls_in_nat_hairpin  ), priority=90   , match=(ip && reg0[[12]] == 1), action=(ct_snat;)
])

AT_CHECK([ovn-sbctl lflow-list sw0 | grep ls_in_hairpin | sort | sed 's/table=../table=??/g'], [0], [dnl
  table=??(ls_in_hairpin      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_hairpin      ), priority=1    , match=((reg0[[6]] == 1 || reg0[[12]] == 1)), action=(eth.dst <-> eth.src; outport = inport; flags.loopback = 1; output;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Router policies - ECMP reroute])
AT_KEYWORDS([router policies ecmp reroute])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:03 10.0.0.3"

check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-port1
check ovn-nbctl lsp-set-addresses sw1-port1 "40:54:00:00:00:03 20.0.0.3"

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 1000::a/64
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24 2000::a/64
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr-sw1

check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

check ovn-nbctl --wait=sb lr-policy-add lr0  10 "ip4.src == 10.0.0.3" reroute 172.168.0.101,172.168.0.102

ovn-nbctl lr-policy-list lr0 > policy-list
AT_CAPTURE_FILE([policy-list])
AT_CHECK([cat policy-list], [0], [dnl
Routing Policies
        10                                ip4.src == 10.0.0.3         reroute             172.168.0.101, 172.168.0.102
])

ovn-sbctl dump-flows lr0 > lr0flows3
AT_CAPTURE_FILE([lr0flows3])

AT_CHECK([grep "lr_in_policy" lr0flows3 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = 0; next;)
  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.3), action=(reg8[[0..15]] = 1; reg8[[16..31]] = select(1, 2);)
  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)
])

check ovn-nbctl --wait=sb lr-policy-add lr0  10 "ip4.src == 10.0.0.4" reroute 172.168.0.101,172.168.0.102,172.168.0.103
ovn-sbctl dump-flows lr0 > lr0flows3
AT_CAPTURE_FILE([lr0flows3])

AT_CHECK([grep "lr_in_policy" lr0flows3 |  \
sed 's/reg8\[[0..15\]] = [[0-9]]*/reg8\[[0..15\]] = <cleared>/' | \
sed 's/reg8\[[0..15\]] == [[0-9]]*/reg8\[[0..15\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)
  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.3), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2);)
  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.4), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2, 3);)
  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 3), action=(reg0 = 172.168.0.103; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)
])

check ovn-nbctl --wait=sb lr-policy-add lr0  10 "ip4.src == 10.0.0.5" reroute 172.168.0.110
ovn-sbctl dump-flows lr0 > lr0flows3
AT_CAPTURE_FILE([lr0flows3])

AT_CHECK([grep "lr_in_policy" lr0flows3 |  \
sed 's/reg8\[[0..15\]] = [[0-9]]*/reg8\[[0..15\]] = <cleared>/' | \
sed 's/reg8\[[0..15\]] == [[0-9]]*/reg8\[[0..15\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)
  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.3), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2);)
  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.4), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2, 3);)
  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.5), action=(reg0 = 172.168.0.110; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; reg8[[0..15]] = <cleared>; next;)
  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 3), action=(reg0 = 172.168.0.103; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)
])

check ovn-nbctl --wait=sb lr-policy-del lr0  10 "ip4.src == 10.0.0.3"
ovn-sbctl dump-flows lr0 > lr0flows3
AT_CAPTURE_FILE([lr0flows3])

AT_CHECK([grep "lr_in_policy" lr0flows3 |  \
sed 's/reg8\[[0..15\]] = [[0-9]]*/reg8\[[0..15\]] = <cleared>/' | \
sed 's/reg8\[[0..15\]] == [[0-9]]*/reg8\[[0..15\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)
  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.4), action=(reg8[[0..15]] = <cleared>; reg8[[16..31]] = select(1, 2, 3);)
  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.5), action=(reg0 = 172.168.0.110; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; reg8[[0..15]] = <cleared>; next;)
  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 1), action=(reg0 = 172.168.0.101; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 2), action=(reg0 = 172.168.0.102; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=100  , match=(reg8[[0..15]] == <cleared> && reg8[[16..31]] == 3), action=(reg0 = 172.168.0.103; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)
])

check ovn-nbctl --wait=sb lr-policy-del lr0  10 "ip4.src == 10.0.0.4"
ovn-sbctl dump-flows lr0 > lr0flows3
AT_CAPTURE_FILE([lr0flows3])

AT_CHECK([grep "lr_in_policy" lr0flows3 |  \
sed 's/reg8\[[0..15\]] = [[0-9]]*/reg8\[[0..15\]] = <cleared>/' | \
sed 's/reg8\[[0..15\]] == [[0-9]]*/reg8\[[0..15\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)
  table=??(lr_in_policy       ), priority=10   , match=(ip4.src == 10.0.0.5), action=(reg0 = 172.168.0.110; reg1 = 172.168.0.100; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; reg8[[0..15]] = <cleared>; next;)
  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)
  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)
])

check ovn-nbctl --wait=sb add logical_router_policy . nexthops "2000\:\:b"
ovn-sbctl dump-flows lr0 > lr0flows3
AT_CAPTURE_FILE([lr0flows3])

AT_CHECK([grep "lr_in_policy" lr0flows3 |  \
sed 's/reg8\[[0..15\]] = [[0-9]]*/reg8\[[0..15\]] = <cleared>/' | \
sed 's/reg8\[[0..15\]] == [[0-9]]*/reg8\[[0..15\]] == <cleared>/' | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_policy       ), priority=0    , match=(1), action=(reg8[[0..15]] = <cleared>; next;)
  table=??(lr_in_policy_ecmp  ), priority=0    , match=(1), action=(drop;)
  table=??(lr_in_policy_ecmp  ), priority=150  , match=(reg8[[0..15]] == <cleared>), action=(next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ACL allow-stateless omit conntrack - Logical_Switch])
ovn_start

ovn-nbctl ls-add ls
ovn-nbctl lsp-add ls lsp1
ovn-nbctl lsp-set-addresses lsp1 00:00:00:00:00:01
ovn-nbctl lsp-add ls lsp2
ovn-nbctl lsp-set-addresses lsp2 00:00:00:00:00:02

for direction in from to; do
    ovn-nbctl acl-add ls ${direction}-lport 3 "tcp" allow-related
    ovn-nbctl acl-add ls ${direction}-lport 2 "udp" allow-related
    ovn-nbctl acl-add ls ${direction}-lport 1 "ip" drop
done
ovn-nbctl --wait=sb sync

flow_eth='eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02'
flow_ip='ip.ttl==64 && ip4.src == 42.42.42.1 && ip4.dst == 66.66.66.66'
flow_tcp='tcp && tcp.dst == 80'
flow_udp='udp && udp.dst == 80'

lsp1_inport=$(fetch_column Port_Binding tunnel_key logical_port=lsp1)

# TCP packets should go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_next(ct_state=new|trk) {
    ct_next(ct_state=new|trk) {
        output("lsp2");
    };
};
])

# UDP packets should go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_udp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_next(ct_state=new|trk) {
    ct_next(ct_state=new|trk) {
        output("lsp2");
    };
};
])

# Allow stateless for TCP.
for direction in from to; do
    ovn-nbctl acl-add ls ${direction}-lport 4 tcp allow-stateless
done
ovn-nbctl --wait=sb sync

# TCP packets should not go to conntrack anymore.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}"
AT_CHECK_UNQUOTED([ovn_trace --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

# UDP packets still go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_udp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_next(ct_state=new|trk) {
    ct_next(ct_state=new|trk) {
        output("lsp2");
    };
};
])

# Add a load balancer.
ovn-nbctl lb-add lb-tcp 66.66.66.66:80 42.42.42.2:8080 tcp
ovn-nbctl lb-add lb-udp 66.66.66.66:80 42.42.42.2:8080 udp
ovn-nbctl ls-lb-add ls lb-tcp
ovn-nbctl ls-lb-add ls lb-udp

# Remove stateless for TCP.
ovn-nbctl acl-del ls
ovn-nbctl --wait=sb sync

# TCP packets should go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_lb_mark {
    ct_lb_mark {
        reg0[[6]] = 0;
        reg0[[12]] = 0;
        ct_lb_mark /* default (use --ct to customize) */ {
            output("lsp2");
        };
    };
};
])

# UDP packets should go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_udp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_lb_mark {
    ct_lb_mark {
        reg0[[6]] = 0;
        reg0[[12]] = 0;
        ct_lb_mark /* default (use --ct to customize) */ {
            output("lsp2");
        };
    };
};
])

# Allow stateless for TCP.
for direction in from to; do
    ovn-nbctl acl-add ls ${direction}-lport 4 tcp allow-stateless
done
ovn-nbctl --wait=sb sync

# TCP packets should not go to conntrack for load balancing.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

# UDP packets still go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_udp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_lb_mark {
    ct_lb_mark {
        reg0[[6]] = 0;
        reg0[[12]] = 0;
        ct_lb_mark /* default (use --ct to customize) */ {
            output("lsp2");
        };
    };
};
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ACL allow-stateless omit conntrack - Port_Group])
ovn_start

ovn-nbctl ls-add ls
ovn-nbctl lsp-add ls lsp1
ovn-nbctl lsp-set-addresses lsp1 00:00:00:00:00:01
ovn-nbctl lsp-add ls lsp2
ovn-nbctl lsp-set-addresses lsp2 00:00:00:00:00:02

ovn-nbctl pg-add pg lsp1 lsp2

for direction in from to; do
    ovn-nbctl acl-add pg ${direction}-lport 3 "tcp" allow-related
    ovn-nbctl acl-add pg ${direction}-lport 2 "udp" allow-related
    ovn-nbctl acl-add pg ${direction}-lport 1 "ip" drop
done
ovn-nbctl --wait=sb sync

lsp1_inport=$(fetch_column Port_Binding tunnel_key logical_port=lsp1)
echo $lsp1_inport

flow_eth='eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02'
flow_ip='ip.ttl==64 && ip4.src == 42.42.42.1 && ip4.dst == 66.66.66.66'
flow_tcp='tcp && tcp.dst == 80'
flow_udp='udp && udp.dst == 80'

# TCP packets should go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_next(ct_state=new|trk) {
    ct_next(ct_state=new|trk) {
        output("lsp2");
    };
};
])

# UDP packets should go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_udp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_next(ct_state=new|trk) {
    ct_next(ct_state=new|trk) {
        output("lsp2");
    };
};
])

# Allow stateless for TCP.
for direction in from to; do
    ovn-nbctl acl-add pg ${direction}-lport 4 tcp allow-stateless
done
ovn-nbctl --wait=sb sync

# TCP packets should not go to conntrack anymore.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}"
AT_CHECK_UNQUOTED([ovn_trace --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

# UDP packets still go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_udp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_next(ct_state=new|trk) {
    ct_next(ct_state=new|trk) {
        output("lsp2");
    };
};
])

# Add a load balancer.
ovn-nbctl lb-add lb-tcp 66.66.66.66:80 42.42.42.2:8080 tcp
ovn-nbctl lb-add lb-udp 66.66.66.66:80 42.42.42.2:8080 udp
ovn-nbctl ls-lb-add ls lb-tcp
ovn-nbctl ls-lb-add ls lb-udp

# Remove stateless for TCP.
ovn-nbctl acl-del pg
ovn-nbctl --wait=sb sync

# TCP packets should go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_lb_mark {
    ct_lb_mark {
        reg0[[6]] = 0;
        reg0[[12]] = 0;
        ct_lb_mark /* default (use --ct to customize) */ {
            output("lsp2");
        };
    };
};
])

# UDP packets should go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_udp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_lb_mark {
    ct_lb_mark {
        reg0[[6]] = 0;
        reg0[[12]] = 0;
        ct_lb_mark /* default (use --ct to customize) */ {
            output("lsp2");
        };
    };
};
])

# Allow stateless for TCP.
for direction in from to; do
    ovn-nbctl acl-add pg ${direction}-lport 4 tcp allow-stateless
done
ovn-nbctl --wait=sb sync

# TCP packets should not go to conntrack for load balancing.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

# UDP packets still go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_udp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_lb_mark {
    ct_lb_mark {
        reg0[[6]] = 0;
        reg0[[12]] = 0;
        ct_lb_mark /* default (use --ct to customize) */ {
            output("lsp2");
        };
    };
};
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ACL allow-stateless overrides stateful rules with higher priority - Logical_Switch])
ovn_start

ovn-nbctl ls-add ls
ovn-nbctl lsp-add ls lsp1
ovn-nbctl lsp-set-addresses lsp1 00:00:00:00:00:01
ovn-nbctl lsp-add ls lsp2
ovn-nbctl lsp-set-addresses lsp2 00:00:00:00:00:02

for direction in from to; do
    ovn-nbctl acl-add ls ${direction}-lport 3 "tcp" allow-related
    ovn-nbctl acl-add ls ${direction}-lport 3 "udp" allow
done
ovn-nbctl --wait=sb sync

flow_eth='eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02'
flow_ip='ip.ttl==64 && ip4.src == 42.42.42.1 && ip4.dst == 66.66.66.66'
flow_tcp='tcp && tcp.dst == 80'
flow_udp='udp && udp.dst == 80'

lsp1_inport=$(fetch_column Port_Binding tunnel_key logical_port=lsp1)

# TCP packets should go to conntrack.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_next(ct_state=new|trk) {
    ct_next(ct_state=new|trk) {
        output("lsp2");
    };
};
])

# Allow stateless with *lower* priority. It always beats stateful rules.
for direction in from to; do
    ovn-nbctl acl-add ls ${direction}-lport 1 tcp allow-stateless
    ovn-nbctl acl-add ls ${direction}-lport 1 udp allow-stateless
done
ovn-nbctl --wait=sb sync

# TCP packets should not go to conntrack anymore.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_tcp}"
AT_CHECK_UNQUOTED([ovn_trace --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

# UDP packets should not go to conntrack anymore.
flow="inport == \"lsp1\" && ${flow_eth} && ${flow_ip} && ${flow_udp}"
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check BFD config propagation to SBDB])
AT_KEYWORDS([northd-bfd])
ovn_start

check ovn-nbctl --wait=sb lr-add r0
for i in $(seq 1 7); do
    check ovn-nbctl --wait=sb lrp-add r0 r0-sw$i 00:00:00:00:00:0$i 192.168.$i.1/24
    check ovn-nbctl --wait=sb ls-add sw$i
    check ovn-nbctl --wait=sb lsp-add sw$i sw$i-r0
    check ovn-nbctl --wait=sb lsp-set-type sw$i-r0 router
    check ovn-nbctl --wait=sb lsp-set-options sw$i-r0 router-port=r0-sw$i
    check ovn-nbctl --wait=sb lsp-set-addresses sw$i-r0 00:00:00:00:00:0$i
done

uuid=$(ovn-nbctl create bfd logical_port=r0-sw1 dst_ip=192.168.1.2 status=down min_tx=250 min_rx=250 detect_mult=10)
ovn-nbctl create bfd logical_port=r0-sw2 dst_ip=192.168.2.2 status=down min_tx=500 min_rx=500 detect_mult=20
ovn-nbctl create bfd logical_port=r0-sw3 dst_ip=192.168.3.2 status=down
ovn-nbctl create bfd logical_port=r0-sw4 dst_ip=192.168.4.2 status=down min_tx=0 detect_mult=0

wait_row_count bfd 1 logical_port=r0-sw1 detect_mult=10 dst_ip=192.168.1.2 \
                     min_rx=250 min_tx=250 status=admin_down
wait_row_count bfd 1 logical_port=r0-sw2 detect_mult=20 dst_ip=192.168.2.2 \
                     min_rx=500 min_tx=500 status=admin_down
wait_row_count bfd 1 logical_port=r0-sw3 detect_mult=5 dst_ip=192.168.3.2 \
                     min_rx=1000 min_tx=1000 status=admin_down

uuid=$(fetch_column nb:bfd _uuid logical_port=r0-sw1)
check ovn-nbctl set bfd $uuid min_tx=1000 min_rx=1000 detect_mult=100

uuid_2=$(fetch_column nb:bfd _uuid logical_port=r0-sw2)
check ovn-nbctl clear bfd $uuid_2 min_rx
wait_row_count bfd 1 logical_port=r0-sw2 min_rx=1000
wait_row_count bfd 1 logical_port=r0-sw1 min_rx=1000 min_tx=1000 detect_mult=100

check ovn-nbctl --bfd=$uuid lr-route-add r0 100.0.0.0/8 192.168.1.2
wait_column down bfd status logical_port=r0-sw1
AT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.1.2 | grep -q bfd],[0])

check ovn-nbctl --bfd lr-route-add r0 200.0.0.0/8 192.168.2.2
wait_column down bfd status logical_port=r0-sw2
AT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.2.2 | grep -q bfd],[0])

check ovn-nbctl --bfd lr-route-add r0 240.0.0.0/8 192.168.5.2 r0-sw5
wait_column down bfd status logical_port=r0-sw5
AT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.5.2 | grep -q bfd],[0])

check ovn-nbctl --bfd --policy=src-ip lr-route-add r0 192.168.6.1/32 192.168.10.10 r0-sw6
wait_column down bfd status logical_port=r0-sw6
AT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.6.1 | grep -q bfd],[0])

check ovn-nbctl --bfd --policy=src-ip lr-route-add r0 192.168.7.1/32 192.168.10.10 r0-sw7
wait_column down bfd status logical_port=r0-sw7
AT_CHECK([ovn-nbctl lr-route-list r0 | grep 192.168.7.1 | grep -q bfd],[0])

route_uuid=$(fetch_column nb:logical_router_static_route _uuid ip_prefix="100.0.0.0/8")
check ovn-nbctl clear logical_router_static_route $route_uuid bfd
wait_column admin_down bfd status logical_port=r0-sw1

ovn-nbctl destroy bfd $uuid
wait_row_count bfd 5

# Simulate BFD up in Southbound for an automatically created entry.
# This entry is referenced so the state in the Northbound should also
# become "up".
wait_column down nb:bfd status logical_port=r0-sw2
bfd2_uuid=$(fetch_column bfd _uuid logical_port=r0-sw2)
check ovn-sbctl set bfd $bfd2_uuid status=up
wait_column up nb:bfd status logical_port=r0-sw2

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ovn -- check CoPP config])
AT_KEYWORDS([northd-CoPP])

ovn_start

check ovn-nbctl --wait=sb lr-add r0
check ovn-nbctl --wait=sb lrp-add r0 r0-sw1 00:00:00:00:00:01 192.168.1.1/24
check ovn-nbctl --wait=sb ls-add sw1
check ovn-nbctl --wait=sb lsp-add sw1 sw1-r0
check ovn-nbctl --wait=sb lsp-set-type sw1-r0 router
check ovn-nbctl --wait=sb lsp-set-options sw1-r0 router-port=r0-sw1
check ovn-nbctl --wait=sb lsp-set-addresses sw1-r0 00:00:00:00:00:01

check ovn-nbctl --event lb-add lb0 192.168.1.100:80 ""
check ovn-nbctl ls-lb-add sw1 lb0
check ovn-nbctl --wait=hv meter-add meter0 drop 100 pktps 10
check ovn-nbctl --wait=hv copp-add copp0 event-elb meter0
check ovn-nbctl --wait=hv ls-copp-add copp0 sw1
AT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl
event-elb: meter0
])

AT_CHECK([ovn-sbctl list logical_flow | grep trigger_event -A 2 | grep -q meter0])

check ovn-nbctl --wait=hv meter-add meter1 drop 300 pktps 10
AT_CHECK([ovn-nbctl meter-list |grep meter1 -A 1], [0], [dnl
meter1: bands:
  drop: 300 pktps, 10 packet burst
])
check ovn-nbctl --wait=hv --may-exist meter-add meter1 drop 200 pktps 10
AT_CHECK([ovn-nbctl meter-list |grep meter1 -A 1], [0], [dnl
meter1: bands:
  drop: 200 pktps, 10 packet burst
])
check ovn-nbctl --wait=hv copp-add copp1 arp meter1
check ovn-nbctl --wait=hv lr-copp-add copp1 r0
AT_CHECK([ovn-nbctl copp-list copp1], [0], [dnl
arp: meter1
])

AT_CHECK([ovn-sbctl list logical_flow | grep arp -A 2 | grep -q meter1])

check ovn-nbctl --wait=hv copp-del copp1 arp
AT_CHECK([ovn-nbctl copp-list copp1], [0], [dnl
])
AT_CHECK([ovn-sbctl list logical_flow | grep arp -A 2 | grep -q meter1],[1])

check ovn-nbctl --wait=hv meter-add meter2 drop 400 pktps 10
check ovn-nbctl --wait=hv copp-add copp2 icmp4-error meter2
check ovn-nbctl --wait=hv lr-copp-add copp2 r0
AT_CHECK([ovn-nbctl copp-list copp2], [0], [dnl
icmp4-error: meter2
])

AT_CHECK([ovn-sbctl list logical_flow | grep icmp4 -A 2 | grep -q meter2])

check ovn-nbctl --wait=hv copp-del copp2 icmp4-error
AT_CHECK([ovn-nbctl copp-list copp2], [0], [dnl
])

check ovn-nbctl --wait=hv copp-add copp3 icmp6-error meter2
check ovn-nbctl --wait=hv lr-copp-add copp3 r0
AT_CHECK([ovn-nbctl copp-list copp3], [0], [dnl
icmp6-error: meter2
])

AT_CHECK([ovn-sbctl list logical_flow | grep icmp6 -A 2 | grep -q meter2])

check ovn-nbctl --wait=hv copp-del copp3 icmp6-error
AT_CHECK([ovn-nbctl copp-list copp3], [0], [dnl
])

check ovn-nbctl --wait=hv copp-add copp4 tcp-reset meter2
check ovn-nbctl --wait=hv lr-copp-add copp4 r0
AT_CHECK([ovn-nbctl copp-list copp4], [0], [dnl
tcp-reset: meter2
])

AT_CHECK([ovn-sbctl list logical_flow | grep tcp -A 2 | grep -q meter2])

check ovn-nbctl --wait=hv copp-del copp4 tcp-reset
AT_CHECK([ovn-nbctl copp-list copp4], [0], [dnl
])

check ovn-nbctl --wait=hv copp-del copp0 event-elb
AT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl
])

AT_CHECK([ovn-sbctl list logical_flow | grep trigger_event -A 2 | grep -q meter0],[1])

# let's try to add an usupported protocol "dhcp"
AT_CHECK([ovn-nbctl --wait=hv copp-add copp5 dhcp meter1],[1],[],[dnl
ovn-nbctl: Invalid control protocol. Allowed values: arp, arp-resolve, dhcpv4-opts, dhcpv6-opts, dns, event-elb, icmp4-error, icmp6-error, igmp, nd-na, nd-ns, nd-ns-resolve, nd-ra-opts, tcp-reset, bfd, reject, svc-monitor.
])

#Let's try to add a valid protocol to an unknown datapath
check ovn-nbctl --wait=hv copp-add copp6 arp meter1
AT_CHECK([ovn-nbctl --wait=hv ls-copp-add copp6 sw10],[1],[],[dnl
ovn-nbctl: sw10: switch name not found
])

check ovn-nbctl --bfd lr-route-add r0 240.0.0.0/8 192.168.50.2 r0-sw1
check ovn-nbctl --wait=hv copp-add copp7 bfd meter0
check ovn-nbctl --wait=hv lr-copp-add copp7 r0
AT_CHECK([ovn-nbctl copp-list copp7], [0], [dnl
bfd: meter0
])
AT_CHECK([ovn-sbctl list logical_flow | grep bfd -A 2 | grep -q meter0])

check ovn-nbctl --wait=hv set Logical_Switch sw1 \
    other_config:mcast_querier="false" \
    other_config:mcast_snoop="true"
check ovn-nbctl --wait=hv copp-add copp8 igmp meter1
check ovn-nbctl --wait=hv ls-copp-add copp8 sw1
AT_CHECK([ovn-nbctl copp-list copp8], [0], [dnl
igmp: meter1
])
AT_CHECK([ovn-sbctl list logical_flow | grep igmp -A 2 | grep -q meter1])

check ovn-nbctl copp-del copp8
AT_CHECK([ovn-nbctl copp-list copp8], [0], [dnl
])

# let's add igmp meter1 twice
AT_CHECK([ovn-nbctl --wait=hv copp-add copp9 igmp meter1])
AT_CHECK([ovn-nbctl copp-list copp9], [0], [dnl
igmp: meter1
])

# let's delete a wrong meter
AT_CHECK([ovn-nbctl --wait=hv copp-del copp9 event-elb])
AT_CHECK([ovn-nbctl copp-list copp9], [0], [dnl
igmp: meter1
])

check ovn-nbctl copp-del copp9
AT_CHECK([ovn-nbctl copp-list copp9], [0], [dnl
])

check ovn-nbctl copp-del copp6
check ovn-nbctl copp-del copp7
AT_CHECK([ovn-nbctl list copp], [0], [dnl
])

check ovn-nbctl --wait=hv copp-add copp0 arp meter0
check ovn-nbctl --wait=hv lr-copp-add copp0 r0
AT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl
arp: meter0
])

AT_CHECK([fetch_column nb:CoPP name], [0], [dnl
copp0
])

copp_uuid=$(fetch_column nb:CoPP _uuid)
check ovn-nbctl --wait=hv copp-add copp0 arp meter0
check ovn-nbctl --wait=hv ls-copp-add copp0 sw1

ls_copp_uuid=$(fetch_column nb:Logical_Switch copp)
AT_CHECK([test "$ls_copp_uuid" = "$copp_uuid"])

check ovn-nbctl --wait=hv copp-add $copp_uuid igmp meter0
AT_CHECK([ovn-nbctl copp-list copp0 | sort], [0], [dnl
arp: meter0
igmp: meter0
])

check ovn-nbctl --wait=sb lrp-add r0 r0-sw2 00:00:00:00:00:03 192.168.2.1/24
check ovn-nbctl --wait=sb ls-add sw2
check ovn-nbctl --wait=sb lsp-add sw2 sw2-r0
check ovn-nbctl --wait=sb lsp-set-type sw2-r0 router
check ovn-nbctl --wait=sb lsp-set-options sw2-r0 router-port=r0-sw2
check ovn-nbctl --wait=sb lsp-set-addresses sw2-r0 00:00:00:00:00:02

check ovn-nbctl --wait=hv copp-add copp0 event-elb meter0
check ovn-nbctl --wait=hv ls-copp-add copp0 sw2
ls2_copp_uuid=$(ovn-nbctl get Logical_Switch sw2 copp)
AT_CHECK([test "$ls2_copp_uuid" = "$copp_uuid"])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check LSP attached to multiple LS])
ovn_start

check ovn-nbctl ls-add ls1 \
    -- ls-add ls2 \
    -- lsp-add ls1 p1
check ovn-nbctl --wait=sb sync

uuid=$(fetch_column nb:Logical_Switch_Port _uuid name=p1)
check ovn-nbctl set Logical_Switch ls2 ports=$uuid
check ovn-nbctl --wait=sb sync

AT_CHECK([grep -qE 'duplicate logical port p1' northd/ovn-northd.log], [0])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check LRP attached to multiple LR])
ovn_start

check ovn-nbctl lr-add lr1 \
    -- lr-add lr2 \
    -- lrp-add lr1 p1 00:00:00:00:00:01 10.0.0.1/24
check ovn-nbctl --wait=sb sync

uuid=$(fetch_column nb:Logical_Router_Port _uuid name=p1)
check ovn-nbctl set Logical_Router lr2 ports=$uuid
check ovn-nbctl --wait=sb sync

AT_CHECK([grep -qE 'duplicate logical router port p1' northd/ovn-northd.log], [0])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check duplicate LSP/LRP])
ovn_start

check ovn-nbctl ls-add ls \
    -- lsp-add ls p1 \
    -- lr-add lr \
    -- lrp-add lr p1 00:00:00:00:00:01 10.0.0.1/24
check ovn-nbctl --wait=sb sync

AT_CHECK([grep -qE 'duplicate logical.*port p1' northd/ovn-northd.log], [0])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Port_Binding.up backwards compatibility])
ovn_start

ovn-nbctl ls-add ls1
ovn-nbctl --wait=sb lsp-add ls1 lsp1

# Simulate the fact that lsp1 had been previously bound on hv1 by an
# ovn-controller running an older version.
ovn-sbctl \
    --id=@e create encap chassis_name=hv1 ip="192.168.0.1" type="geneve" \
    -- --id=@c create chassis name=hv1 encaps=@e \
    -- set Port_Binding lsp1 chassis=@c

wait_for_ports_up lsp1

# Simulate the fact that hv1 is aware of Port_Binding.up, ovn-northd
# should transition the port state to down.
check ovn-sbctl set chassis hv1 other_config:port-up-notif=true
wait_row_count nb:Logical_Switch_Port 1 up=false name=lsp1

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV_PARALLELIZATION([
AT_SETUP([Load Balancers and lb_force_snat_ip for Gateway Routers])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

lbg=$(ovn-nbctl create load_balancer_group name=lbg)

check ovn-nbctl lb-add lb1 10.0.0.10:80 10.0.0.4:8080
check ovn-nbctl lb-add lbg1 10.0.0.100:80 10.0.0.40:8080
lbg1=$(fetch_column nb:load_balancer _uuid name=lbg1)
check ovn-nbctl add load_balancer_group $lbg load_balancer $lbg1
check ovn-nbctl lr-lb-add lr0 lb1
check ovn-nbctl add logical_router lr0 load_balancer_group $lbg
check ovn-nbctl set logical_router lr0 options:chassis=ch1

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.4:8080);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.40:8080);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])


check ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip="20.0.0.4 aef0::4"

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])


AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(ip4 && ip4.dst == 20.0.0.4), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(ip6 && ip6.dst == aef0::4), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; force_snat);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=100  , match=(flags.force_snat_for_lb == 1 && ip4), action=(ct_snat(20.0.0.4);)
  table=? (lr_out_snat        ), priority=100  , match=(flags.force_snat_for_lb == 1 && ip6), action=(ct_snat(aef0::4);)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)
  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )
])

check ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip="router_ip"

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_ip_input" lr0flows | grep "priority=60" | sort], [0], [dnl
])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-public" && ip4.dst == 172.168.0.100), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw0" && ip4.dst == 10.0.0.1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw1" && ip4.dst == 20.0.0.1), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; force_snat);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-public"), action=(ct_snat(172.168.0.100);)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-sw0"), action=(ct_snat(10.0.0.1);)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-sw1"), action=(ct_snat(20.0.0.1);)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)
  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )
])

check ovn-nbctl --wait=sb remove logical_router lr0 options chassis

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
])

check ovn-nbctl set logical_router lr0 options:chassis=ch1
check ovn-nbctl --wait=sb add logical_router_port lr0-sw1 networks "bef0\:\:1/64"

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-public" && ip4.dst == 172.168.0.100), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw0" && ip4.dst == 10.0.0.1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw1" && ip4.dst == 20.0.0.1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw1" && ip6.dst == bef0::1), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.100 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; force_snat);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-public"), action=(ct_snat(172.168.0.100);)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-sw0"), action=(ct_snat(10.0.0.1);)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-sw1"), action=(ct_snat(20.0.0.1);)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip6 && outport == "lr0-sw1"), action=(ct_snat(bef0::1);)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)
  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )
])

check ovn-nbctl --wait=sb lb-add lb2 10.0.0.20:80 10.0.0.40:8080
check ovn-nbctl --wait=sb set load_balancer lb2 options:skip_snat=true
check ovn-nbctl lr-lb-add lr0 lb2
check ovn-nbctl --wait=sb lb-del lb1
ovn-sbctl dump-flows lr0 > lr0flows

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-public" && ip4.dst == 172.168.0.100), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw0" && ip4.dst == 10.0.0.1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw1" && ip4.dst == 20.0.0.1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw1" && ip6.dst == bef0::1), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.100), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.20), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | grep skip_snat_for_lb | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.20 && tcp && tcp.dst == 80), action=(flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.40:8080; skip_snat);)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | grep skip_snat_for_lb | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=120  , match=(flags.skip_snat_for_lb == 1 && ip), action=(next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)
  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([HA chassis group cleanup for external port ])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-type sw0-p1 external

check ovn-sbctl chassis-add ch1 geneve 127.0.0.1
check ovn-sbctl chassis-add ch2 geneve 127.0.0.2

check ovn-nbctl ha-chassis-group-add hagrp1
check ovn-nbctl ha-chassis-group-add-chassis hagrp1 ch1 20
check ovn-nbctl --wait=sb ha-chassis-group-add-chassis hagrp1 ch2 10

ha_grp1_uuid=$(fetch_column nb:ha_chassis_group _uuid)
echo "ha grp1 uuid = $ha_grp1_uuid"
ovn-nbctl list ha_chassis_group
check ovn-nbctl set logical_switch_port sw0-p1 ha_chassis_group=$ha_grp1_uuid

wait_row_count ha_chassis_group 1
check ovn-nbctl clear logical_switch_port sw0-p1 ha_chassis_group
wait_row_count ha_chassis_group 0

check ovn-nbctl set logical_switch_port sw0-p1 ha_chassis_group=$ha_grp1_uuid
wait_row_count ha_chassis_group 1
sb_ha_grp1_uuid=$(fetch_column ha_chassis_group _uuid)

echo
echo "__file__:__line__:Check that port_binding sw0-p1 has ha_chassis_group set"

check_column "$sb_ha_grp1_uuid" Port_Binding ha_chassis_group logical_port=sw0-p1

AS_BOX([Clear ha_chassis_group for sw0-p1 and reset port type to normal port in the same txn])

check ovn-nbctl clear logical_switch_port sw0-p1 ha_chassis_group -- set logical_switch_port sw0-p1 'type=""'
wait_row_count ha_chassis_group 0
check_column "" Port_Binding chassis logical_port=sw0-p1

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([FDB cleanup])

ovn_start

ovn-nbctl ls-add sw0
ovn-nbctl lsp-add sw0 sw0-p1
ovn-nbctl lsp-add sw0 sw0-p2
ovn-nbctl lsp-add sw0 sw0-p3

ovn-nbctl ls-add sw1
ovn-nbctl lsp-add sw1 sw1-p1
ovn-nbctl lsp-add sw1 sw1-p2
ovn-nbctl --wait=sb lsp-add sw1 sw1-p3

sw0_key=$(fetch_column datapath_binding tunnel_key external_ids:name=sw0)
sw1_key=$(fetch_column datapath_binding tunnel_key external_ids:name=sw1)
sw0p1_key=$(fetch_column port_binding tunnel_key logical_port=sw0-p1)
sw0p2_key=$(fetch_column port_binding tunnel_key logical_port=sw0-p2)
sw1p1_key=$(fetch_column port_binding tunnel_key logical_port=sw1-p1)

ovn-sbctl create FDB mac="00\:00\:00\:00\:00\:01" dp_key=$sw0_key port_key=$sw0p1_key
ovn-sbctl create FDB mac="00\:00\:00\:00\:00\:02" dp_key=$sw0_key port_key=$sw0p1_key
ovn-sbctl create FDB mac="00\:00\:00\:00\:00\:03" dp_key=$sw0_key port_key=$sw0p2_key
ovn-sbctl create FDB mac="00\:00\:00\:00\:01\:01" dp_key=$sw1_key port_key=$sw1p1_key
ovn-sbctl create FDB mac="00\:00\:00\:00\:01\:02" dp_key=$sw1_key port_key=$sw1p1_key
ovn-sbctl create FDB mac="00\:00\:00\:00\:01\:03" dp_key=$sw1_key port_key=$sw1p1_key

wait_row_count FDB 6

ovn-sbctl create fdb mac="00\:00\:00\:00\:01\:03" dp_key=$sw1_key port_key=10
wait_row_count FDB 6
ovn-sbctl create fdb mac="00\:00\:00\:00\:01\:03" dp_key=4 port_key=10
wait_row_count FDB 6

ovn-nbctl --wait=sb ls-del sw1
wait_row_count FDB 3

ovn-nbctl lsp-del sw0-p3
wait_row_count FDB 3

ovn-nbctl lsp-del sw0-p1
wait_row_count FDB 1

check_column '00:00:00:00:00:03' FDB mac
ovn-sbctl list fdb

check_column $sw0_key FDB dp_key
check_column $sw0p2_key FDB port_key

ovn-nbctl --wait=sb lsp-add sw0-p1
wait_row_count FDB 1

ovn-nbctl lsp-del sw0-p2
ovn-nbctl lsp-add sw0-p2
wait_row_count FDB 0

ovn-sbctl list FDB

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([LS load balancer logical flows])
ovn_start

lbg=$(ovn-nbctl create load_balancer_group name=lbg)
check ovn-nbctl \
    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080 \
    -- lb-add lbg0 10.0.0.20:80 10.0.0.40:8080
lbg0=$(fetch_column nb:load_balancer _uuid name=lbg0)

check ovn-nbctl \
    -- ls-add sw0 \
    -- add logical_switch sw0 load_balancer_group $lbg \
    -- ls-lb-add sw0 lb0 \
    -- add load_balancer_group $lbg load_balancer $lbg0

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl --wait=sb sync

check_stateful_flows() {
    action=$1
    ovn-sbctl dump-flows sw0 > sw0flows
    AT_CAPTURE_FILE([sw0flows])

    AT_CHECK([grep "ls_in_pre_lb" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_pre_lb       ), priority=0    , match=(1), action=(next;)
  table=? (ls_in_pre_lb       ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)
  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.mcast), action=(next;)
  table=? (ls_in_pre_lb       ), priority=110  , match=(ip && inport == "sw0-lr0"), action=(next;)
  table=? (ls_in_pre_lb       ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)
  table=? (ls_in_pre_lb       ), priority=110  , match=(reg0[[16]] == 1), action=(next;)
])

    AT_CHECK([grep "ls_in_pre_stateful" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_pre_stateful ), priority=0    , match=(1), action=(next;)
  table=? (ls_in_pre_stateful ), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)
  table=? (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)
  table=? (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg1 = 10.0.0.10; reg2[[0..15]] = 80; ct_lb_mark;)
  table=? (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 10.0.0.20 && tcp.dst == 80), action=(reg1 = 10.0.0.20; reg2[[0..15]] = 80; ct_lb_mark;)
])

    AT_CHECK([grep "ls_in_lb " sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.4:8080);)
  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 10.0.0.20 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.40:8080);)
])

    AT_CHECK([grep "ls_in_stateful" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

    AT_CHECK_UNQUOTED([grep "ls_out_pre_lb" sw0flows | sort], [0], [dnl
  table=1 (ls_out_pre_lb      ), priority=0    , match=(1), action=(next;)
  table=1 (ls_out_pre_lb      ), priority=100  , match=(ip), action=(reg0[[2]] = 1; next;)
  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.mcast), action=(next;)
  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.src == \$svc_monitor_mac), action=(next;)
  table=1 (ls_out_pre_lb      ), priority=110  , match=(ip && outport == "sw0-lr0"), action=($action)
  table=1 (ls_out_pre_lb      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)
  table=1 (ls_out_pre_lb      ), priority=110  , match=(reg0[[16]] == 1), action=(next;)
])

    AT_CHECK([grep "ls_out_pre_stateful" sw0flows | sort], [0], [dnl
  table=2 (ls_out_pre_stateful), priority=0    , match=(1), action=(next;)
  table=2 (ls_out_pre_stateful), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)
  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)
])

    AT_CHECK([grep "ls_out_lb" sw0flows | sort], [0], [])

    AT_CHECK([grep "ls_out_stateful" sw0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_out_stateful    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])
}

check_stateful_flows "ct_clear; next;"

# Add few ACLs
check ovn-nbctl --wait=sb acl-add sw0 from-lport 1002 "ip4 && tcp && tcp.dst == 80" allow-related
check ovn-nbctl --wait=sb acl-add sw0 to-lport 1002 "ip4 && tcp && tcp.src == 80" drop

check_stateful_flows "next;"

# Remove load balancers from sw0
check ovn-nbctl ls-lb-del sw0 lb0
check ovn-nbctl clear logical_switch sw0 load_balancer_group
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep "ls_in_pre_lb" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_pre_lb       ), priority=0    , match=(1), action=(next;)
  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=? (ls_in_pre_lb       ), priority=110  , match=(eth.mcast), action=(next;)
  table=? (ls_in_pre_lb       ), priority=110  , match=(ip && inport == "sw0-lr0"), action=(next;)
  table=? (ls_in_pre_lb       ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)
  table=? (ls_in_pre_lb       ), priority=110  , match=(reg0[[16]] == 1), action=(next;)
])

AT_CHECK([grep "ls_in_pre_stateful" sw0flows | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_pre_stateful ), priority=0    , match=(1), action=(next;)
  table=? (ls_in_pre_stateful ), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)
  table=? (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)
])

AT_CHECK([grep "ls_in_lb " sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "ls_in_stateful" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

AT_CHECK([grep "ls_out_pre_lb" sw0flows | sort], [0], [dnl
  table=1 (ls_out_pre_lb      ), priority=0    , match=(1), action=(next;)
  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.mcast), action=(next;)
  table=1 (ls_out_pre_lb      ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
  table=1 (ls_out_pre_lb      ), priority=110  , match=(ip && outport == "sw0-lr0"), action=(next;)
  table=1 (ls_out_pre_lb      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2), action=(next;)
  table=1 (ls_out_pre_lb      ), priority=110  , match=(reg0[[16]] == 1), action=(next;)
])

AT_CHECK([grep "ls_out_pre_stateful" sw0flows | sort], [0], [dnl
  table=2 (ls_out_pre_stateful), priority=0    , match=(1), action=(next;)
  table=2 (ls_out_pre_stateful), priority=100  , match=(reg0[[0]] == 1), action=(ct_next;)
  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)
])

AT_CHECK([grep "ls_out_stateful" sw0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_out_stateful    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

# LB with event=false and reject=false
AT_CHECK([ovn-nbctl create load_balancer name=lb1 options:reject=false options:event=false vips:\"10.0.0.20\"=\"\" protocol=tcp], [0], [ignore])
check ovn-nbctl --wait=sb ls-lb-add sw0 lb1

AT_CHECK([ovn-sbctl dump-flows sw0 | grep "ls_in_lb " | sed 's/table=../table=??/' | sort ], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.20), action=(drop;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV_PARALLELIZATION([
AT_SETUP([ovn -- ACL label usage])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0p1

check ovn-nbctl --wait=sb --label=1234 acl-add sw0 to-lport 1002 tcp allow-related
check ovn-nbctl --wait=sb --label=1234 acl-add sw0 from-lport 1002 tcp allow-related

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep -w "ls_in_acl_eval" sw0flows | grep 2002 | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_acl_eval     ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)
  table=? (ls_in_acl_eval     ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)
])
AT_CHECK([grep "ls_in_stateful" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

AT_CHECK([grep -w "ls_out_acl_eval" sw0flows | grep 2002 | sort], [0], [dnl
  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)
  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)
])
AT_CHECK([grep "ls_out_stateful" sw0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_out_stateful    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

# Add new ACL without label
check ovn-nbctl --wait=sb acl-add sw0 to-lport 1002 udp allow-related
check ovn-nbctl --wait=sb acl-add sw0 from-lport 1002 udp allow-related

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep -w "ls_in_acl_eval" sw0flows | grep 2002 | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_acl_eval     ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)
  table=? (ls_in_acl_eval     ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)
  table=? (ls_in_acl_eval     ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(reg8[[16]] = 1; next;)
])
AT_CHECK([grep "ls_in_stateful" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

AT_CHECK([grep -w "ls_out_acl_eval" sw0flows | grep 2002 | sort], [0], [dnl
  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[7]] == 1 && (tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)
  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[8]] == 1 && (tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; reg0[[13]] = 1; reg3 = 1234; next;)
  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(reg8[[16]] = 1; next;)
])
AT_CHECK([grep "ls_out_stateful" sw0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_out_stateful    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

# Delete new ACL with label
check ovn-nbctl --wait=sb acl-del sw0 to-lport 1002 tcp
check ovn-nbctl --wait=sb acl-del sw0 from-lport 1002 tcp

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep -w "ls_in_acl_eval" sw0flows | grep 2002 | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_acl_eval     ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(reg8[[16]] = 1; next;)
])
AT_CHECK([grep "ls_in_stateful" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

AT_CHECK([grep -w "ls_out_acl_eval" sw0flows | grep 2002 | sort], [0], [dnl
  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[7]] == 1 && (udp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=2002 , match=(reg0[[8]] == 1 && (udp)), action=(reg8[[16]] = 1; next;)
])
AT_CHECK([grep "ls_out_stateful" sw0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_out_stateful    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_out_stateful    ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV_PARALLELIZATION([
AT_SETUP([ovn -- ct.inv usage])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0p1

check ovn-nbctl --wait=sb acl-add sw0 to-lport 1002 ip allow-related

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep -w "ls_in_acl_eval" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
])

AT_CHECK([grep -w "ls_out_acl_eval" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
])

# Disable ct.inv usage.
check ovn-nbctl --wait=sb set NB_Global . options:use_ct_inv_match=false

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep -w "ls_in_acl_eval" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=? (ls_in_acl_eval     ), priority=65532, match=((ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
])

AT_CHECK([grep -w "ls_out_acl_eval" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=? (ls_out_acl_eval    ), priority=65532, match=((ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
])

AT_CHECK([grep -c "ct.inv" sw0flows], [1], [dnl
0
])

# Enable ct.inv usage.
check ovn-nbctl --wait=sb set NB_Global . options:use_ct_inv_match=true

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep -w "ls_in_acl_eval" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
])

AT_CHECK([grep -w "ls_out_acl_eval" sw0flows | grep 6553 | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
])

AT_CHECK([grep -c "ct.inv" sw0flows], [0], [dnl
6
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([northd ssl file change])
AT_SKIP_IF([test "$HAVE_OPENSSL" = no])
PKIDIR="$(cd $abs_top_builddir/tests && pwd)"
AT_SKIP_IF([expr "$PKIDIR" : ".*[[ 	'\"
\\]]"])
ovn_start --backup-northd=none

as northd
OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])

as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

key_server=testpki-test-privkey.pem
cert_server=testpki-test-cert.pem
cacert=testpki-cacert.pem

cd ovn-sb
rm ovsdb-server.log
ssl_options="--remote=pssl:0:127.0.0.1 ovn-sb.db -p $PKIDIR/$key_server -c $PKIDIR/$cert_server -C $PKIDIR/$cacert"
AT_CHECK([ovsdb-server --detach --no-chdir --pidfile --log-file $ssl_options], [0], [], [stderr])
on_exit "kill `cat ovsdb-server.pid`"
PARSE_LISTENING_PORT([ovsdb-server.log], [TCP_PORT])
cd ..

key=testpki-hv1-privkey.pem
cert=testpki-hv1-cert.pem

key2=testpki-hv2-privkey.pem
cert3=testpki-hv3-cert.pem

# Use mismatched key and cert when restarting using SSL options
cp $PKIDIR/$key2 $key
cp $PKIDIR/$cert3 $cert
cp $PKIDIR/$cacert $cacert
as northd
start_daemon ovn$NORTHD_TYPE -vjsonrpc \
    --ovnnb-db=$OVN_NB_DB --ovnsb-db=ssl:127.0.0.1:$TCP_PORT \
    -p $key -c $cert -C $cacert

# SSL should not connect because of key and cert mismatch
AT_FAIL_IF([ovn-nbctl --timeout=3 --wait=sb sync])

# Modify the files with the correct key and cert, and reconnect should succeed
cp $PKIDIR/$key $key
cp $PKIDIR/$cert $cert
check ovn-nbctl --wait=sb sync

OVS_APP_EXIT_AND_WAIT([NORTHD_TYPE])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([trace with IPv4 dnat])
AT_KEYWORDS([dnat])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 192.168.0.2"

check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-port1
check ovn-nbctl lsp-set-addresses sw1-port1 "50:54:00:00:00:03 11.0.0.2"

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lrp0 00:00:00:00:ff:01 192.168.0.1/24
check ovn-nbctl lsp-add sw0 lrp0-attachment
check ovn-nbctl lsp-set-type lrp0-attachment router
check ovn-nbctl lsp-set-addresses lrp0-attachment 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options lrp0-attachment router-port=lrp0
check ovn-nbctl lrp-add lr0 lrp1 00:00:00:00:ff:02 11.0.0.1/24 -- lrp-set-gateway-chassis lrp1 chassis-1
check ovn-nbctl lsp-add sw1 lrp1-attachment
check ovn-nbctl lsp-set-type lrp1-attachment router
check ovn-nbctl lsp-set-addresses lrp1-attachment 00:00:00:00:ff:02
check ovn-nbctl lsp-set-options lrp1-attachment router-port=lrp1

check ovn-nbctl lr-nat-add lr0 dnat 42.42.42.42 192.168.0.2
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn_trace --minimal 'inport == "sw1-port1" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip4.dst == 42.42.42.42 && ip4.src == 11.0.0.2 && ip.ttl == 64' | grep "output(\"sw0-port1\")"], [0], [ignore])

dnl If we remove the DNAT entry we will be unable to trace to the DNAT address
check ovn-nbctl lr-nat-del lr0 dnat 42.42.42.42
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn_trace --minimal 'inport == "sw1-port1" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip4.dst == 42.42.42.42 && ip4.src == 11.0.0.2 && ip.ttl == 64' | grep "output(\"sw0-port1\")"], [1], [ignore])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([trace with IPv6 dnat])
AT_KEYWORDS([dnat])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 fd68::2"

check ovn-nbctl ls-add sw1
check ovn-nbctl lsp-add sw1 sw1-port1
check ovn-nbctl lsp-set-addresses sw1-port1 "50:54:00:00:00:03 fd11::2"

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lrp0 00:00:00:00:ff:01 fd68::1/64
check ovn-nbctl lsp-add sw0 lrp0-attachment
check ovn-nbctl lsp-set-type lrp0-attachment router
check ovn-nbctl lsp-set-addresses lrp0-attachment 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options lrp0-attachment router-port=lrp0
check ovn-nbctl lrp-add lr0 lrp1 00:00:00:00:ff:02 fd11::1/64 -- lrp-set-gateway-chassis lrp1 chassis-1
check ovn-nbctl lsp-add sw1 lrp1-attachment
check ovn-nbctl lsp-set-type lrp1-attachment router
check ovn-nbctl lsp-set-addresses lrp1-attachment 00:00:00:00:ff:02
check ovn-nbctl lsp-set-options lrp1-attachment router-port=lrp1

check ovn-nbctl lr-nat-add lr0 dnat fd42::42 fd68::2
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn_trace --minimal 'inport == "sw1-port1" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip6.dst == fd42::42 && ip6.src == fd11::2 && ip.ttl == 64' | grep "output(\"sw0-port1\")"], [0], [ignore])

dnl If we remove the DNAT entry we will be unable to trace to the DNAT address
check ovn-nbctl lr-nat-del lr0 dnat fd42::42
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn_trace --minimal 'inport == "sw1-port1" && eth.src == 50:54:00:00:00:03 && eth.dst == 00:00:00:00:ff:02 && ip6.dst == fd42::42 && ip6.src == fd11::2 && ip.ttl == 64' | grep "output(\"sw0-port1\")"], [1], [ignore])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([DHCP options])
AT_KEYWORDS([dnat])
ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-port1
check ovn-nbctl lsp-set-addresses sw0-port1 "50:54:00:00:00:01 10.0.0.2"
check ovn-nbctl lsp-add sw0 sw0-port2
check ovn-nbctl lsp-set-addresses sw0-port2 "50:54:00:00:00:02 10.0.0.3"

ovn-nbctl dhcp-options-create 10.0.0.0/24

CIDR_UUID=$(ovn-nbctl --bare --columns=_uuid find dhcp_options cidr="10.0.0.0/24")
ovn-nbctl dhcp-options-set-options $CIDR_UUID   lease_time=3600   router=10.0.0.1   server_id=10.0.0.1   server_mac=c0:ff:ee:00:00:01 hostname="\"foo\""
ovn-nbctl --wait=sb lsp-set-dhcpv4-options sw0-port1 $CIDR_UUID

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep -w "ls_in_dhcp_options" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_dhcp_options ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == "sw0-port1" && eth.src == 50:54:00:00:00:01 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = "foo", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)
  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == "sw0-port1" && eth.src == 50:54:00:00:00:01 && ip4.src == 10.0.0.2 && ip4.dst == {10.0.0.1, 255.255.255.255} && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = "foo", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)
])

check ovn-nbctl --wait=sb lsp-set-options sw0-port1 hostname="\"port1\""
ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep -w "ls_in_dhcp_options" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_dhcp_options ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == "sw0-port1" && eth.src == 50:54:00:00:00:01 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = "port1", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)
  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == "sw0-port1" && eth.src == 50:54:00:00:00:01 && ip4.src == 10.0.0.2 && ip4.dst == {10.0.0.1, 255.255.255.255} && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = "port1", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)
])

ovn-nbctl dhcp-options-set-options $CIDR_UUID  lease_time=3600   router=10.0.0.1   server_id=10.0.0.1   server_mac=c0:ff:ee:00:00:01
check ovn-nbctl --wait=sb lsp-set-options sw0-port1 hostname="\"bar\""
ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([grep -w "ls_in_dhcp_options" sw0flows | sort | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_dhcp_options ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == "sw0-port1" && eth.src == 50:54:00:00:00:01 && ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = "bar", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)
  table=??(ls_in_dhcp_options ), priority=100  , match=(inport == "sw0-port1" && eth.src == 50:54:00:00:00:01 && ip4.src == 10.0.0.2 && ip4.dst == {10.0.0.1, 255.255.255.255} && udp.src == 68 && udp.dst == 67), action=(reg0[[3]] = put_dhcp_opts(offerip = 10.0.0.2, hostname = "bar", lease_time = 3600, netmask = 255.255.255.0, router = 10.0.0.1, server_id = 10.0.0.1); next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ovn -- NAT and Load Balancer flows])

# Determine if expected flows are present. The only parameter to this
# function is the number of expected flows per NAT destination address.
# This should always be either 0 or 1. 0 means that we do not expect
# lflows to be present. 1 means we expect an lflow to be present
check_lflows() {
    expected=$1
    ro1_flows=$(ovn-sbctl lflow-list ro1)

    ro1_ip_routing=$(grep lr_in_ip_routing <<< "$ro1_flows")
    match=$(grep -c "match=(ip4.dst == 20.0.0.100/32)" <<< "$ro1_ip_routing")
    AT_CHECK([test "$expected" = "$match"])

    ro1_arp_resolve=$(grep lr_in_arp_resolve <<< "$ro1_flows")
    match=$(grep -c 'match=(outport == "ro1-sw" && reg0 == {20.0.0.100})' <<< "$ro1_arp_resolve")
    AT_CHECK([test "$expected" = "$match"])

    ro2_flows=$(ovn-sbctl lflow-list ro2)

    ro2_ip_routing=$(grep lr_in_ip_routing <<< "$ro2_flows")
    match=$(grep -c "match=(ip4.dst == 10.0.0.100/32)" <<< "$ro2_ip_routing")
    AT_CHECK([test "$expected" = "$match"])

    ro2_arp_resolve=$(grep lr_in_arp_resolve <<< "$ro2_flows")
    match=$(grep -c 'match=(outport == "ro2-sw" && reg0 == {10.0.0.100})' <<< "$ro2_arp_resolve")
    AT_CHECK([test "$expected" = "$match"])
}

ovn_start

AS_BOX([Setting up the logical network])

check ovn-nbctl ls-add sw

check ovn-nbctl lr-add ro1
check ovn-nbctl lrp-add ro1 ro1-sw 00:00:00:00:00:01 10.0.0.1/24
check ovn-nbctl lsp-add sw sw-ro1

check ovn-nbctl lr-add ro2
check ovn-nbctl lrp-add ro2 ro2-sw 00:00:00:00:00:02 20.0.0.1/24
check ovn-nbctl --wait=sb lsp-add sw sw-ro2

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 vm1
check ovn-nbctl lsp-set-addresses vm1 "00:00:00:00:01:02 192.168.1.2"
check ovn-nbctl lrp-add ro1 ro1-ls1 00:00:00:00:01:01 192.168.1.1/24
check ovn-nbctl lsp-add ls1 ls1-ro1
check ovn-nbctl lsp-set-type ls1-ro1 router
check ovn-nbctl lsp-set-addresses ls1-ro1 router
check ovn-nbctl lsp-set-options ls1-ro1 router-port=ro1-ls1

check ovn-nbctl ls-add ls2
check ovn-nbctl lsp-add ls2 vm2
check ovn-nbctl lsp-set-addresses vm2 "00:00:00:00:02:02 192.168.2.2"
check ovn-nbctl lrp-add ro2 ro2-ls2 00:00:00:00:02:01 192.168.2.1/24
check ovn-nbctl lsp-add ls2 ls2-ro2
check ovn-nbctl lsp-set-type ls2-ro2 router
check ovn-nbctl lsp-set-addresses ls2-ro2 router
check ovn-nbctl lsp-set-options ls2-ro2 router-port=ro2-ls2

check ovn-nbctl ha-chassis-group-add grp1
check ovn-nbctl ha-chassis-group-add-chassis grp1 hv1 100
grp1_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp1)

check ovn-nbctl ha-chassis-group-add grp2
check ovn-nbctl ha-chassis-group-add-chassis grp2 hv2 100
grp2_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp2)

AS_BOX([Checking that unconnected logical switch ports generate no lflows])

check_lflows 0

AS_BOX([Checking that connected logical switch ports have no lflows for non-gateway ports])

check ovn-nbctl lsp-set-type sw-ro1 router
check ovn-nbctl lsp-set-addresses sw-ro1 router
check ovn-nbctl lsp-set-options sw-ro1 router-port=ro1-sw

check ovn-nbctl lsp-set-type sw-ro2 router
check ovn-nbctl lsp-set-addresses sw-ro2 router
check ovn-nbctl --wait=sb lsp-set-options sw-ro2 router-port=ro2-sw

check_lflows 0

AS_BOX([Checking that NAT flows are not installed for non-gateway routers])

check ovn-nbctl lr-nat-add ro1 dnat 10.0.0.100 192.168.1.100
check ovn-nbctl lr-nat-add ro2 dnat 20.0.0.100 192.168.2.100

check_lflows 0

AS_BOX([Checking that non-routable NAT flows are not installed for gateway routers])

check ovn-nbctl lrp-set-gateway-chassis ro1-sw hv1 100
check ovn-nbctl --wait=sb lrp-set-gateway-chassis ro2-sw hv2 100

check_lflows 0

AS_BOX([Checking that routable NAT flows are installed when gateway chassis exists])

check ovn-nbctl lr-nat-del ro1
check ovn-nbctl lr-nat-del ro2
check ovn-nbctl --add-route lr-nat-add ro1 dnat 10.0.0.100 192.168.1.100
check ovn-nbctl --wait=sb --add-route lr-nat-add ro2 dnat 20.0.0.100 192.168.2.100

check_lflows 1

AS_BOX([Checking that NAT flows are not installed for routers with gateway chassis removed])

check ovn-nbctl lrp-del-gateway-chassis ro1-sw hv1
check ovn-nbctl --wait=sb lrp-del-gateway-chassis ro2-sw hv2

check_lflows 0

AS_BOX([Checking that NAT flows are installed for routers with HA_Chassis_Group])

check ovn-nbctl set logical_router_port ro1-sw ha_chassis_group="$grp1_uuid"
check ovn-nbctl --wait=sb set logical_router_port ro2-sw ha_chassis_group="$grp2_uuid"

check_lflows 1

AS_BOX([Checking that NAT flows are not installed for routers with HA_Chassis_Group removed])

check ovn-nbctl clear logical_router_port ro1-sw ha_chassis_group
check ovn-nbctl --wait=sb clear logical_router_port ro2-sw ha_chassis_group

check_lflows 0

AS_BOX([Checking that Floating IP NAT flows are not installed with no gateway port set])

check ovn-nbctl lr-nat-del ro1
check ovn-nbctl lr-nat-del ro2

check ovn-nbctl lr-nat-add ro1 dnat_and_snat 10.0.0.100 192.168.1.2 vm1 00:00:00:00:00:01
check ovn-nbctl --wait=sb lr-nat-add ro2 dnat_and_snat 20.0.0.100 192.168.2.2 vm2 00:00:00:00:00:02

check_lflows 0

AS_BOX([Checking that non-routable Floating IP NAT flows are not installed for gateway routers])

check ovn-nbctl lrp-set-gateway-chassis ro1-sw hv1 100
check ovn-nbctl --wait=sb lrp-set-gateway-chassis ro2-sw hv2 100

check_lflows 0

AS_BOX([Checking that routable Floating IP NAT flows are installed for gateway routers])
check ovn-nbctl lr-nat-del ro1
check ovn-nbctl lr-nat-del ro2

check ovn-nbctl --add-route lr-nat-add ro1 dnat_and_snat 10.0.0.100 192.168.1.2 vm1 00:00:00:00:00:01
check ovn-nbctl --wait=sb --add-route lr-nat-add ro2 dnat_and_snat 20.0.0.100 192.168.2.2 vm2 00:00:00:00:00:02

check_lflows 1

AS_BOX([Checking that Floating IP NAT flows are not installed for routers with gateway chassis removed])

check ovn-nbctl lrp-del-gateway-chassis ro1-sw hv1
check ovn-nbctl --wait=sb lrp-del-gateway-chassis ro2-sw hv2

check_lflows 0

AS_BOX([Checking that Floating IP NAT flows are installed for routers with ha_chassis_group])

grp1_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp1)
check ovn-nbctl set logical_router_port ro1-sw ha_chassis_group="$grp1_uuid"

grp2_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp2)
check ovn-nbctl --wait=sb set logical_router_port ro2-sw ha_chassis_group="$grp2_uuid"

check_lflows 1

AS_BOX([Checking that Floating IP NAT flows are not installed for routers with HA_Chassis_Group removed])

check ovn-nbctl clear logical_router_port ro1-sw ha_chassis_group
check ovn-nbctl --wait=sb clear logical_router_port ro2-sw ha_chassis_group

check_lflows 0

AS_BOX([Checking that Load Balancer VIP flows are not installed for routers with no gateway port])

check ovn-nbctl lr-nat-del ro1
check ovn-nbctl lr-nat-del ro2

check ovn-nbctl lb-add lb1 10.0.0.100 192.168.1.2
check ovn-nbctl lr-lb-add ro1 lb1

check ovn-nbctl lb-add lb2 20.0.0.100 192.168.2.2
check ovn-nbctl --wait=sb lr-lb-add ro2 lb2

check_lflows 0

AS_BOX([Checking that non-routable Load Balancer VIP flows are not installed for gateway routers])

check ovn-nbctl lrp-set-gateway-chassis ro1-sw hv1 100
check ovn-nbctl --wait=sb lrp-set-gateway-chassis ro2-sw hv2 100

check_lflows 0

AS_BOX([Checking that routable Load Balancer VIP flows are installed for gateway routers])

check ovn-nbctl lr-lb-del ro1 lb1
check ovn-nbctl lr-lb-del ro2 lb2
check ovn-nbctl lb-del lb1
check ovn-nbctl lb-del lb2

check ovn-nbctl --add-route lb-add lb1 10.0.0.100 192.168.1.2
check ovn-nbctl --add-route lb-add lb2 20.0.0.100 192.168.2.2
check ovn-nbctl lr-lb-add ro1 lb1
check ovn-nbctl --wait=sb lr-lb-add ro2 lb2

check_lflows 1

AS_BOX([Checking that Load Balancer VIP flows are not installed for routers with gateway chassis removed])

check ovn-nbctl lrp-del-gateway-chassis ro1-sw hv1
check ovn-nbctl --wait=sb lrp-del-gateway-chassis ro2-sw hv2

check_lflows 0

AS_BOX([Checking that Load Balancer VIP flows are installed for routers with ha_chassis_group])

grp1_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp1)
check ovn-nbctl set logical_router_port ro1-sw ha_chassis_group="$grp1_uuid"

grp2_uuid=$(ovn-nbctl --columns=_uuid --bare find HA_Chassis_group name=grp2)
check ovn-nbctl --wait=sb set logical_router_port ro2-sw ha_chassis_group="$grp2_uuid"

check_lflows 1

AS_BOX([Checking that Load Balancer VIP flows are not iinstalled for routers with HA_Chassis_Group removed])

check ovn-nbctl clear logical_router_port ro1-sw ha_chassis_group
check ovn-nbctl --wait=sb clear logical_router_port ro2-sw ha_chassis_group

check_lflows 0

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV_PARALLELIZATION([
AT_SETUP([ovn -- ARP flows for unreachable addresses - NAT and LB])
ovn_start

AS_BOX([Setting up the logical network])

# This network is the same as the one from "Router Address Propagation"
check ovn-nbctl ls-add sw

check ovn-nbctl lr-add ro1
check ovn-nbctl lrp-add ro1 ro1-sw 00:00:00:00:00:01 10.0.0.1/24
check ovn-nbctl lsp-add sw sw-ro1
check ovn-nbctl lsp-set-type sw-ro1 router
check ovn-nbctl lsp-set-addresses sw-ro1 router
check ovn-nbctl lsp-set-options sw-ro1 router-port=ro1-sw

check ovn-nbctl lr-add ro2
check ovn-nbctl lrp-add ro2 ro2-sw 00:00:00:00:00:02 20.0.0.1/24
check ovn-nbctl lsp-add sw sw-ro2
check ovn-nbctl lsp-set-type sw-ro2 router
check ovn-nbctl lsp-set-addresses sw-ro2 router
check ovn-nbctl --wait=sb lsp-set-options sw-ro2 router-port=ro2-sw

check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 vm1
check ovn-nbctl lsp-set-addresses vm1 "00:00:00:00:01:02 192.168.1.2"
check ovn-nbctl lrp-add ro1 ro1-ls1 00:00:00:00:01:01 192.168.1.1/24
check ovn-nbctl lsp-add ls1 ls1-ro1
check ovn-nbctl lsp-set-type ls1-ro1 router
check ovn-nbctl lsp-set-addresses ls1-ro1 router
check ovn-nbctl lsp-set-options ls1-ro1 router-port=ro1-ls1

check ovn-nbctl ls-add ls2
check ovn-nbctl lsp-add ls2 vm2
check ovn-nbctl lsp-set-addresses vm2 "00:00:00:00:02:02 192.168.2.2"
check ovn-nbctl lrp-add ro2 ro2-ls2 00:00:00:00:02:01 192.168.2.1/24
check ovn-nbctl lsp-add ls2 ls2-ro2
check ovn-nbctl lsp-set-type ls2-ro2 router
check ovn-nbctl lsp-set-addresses ls2-ro2 router
check ovn-nbctl lsp-set-options ls2-ro2 router-port=ro2-ls2
check ovn-nbctl --wait=sb sync

ovn-sbctl lflow-list ls1 > ls1_lflows
AT_CHECK([grep "ls_in_l2_lkup" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = "ls1-ro1"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = "vm1"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
])

ovn-sbctl lflow-list ls2 > ls2_lflows
AT_CHECK([grep "ls_in_l2_lkup" ls2_lflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:01), action=(outport = "ls2-ro2"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:02), action=(outport = "vm2"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:02:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.2.1), action=(clone {outport = "ls2-ro2"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:201), action=(clone {outport = "ls2-ro2"; output; }; outport = "_MC_flood_l2"; output;)
])

AS_BOX([Adding some reachable NAT addresses])

check ovn-nbctl lr-nat-add ro1 dnat 10.0.0.100 192.168.1.100
check ovn-nbctl lr-nat-add ro1 snat 10.0.0.200 192.168.1.200/30

check ovn-nbctl lr-nat-add ro2 dnat 20.0.0.100 192.168.2.100
check ovn-nbctl --wait=sb lr-nat-add ro2 snat 20.0.0.200 192.168.2.200/30

ovn-sbctl lflow-list ls1 > ls1_lflows
AT_CHECK([grep "ls_in_l2_lkup" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = "ls1-ro1"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = "vm1"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
])

ovn-sbctl lflow-list ls2 > ls2_lflows
AT_CHECK([grep "ls_in_l2_lkup" ls2_lflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:01), action=(outport = "ls2-ro2"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:02), action=(outport = "vm2"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:02:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.2.1), action=(clone {outport = "ls2-ro2"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 20.0.0.100), action=(clone {outport = "ls2-ro2"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:201), action=(clone {outport = "ls2-ro2"; output; }; outport = "_MC_flood_l2"; output;)
])

AS_BOX([Adding some unreachable NAT addresses])

check ovn-nbctl lr-nat-add ro1 dnat 30.0.0.100 192.168.1.130
check ovn-nbctl lr-nat-add ro1 snat 30.0.0.200 192.168.1.148/30

check ovn-nbctl lr-nat-add ro2 dnat 40.0.0.100 192.168.2.130
check ovn-nbctl --wait=sb lr-nat-add ro2 snat 40.0.0.200 192.168.2.148/30

ovn-sbctl lflow-list ls1 > ls1_lflows
AT_CHECK([grep "ls_in_l2_lkup" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = "ls1-ro1"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = "vm1"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
])

ovn-sbctl lflow-list ls2 > ls2_lflows
AT_CHECK([grep "ls_in_l2_lkup" ls2_lflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:01), action=(outport = "ls2-ro2"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:02:02), action=(outport = "vm2"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:02:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.2.1), action=(clone {outport = "ls2-ro2"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 20.0.0.100), action=(clone {outport = "ls2-ro2"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 40.0.0.100), action=(clone {outport = "ls2-ro2"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:201), action=(clone {outport = "ls2-ro2"; output; }; outport = "_MC_flood_l2"; output;)
])

AS_BOX([Adding load balancer reachable VIPs to ro1])

ovn-nbctl lb-add lb1 192.168.1.100:80 10.0.0.10:80
ovn-nbctl --wait=sb lr-lb-add ro1 lb1

ovn-sbctl lflow-list ls1 > ls1_lflows
AT_CHECK([grep "ls_in_l2_lkup" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = "ls1-ro1"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = "vm1"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
])

AS_BOX([Adding load balancer unreachable VIPs to ro1])
ovn-nbctl --wait=sb lb-add lb1 192.168.4.100:80 10.0.0.10:80

ovn-sbctl lflow-list ls1 > ls1_lflows
AT_CHECK([grep "ls_in_l2_lkup" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = "ls1-ro1"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = "vm1"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
])

# Make sure that there is no flow for VIP 192.168.4.100 as ro1-ls1 doesn't
# have a gw router port or is not a gateway router.
AT_CHECK([grep "ls_in_l2_lkup" ls1_lflows | grep "192.168.4.100" | grep "_MC_flood" -c], [1], [0
])

AS_BOX([Configuring ro1-ls1 router port as a gateway router port])

ovn-nbctl --wait=sb lrp-set-gateway-chassis ro1-ls1 chassis-1 30

ovn-sbctl lflow-list ls1 > ls1_lflows
AT_CHECK([grep "ls_in_l2_lkup" ls1_lflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:01), action=(outport = "ls1-ro1"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:01:02), action=(outport = "vm1"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_lkup      ), priority=75   , match=(eth.src == {00:00:00:00:01:01} && (arp.op == 1 || rarp.op == 3 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 10.0.0.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.1), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 192.168.1.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && arp.op == 1 && arp.tpa == 30.0.0.100), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
  table=??(ls_in_l2_lkup      ), priority=80   , match=(flags[[1]] == 0 && nd_ns && nd.target == fe80::200:ff:fe00:101), action=(clone {outport = "ls1-ro1"; output; }; outport = "_MC_flood_l2"; output;)
])


# Make sure that there is no flow for VIP 192.168.4.100 as it is unreachable.
AT_CHECK([grep "ls_in_l2_lkup" ls1_lflows | grep "192.168.4.100" | grep -v clone | grep "_MC_flood" -c], [1], [0
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV_PARALLELIZATION([
AT_SETUP([ovn -- LR NAT flows])
ovn_start

check ovn-nbctl \
    -- ls-add sw0 \
    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080 \
    -- ls-lb-add sw0 lb0

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
])

# Create few dnat_and_snat entries

check ovn-nbctl lr-nat-add lr0 snat 172.168.0.10 10.0.0.0/24
check ovn-nbctl lr-nat-add lr0 dnat_and_snat 172.168.0.20 10.0.0.3
check ovn-nbctl lr-nat-add lr0 snat 172.168.0.30 10.0.0.10

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_chk_dnat_local" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
])

check ovn-sbctl chassis-add gw1 geneve 127.0.0.1 \
  -- set chassis gw1 other_config:ct-no-masked-label="true" \
  -- set chassis gw1 other_config:ovn-ct-lb-related="true"

# Create a distributed gw port on lr0
check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:00:00:ff:02 172.168.0.10/24
check ovn-nbctl lrp-set-gateway-chassis lr0-public gw1

ovn-nbctl lsp-add public public-lr0 -- set Logical_Switch_Port public-lr0 \
    type=router options:router-port=lr0-public \
    -- lsp-set-addresses public-lr0 router

# Common zone for DGP

check ovn-nbctl set nb_global . options:use_common_zone="true"
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 0), action=(ct_snat_in_czone;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 1 && flags.use_snat_zone == 1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 0), action=(ct_snat_in_czone;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 1 && flags.use_snat_zone == 1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 0), action=(ct_snat_in_czone;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 1 && flags.use_snat_zone == 1), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_dnat_in_czone(10.0.0.3);)
])

AT_CHECK([grep "lr_out_chk_dnat_local" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)
  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)
  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.10 && is_chassis_resident("cr-lr0-public")), action=(reg9[[4]] = 1; next;)
  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.20 && is_chassis_resident("cr-lr0-public")), action=(reg9[[4]] = 1; next;)
  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.30 && is_chassis_resident("cr-lr0-public")), action=(reg9[[4]] = 1; next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 10.0.0.3 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_dnat_in_czone;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=? (lr_out_snat        ), priority=153  , match=(ip && ip4.src == 10.0.0.0/24 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat_in_czone(172.168.0.10);)
  table=? (lr_out_snat        ), priority=154  , match=(ip && ip4.src == 10.0.0.0/24 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.10 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat_in_czone(172.168.0.30);)
  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.3 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat_in_czone(172.168.0.20);)
  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.10 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.30);)
  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.3 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.20);)
])

# Separate zones for DGP

check ovn-nbctl remove nb_global . options use_common_zone
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_dnat(10.0.0.3);)
])

AT_CHECK([grep "lr_out_chk_dnat_local" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 10.0.0.3 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=? (lr_out_snat        ), priority=153  , match=(ip && ip4.src == 10.0.0.0/24 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.10 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat(172.168.0.30);)
  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.3 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat(172.168.0.20);)
])

# Associate load balancer to lr0

check ovn-nbctl lb-add lb0 172.168.0.100:8082 "10.0.0.50:82,10.0.0.60:82"

# No L4
check ovn-nbctl lb-add lb1 172.168.0.200 "10.0.0.80,10.0.0.81"
check ovn-nbctl lb-add lb2 172.168.0.210:60 "10.0.0.50:6062,10.0.0.60:6062" udp

check ovn-nbctl lr-lb-add lr0 lb0
check ovn-nbctl lr-lb-add lr0 lb1
check ovn-nbctl lr-lb-add lr0 lb2

# Common zone for DGP

check ovn-nbctl set nb_global . options:use_common_zone="true"
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 0), action=(ct_snat_in_czone;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 1 && flags.use_snat_zone == 1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 0), action=(ct_snat_in_czone;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 1 && flags.use_snat_zone == 1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 0), action=(ct_snat_in_czone;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public") && flags.loopback == 1 && flags.use_snat_zone == 1), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_dnat_in_czone(10.0.0.3);)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200 && is_chassis_resident("cr-lr0-public")), action=(ct_lb_mark(backends=10.0.0.80,10.0.0.81);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80 && is_chassis_resident("cr-lr0-public")), action=(ct_lb_mark(backends=10.0.0.4:8080);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082 && is_chassis_resident("cr-lr0-public")), action=(ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60 && is_chassis_resident("cr-lr0-public")), action=(ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_chk_dnat_local" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)
  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ct_mark.natted == 1), action=(reg9[[4]] = 1; next;)
  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.10 && is_chassis_resident("cr-lr0-public")), action=(reg9[[4]] = 1; next;)
  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.20 && is_chassis_resident("cr-lr0-public")), action=(reg9[[4]] = 1; next;)
  table=? (lr_out_chk_dnat_local), priority=50   , match=(ip && ip4.dst == 172.168.0.30 && is_chassis_resident("cr-lr0-public")), action=(reg9[[4]] = 1; next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 10.0.0.3 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_dnat_in_czone;)
  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.4 && tcp.src == 8080)) && (inport == "lr0-public" || outport == "lr0-public") && is_chassis_resident("cr-lr0-public")), action=(ct_dnat_in_czone;)
  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.50 && tcp.src == 82) || (ip4.src == 10.0.0.60 && tcp.src == 82)) && (inport == "lr0-public" || outport == "lr0-public") && is_chassis_resident("cr-lr0-public")), action=(ct_dnat_in_czone;)
  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.50 && udp.src == 6062) || (ip4.src == 10.0.0.60 && udp.src == 6062)) && (inport == "lr0-public" || outport == "lr0-public") && is_chassis_resident("cr-lr0-public")), action=(ct_dnat_in_czone;)
  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.80) || (ip4.src == 10.0.0.81)) && (inport == "lr0-public" || outport == "lr0-public") && is_chassis_resident("cr-lr0-public")), action=(ct_dnat_in_czone;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=? (lr_out_snat        ), priority=153  , match=(ip && ip4.src == 10.0.0.0/24 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat_in_czone(172.168.0.10);)
  table=? (lr_out_snat        ), priority=154  , match=(ip && ip4.src == 10.0.0.0/24 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.10 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat_in_czone(172.168.0.30);)
  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.3 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat_in_czone(172.168.0.20);)
  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.10 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.30);)
  table=? (lr_out_snat        ), priority=162  , match=(ip && ip4.src == 10.0.0.3 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public") && reg9[[4]] == 1), action=(reg9[[4]] = 0; ct_snat(172.168.0.20);)
])

# Separate zones for DGP

check ovn-nbctl remove nb_global . options use_common_zone
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.168.0.30 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_dnat(10.0.0.3);)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200 && is_chassis_resident("cr-lr0-public")), action=(ct_lb_mark(backends=10.0.0.80,10.0.0.81);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80 && is_chassis_resident("cr-lr0-public")), action=(ct_lb_mark(backends=10.0.0.4:8080);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082 && is_chassis_resident("cr-lr0-public")), action=(ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60 && is_chassis_resident("cr-lr0-public")), action=(ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_chk_dnat_local" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 10.0.0.3 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_dnat;)
  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.4 && tcp.src == 8080)) && (inport == "lr0-public" || outport == "lr0-public") && is_chassis_resident("cr-lr0-public")), action=(ct_dnat;)
  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.50 && tcp.src == 82) || (ip4.src == 10.0.0.60 && tcp.src == 82)) && (inport == "lr0-public" || outport == "lr0-public") && is_chassis_resident("cr-lr0-public")), action=(ct_dnat;)
  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.50 && udp.src == 6062) || (ip4.src == 10.0.0.60 && udp.src == 6062)) && (inport == "lr0-public" || outport == "lr0-public") && is_chassis_resident("cr-lr0-public")), action=(ct_dnat;)
  table=? (lr_out_undnat      ), priority=120  , match=(ip4 && ((ip4.src == 10.0.0.80) || (ip4.src == 10.0.0.81)) && (inport == "lr0-public" || outport == "lr0-public") && is_chassis_resident("cr-lr0-public")), action=(ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=? (lr_out_snat        ), priority=153  , match=(ip && ip4.src == 10.0.0.0/24 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.10 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat(172.168.0.30);)
  table=? (lr_out_snat        ), priority=161  , match=(ip && ip4.src == 10.0.0.3 && outport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(ct_snat(172.168.0.20);)
])

# Make the logical router as Gateway router
check ovn-nbctl clear logical_router_port lr0-public gateway_chassis
check ovn-nbctl set logical_router lr0 options:chassis=gw1
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])


AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(ct_lb_mark(backends=10.0.0.80,10.0.0.81);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.4:8080);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_chk_dnat_local" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)
  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)
  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)
])


# Set lb force snat logical router.
check ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip="router_ip"
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-public" && ip4.dst == 172.168.0.10), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw0" && ip4.dst == 10.0.0.1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.80,10.0.0.81; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_chk_dnat_local" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)
  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-public"), action=(ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-sw0"), action=(ct_snat(10.0.0.1);)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)
  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)
])

# Add a LB VIP same as router ip.
check ovn-nbctl lb-add lb0 172.168.0.10:9082 "10.0.0.50:82,10.0.0.60:82"
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-public" && ip4.dst == 172.168.0.10), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw0" && ip4.dst == 10.0.0.1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(next;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.80,10.0.0.81; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_chk_dnat_local" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)
  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-public"), action=(ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-sw0"), action=(ct_snat(10.0.0.1);)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)
  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)
])

# Add IPv6 router port and LB.
check ovn-nbctl lrp-del lr0-sw0
check ovn-nbctl lrp-del lr0-public
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24 aef0::1
check ovn-nbctl lrp-add lr0 lr0-public 00:00:00:00:ff:02 172.168.0.10/24 def0::10

lb1_uuid=$(fetch_column nb:Load_Balancer _uuid name=lb1)
ovn-nbctl set load_balancer $lb1_uuid vips:'"[[def0::2]]:8000"'='"@<:@aef0::2@:>@:80,@<:@aef0::3@:>@:80"'

ovn-nbctl list load_Balancer
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-public" && ip4.dst == 172.168.0.10), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-public" && ip6.dst == def0::10), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw0" && ip4.dst == 10.0.0.1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=110  , match=(inport == "lr0-sw0" && ip6.dst == aef0::1), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=120  , match=(ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(next;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.10), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.20), action=(ct_snat;)
  table=4 (lr_in_unsnat       ), priority=90   , match=(ip && ip4.dst == 172.168.0.30), action=(ct_snat;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.10), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.100), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.200), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip6.dst == def0::2), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.168.0.20), action=(flags.loopback = 1; ct_dnat(10.0.0.3);)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.200), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.80,10.0.0.81; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 10.0.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.4:8080; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.10 && tcp && tcp.dst == 9082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.100 && tcp && tcp.dst == 8082), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:82,10.0.0.60:82; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip6 && ip6.dst == def0::2 && tcp && tcp.dst == 8000), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=[[aef0::2]]:80,[[aef0::3]]:80; force_snat);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_chk_dnat_local" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)
  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-public"), action=(ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip4 && outport == "lr0-sw0"), action=(ct_snat(10.0.0.1);)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip6 && outport == "lr0-public"), action=(ct_snat(def0::10);)
  table=? (lr_out_snat        ), priority=110  , match=(flags.force_snat_for_lb == 1 && ip6 && outport == "lr0-sw0"), action=(ct_snat(aef0::1);)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
  table=? (lr_out_snat        ), priority=25   , match=(ip && ip4.src == 10.0.0.0/24 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.10);)
  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.10 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.30);)
  table=? (lr_out_snat        ), priority=33   , match=(ip && ip4.src == 10.0.0.3 && (!ct.trk || !ct.rpl)), action=(ct_snat(172.168.0.20);)
])

check ovn-nbctl lrp-del lr0-sw0
check ovn-nbctl lrp-del lr0-public
check ovn-nbctl lr-lb-del lr0
check ovn-nbctl lr-nat-del lr0

check ovn-nbctl lb-add lb3 172.168.0.210:60 "10.0.0.50:6062,10.0.0.60:6062" udp
check ovn-nbctl lb-add lb4 172.168.0.210:60 "10.0.0.50:6062,10.0.0.60:6062" tcp
check ovn-nbctl lr-lb-add lr0 lb3
check ovn-nbctl lr-lb-add lr0 lb4
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep "lr_in_unsnat" lr0flows | sort], [0], [dnl
  table=4 (lr_in_unsnat       ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_in_defrag" lr0flows | sort], [0], [dnl
  table=5 (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=5 (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 172.168.0.210), action=(ct_dnat;)
])

AT_CHECK([grep "lr_in_dnat" lr0flows | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && tcp && tcp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)
  table=7 (lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.0.210 && udp && udp.dst == 60), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.50:6062,10.0.0.60:6062; force_snat);)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep "lr_out_chk_dnat_local" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_chk_dnat_local), priority=0    , match=(1), action=(reg9[[4]] = 0; next;)
])

AT_CHECK([grep "lr_out_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_undnat      ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_undnat      ), priority=100  , match=(nd || nd_rs || nd_ra), action=(next;)
  table=? (lr_out_undnat      ), priority=50   , match=(ip), action=(flags.loopback = 1; ct_dnat;)
])

AT_CHECK([grep "lr_out_post_undnat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_post_undnat ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_post_undnat ), priority=50   , match=(ip && ct.new), action=(ct_commit { } ; next; )
])

AT_CHECK([grep "lr_out_snat" lr0flows | sed 's/table=./table=?/' | sort], [0], [dnl
  table=? (lr_out_snat        ), priority=0    , match=(1), action=(next;)
  table=? (lr_out_snat        ), priority=120  , match=(nd_ns), action=(next;)
])

# LB with reject configured
check ovn-nbctl --wait=sb remove logical_router lr0 options lb_force_snat_ip
check ovn-nbctl --wait=sb sync

check ovn-nbctl lr-lb-del lr0
check ovn-nbctl lsp-add sw0 vip1
check ovn-nbctl lsp-add sw0 vip2
check ovn-nbctl --reject lb-add lb5 172.168.10.10 10.0.20.10,10.0.20.20
check ovn-nbctl --wait=sb set load_balancer lb5 ip_port_mappings:10.0.20.10=vip1:10.0.0.2
check ovn-nbctl --wait=sb set load_balancer lb5 ip_port_mappings:10.0.20.20=vip2:20.0.0.2

check ovn-nbctl --wait=sb lr-lb-add lr0 lb5
AT_CHECK([ovn-nbctl --wait=sb -- --id=@hc create \
Load_Balancer_Health_Check vip="172.168.10.10" -- add Load_Balancer lb5 \
health_check @hc | uuidfilt], [0], [<0>
])
wait_row_count Service_Monitor 2

# Set the service monitor for vip1 and vip2 to offline
sm_vip1=$(fetch_column Service_Monitor _uuid logical_port=vip1)
sm_vip2=$(fetch_column Service_Monitor _uuid logical_port=vip2)

ovn-sbctl set service_monitor $sm_vip1 status=offline
ovn-sbctl set service_monitor $sm_vip2 status=offline
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn-sbctl dump-flows lr0 | grep "lr_in_dnat" | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.10), action=(reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=3);};)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

# LB with reject and skip_snat
check ovn-nbctl --wait=sb set load_balancer lb5 options:skip_snat=true

AT_CHECK([ovn-sbctl dump-flows lr0 | grep "lr_in_dnat" | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.10), action=(flags.skip_snat_for_lb = 1; reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=3);};)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

check ovn-nbctl --wait=sb remove load_balancer lb5 options skip_snat

# LB with reject and force_snat
check ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip="router_ip"

AT_CHECK([ovn-sbctl dump-flows lr0 | grep "lr_in_dnat" | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.10), action=(flags.force_snat_for_lb = 1; reg0 = 0; reject { outport <-> inport; next(pipeline=egress,table=3);};)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

# LB with event=false and reject=false
check ovn-nbctl lr-lb-del lr0
check ovn-nbctl remove logical_router lr0 options lb_force_snat_ip
AT_CHECK([ovn-nbctl create load_balancer name=lb6 options:reject=false options:event=false vips:\"172.168.10.30\"=\"\" protocol=tcp], [0], [ignore])
check ovn-nbctl --wait=sb lr-lb-add lr0 lb6

AT_CHECK([ovn-sbctl dump-flows lr0 | grep "lr_in_dnat" | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.30), action=(drop;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

# LB with event=false, reject=false and skip_snat
check ovn-nbctl --wait=sb set load_balancer lb6 options:skip_snat=true

AT_CHECK([ovn-sbctl dump-flows lr0 | grep "lr_in_dnat" | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.30), action=(flags.skip_snat_for_lb = 1; drop;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

check ovn-nbctl remove load_balancer lb6 options skip_snat

# LB with event=false, reject=false and force_snat
check ovn-nbctl --wait=sb set logical_router lr0 options:lb_force_snat_ip="router_ip"

AT_CHECK([ovn-sbctl dump-flows lr0 | grep "lr_in_dnat" | sort], [0], [dnl
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.168.10.30), action=(flags.force_snat_for_lb = 1; drop;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV_PARALLELIZATION([
AT_SETUP([Load Balancer SB duplicates])
ovn_start

check ovn-nbctl ls-add ls -- lb-add lb1 10.0.0.1:80 10.0.0.2:80 -- ls-lb-add ls lb1
check ovn-nbctl --wait=sb sync

dps=$(fetch_column Load_Balancer datapath_group)
nlb=$(fetch_column nb:Load_Balancer _uuid)
AT_CHECK([ovn-sbctl create Load_Balancer name=lb1 datapath_group="$dps" external_ids="lb_id=$nlb"], [0], [ignore])

check ovn-nbctl --wait=sb sync
check_row_count Load_Balancer 1

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ovn -- Add tags to logical flows])
ovn_start

check ovn-nbctl \
    -- ls-add sw0 \
    -- lb-add lb0 10.0.0.10:80 10.0.0.4:8080 \
    -- ls-lb-add sw0 lb0

check ovn-nbctl lsp-add sw0 lsp0 \
    -- lsp-set-addresses lsp0 "00:00:00:00:ff:01 1.2.3.4" \
    -- lsp-set-port-security lsp0 "00:00:00:00:ff:01 1.2.3.4"

check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl --columns=tags list logical_flow | grep lsp0 -c], [0], [dnl
1
])

check ovn-nbctl set logical_switch_port lsp0 enabled=false
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl --columns=tags list logical_flow | grep lsp0 -c], [0], [dnl
3
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ovn -- gateway mtu check pkt larger flows])
ovn_start

check ovn-sbctl chassis-add ch1 geneve 127.0.0.1

check ovn-nbctl ls-add sw0
check ovn-nbctl ls-add sw1

# Create a logical router and attach both logical switches
check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
check ovn-nbctl lsp-add sw0 sw0-lr0
check ovn-nbctl lsp-set-type sw0-lr0 router
check ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check ovn-nbctl lsp-set-options sw0-lr0 router-port=lr0-sw0

check ovn-nbctl lrp-add lr0 lr0-sw1 00:00:00:00:ff:02 20.0.0.1/24
check ovn-nbctl lsp-add sw1 sw1-lr0
check ovn-nbctl lsp-set-type sw1-lr0 router
check ovn-nbctl lsp-set-addresses sw1-lr0 00:00:00:00:ff:02
check ovn-nbctl lsp-set-options sw1-lr0 router-port=lr0-sw1

check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 172.168.0.100/24
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

check ovn-nbctl --wait=sb lrp-set-gateway-chassis lr0-public ch1

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep -e "chk_pkt_len" -e "lr_in_larger_pkts" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)
])

check ovn-nbctl --wait=sb set logical_router_port lr0-public options:gateway_mtu=1500

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep -e "chk_pkt_len" -e "lr_in_larger_pkts" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); next;)
  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw0" && outport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw0" && outport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
])

AT_CHECK([grep -E "lr_in_admission.*check_pkt_larger" lr0flows | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == "lr0-public" && is_chassis_resident("cr-lr0-public")), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
])

AT_CHECK([grep -E "lr_in_ip_input.*icmp4_error" lr0flows | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
])
AT_CHECK([grep -E "lr_in_ip_input.*icmp6_error" lr0flows | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
])

# Clear the gateway-chassis for lr0-public
check ovn-nbctl --wait=sb clear logical_router_port lr0-public gateway_chassis

# Make lr0 as a gateway router.
check ovn-nbctl --wait=sb set logical_router lr0 options:chassis=ch1

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep -e "chk_pkt_len" -e "lr_in_larger_pkts" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); next;)
  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw0" && outport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw0" && outport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
])

AT_CHECK([grep -E "lr_in_admission.*check_pkt_larger" lr0flows | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
])

AT_CHECK([grep -E "lr_in_ip_input.*icmp4_error" lr0flows | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
])
AT_CHECK([grep -E "lr_in_ip_input.*icmp6_error" lr0flows | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
])

# Set gateway_mtu_bypass to avoid check_pkt_larger() for tcp on lr0-public.
check ovn-nbctl --wait=sb set logical_router_port lr0-public options:gateway_mtu_bypass=tcp

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep -e "chk_pkt_len" -e "lr_in_larger_pkts" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); next;)
  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == "lr0-public" && (tcp)), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw0" && outport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw0" && outport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
])

AT_CHECK([grep "lr_in_admission" lr0flows | grep -e "check_pkt_larger" -e "tcp" | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=55   , match=(eth.dst == 00:00:20:20:12:13 && inport == "lr0-public" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=55   , match=(eth.mcast && inport == "lr0-public" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)
])

# Set gateway_mtu option on lr0-sw0
check ovn-nbctl --wait=sb set logical_router_port lr0-sw0 options:gateway_mtu=1400

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep -e "chk_pkt_len" -e "lr_in_larger_pkts" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); next;)
  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == "lr0-sw0"), action=(reg9[[1]] = check_pkt_larger(1414); next;)
  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == "lr0-public" && (tcp)), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-public" && outport == "lr0-sw0" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-public" && outport == "lr0-sw0" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw0" && outport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw0" && outport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-sw0" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-sw0" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
])

AT_CHECK([grep "lr_in_admission.*check_pkt_larger" lr0flows | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:ff:01 && inport == "lr0-sw0"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lr0-sw0"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)
])

AT_CHECK([grep -E "lr_in_ip_input.*icmp4_error" lr0flows | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == "lr0-sw0" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
])
AT_CHECK([grep -E "lr_in_ip_input.*icmp6_error" lr0flows | sort], [0], [dnl
  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=3 (lr_in_ip_input     ), priority=150  , match=(inport == "lr0-sw0" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
])

# Set gateway_mtu_bypass to avoid check_pkt_larger() for tcp on lr0-sw0.
check ovn-nbctl --wait=sb set logical_router_port lr0-sw0 options:gateway_mtu_bypass=tcp

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep -e "chk_pkt_len" -e "lr_in_larger_pkts" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); next;)
  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == "lr0-sw0"), action=(reg9[[1]] = check_pkt_larger(1414); next;)
  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == "lr0-public" && (tcp)), action=(next;)
  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == "lr0-sw0" && (tcp)), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-public" && outport == "lr0-sw0" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-public" && outport == "lr0-sw0" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw0" && outport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip4.dst = ip4.src; ip4.src = 10.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw0" && outport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:01; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff01; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-public" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-public" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1500; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-sw0" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-sw0" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
])

AT_CHECK([grep "lr_in_admission" lr0flows | grep -e "check_pkt_larger" -e "tcp" | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:ff:01 && inport == "lr0-sw0"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1514); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lr0-sw0"), action=(reg9[[1]] = check_pkt_larger(1414); xreg0[[0..47]] = 00:00:00:00:ff:01; next;)
  table=0 (lr_in_admission    ), priority=55   , match=(eth.dst == 00:00:00:00:ff:01 && inport == "lr0-sw0" && (tcp)), action=(xreg0[[0..47]] = 00:00:00:00:ff:01; next;)
  table=0 (lr_in_admission    ), priority=55   , match=(eth.dst == 00:00:20:20:12:13 && inport == "lr0-public" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=55   , match=(eth.mcast && inport == "lr0-public" && (tcp)), action=(xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=55   , match=(eth.mcast && inport == "lr0-sw0" && (tcp)), action=(xreg0[[0..47]] = 00:00:00:00:ff:01; next;)
])

# Clear gateway_mtu option on lr0-public
check ovn-nbctl --wait=sb clear logical_router_port lr0-public options
ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep -e "chk_pkt_len" -e "lr_in_larger_pkts" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_chk_pkt_len  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_chk_pkt_len  ), priority=50   , match=(outport == "lr0-sw0"), action=(reg9[[1]] = check_pkt_larger(1414); next;)
  table=??(lr_in_chk_pkt_len  ), priority=55   , match=(outport == "lr0-sw0" && (tcp)), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-public" && outport == "lr0-sw0" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip4.dst = ip4.src; ip4.src = 172.168.0.100; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-public" && outport == "lr0-sw0" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:20:20:12:13; ip6.dst = ip6.src; ip6.src = fe80::200:20ff:fe20:1213; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-sw0" && ip4 && reg9[[1]] && reg9[[0]] == 0), action=(icmp4_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip4.dst = ip4.src; ip4.src = 20.0.0.1; ip.ttl = 255; icmp4.type = 3; /* Destination Unreachable. */ icmp4.code = 4; /* Frag Needed and DF was Set. */ icmp4.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
  table=??(lr_in_larger_pkts  ), priority=150  , match=(inport == "lr0-sw1" && outport == "lr0-sw0" && ip6 && reg9[[1]] && reg9[[0]] == 0), action=(icmp6_error {reg9[[0]] = 1; reg9[[1]] = 0; eth.dst = 00:00:00:00:ff:02; ip6.dst = ip6.src; ip6.src = fe80::200:ff:fe00:ff02; ip.ttl = 255; icmp6.type = 2; /* Packet Too Big. */ icmp6.code = 0; icmp6.frag_mtu = 1400; next(pipeline=ingress, table=0); };)
])

check ovn-nbctl --wait=sb clear logical_router_port lr0-sw0 options
check ovn-nbctl --wait=sb set logical_router_port lr0-public options:gateway_mtu=1500
check ovn-nbctl lsp-add public ext-port
check ovn-nbctl lsp-set-addresses ext-port unknown
check ovn-nbctl lsp-set-type ext-port localnet
check ovn-nbctl --wait=sb set Logical_Switch_Port ext-port tag_request=2
ovn-sbctl dump-flows lr0 > lr0flows

AT_CHECK([grep "lr_in_admission" lr0flows | grep -e "check_pkt_larger" | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:20:20:12:13 && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1518); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lr0-public"), action=(reg9[[1]] = check_pkt_larger(1518); xreg0[[0..47]] = 00:00:20:20:12:13; next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ovn -- static routes flows])
AT_KEYWORDS([static-routes-flows])
ovn_start

check ovn-sbctl chassis-add ch1 geneve 127.0.0.1

check ovn-nbctl lr-add lr0
check ovn-nbctl set logical_router lr0 options:chassis=ch1
check ovn-nbctl ls-add public
check ovn-nbctl lrp-add lr0 lr0-public 00:00:20:20:12:13 192.168.0.1/24
check ovn-nbctl lsp-add public public-lr0
check ovn-nbctl lsp-set-type public-lr0 router
check ovn-nbctl lsp-set-addresses public-lr0 router
check ovn-nbctl lsp-set-options public-lr0 router-port=lr0-public

check ovn-nbctl --wait=sb --ecmp-symmetric-reply lr-route-add lr0 1.0.0.1 192.168.0.10

ovn-sbctl dump-flows lr0 > lr0flows

AT_CHECK([grep -e "lr_in_ip_routing.*select" lr0flows |sort], [0], [dnl
])
AT_CHECK([grep -e "lr_in_ip_routing_ecmp" lr0flows | sed 's/table=../table=??/' |sort], [0], [dnl
  table=??(lr_in_ip_routing_ecmp), priority=0    , match=(1), action=(drop;)
  table=??(lr_in_ip_routing_ecmp), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)
])

check ovn-nbctl --wait=sb --ecmp-symmetric-reply lr-route-add lr0 1.0.0.1 192.168.0.20

ovn-sbctl dump-flows lr0 > lr0flows
AT_CHECK([grep -e "lr_in_ip_routing.*select" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_routing   ), priority=97   , match=(reg7 == 0 && ip4.dst == 1.0.0.1/32), action=(ip.ttl--; flags.loopback = 1; reg8[[0..15]] = 1; reg8[[16..31]] = select(1, 2);)
])
AT_CHECK([grep -e "lr_in_ip_routing_ecmp" lr0flows | sed 's/192\.168\.0\..0/192.168.0.??/' | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_routing_ecmp), priority=0    , match=(1), action=(drop;)
  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 1), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; next;)
  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 2), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; next;)
  table=??(lr_in_ip_routing_ecmp), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)
])

AT_CHECK([grep -e "lr_in_defrag" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_defrag       ), priority=100  , match=(inport == "lr0-public" && ip4.src == 1.0.0.1), action=(ct_next;)
  table=??(lr_in_defrag       ), priority=100  , match=(reg7 == 0 && ip4.dst == 1.0.0.1/32), action=(ct_next;)
])

dnl The chassis was created with other_config:ct-no-masked-label=false, the flows
dnl should be using ct_label.ecmp_reply_port.
AT_CHECK([grep -e "lr_in_arp_resolve.*ecmp" lr0flows | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_arp_resolve  ), priority=200  , match=(ct.rpl && ct_label.ecmp_reply_port == 1), action=(push(xxreg1); xxreg1 = ct_label; eth.dst = xxreg1[[32..79]]; pop(xxreg1); next;)
])

dnl Simulate an ovn-controller upgrade to a version that supports
dnl ct-no-masked-label.  ovn-northd should start using ct_mark.ecmp_reply_port.

check ovn-sbctl set chassis ch1 other_config:ct-no-masked-label=true
check ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows lr0 > lr0flows
AT_CHECK([grep -e "lr_in_arp_resolve.*ecmp" lr0flows | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_arp_resolve  ), priority=200  , match=(ct.rpl && ct_mark.ecmp_reply_port == 1), action=(push(xxreg1); xxreg1 = ct_label; eth.dst = xxreg1[[32..79]]; pop(xxreg1); next;)
])

# add ecmp route with wrong nexthop
check ovn-nbctl --wait=sb --ecmp-symmetric-reply lr-route-add lr0 1.0.0.1 192.168.1.20

ovn-sbctl dump-flows lr0 > lr0flows
AT_CHECK([grep -e "lr_in_ip_routing.*select" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_routing   ), priority=97   , match=(reg7 == 0 && ip4.dst == 1.0.0.1/32), action=(ip.ttl--; flags.loopback = 1; reg8[[0..15]] = 1; reg8[[16..31]] = select(1, 2);)
])
AT_CHECK([grep -e "lr_in_ip_routing_ecmp" lr0flows | sed 's/192\.168\.0\..0/192.168.0.??/' | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_routing_ecmp), priority=0    , match=(1), action=(drop;)
  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 1), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; next;)
  table=??(lr_in_ip_routing_ecmp), priority=100  , match=(reg8[[0..15]] == 1 && reg8[[16..31]] == 2), action=(reg0 = 192.168.0.??; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; next;)
  table=??(lr_in_ip_routing_ecmp), priority=150  , match=(reg8[[0..15]] == 0), action=(next;)
])

check ovn-nbctl lr-route-del lr0
wait_row_count nb:Logical_Router_Static_Route 0

check ovn-nbctl --wait=sb lr-route-add lr0 1.0.0.0/24 192.168.0.10
ovn-sbctl dump-flows lr0 > lr0flows

AT_CHECK([grep -e "lr_in_ip_routing.*192.168.0.10" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_routing   ), priority=73   , match=(reg7 == 0 && ip4.dst == 1.0.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.10; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
])

check ovn-nbctl --wait=sb lr-route-add lr0 2.0.0.0/24 lr0-public

ovn-sbctl dump-flows lr0 > lr0flows
AT_CHECK([grep -e "lr_in_ip_routing.*2.0.0.0" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_routing   ), priority=73   , match=(reg7 == 0 && ip4.dst == 2.0.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.0.1; eth.src = 00:00:20:20:12:13; outport = "lr0-public"; flags.loopback = 1; next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ovn-northd -- lr multiple gw ports])
AT_KEYWORDS([multiple-l3dgw-ports])
ovn_start

# Logical network:
# 1 Logical Router, 3 bridged Logical Switches,
# 1 gateway chassis attached to each corresponding LRP.
#
#                | S1 (gw1)
#                |
#      ls  ----  DR -- S3 (gw3)
# (20.0.0.0/24)  |
#                | S2 (gw2)
#
# Validate basic LR logical flows.

check ovn-sbctl chassis-add gw1 geneve 127.0.0.1
check ovn-sbctl chassis-add gw2 geneve 128.0.0.1
check ovn-sbctl chassis-add gw3 geneve 129.0.0.1

check ovn-nbctl lr-add DR
check ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24
check ovn-nbctl lrp-add DR DR-S2 03:ac:10:01:00:01 172.16.2.1/24
check ovn-nbctl lrp-add DR DR-S3 04:ac:10:01:00:01 172.16.3.1/24
check ovn-nbctl lrp-add DR DR-ls 05:ac:10:01:00:01 20.0.0.1/24

check ovn-nbctl ls-add S1
check ovn-nbctl lsp-add S1 S1-DR
check ovn-nbctl lsp-set-type S1-DR router
check ovn-nbctl lsp-set-addresses S1-DR router
check ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1

check ovn-nbctl ls-add S2
check ovn-nbctl lsp-add S2 S2-DR
check ovn-nbctl lsp-set-type S2-DR router
check ovn-nbctl lsp-set-addresses S2-DR router
check ovn-nbctl --wait=sb lsp-set-options S2-DR router-port=DR-S2

check ovn-nbctl ls-add S3
check ovn-nbctl lsp-add S3 S3-DR
check ovn-nbctl lsp-set-type S3-DR router
check ovn-nbctl lsp-set-addresses S3-DR router
check ovn-nbctl --wait=sb lsp-set-options S3-DR router-port=DR-S3

check ovn-nbctl ls-add  ls
check ovn-nbctl lsp-add ls ls-DR
check ovn-nbctl lsp-set-type ls-DR router
check ovn-nbctl lsp-set-addresses ls-DR router
check ovn-nbctl --wait=sb lsp-set-options ls-DR router-port=DR-ls

check ovn-nbctl lrp-set-gateway-chassis DR-S1 gw1
check ovn-nbctl lrp-set-gateway-chassis DR-S2 gw2
check ovn-nbctl lrp-set-gateway-chassis DR-S3 gw3

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows DR > lrflows
AT_CAPTURE_FILE([lrflows])

# Check the flows in lr_in_admission stage
AT_CHECK([grep lr_in_admission lrflows | grep cr-DR | sort], [0], [dnl
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 02:ac:10:01:00:01 && inport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(xreg0[[0..47]] = 02:ac:10:01:00:01; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 03:ac:10:01:00:01 && inport == "DR-S2" && is_chassis_resident("cr-DR-S2")), action=(xreg0[[0..47]] = 03:ac:10:01:00:01; next;)
  table=0 (lr_in_admission    ), priority=50   , match=(eth.dst == 04:ac:10:01:00:01 && inport == "DR-S3" && is_chassis_resident("cr-DR-S3")), action=(xreg0[[0..47]] = 04:ac:10:01:00:01; next;)
])
# Check the flows in lr_in_lookup_neighbor stage
AT_CHECK([grep lr_in_lookup_neighbor lrflows | grep cr-DR | sort], [0], [dnl
  table=1 (lr_in_lookup_neighbor), priority=100  , match=(inport == "DR-S1" && arp.spa == 172.16.1.0/24 && arp.op == 1 && is_chassis_resident("cr-DR-S1")), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)
  table=1 (lr_in_lookup_neighbor), priority=100  , match=(inport == "DR-S2" && arp.spa == 172.16.2.0/24 && arp.op == 1 && is_chassis_resident("cr-DR-S2")), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)
  table=1 (lr_in_lookup_neighbor), priority=100  , match=(inport == "DR-S3" && arp.spa == 172.16.3.0/24 && arp.op == 1 && is_chassis_resident("cr-DR-S3")), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)
])
# Check the flows in lr_in_gw_redirect stage
AT_CHECK([grep lr_in_gw_redirect lrflows | grep cr-DR | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == "DR-S1"), action=(outport = "cr-DR-S1"; next;)
  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == "DR-S2"), action=(outport = "cr-DR-S2"; next;)
  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == "DR-S3"), action=(outport = "cr-DR-S3"; next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ovn-northd -- lrp with chassis-redirect and ls with vtep lport])
AT_KEYWORDS([multiple-l3dgw-ports])
ovn_start NORTHD_TYPE
check ovn-sbctl chassis-add ch1 geneve 127.0.0.2

check ovn-nbctl lr-add lr1
check ovn-nbctl lrp-add lr1 lrp1 00:00:00:00:00:01 10.0.0.1/24
check ovn-nbctl ls-add ls1
check ovn-nbctl lsp-add ls1 lsp1 -- \
    lsp-set-addresses lsp1 router -- \
    lsp-set-type lsp1 router -- \
    lsp-set-options lsp1 router-port=lrp1

# ensure initial flows are installed without is_chassis_resident match part
ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows lr1 > lrflows
AT_CAPTURE_FILE([lrflows])

# Check the flows in lr_in_admission stage
AT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == "lrp1"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lrp1"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
])

# Check the flows in lr_in_gw_redirect stage
AT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [])

wait_row_count Port_Binding 0 logical_port=cr-lrp1 options:always-redirect="true"

# make lrp a cr-port and check its flows
check ovn-nbctl lrp-set-gateway-chassis lrp1 ch1

ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows lr1 > lrflows
AT_CAPTURE_FILE([lrflows])

# Check the flows in lr_in_admission stage
AT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == "lrp1" && is_chassis_resident("cr-lrp1")), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lrp1"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
])

# Check the flows in lr_in_gw_redirect stage
AT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == "lrp1"), action=(outport = "cr-lrp1"; next;)
])

wait_row_count Port_Binding 1 logical_port=cr-lrp1 options:always-redirect="true"

# attach vtep logical port to logical switch and check flows.
# there should not be is_chassis_resident part.
check ovn-nbctl lsp-add ls1 lsp-vtep -- lsp-set-type lsp-vtep vtep

ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows lr1 > lrflows
AT_CAPTURE_FILE([lrflows])

# Check the flows in lr_in_admission stage
AT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == "lrp1"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lrp1"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
])

# Check the flows in lr_in_gw_redirect stage
AT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [])

wait_row_count Port_Binding 0 logical_port=cr-lrp1 options:always-redirect="true"

# delete vtep lport and check lrp has is_chassis_resident match part again.
check ovn-nbctl lsp-del lsp-vtep

ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows lr1 > lrflows
AT_CAPTURE_FILE([lrflows])

# Check the flows in lr_in_admission stage
AT_CHECK([grep lr_in_admission lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_admission    ), priority=50   , match=(eth.dst == 00:00:00:00:00:01 && inport == "lrp1" && is_chassis_resident("cr-lrp1")), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
  table=??(lr_in_admission    ), priority=50   , match=(eth.mcast && inport == "lrp1"), action=(xreg0[[0..47]] = 00:00:00:00:00:01; next;)
])

# Check the flows in lr_in_gw_redirect stage
AT_CHECK([grep lr_in_gw_redirect lrflows | grep lrp1 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == "lrp1"), action=(outport = "cr-lrp1"; next;)
])

wait_row_count Port_Binding 1 logical_port=cr-lrp1 options:always-redirect="true"

AT_CLEANUP
])


OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check options:requested-chassis fills requested_chassis col])
ovn_start NORTHD_TYPE

# Add chassis ch1.
check ovn-sbctl chassis-add ch1 geneve 127.0.0.2
check ovn-sbctl chassis-add ch2 geneve 127.0.0.3

wait_row_count Chassis 2

ch1_uuid=`ovn-sbctl --bare --columns _uuid find Chassis name="ch1"`
ch2_uuid=`ovn-sbctl --bare --columns _uuid find Chassis name="ch2"`

check ovn-sbctl set chassis $ch2_uuid hostname=ch2-hostname

ovn-nbctl ls-add S1
ovn-nbctl --wait=sb lsp-add S1 S1-vm1
ovn-nbctl --wait=sb lsp-add S1 S1-vm2

wait_row_count Port_Binding 1 logical_port=S1-vm1 requested_chassis!=$ch1_uuid
wait_row_count Port_Binding 1 logical_port=S1-vm2 requested_chassis!=$ch2_uuid

ovn-nbctl --wait=sb set logical_switch_port S1-vm1 \
    options:requested-chassis=ch1

wait_row_count Port_Binding 1 logical_port=S1-vm1 requested_chassis=$ch1_uuid

ovn-nbctl --wait=sb set logical_switch_port S1-vm2 \
    options:requested-chassis=ch2-hostname

wait_row_count Port_binding 1 logical-port=S1-vm2 requested_chassis=$ch2_uuid

ovn-nbctl --wait=sb remove logical_switch_port S1-vm2 \
    options requested-chassis=ch2-hostname

wait_row_count Port_binding 1 logical-port=S1-vm2 requested_chassis!=$ch2_uuid

ovn-nbctl --wait=sb set logical_switch_port S1-vm2 \
    options:requested-chassis=ch2

wait_row_count Port_binding 1 logical-port=S1-vm2 requested_chassis=$ch2_uuid

AT_CLEANUP
])

# Duplicated datapaths shouldn't be created, but in case it is created because
# of bug or dirty data, it should be properly deleted instead of causing
# permanent failure in northd.
OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([handling duplicated datapaths])
ovn_start

check ovn-nbctl --wait=sb ls-add ls1
ls1_uuid=$(fetch_column nb:Logical_Switch _uuid)

# create a duplicated sb datapath (and an IP_Mulicast record that references
# it) on purpose.
AT_CHECK([ovn-sbctl --id=@dp create Datapath_Binding external_ids:logical-switch=$ls1_uuid external_ids:name=ls1 tunnel_key=123 -- create IP_Multicast datapath=@dp], [0], [ignore])

# northd should delete one of the datapaths in the end
wait_row_count Datapath_Binding 1

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([conntrack nat implies conntrack])
ovn_start

check ovn-nbctl lr-add rtr \
  -- set logical_router rtr options:chassis=hv \
  -- lrp-add rtr rtr-ls 00:00:00:00:01:00 42.42.42.1/24 \
  -- lb-add lb-test 43.43.43.43:4343 42.42.42.2:4242 tcp \
  -- lr-lb-add rtr lb-test
check ovn-nbctl --wait=sb sync

flow="eth.dst == 00:00:00:00:01:00 && inport == \"rtr-ls\" && ip4.src == 42.42.42.42 && ip4.dst == 43.43.43.43 && ip.ttl == 64 && tcp && tcp.dst == 4343"

AT_CHECK_UNQUOTED([ovn_trace --ct new --minimal "${flow}" --lb-dst 42.42.42.42:4242], [0], [dnl
ct_dnat /* assuming no un-dnat entry, so no change */ {
    ct_lb_mark /* default (use --ct to customize) */ {
        ip.ttl--;
        eth.src = 00:00:00:00:01:00;
        eth.dst = 00:00:00:00:00:00;
        arp {
            eth.dst = ff:ff:ff:ff:ff:ff;
            arp.spa = 0x2a2a2a01;
            arp.tpa = 0x2a2a2a02;
            arp.op = 1;
            output("rtr-ls");
        };
    };
};
])

AT_CHECK_UNQUOTED([ovn_trace --minimal "${flow}" --lb-dst 42.42.42.42:4242], [0], [dnl
ct_dnat /* assuming no un-dnat entry, so no change */ /* default (use --ct to customize) */;
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV_PARALLELIZATION([
AT_SETUP([route tables -- flows])
AT_KEYWORDS([route-tables-flows])
ovn_start

check ovn-nbctl lr-add lr0
check ovn-nbctl lrp-add lr0 lrp0 00:00:00:00:00:01 192.168.0.1/24
check ovn-nbctl lrp-add lr0 lrp1 00:00:00:00:01:01 192.168.1.1/24
check ovn-nbctl lrp-add lr0 lrp2 00:00:00:00:02:01 192.168.2.1/24
check ovn-nbctl lrp-set-options lrp1 route_table=rtb-1
check ovn-nbctl lrp-set-options lrp2 route_table=rtb-2

check ovn-nbctl lr-route-add lr0 0.0.0.0/0 192.168.0.10
check ovn-nbctl --route-table=rtb-1 lr-route-add lr0 192.168.0.0/24 192.168.1.10
check ovn-nbctl --route-table=rtb-2 lr-route-add lr0 0.0.0.0/0 192.168.0.10
check ovn-nbctl --route-table=rtb-2 lr-route-add lr0 1.1.1.1/32 192.168.0.20
check ovn-nbctl --route-table=rtb-2 lr-route-add lr0 2.2.2.2/32 192.168.0.30
check ovn-nbctl --route-table=rtb-2 --ecmp lr-route-add lr0 2.2.2.2/32 192.168.0.31
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr0 > lr0flows
AT_CAPTURE_FILE([lr0flows])

AT_CHECK([grep -e "lr_in_ip_routing_pre.*match=(1)" lr0flows | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_ip_routing_pre), priority=0    , match=(1), action=(reg7 = 0; next;)
])

p1_reg=$(grep -oP "lr_in_ip_routing_pre.*lrp1.*action=\(reg7 = \K." lr0flows)
p2_reg=$(grep -oP "lr_in_ip_routing_pre.*lrp2.*action=\(reg7 = \K." lr0flows)
echo $p1_reg
echo $p2_reg

# exact register values are not predictable
if [[ $p1_reg -eq 2 ] && [ $p2_reg -eq 1 ]]; then
  echo "swap reg values in dump"
  sed -i -r s'/^(.*lrp2.*action=\(reg7 = )(1)(.*)/\12\3/g' lr0flows  # "reg7 = 1" -> "reg7 = 2"
  sed -i -r s'/^(.*lrp1.*action=\(reg7 = )(2)(.*)/\11\3/g' lr0flows  # "reg7 = 2" -> "reg7 = 1"
  sed -i -r s'/^(.*match=\(reg7 == )(2)( &&.*lrp1.*)/\11\3/g' lr0flows  # "reg7 == 2" -> "reg7 == 1"
  sed -i -r s'/^(.*match=\(reg7 == )(1)( &&.*lrp0.*)/\12\3/g' lr0flows  # "reg7 == 1" -> "reg7 == 2"
fi

check test "$p1_reg" != "$p2_reg" -a $((p1_reg * p2_reg)) -eq 2

AT_CHECK([grep "lr_in_ip_routing_pre" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_routing_pre), priority=0    , match=(1), action=(reg7 = 0; next;)
  table=??(lr_in_ip_routing_pre), priority=100  , match=(inport == "lrp1"), action=(reg7 = 1; next;)
  table=??(lr_in_ip_routing_pre), priority=100  , match=(inport == "lrp2"), action=(reg7 = 2; next;)
])

grep -e "(lr_in_ip_routing   ).*outport" lr0flows

AT_CHECK([grep -e "(lr_in_ip_routing   ).*outport" lr0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_routing   ), priority=1    , match=(reg7 == 0 && ip4.dst == 0.0.0.0/0), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.10; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = "lrp0"; flags.loopback = 1; next;)
  table=??(lr_in_ip_routing   ), priority=1    , match=(reg7 == 2 && ip4.dst == 0.0.0.0/0), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.10; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = "lrp0"; flags.loopback = 1; next;)
  table=??(lr_in_ip_routing   ), priority=194  , match=(inport == "lrp0" && ip6.dst == fe80::/64), action=(ip.ttl--; reg8[[0..15]] = 0; xxreg0 = ip6.dst; xxreg1 = fe80::200:ff:fe00:1; eth.src = 00:00:00:00:00:01; outport = "lrp0"; flags.loopback = 1; next;)
  table=??(lr_in_ip_routing   ), priority=194  , match=(inport == "lrp1" && ip6.dst == fe80::/64), action=(ip.ttl--; reg8[[0..15]] = 0; xxreg0 = ip6.dst; xxreg1 = fe80::200:ff:fe00:101; eth.src = 00:00:00:00:01:01; outport = "lrp1"; flags.loopback = 1; next;)
  table=??(lr_in_ip_routing   ), priority=194  , match=(inport == "lrp2" && ip6.dst == fe80::/64), action=(ip.ttl--; reg8[[0..15]] = 0; xxreg0 = ip6.dst; xxreg1 = fe80::200:ff:fe00:201; eth.src = 00:00:00:00:02:01; outport = "lrp2"; flags.loopback = 1; next;)
  table=??(lr_in_ip_routing   ), priority=73   , match=(reg7 == 1 && ip4.dst == 192.168.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.1.10; reg1 = 192.168.1.1; eth.src = 00:00:00:00:01:01; outport = "lrp1"; flags.loopback = 1; next;)
  table=??(lr_in_ip_routing   ), priority=74   , match=(ip4.dst == 192.168.0.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = "lrp0"; flags.loopback = 1; next;)
  table=??(lr_in_ip_routing   ), priority=74   , match=(ip4.dst == 192.168.1.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.1.1; eth.src = 00:00:00:00:01:01; outport = "lrp1"; flags.loopback = 1; next;)
  table=??(lr_in_ip_routing   ), priority=74   , match=(ip4.dst == 192.168.2.0/24), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = ip4.dst; reg1 = 192.168.2.1; eth.src = 00:00:00:00:02:01; outport = "lrp2"; flags.loopback = 1; next;)
  table=??(lr_in_ip_routing   ), priority=97   , match=(reg7 == 2 && ip4.dst == 1.1.1.1/32), action=(ip.ttl--; reg8[[0..15]] = 0; reg0 = 192.168.0.20; reg1 = 192.168.0.1; eth.src = 00:00:00:00:00:01; outport = "lrp0"; flags.loopback = 1; next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check exclude-lb-vips-from-garp option])
ovn_start

ovn-nbctl lr-add R1
ovn-nbctl set logical_router R1 options:chassis=hv1
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:00:01
ovn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1 nat-addresses="router"

ovn-nbctl lr-nat-add R1 snat 172.16.1.1 10.0.0.0/24
ovn-nbctl lr-nat-add R1 dnat 172.16.1.2 10.0.0.1
# Add load balancers
ovn-nbctl lb-add lb0 172.16.1.10:80 10.0.0.1:80
ovn-nbctl lr-lb-add R1 lb0
ovn-nbctl lb-add lb1 172.16.1.10:8080 10.0.0.1:8080
ovn-nbctl lr-lb-add R1 lb1
ovn-nbctl --wait=sb sync

AT_CHECK([ovn-sbctl get Port_Binding S1-R1 nat_addresses |grep -q 172.16.1.10], [0])

ovn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1 nat-addresses="router" \
                    exclude-lb-vips-from-garp="true"

AT_CHECK([ovn-sbctl get Port_Binding S1-R1 nat_addresses |grep -q 172.16.1.10], [1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check broadcast-arps-to-all-routers option])
ovn_start

check ovn-nbctl lr-add R1
check ovn-nbctl set logical_router R1 options:chassis=hv1
check ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24

check ovn-nbctl ls-add S1
check ovn-nbctl lsp-add S1 S1-R1
check ovn-nbctl lsp-set-type S1-R1 router
check ovn-nbctl lsp-set-addresses S1-R1 "02:ac:10:01:00:01 172.16.1.1"
check ovn-nbctl --wait=sb lsp-set-options S1-R1 router-port=R1-S1 nat-addresses="router"
check ovn-nbctl lsp-add S1 S1-VIF
check ovn-nbctl lsp-set-addresses S1-VIF "02:ac:10:01:00:02 unkown"
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn-sbctl lflow-list S1 | grep ls_in_l2_lkup | grep -q 'match=(eth.mcast && (arp.op == 1 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)'], [1])

check ovn-nbctl --wait=sb set Logical_Switch S1 \
    other_config:broadcast-arps-to-all-routers=false

AT_CHECK([ovn-sbctl lflow-list S1 | grep ls_in_l2_lkup | grep -q 'match=(eth.mcast && (arp.op == 1 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)'], [0])

check ovn-nbctl --wait=sb set Logical_Switch S1 \
    other_config:broadcast-arps-to-all-routers=true

AT_CHECK([ovn-sbctl lflow-list S1 | grep ls_in_l2_lkup | grep -q 'match=(eth.mcast && (arp.op == 1 || nd_ns)), action=(outport = "_MC_flood_l2"; output;)'], [1])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ACL log replies -- flows])

set_acl_options() {
    local acl_name=$1
    local label=$2
    local log_related=$3

    local acl_uuid=$(fetch_column nb:ACL _uuid name=$acl_name)
    check ovn-nbctl set ACL $acl_uuid label=$label options:log-related=$log_related
}

record_log_flows() {
    ovn-sbctl lflow-list sw0 | grep -E 'ls_(out|in)_acl_eval.*, priority=65533' | sed 's/table=../table=??/' | sort > log_flows
}

check_log_flows_count() {
    local expected=$1
    local table=$2
    local count=

    echo $table
    if test -f log_flows; then
        count=$(grep -c -E ls_${table}_acl_eval log_flows)
    else
        count=$(ovn-sbctl lflow-list sw0 | grep -c -E "ls_$table_acl_eval.*, priority=65533")
    fi

    check test "$count" -eq "$expected"
}

ovn_start

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 "00:00:00:00:00:01 10.0.0.1"
check ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 "00:00:00:00:00:02 10.0.0.2"

check ovn-nbctl pg-add pg1 sw0-p1 sw0-p2
check ovn-nbctl pg-add pg2 sw0-p1 sw0-p2
check ovn-nbctl pg-add pg3 sw0-p1 sw0-p2

check ovn-nbctl --log --name=allow_acl acl-add pg1 from-lport 100 'inport=@pg1 && ip4' allow
set_acl_options allow_acl 1 true

check ovn-nbctl --wait=sb sync

# An allow ACL should *not* result in a priority 65533 log flow being installed
# since there are no stateful ACLs on the system.
check_log_flows_count 0 in
check_log_flows_count 0 out

# Now add an allow-related ACL. This should result in both the allow-related
# ACL and the allow ACL having priority 65533 log flows added.
check ovn-nbctl --log --name=allow_related_acl acl-add pg2 from-lport 100 'inport=@pg2 && ip4' allow-related
set_acl_options allow_related_acl 2 true
check ovn-nbctl --wait=sb sync

record_log_flows

# The count will be 4 since we have
# 2 flows for reply traffic for each ACL
# 2 flows for related traffic for each ACL
check_log_flows_count 4 out
# Since the ACLs are ingress, the ingress table
# should have no log flows
check_log_flows_count 0 in

# Now ensure the flows are what we expect them to be for the ACLs we created
AT_CHECK([cat log_flows], [0], [dnl
  table=??(ls_out_acl_eval    ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name="allow_related_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name="allow_related_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
])

rm log_flows

# Now add a stateless-allow ACL.
check ovn-nbctl --log --name=allow_stateless_acl acl-add pg3 from-lport 100 'inport=@pg3 && ip4' allow-stateless
set_acl_options allow_stateless_acl 3 true
check ovn-nbctl --wait=sb sync

record_log_flows

# The count will still be 4 since the stateless ACL should not have special log flows created
check_log_flows_count 4 out
check_log_flows_count 0 in

# And the log flows will remain the same since the stateless ACL will not be represented.
AT_CHECK([cat log_flows], [0], [dnl
  table=??(ls_out_acl_eval    ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name="allow_related_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name="allow_related_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
])

rm log_flows

# Now remove the label from the allow-related ACL.
set_acl_options allow_related_acl 0 true
ovn-nbctl --wait=sb sync

record_log_flows

# The count should now be 2 since the allow_related ACL will not have special
# log flows created. But since there there is an allow-related ACL present, the
# allow ACL will be stateful and have special log flows created.
check_log_flows_count 2 out
check_log_flows_count 0 in

# And make sure only the allow ACL has the log flows installed
AT_CHECK([cat log_flows], [0], [dnl
  table=??(ls_out_acl_eval    ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
])

rm log_flows

# And now add the label back, but disable log_related on the allow-related ACL.
set_acl_options allow_related_acl 2 false

record_log_flows

# The count will again be 2 because only the allow ACL will have log flows installed.
check_log_flows_count 2 out
check_log_flows_count 0 in

# And make sure only the allow ACL has the log flows installed
AT_CHECK([cat log_flows], [0], [dnl
  table=??(ls_out_acl_eval    ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
])

rm log_flows

# And just for sanity's sake, let's remove the allow-related ACL and make sure
# all the special log messages are gone.
check ovn-nbctl acl-del pg2
check ovn-nbctl --wait=sb sync

check_log_flows_count 0 out
check_log_flows_count 0 in

# Now let's clear out all the ACLs, and re-do everything but with egress ACLs.
check ovn-nbctl acl-del pg1
check ovn-nbctl acl-del pg3
check_row_count nb:ACL 0

# Start again with an allow_acl only
check ovn-nbctl --log --name=allow_acl acl-add pg1 to-lport 100 'inport=@pg1 && ip4' allow
set_acl_options allow_acl 1 true

check ovn-nbctl --wait=sb sync

# Again, the allow ACL is stateless, so no related log flows.
check_log_flows_count 0 in
check_log_flows_count 0 out

# Adding a new allow-related ACL...
check ovn-nbctl --log --name=allow_related_acl acl-add pg2 to-lport 100 'inport=@pg2 && ip4' allow-related
set_acl_options allow_related_acl 2 true
check ovn-nbctl --wait=sb sync

record_log_flows

# The count will be 4 since we have
# 2 flows for reply traffic for each ACL
# 2 flows for related traffic for each ACL
check_log_flows_count 4 in
# And this time, we should have no egress flows
check_log_flows_count 0 out

# Now ensure the flows are what we expect them to be for the ACLs we created
AT_CHECK([cat log_flows], [0], [dnl
  table=??(ls_in_acl_eval     ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name="allow_related_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name="allow_related_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
])

rm log_flows

# Now add a stateless-allow ACL.
check ovn-nbctl --log --name=allow_stateless_acl acl-add pg3 from-lport 100 'inport=@pg3 && ip4' allow-stateless
set_acl_options allow_stateless_acl 3 true
check ovn-nbctl --wait=sb sync

record_log_flows

# The count will still be 4 since the stateless ACL should not have special log flows created
check_log_flows_count 4 in
check_log_flows_count 0 out

# And the log flows will remain the same since the stateless ACL will not be represented.
AT_CHECK([cat log_flows], [0], [dnl
  table=??(ls_in_acl_eval     ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name="allow_related_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 2), action=(log(name="allow_related_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
])

rm log_flows

# Now remove the label from the allow-related ACL.
set_acl_options allow_related_acl 0 true
ovn-nbctl --wait=sb sync

record_log_flows

# The count should now be 2 since the allow_related ACL will not have special
# log flows created. But since there there is an allow-related ACL present, the
# allow ACL will be stateful and have special log flows created.
check_log_flows_count 2 in
check_log_flows_count 0 out

# And make sure only the allow ACL has the log flows installed
AT_CHECK([cat log_flows], [0], [dnl
  table=??(ls_in_acl_eval     ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
])

rm log_flows

# And now add the label back, but disable log_related on the allow-related ACL.
set_acl_options allow_related_acl 2 false

record_log_flows

# The count will again be 2 because only the allow ACL will have log flows installed.
check_log_flows_count 2 in
check_log_flows_count 0 out

# And make sure only the allow ACL has the log flows installed
AT_CHECK([cat log_flows], [0], [dnl
  table=??(ls_in_acl_eval     ), priority=65533, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65533, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0 && ct_label.label == 1), action=(log(name="allow_acl", severity=info, verdict=allow); reg8[[16]] = 1; next;)
])

rm log_flows

# And just for sanity's sake, let's remove the allow-related ACL and make sure
# all the special log messages are gone.
check ovn-nbctl acl-del pg2
check ovn-nbctl --wait=sb sync

check_log_flows_count 0 out
check_log_flows_count 0 in

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Static IP multicast report forwarding])

ovn_start

check ovn-nbctl lr-add lr
check ovn-nbctl lrp-add lr lrp1 00:00:00:00:00:01 10.10.10.1/24 1010::1/64
check ovn-nbctl lrp-add lr lrp2 00:00:00:00:00:02 20.20.20.1/24 2020::1/64
check ovn-nbctl set logical_router lr options:mcast_relay="true"
check ovn-nbctl set logical_router_port lrp1 options:mcast_flood="true"
check ovn-nbctl set logical_router_port lrp2 options:mcast_flood="true"

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows lr > lrflows
AT_CAPTURE_FILE([lrflows])

dnl Flows to skip TTL == {0, 1} check for IGMP and MLD packets.
AT_CHECK([grep -e 'lr_in_ip_input    ' lrflows | grep -e 'igmp' -e 'mld' -e 'ip.ttl == {0, 1}' | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_ip_input     ), priority=120  , match=((mldv1 || mldv2) && ip.ttl == 1), action=(next;)
  table=??(lr_in_ip_input     ), priority=120  , match=(igmp && ip.ttl == 1), action=(next;)
  table=??(lr_in_ip_input     ), priority=32   , match=(ip.ttl == {0, 1} && !ip.later_frag && (ip4.mcast || ip6.mcast)), action=(drop;)
  table=??(lr_in_ip_input     ), priority=31   , match=(inport == "lrp1" && ip4 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp4 {eth.dst <-> eth.src; icmp4.type = 11; /* Time exceeded */ icmp4.code = 0; /* TTL exceeded in transit */ ip4.dst = ip4.src; ip4.src = 10.10.10.1 ; ip.ttl = 254; outport = "lrp1"; flags.loopback = 1; output; };)
  table=??(lr_in_ip_input     ), priority=31   , match=(inport == "lrp1" && ip6 && ip6.src == 1010::/64 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp6 {eth.dst <-> eth.src; ip6.dst = ip6.src; ip6.src = 1010::1 ; ip.ttl = 254; icmp6.type = 3; /* Time exceeded */ icmp6.code = 0; /* TTL exceeded in transit */ outport = "lrp1"; flags.loopback = 1; output; };)
  table=??(lr_in_ip_input     ), priority=31   , match=(inport == "lrp2" && ip4 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp4 {eth.dst <-> eth.src; icmp4.type = 11; /* Time exceeded */ icmp4.code = 0; /* TTL exceeded in transit */ ip4.dst = ip4.src; ip4.src = 20.20.20.1 ; ip.ttl = 254; outport = "lrp2"; flags.loopback = 1; output; };)
  table=??(lr_in_ip_input     ), priority=31   , match=(inport == "lrp2" && ip6 && ip6.src == 2020::/64 && ip.ttl == {0, 1} && !ip.later_frag), action=(icmp6 {eth.dst <-> eth.src; ip6.dst = ip6.src; ip6.src = 2020::1 ; ip.ttl = 254; icmp6.type = 3; /* Time exceeded */ icmp6.code = 0; /* TTL exceeded in transit */ outport = "lrp2"; flags.loopback = 1; output; };)
  table=??(lr_in_ip_input     ), priority=30   , match=(ip.ttl == {0, 1}), action=(drop;)
])

dnl Flows to "route" (statically forward) without decrementing TTL for
dnl IGMP and MLD packets.  Also, flows to drop potentially looping IGMP/MLD
dnl packets.
AT_CHECK([grep -e 'lr_in_ip_routing   ' lrflows | grep -e 'igmp' -e 'mld' | sed 's/table=../table=??/'], [0], [dnl
  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:01 && (mldv1 || mldv2)), action=(drop;)
  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:01 && igmp), action=(drop;)
  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:02 && (mldv1 || mldv2)), action=(drop;)
  table=??(lr_in_ip_routing   ), priority=10550, match=(eth.src == 00:00:00:00:00:02 && igmp), action=(drop;)
  table=??(lr_in_ip_routing   ), priority=10460, match=(igmp), action=(clone { outport = "_MC_static"; next; };)
  table=??(lr_in_ip_routing   ), priority=10460, match=(mldv1 || mldv2), action=(clone { outport = "_MC_static"; next; };)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV_PARALLELIZATION([
AT_SETUP([ACLs after lb])
AT_KEYWORDS([acl])
ovn_start

check ovn-nbctl --wait=sb \
    -- ls-add ls \
    -- lsp-add ls lsp

check ovn-nbctl pg-add pg0 lsp

check ovn-nbctl acl-add pg0 from-lport 1004 "ip4 && ip4.dst == 10.0.0.2" drop
check ovn-nbctl acl-add pg0 from-lport 1002 "ip4 && tcp" allow-related
check ovn-nbctl acl-add pg0 from-lport 1003 "ip4 && icmp" allow-related
check ovn-nbctl acl-add pg0 from-lport 1001 "ip4" drop

check ovn-nbctl lb-add lb0 10.0.0.2 10.0.0.10
check ovn-nbctl ls-lb-add ls lb0
check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows ls > lsflows
AT_CAPTURE_FILE([lsflows])

AT_CHECK([grep -e "ls_in_acl.*eval" -e "ls_in_acl_hint" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(reg0[[17]] == 1), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=2001 , match=(reg0[[10]] == 1 && (ip4)), action=(reg8[[17]] = 1; ct_commit { ct_mark.blocked = 1; }; next;)
  table=??(ls_in_acl_eval     ), priority=2001 , match=(reg0[[9]] == 1 && (ip4)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=2002 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=2002 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=2003 , match=(reg0[[7]] == 1 && (ip4 && icmp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=2003 , match=(reg0[[8]] == 1 && (ip4 && icmp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=2004 , match=(reg0[[10]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(reg8[[17]] = 1; ct_commit { ct_mark.blocked = 1; }; next;)
  table=??(ls_in_acl_eval     ), priority=2004 , match=(reg0[[9]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
])

AT_CHECK([grep -e "ls_in_lb " lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.2), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.10);)
])

AT_CHECK([grep -e "ls_in_stateful" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

AS_BOX([Remove and add the ACLs back with the apply-after-lb option])

check ovn-nbctl clear port_group . acls

check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1004 "ip4 && ip4.dst == 10.0.0.2" drop
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1002 "ip4 && tcp" allow-related
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1003 "ip4 && icmp" allow-related
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1001 "ip4" drop

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows ls > lsflows
AT_CAPTURE_FILE([lsflows])

AT_CHECK([grep -e "ls_in_acl.*eval" -e "ls_in_acl_hint" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=2001 , match=(reg0[[10]] == 1 && (ip4)), action=(reg8[[17]] = 1; ct_commit { ct_mark.blocked = 1; }; next;)
  table=??(ls_in_acl_after_lb_eval), priority=2001 , match=(reg0[[9]] == 1 && (ip4)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=2002 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=2002 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=2003 , match=(reg0[[7]] == 1 && (ip4 && icmp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=2003 , match=(reg0[[8]] == 1 && (ip4 && icmp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=2004 , match=(reg0[[10]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(reg8[[17]] = 1; ct_commit { ct_mark.blocked = 1; }; next;)
  table=??(ls_in_acl_after_lb_eval), priority=2004 , match=(reg0[[9]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(reg0[[17]] == 1), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
])

AT_CHECK([grep -e "ls_in_lb " lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.2), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.10);)
])

AT_CHECK([grep -e "ls_in_stateful" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

AS_BOX([Remove and add the ACLs back with a few ACLs with apply-after-lb option])

check ovn-nbctl clear port_group . acls

check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1004 "ip4 && ip4.dst == 10.0.0.2" drop
check ovn-nbctl acl-add pg0 from-lport 1002 "ip4 && tcp" allow-related
check ovn-nbctl acl-add pg0 from-lport 1003 "ip4 && icmp" allow-related
check ovn-nbctl --apply-after-lb acl-add pg0 from-lport 1001 "ip4" drop

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows ls > lsflows
AT_CAPTURE_FILE([lsflows])

AT_CHECK([grep -e "ls_in_acl.*eval" -e "ls_in_acl_hint" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=2001 , match=(reg0[[10]] == 1 && (ip4)), action=(reg8[[17]] = 1; ct_commit { ct_mark.blocked = 1; }; next;)
  table=??(ls_in_acl_after_lb_eval), priority=2001 , match=(reg0[[9]] == 1 && (ip4)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=2004 , match=(reg0[[10]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(reg8[[17]] = 1; ct_commit { ct_mark.blocked = 1; }; next;)
  table=??(ls_in_acl_after_lb_eval), priority=2004 , match=(reg0[[9]] == 1 && (ip4 && ip4.dst == 10.0.0.2)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(reg0[[17]] == 1), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && !ct.est), action=(reg0[[1]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=2002 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=2002 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=2003 , match=(reg0[[7]] == 1 && (ip4 && icmp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=2003 , match=(reg0[[8]] == 1 && (ip4 && icmp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
])

AT_CHECK([grep -e "ls_in_lb " lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 10.0.0.2), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.10);)
])

AT_CHECK([grep -e "ls_in_stateful" lsflows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_stateful     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 0), action=(ct_commit { ct_mark.blocked = 0; }; next;)
  table=??(ls_in_stateful     ), priority=100  , match=(reg0[[1]] == 1 && reg0[[13]] == 1), action=(ct_commit { ct_mark.blocked = 0; ct_label.label = reg3; }; next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV_PARALLELIZATION([
AT_SETUP([ovn-northd -- lr multiple gw ports NAT])
AT_KEYWORDS([multiple-l3dgw-ports])
ovn_start

# Logical network:
# 1 Logical Router, 3 bridged Logical Switches,
# 1 gateway chassis attached to each corresponding LRP.
#
#                | S1 (gw1)
#                |
#      ls  ----  DR -- S3 (gw3)
# (20.0.0.0/24)  |
#                | S2 (gw2)
#
# Validate SNAT, DNAT and DNAT_AND_SNAT behavior with multiple
# distributed gateway LRPs.

check ovn-sbctl chassis-add gw1 geneve 127.0.0.1
check ovn-sbctl chassis-add gw2 geneve 128.0.0.1
check ovn-sbctl chassis-add gw3 geneve 129.0.0.1

check ovn-nbctl lr-add DR
check ovn-nbctl lrp-add DR DR-S1 02:ac:10:01:00:01 172.16.1.1/24
check ovn-nbctl lrp-add DR DR-S2 03:ac:10:01:00:01 10.0.0.1/24
check ovn-nbctl lrp-add DR DR-S3 04:ac:10:01:00:01 192.168.0.1/24
check ovn-nbctl lrp-add DR DR-ls 05:ac:10:01:00:01 20.0.0.1/24

check ovn-nbctl ls-add S1
check ovn-nbctl lsp-add S1 S1-DR
check ovn-nbctl lsp-set-type S1-DR router
check ovn-nbctl lsp-set-addresses S1-DR router
check ovn-nbctl --wait=sb lsp-set-options S1-DR router-port=DR-S1

check ovn-nbctl ls-add S2
check ovn-nbctl lsp-add S2 S2-DR
check ovn-nbctl lsp-set-type S2-DR router
check ovn-nbctl lsp-set-addresses S2-DR router
check ovn-nbctl --wait=sb lsp-set-options S2-DR router-port=DR-S2

check ovn-nbctl ls-add S3
check ovn-nbctl lsp-add S3 S3-DR
check ovn-nbctl lsp-set-type S3-DR router
check ovn-nbctl lsp-set-addresses S3-DR router
check ovn-nbctl --wait=sb lsp-set-options S3-DR router-port=DR-S3

check ovn-nbctl ls-add  ls
check ovn-nbctl lsp-add ls ls-DR
check ovn-nbctl lsp-set-type ls-DR router
check ovn-nbctl lsp-set-addresses ls-DR router
check ovn-nbctl --wait=sb lsp-set-options ls-DR router-port=DR-ls

check ovn-nbctl lrp-set-gateway-chassis DR-S1 gw1
check ovn-nbctl lrp-set-gateway-chassis DR-S2 gw2
check ovn-nbctl lrp-set-gateway-chassis DR-S3 gw3

# Configure SNAT with and without setting "gateway_port" column
check ovn-nbctl                      lr-nat-add DR snat  172.16.1.10    20.0.0.10
check ovn-nbctl --gateway-port=DR-S2 lr-nat-add DR snat  10.0.0.10      20.0.0.10
check ovn-nbctl                      lr-nat-add DR snat  192.168.0.10   20.0.0.10

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows DR > lrflows
AT_CAPTURE_FILE([lrflows])

AT_CHECK([grep lr_in_ip_input lrflows | grep arp | grep -e 172.16.1.10 -e 10.0.0.10 -e 192.168.0.10 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 10.0.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 172.16.1.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 192.168.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=91   , match=(inport == "DR-S1" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)
  table=??(lr_in_ip_input     ), priority=91   , match=(inport == "DR-S2" && arp.op == 1 && arp.tpa == 10.0.0.10), action=(drop;)
  table=??(lr_in_ip_input     ), priority=91   , match=(inport == "DR-S3" && arp.op == 1 && arp.tpa == 192.168.0.10), action=(drop;)
  table=??(lr_in_ip_input     ), priority=92   , match=(inport == "DR-S1" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident("cr-DR-S1")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=92   , match=(inport == "DR-S2" && arp.op == 1 && arp.tpa == 10.0.0.10 && is_chassis_resident("cr-DR-S2")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=92   , match=(inport == "DR-S3" && arp.op == 1 && arp.tpa == 192.168.0.10 && is_chassis_resident("cr-DR-S3")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
])

AT_CHECK([grep lr_in_unsnat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == "DR-S2" && is_chassis_resident("cr-DR-S2")), action=(ct_snat;)
  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ct_snat;)
  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == "DR-S3" && is_chassis_resident("cr-DR-S3")), action=(ct_snat;)
])

AT_CHECK([grep lr_out_snat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ct_snat(172.16.1.10);)
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S2" && is_chassis_resident("cr-DR-S2")), action=(ct_snat(10.0.0.10);)
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S3" && is_chassis_resident("cr-DR-S3")), action=(ct_snat(192.168.0.10);)
])

check ovn-nbctl --wait=sb lr-nat-del DR snat 20.0.0.10
AT_CHECK([ovn-sbctl dump-flows DR | grep -e lr_in_unsnat -e lr_out_snat | grep ct_snat | wc -l], [0], [0
])

# Configure DNAT - 2 gateway_ports configured for same external IP
check ovn-nbctl                      lr-nat-add DR dnat  172.16.1.10    20.0.0.10
check ovn-nbctl --gateway-port=DR-S2 lr-nat-add DR dnat  10.0.0.10      20.0.0.10
check ovn-nbctl --gateway-port=DR-S3 lr-nat-add DR dnat  172.16.1.10    20.0.0.10

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows DR > lrflows
AT_CAPTURE_FILE([lrflows])

AT_CHECK([grep lr_in_ip_input lrflows | grep arp | grep -e 172.16.1.10 -e 10.0.0.10 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 10.0.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 172.16.1.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=91   , match=(inport == "DR-S1" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)
  table=??(lr_in_ip_input     ), priority=91   , match=(inport == "DR-S2" && arp.op == 1 && arp.tpa == 10.0.0.10), action=(drop;)
  table=??(lr_in_ip_input     ), priority=91   , match=(inport == "DR-S3" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)
  table=??(lr_in_ip_input     ), priority=92   , match=(inport == "DR-S1" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident("cr-DR-S1")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=92   , match=(inport == "DR-S2" && arp.op == 1 && arp.tpa == 10.0.0.10 && is_chassis_resident("cr-DR-S2")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=92   , match=(inport == "DR-S3" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident("cr-DR-S3")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
])

AT_CHECK([grep lr_in_dnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == "DR-S2" && is_chassis_resident("cr-DR-S2")), action=(ct_dnat(20.0.0.10);)
  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ct_dnat(20.0.0.10);)
  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == "DR-S3" && is_chassis_resident("cr-DR-S3")), action=(ct_dnat(20.0.0.10);)
])

AT_CHECK([grep lr_out_undnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ct_dnat;)
  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S2" && is_chassis_resident("cr-DR-S2")), action=(ct_dnat;)
  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S3" && is_chassis_resident("cr-DR-S3")), action=(ct_dnat;)
])

check ovn-nbctl --wait=sb lr-nat-del DR dnat

AT_CHECK([ovn-sbctl dump-flows DR | grep -e lr_in_dnat -e lr_out_undnat | grep ct_dnat | wc -l], [0], [0
])

# Configure DNAT_AND_SNAT
check ovn-nbctl --gateway-port=DR-S1 lr-nat-add DR dnat_and_snat  172.16.1.10    20.0.0.10
check ovn-nbctl                      lr-nat-add DR dnat_and_snat  10.0.0.10      20.0.0.10
check ovn-nbctl --gateway-port=DR-S3 lr-nat-add DR dnat_and_snat  192.168.0.10   20.0.0.10

check ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows DR > lrflows
AT_CAPTURE_FILE([lrflows])

AT_CHECK([grep lr_in_ip_input lrflows | grep arp | grep -e 172.16.1.10 -e 10.0.0.10 -e 192.168.0.10 | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 10.0.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 172.16.1.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=90   , match=(arp.op == 1 && arp.tpa == 192.168.0.10), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=91   , match=(inport == "DR-S1" && arp.op == 1 && arp.tpa == 172.16.1.10), action=(drop;)
  table=??(lr_in_ip_input     ), priority=91   , match=(inport == "DR-S2" && arp.op == 1 && arp.tpa == 10.0.0.10), action=(drop;)
  table=??(lr_in_ip_input     ), priority=91   , match=(inport == "DR-S3" && arp.op == 1 && arp.tpa == 192.168.0.10), action=(drop;)
  table=??(lr_in_ip_input     ), priority=92   , match=(inport == "DR-S1" && arp.op == 1 && arp.tpa == 172.16.1.10 && is_chassis_resident("cr-DR-S1")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=92   , match=(inport == "DR-S2" && arp.op == 1 && arp.tpa == 10.0.0.10 && is_chassis_resident("cr-DR-S2")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
  table=??(lr_in_ip_input     ), priority=92   , match=(inport == "DR-S3" && arp.op == 1 && arp.tpa == 192.168.0.10 && is_chassis_resident("cr-DR-S3")), action=(eth.dst = eth.src; eth.src = xreg0[[0..47]]; arp.op = 2; /* ARP reply */ arp.tha = arp.sha; arp.sha = xreg0[[0..47]]; arp.tpa <-> arp.spa; outport = inport; flags.loopback = 1; output;)
])

AT_CHECK([grep lr_in_unsnat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == "DR-S2" && is_chassis_resident("cr-DR-S2")), action=(ct_snat;)
  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ct_snat;)
  table=??(lr_in_unsnat       ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == "DR-S3" && is_chassis_resident("cr-DR-S3")), action=(ct_snat;)
])

AT_CHECK([grep lr_out_snat lrflows | grep ct_snat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ct_snat(172.16.1.10);)
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S2" && is_chassis_resident("cr-DR-S2")), action=(ct_snat(10.0.0.10);)
  table=??(lr_out_snat        ), priority=161  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S3" && is_chassis_resident("cr-DR-S3")), action=(ct_snat(192.168.0.10);)
])

AT_CHECK([grep lr_in_dnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 10.0.0.10 && inport == "DR-S2" && is_chassis_resident("cr-DR-S2")), action=(ct_dnat(20.0.0.10);)
  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 172.16.1.10 && inport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ct_dnat(20.0.0.10);)
  table=??(lr_in_dnat         ), priority=100  , match=(ip && ip4.dst == 192.168.0.10 && inport == "DR-S3" && is_chassis_resident("cr-DR-S3")), action=(ct_dnat(20.0.0.10);)
])

AT_CHECK([grep lr_out_undnat lrflows | grep ct_dnat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S1" && is_chassis_resident("cr-DR-S1")), action=(ct_dnat;)
  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S2" && is_chassis_resident("cr-DR-S2")), action=(ct_dnat;)
  table=??(lr_out_undnat      ), priority=100  , match=(ip && ip4.src == 20.0.0.10 && outport == "DR-S3" && is_chassis_resident("cr-DR-S3")), action=(ct_dnat;)
])

check ovn-nbctl --wait=sb lr-nat-del DR dnat_and_snat

AT_CHECK([ovn-sbctl dump-flows DR | grep -e lr_in_unsnat -e lr_out_snat -e lr_in_dnat -e lr_out_undnat | grep ct_snat| wc -l], [0], [0
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([LR NB Static_MAC_Binding table])
ovn_start

# Create logical routers
ovn-nbctl lr-add lr0
ovn-nbctl lrp-add lr0 lr0-p0 00:00:01:01:02:03 192.168.10.1/24
ovn-nbctl lrp-add lr0 lr0-p1 00:00:02:02:03:04 192.168.11.1/24

ovn-nbctl static-mac-binding-add lr0-p0 192.168.10.10 00:00:11:22:33:44
ovn-nbctl static-mac-binding-add lr0-p0 192.168.10.100 00:00:22:33:44:55

wait_row_count nb:Static_MAC_Binding 2 logical_port=lr0-p0
wait_row_count Static_MAC_Binding 1 logical_port=lr0-p0 ip=192.168.10.10 mac="00\:00\:11\:22\:33\:44"
wait_row_count Static_MAC_Binding 1 logical_port=lr0-p0 ip=192.168.10.100 mac="00\:00\:22\:33\:44\:55"

ovn-nbctl static-mac-binding-add lr0-p1 10.0.0.10 00:00:33:44:55:66
wait_row_count nb:Static_MAC_Binding 1 logical_port=lr0-p1
wait_row_count Static_MAC_Binding 1 logical_port=lr0-p1 ip=10.0.0.10 mac="00\:00\:33\:44\:55\:66"

ovn-nbctl --may-exist static-mac-binding-add lr0-p0 192.168.10.100 00:00:22:33:55:66
wait_row_count Static_MAC_Binding 1 logical_port=lr0-p0 ip=192.168.10.100 mac="00\:00\:22\:33\:55\:66"

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([LR neighbor lookup and learning flows])
ovn_start

# Create logical routers
ovn-nbctl --wait=sb lr-add lr0

ovn-sbctl dump-flows lr0 > lrflows
AT_CAPTURE_FILE([lrflows])

AT_CHECK([cat lrflows | grep -e lr_in_lookup_neighbor -e lr_in_learn_neighbor | sort], [0], [dnl
  table=1 (lr_in_lookup_neighbor), priority=0    , match=(1), action=(reg9[[2]] = 1; next;)
  table=1 (lr_in_lookup_neighbor), priority=100  , match=(arp.op == 2), action=(reg9[[2]] = lookup_arp(inport, arp.spa, arp.sha); next;)
  table=1 (lr_in_lookup_neighbor), priority=100  , match=(nd_na), action=(reg9[[2]] = lookup_nd(inport, nd.target, nd.tll); next;)
  table=1 (lr_in_lookup_neighbor), priority=100  , match=(nd_ns), action=(reg9[[2]] = lookup_nd(inport, ip6.src, nd.sll); next;)
  table=2 (lr_in_learn_neighbor), priority=0    , match=(1), action=(drop;)
  table=2 (lr_in_learn_neighbor), priority=100  , match=(reg9[[2]] == 1), action=(mac_cache_use; next;)
  table=2 (lr_in_learn_neighbor), priority=90   , match=(arp), action=(put_arp(inport, arp.spa, arp.sha); next;)
  table=2 (lr_in_learn_neighbor), priority=90   , match=(nd_na), action=(put_nd(inport, nd.target, nd.tll); next;)
  table=2 (lr_in_learn_neighbor), priority=90   , match=(nd_ns), action=(put_nd(inport, ip6.src, nd.sll); next;)
  table=2 (lr_in_learn_neighbor), priority=95   , match=(nd_na && nd.tll == 0), action=(put_nd(inport, nd.target, eth.src); next;)
  table=2 (lr_in_learn_neighbor), priority=95   , match=(nd_ns && (ip6.src == 0 || nd.sll == 0)), action=(next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV_PARALLELIZATION([
AT_SETUP([LS default ACL drop])
AT_KEYWORDS([acl])

ovn_start

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls lsp1 -- lsp-set-addresses lsp1 00:00:00:00:00:01
check ovn-nbctl lsp-add ls lsp2 -- lsp-set-addresses lsp2 00:00:00:00:00:02

flow="inport == \"lsp1\" && eth.src == 00:00:00:00:00:01 && eth.dst == 00:00:00:00:00:02 && ip.ttl == 64 && ip4.src == 42.42.42.42 && ip4.dst == 42.42.42.43 && udp && udp.src == 42 && udp.dst == 84"

AS_BOX([No ACL, default_acl_drop not set])
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65535, match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65535, match=(1), action=(next;)
  table=??(ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be allowed.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

AS_BOX([No ACL, default_acl_drop false])
check ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65535, match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65535, match=(1), action=(next;)
  table=??(ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be allowed.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

AS_BOX([No ACL, default_acl_drop true])
check ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65535, match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=65535, match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65535, match=(1), action=(next;)
  table=??(ls_out_acl_hint    ), priority=65535, match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be allowed.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

AS_BOX([from-lport ACL])
check ovn-nbctl acl-del ls
check ovn-nbctl acl-add ls from-lport 1 "ip4 && tcp" allow

AS_BOX([from-lport ACL, default_acl_drop not set])
check ovn-nbctl --wait=sb remove NB_Global . options default_acl_drop
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1001 , match=((ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be allowed.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

AS_BOX([from-lport ACL, default_acl_drop false])
check ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1001 , match=((ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be allowed.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

AS_BOX([from-lport ACL, default_acl_drop true])
check ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1001 , match=((ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be dropped.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
])

AS_BOX([from-lport ACL allow-related, default_acl_drop true])
check ovn-nbctl acl-del ls
check ovn-nbctl --wait=sb acl-add ls from-lport 1 "ip4 && tcp" allow-related
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(reg0[[17]] == 1), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && !ct.est), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=1001 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=1001 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.mcast), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=1    , match=(ip && !ct.est), action=(next;)
  table=??(ls_out_acl_eval    ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.mcast), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)
])

dnl UDP traffic should be dropped.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_next(ct_state=new|trk);
])

AS_BOX([from-lport --apply-after-lb ACL])
check ovn-nbctl acl-del ls
check ovn-nbctl --apply-after-lb acl-add ls from-lport 1 "ip4 && tcp" allow

AS_BOX([from-lport --apply-after-lb ACL, default_acl_drop not set])
check ovn-nbctl --wait=sb remove NB_Global . options default_acl_drop
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=1001 , match=((ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be allowed.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

AS_BOX([from-lport --apply-after-lb ACL, default_acl_drop false])
check ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=1001 , match=((ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be allowed.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

AS_BOX([from-lport --apply-after-lb ACL, default_acl_drop true])
check ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=1001 , match=((ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be dropped.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
])

AS_BOX([from-lport --apply-after-lb ACL allow-related, default_acl_drop true])
check ovn-nbctl acl-del ls
check ovn-nbctl --wait=sb --apply-after-lb acl-add ls from-lport 1 "ip4 && tcp" allow-related
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=1001 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=1001 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(reg0[[17]] == 1), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && !ct.est), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.mcast), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=1    , match=(ip && !ct.est), action=(next;)
  table=??(ls_out_acl_eval    ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.mcast), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)
])

dnl UDP traffic should be dropped.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_next(ct_state=new|trk);
])

AS_BOX([to-lport ACL])
check ovn-nbctl acl-del ls
check ovn-nbctl acl-add ls to-lport 1 "ip4 && tcp" allow

AS_BOX([to-lport ACL, default_acl_drop not set])
check ovn-nbctl --wait=sb remove NB_Global . options default_acl_drop
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=1001 , match=((ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be allowed.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

AS_BOX([to-lport ACL, default_acl_drop false])
check ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=false
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=1001 , match=((ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be allowed.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
output("lsp2");
])

AS_BOX([to-lport ACL, default_acl_drop true])
check ovn-nbctl --wait=sb set NB_Global . options:default_acl_drop=true
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=1001 , match=((ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
])

dnl UDP traffic should be dropped.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
])

AS_BOX([to-lport ACL allow-related, default_acl_drop true])
check ovn-nbctl acl-del ls
check ovn-nbctl --wait=sb acl-add ls to-lport 1 "ip4 && tcp" allow-related
AT_CHECK([ovn-sbctl dump-flows | grep -E "ls_.*_acl" | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_action   ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_in_acl_after_lb_action), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=egress,table=6); };)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_after_lb_eval), priority=65532, match=(reg0[[17]] == 1), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && !ct.est), action=(next;)
  table=??(ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=34000, match=(eth.dst == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=??(ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_acl_hint     ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_in_pre_acl      ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_pre_acl      ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.dst == $svc_monitor_mac), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(eth.mcast), action=(next;)
  table=??(ls_in_pre_acl      ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)
  table=??(ls_out_acl_action  ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[16]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[17]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; /* drop */)
  table=??(ls_out_acl_action  ), priority=1000 , match=(reg8[[18]] == 1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; reg0 = 0; reject { /* eth.dst <-> eth.src; ip.dst <-> ip.src; is implicit. */ outport <-> inport; next(pipeline=ingress,table=27); };)
  table=??(ls_out_acl_eval    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_eval    ), priority=1    , match=(ip && !ct.est), action=(next;)
  table=??(ls_out_acl_eval    ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=1001 , match=(reg0[[7]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; reg0[[1]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=1001 , match=(reg0[[8]] == 1 && (ip4 && tcp)), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=34000, match=(eth.src == $svc_monitor_mac), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=??(ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=3    , match=(!ct.est), action=(reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=5    , match=(!ct.trk), action=(reg0[[8]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_out_acl_hint    ), priority=7    , match=(ct.new && !ct.est), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=??(ls_out_pre_acl     ), priority=0    , match=(1), action=(next;)
  table=??(ls_out_pre_acl     ), priority=100  , match=(ip), action=(reg0[[0]] = 1; next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.mcast), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(eth.src == $svc_monitor_mac), action=(next;)
  table=??(ls_out_pre_acl     ), priority=110  , match=(nd || nd_rs || nd_ra || mldv1 || mldv2 || (udp && udp.src == 546 && udp.dst == 547)), action=(next;)
])

dnl UDP traffic should be dropped.
AT_CHECK_UNQUOTED([ovn_trace --ct new --ct new --minimal ls "${flow}"], [0], [dnl
ct_next(ct_state=new|trk);
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([northd-parallelization unixctl])
ovn_start

check as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1
OVS_WAIT_FOR_OUTPUT([as northd ovn-appctl -t NORTHD_TYPE parallel-build/get-n-threads], [0], [1
])

check as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 4
OVS_WAIT_FOR_OUTPUT([as northd ovn-appctl -t NORTHD_TYPE parallel-build/get-n-threads], [0], [4
])

check as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1
OVS_WAIT_FOR_OUTPUT([as northd ovn-appctl -t NORTHD_TYPE parallel-build/get-n-threads], [0], [1
])

AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 0], [2], [],
  [invalid n_threads: 0
ovn-appctl: ovn-northd: server returned an error
])

AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads -1], [2], [],
  [invalid n_threads: -1
ovn-appctl: ovn-northd: server returned an error
])

AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 300], [2], [],
  [invalid n_threads: 300
ovn-appctl: ovn-northd: server returned an error
])

AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads], [2], [],
  ["parallel-build/set-n-threads" command requires at least 1 arguments
ovn-appctl: ovn-northd: server returned an error
])

AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1 2], [2], [],
  ["parallel-build/set-n-threads" command takes at most 1 arguments
ovn-appctl: ovn-northd: server returned an error
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([northd-parallelization runtime])
ovn_start

add_switch_ports() {
    for port in $(seq $1 $2); do
        OVN_NBCTL(lsp-add ls1 lsp${port})
        OVN_NBCTL(lsp-set-addresses lsp${port} dynamic)
    done
    RUN_OVN_NBCTL()
}

delete_switch_ports() {
    for port in $(seq $1 $2); do
        OVN_NBCTL(lsp-del lsp${port})
    done
    RUN_OVN_NBCTL()
}

m4_define([DUMP_FLOWS_SORTED], [sed -e 's/arp.tpa == 10.1.0.[[0-9]]\{1,3\}/arp.tpa == 10.1.0.??/;s/eth.dst == ..:..:..:..:..:../??:??:??:??:??:??/' | sort])

# Build some rather heavy config and modify number of threads in the middle
check ovn-nbctl ls-add ls1
check ovn-nbctl set Logical_Switch ls1 other_config:subnet=10.1.0.0/16
check ovn-nbctl set Logical_Switch ls1 other_config:exclude_ips=10.1.255.254

check ovn-nbctl lr-add lr1
check ovn-nbctl lsp-add ls1 lsp0 -- set Logical_Switch_Port lsp0 type=router options:router-port=lrp0 addresses=dynamic
check ovn-nbctl lrp-add lr1 lrp0 "f0:00:00:01:00:01" 10.1.255.254/16
check ovn-nbctl lr-nat-add lr1 snat 10.2.0.1 10.1.0.0/16
add_switch_ports 1 50

check as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 4
add_switch_ports 51 100

check as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 8
add_switch_ports 101 150

check as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 4
add_switch_ports 151 200

check as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 1
add_switch_ports 201 250
check ovn-nbctl --wait=sb sync

# Run 3 times: one with parallelization enabled, one with disabled, and one while changing
# Compare the flows produced by the three runs
# Ignore IP/MAC addresses
ovn-sbctl dump-flows | DUMP_FLOWS_SORTED > flows1

# Restart with 1 thread
delete_switch_ports 1 250
add_switch_ports 1 250
check ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows | DUMP_FLOWS_SORTED > flows2
AT_CHECK([diff flows1 flows2])

# Restart with with 8 threads
check as northd ovn-appctl -t NORTHD_TYPE parallel-build/set-n-threads 8
delete_switch_ports 1 250
add_switch_ports 1 250
check ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows | DUMP_FLOWS_SORTED > flows3
AT_CHECK([diff flows1 flows3])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Port security lflows])
ovn_start

# Create logical routers
check ovn-nbctl --wait=sb ls-add sw0

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \
sort | sed 's/table=../table=??/' ], [0], [dnl
  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)
  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)
  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)
  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)
  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)
  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)
  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == "none"), action=(drop;)
  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)
  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)
])

check ovn-nbctl lsp-add sw0 sw0p1 -- lsp-set-addresses sw0p1 "00:00:00:00:00:01"
check ovn-nbctl lsp-add sw0 sw0p2 -- lsp-set-addresses sw0p2 "00:00:00:00:00:02"
check ovn-nbctl --wait=sb lsp-add sw0 localnetport -- lsp-set-type localnetport localnet

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \
sort | sed 's/table=../table=??/' ], [0], [dnl
  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)
  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)
  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)
  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)
  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)
  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = "sw0p1"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = "sw0p2"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)
  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == "none"), action=(drop;)
  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)
  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)
])

check ovn-nbctl lsp-set-port-security sw0p1 "00:00:00:00:00:01 10.0.0.3 1000::3"
check ovn-nbctl --wait=sb lsp-set-port-security sw0p2 "00:00:00:00:00:02 10.0.0.4 1000::4"

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \
sort | sed 's/table=../table=??/' ], [0], [dnl
  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)
  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)
  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)
  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)
  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)
  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = "sw0p1"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = "sw0p2"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)
  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == "none"), action=(drop;)
  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)
  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)
])

# Disable sw0p1
check ovn-nbctl --wait=sb set logical_switch_port sw0p1 enabled=false

ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \
sort | sed 's/table=../table=??/' ], [0], [dnl
  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)
  table=??(ls_in_check_port_sec), priority=100  , match=(inport == "sw0p1"), action=(reg0[[15]] = 1; next;)
  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)
  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)
  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)
  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)
  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(drop;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = "sw0p2"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)
  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == "none"), action=(drop;)
  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == "sw0p1"), action=(drop;)
  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)
  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)
])

check ovn-nbctl --wait=sb lsp-set-options sw0p2 qdisc_queue_id=10
ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \
sort | sed 's/table=../table=??/' ], [0], [dnl
  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)
  table=??(ls_in_check_port_sec), priority=100  , match=(inport == "sw0p1"), action=(reg0[[15]] = 1; next;)
  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)
  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)
  table=??(ls_in_check_port_sec), priority=70   , match=(inport == "sw0p2"), action=(set_queue(10); reg0[[15]] = check_in_port_sec(); next;)
  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)
  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)
  table=??(ls_out_apply_port_sec), priority=110  , match=(outport == "localnetport" && inport == "sw0p2"), action=(set_queue(10); output;)
  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(drop;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = "sw0p2"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)
  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == "none"), action=(drop;)
  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == "sw0p1"), action=(drop;)
  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)
  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)
])

check ovn-nbctl set logical_switch_port sw0p1 enabled=true
check ovn-nbctl lsp-set-type sw0p1 vtep
check ovn-nbctl --wait=sb lsp-set-options localnetport qdisc_queue_id=10
ovn-sbctl dump-flows sw0 > sw0flows
AT_CAPTURE_FILE([sw0flows])

AT_CHECK([cat sw0flows | grep -e port_sec -e ls_in_l2_lkup -e ls_in_l2_unknown | \
sort | sed 's/table=../table=??/' ], [0], [dnl
  table=??(ls_in_check_port_sec), priority=100  , match=(eth.src[[40]]), action=(drop;)
  table=??(ls_in_check_port_sec), priority=100  , match=(vlan.present), action=(drop;)
  table=??(ls_in_check_port_sec), priority=50   , match=(1), action=(reg0[[15]] = check_in_port_sec(); next;)
  table=??(ls_in_check_port_sec), priority=70   , match=(inport == "localnetport"), action=(set_queue(10); reg0[[15]] = check_in_port_sec(); next;)
  table=??(ls_in_check_port_sec), priority=70   , match=(inport == "sw0p1"), action=(reg0[[14]] = 1; next(pipeline=ingress, table=17);)
  table=??(ls_in_check_port_sec), priority=70   , match=(inport == "sw0p2"), action=(set_queue(10); reg0[[15]] = check_in_port_sec(); next;)
  table=??(ls_in_apply_port_sec), priority=0    , match=(1), action=(next;)
  table=??(ls_in_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_out_apply_port_sec), priority=0    , match=(1), action=(output;)
  table=??(ls_out_apply_port_sec), priority=100  , match=(outport == "localnetport"), action=(set_queue(10); output;)
  table=??(ls_out_apply_port_sec), priority=110  , match=(outport == "localnetport" && inport == "sw0p2"), action=(set_queue(10); output;)
  table=??(ls_out_apply_port_sec), priority=50   , match=(reg0[[15]] == 1), action=(drop;)
  table=??(ls_in_l2_lkup      ), priority=0    , match=(1), action=(outport = get_fdb(eth.dst); next;)
  table=??(ls_in_l2_lkup      ), priority=110  , match=(eth.dst == $svc_monitor_mac && (tcp || icmp || icmp6)), action=(handle_svc_check(inport);)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:01), action=(outport = "sw0p1"; output;)
  table=??(ls_in_l2_lkup      ), priority=50   , match=(eth.dst == 00:00:00:00:00:02), action=(outport = "sw0p2"; output;)
  table=??(ls_in_l2_lkup      ), priority=70   , match=(eth.mcast), action=(outport = "_MC_flood"; output;)
  table=??(ls_in_l2_unknown   ), priority=0    , match=(1), action=(output;)
  table=??(ls_in_l2_unknown   ), priority=50   , match=(outport == "none"), action=(drop;)
  table=??(ls_out_check_port_sec), priority=0    , match=(1), action=(reg0[[15]] = check_out_port_sec(); next;)
  table=??(ls_out_check_port_sec), priority=100  , match=(eth.mcast), action=(reg0[[15]] = 0; next;)
])

AT_CLEANUP
])


OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Load balancer ct_lb_mark backwards compatibility])
AT_KEYWORDS([lb])
ovn_start

check ovn-nbctl                                               \
  -- ls-add ls                                                \
  -- lr-add lr -- set logical_router lr options:chassis=local \
  -- lb-add lb-test 66.66.66.66 42.42.42.2                    \
  -- ls-lb-add ls lb-test                                     \
  -- lr-lb-add lr lb-test

AS_BOX([No chassis registered - use ct_lb_mark and ct_mark.natted])
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep -e natted -e ct_lb], [0], [dnl
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(ct_lb_mark(backends=42.42.42.2);)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=6 (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 66.66.66.66), action=(reg1 = 66.66.66.66; ct_lb_mark;)
  table=6 (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)
  table=13(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 66.66.66.66), action=(reg0[[1]] = 0; ct_lb_mark(backends=42.42.42.2);)
  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)
])

AS_BOX([Chassis registered that doesn't support ct_lb_mark - use ct_lb and ct_label.natted])
check ovn-sbctl chassis-add hv geneve 127.0.0.1
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep -e natted -e ct_lb], [0], [dnl
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(ct_lb(backends=42.42.42.2);)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted), action=(next;)
  table=6 (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 66.66.66.66), action=(reg1 = 66.66.66.66; ct_lb;)
  table=6 (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb;)
  table=13(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 66.66.66.66), action=(reg0[[1]] = 0; ct_lb(backends=42.42.42.2);)
  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb;)
])

check ovn-nbctl --wait=sb set logical_router lr options:lb_force_snat_ip="42.42.42.1"
AT_CHECK([ovn-sbctl lflow-list | grep lr_in_dnat], [0], [dnl
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(flags.force_snat_for_lb = 1; ct_lb(backends=42.42.42.2; force_snat);)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
])
check ovn-nbctl remove logical_router lr options lb_force_snat_ip

check ovn-nbctl --wait=sb set load_balancer lb-test options:skip_snat="true"
AT_CHECK([ovn-sbctl lflow-list | grep lr_in_dnat], [0], [dnl
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(flags.skip_snat_for_lb = 1; ct_lb(backends=42.42.42.2; skip_snat);)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
])
check ovn-nbctl remove load_balancer lb-test options skip_snat

AS_BOX([Chassis upgrades and supports ct_lb_mark - use ct_lb_mark and ct_mark.natted])
check ovn-sbctl set chassis hv other_config:ct-no-masked-label=true
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep -e natted -e ct_lb], [0], [dnl
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 66.66.66.66), action=(ct_lb_mark(backends=42.42.42.2);)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=6 (ls_in_pre_stateful ), priority=120  , match=(reg0[[2]] == 1 && ip4.dst == 66.66.66.66), action=(reg1 = 66.66.66.66; ct_lb_mark;)
  table=6 (ls_in_pre_stateful ), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)
  table=13(ls_in_lb           ), priority=110  , match=(ct.new && ip4.dst == 66.66.66.66), action=(reg0[[1]] = 0; ct_lb_mark(backends=42.42.42.2);)
  table=2 (ls_out_pre_stateful), priority=110  , match=(reg0[[2]] == 1), action=(ct_lb_mark;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ACL ct_mark.blocked backwards compatibility])
AT_KEYWORDS([acl])
ovn_start

check ovn-nbctl                                               \
  -- ls-add ls                                                \
  -- acl-add ls from-lport 1 1 allow-related                  \
  -- --apply-after-lb acl-add ls from-lport 1 1 allow-related \
  -- acl-add ls to-lport 1 1 allow-related

AS_BOX([No chassis registered - use ct_mark.blocked])
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep 'ls.*acl.*blocked' ], [0], [dnl
  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
])

AS_BOX([Chassis registered that doesn't support ct_mark.blocked - use ct_label.blocked])
check ovn-sbctl chassis-add hv geneve 127.0.0.1
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep 'ls.*acl.*blocked' ], [0], [dnl
  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_label.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_label.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_label.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_label.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_label.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_label.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=1    , match=(ip && ct.est && ct_label.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
])

AS_BOX([Chassis upgrades and supports ct_mark.blocked - use ct_mark.blocked])
check ovn-sbctl set chassis hv other_config:ct-no-masked-label=true
check ovn-nbctl --wait=sb sync
AT_CHECK([ovn-sbctl lflow-list | grep 'ls.*acl.*blocked' ], [0], [dnl
  table=7 (ls_in_acl_hint     ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=7 (ls_in_acl_hint     ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=8 (ls_in_acl_eval     ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=6    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 1), action=(reg0[[7]] = 1; reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=4    , match=(!ct.new && ct.est && !ct.rpl && ct_mark.blocked == 0), action=(reg0[[8]] = 1; reg0[[10]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=2    , match=(ct.est && ct_mark.blocked == 1), action=(reg0[[9]] = 1; next;)
  table=3 (ls_out_acl_hint    ), priority=1    , match=(ct.est && ct_mark.blocked == 0), action=(reg0[[10]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=4 (ls_out_acl_eval    ), priority=1    , match=(ip && ct.est && ct_mark.blocked == 1), action=(reg0[[1]] = 1; reg8[[16]] = 1; next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Localnet MAC learning option])
ovn_start

AT_CHECK([ovn-nbctl ls-add ls0])

AT_CHECK([ovn-nbctl lsp-add ls0 ln_port])
AT_CHECK([ovn-nbctl lsp-set-addresses ln_port unknown])
AT_CHECK([ovn-nbctl lsp-set-type ln_port localnet])
AT_CHECK([ovn-nbctl lsp-set-options ln_port network_name=phys])
AT_CHECK([ovn-nbctl --wait=sb sync])

# Check MAC learning flows with 'localnet_learn_fdb' default (false)
AT_CHECK([ovn-sbctl dump-flows ls0 | grep -e 'ls_in_\(put\|lookup\)_fdb' | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_lookup_fdb   ), priority=0    , match=(1), action=(next;)
  table=? (ls_in_put_fdb      ), priority=0    , match=(1), action=(next;)
])

# Enable 'localnet_learn_fdb' and check the flows
AT_CHECK([ovn-nbctl --wait=sb lsp-set-options ln_port localnet_learn_fdb=true])
AT_CHECK([ovn-sbctl dump-flows ls0 | grep -e 'ls_in_\(put\|lookup\)_fdb' | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_lookup_fdb   ), priority=0    , match=(1), action=(next;)
  table=? (ls_in_lookup_fdb   ), priority=100  , match=(inport == "ln_port"), action=(reg0[[11]] = lookup_fdb(inport, eth.src); next;)
  table=? (ls_in_put_fdb      ), priority=0    , match=(1), action=(next;)
  table=? (ls_in_put_fdb      ), priority=100  , match=(inport == "ln_port" && reg0[[11]] == 0), action=(put_fdb(inport, eth.src); next;)
])

# Disable 'localnet_learn_fdb' and check the flows
AT_CHECK([ovn-nbctl --wait=sb lsp-set-options ln_port localnet_learn_fdb=false])
AT_CHECK([ovn-sbctl dump-flows ls0 | grep -e 'ls_in_\(put\|lookup\)_fdb' | sort | sed 's/table=./table=?/'], [0], [dnl
  table=? (ls_in_lookup_fdb   ), priority=0    , match=(1), action=(next;)
  table=? (ls_in_put_fdb      ), priority=0    , match=(1), action=(next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check install_ls_lb_from_router option])
AT_KEYWORDS([lb-ls-install-from-lrouter])
ovn_start

ovn-nbctl lr-add R1
ovn-nbctl set logical_router R1 options:chassis=hv1
ovn-nbctl lrp-add R1 R1-S0 02:ac:10:01:00:01 10.0.0.1/24
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:01:01 20.0.0.1/24
ovn-nbctl lrp-add R1 R1-PUB 02:ac:20:01:01:01 172.16.0.1/24

ovn-nbctl ls-add S0
ovn-nbctl lsp-add S0 S0-R1
ovn-nbctl lsp-set-type S0-R1 router
ovn-nbctl lsp-set-addresses S0-R1 02:ac:10:01:00:01
ovn-nbctl lsp-set-options S0-R1 router-port=R1-S0

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:01:01
ovn-nbctl lsp-set-options S1-R1 router-port=R1-S1

# Add load balancers on the logical router R1
ovn-nbctl lb-add lb0 172.16.0.10:80 10.0.0.2:80
ovn-nbctl lr-lb-add R1 lb0

ovn-nbctl lb-add lb1 172.16.0.11:8080 10.0.0.2:8080
lb1_uuid=$(fetch_column nb:load_balancer _uuid name=lb1)
lbg=$(ovn-nbctl create load_balancer_group name=lbg -- \
    add load_balancer_group lbg load_balancer $lb1_uuid)
ovn-nbctl add logical_router R1 load_balancer_group $lbg
ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows S0 > S0flows
ovn-sbctl dump-flows S1 > S1flows

AT_CAPTURE_FILE([S0flows])
AT_CAPTURE_FILE([S1flows])

AT_CHECK([grep "ls_in_lb " S0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
])
AT_CHECK([grep "ls_in_lb " S1flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
])

ovn-nbctl --wait=sb set NB_Global . options:install_ls_lb_from_router=true

ovn-sbctl dump-flows S0 > S0flows
ovn-sbctl dump-flows S1 > S1flows

AT_CAPTURE_FILE([S0flows])
AT_CAPTURE_FILE([S1flows])

AT_CHECK([grep "ls_in_lb " S0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:80);)
  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.11 && tcp.dst == 8080), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:8080);)
])
AT_CHECK([grep "ls_in_lb " S1flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:80);)
  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.11 && tcp.dst == 8080), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:8080);)
])

ovn-sbctl get datapath S0 _uuid > dp_uuids
ovn-sbctl get datapath S1 _uuid >> dp_uuids
lb_dp_group=$(ovn-sbctl --bare --columns datapath_group find Load_Balancer name=lb0)
AT_CHECK_UNQUOTED([ovn-sbctl --bare --columns _uuid,datapaths find Logical_DP_Group dnl
                    | grep -A1 $lb_dp_group | tail -1 | tr ' ' '\n' | sort], [0], [dnl
$(cat dp_uuids | sort)
])

ovn-nbctl --wait=sb set NB_Global . options:install_ls_lb_from_router=false

ovn-sbctl dump-flows S0 > S0flows
ovn-sbctl dump-flows S1 > S1flows

AT_CAPTURE_FILE([S0flows])
AT_CAPTURE_FILE([S1flows])

AT_CHECK([grep "ls_in_lb " S0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
])
AT_CHECK([grep "ls_in_lb " S1flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
])

check_column "" sb:load_balancer datapaths name=lb0

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check fip flows with redirect-type bridged])
AT_KEYWORDS([fip-redirect-type-bridged])
ovn_start

ovn-nbctl lr-add R1
ovn-nbctl lrp-add R1 R1-S0 02:ac:10:01:00:01 10.0.0.1/24 1000::a/64
ovn-nbctl lrp-add R1 R1-PUB 02:ac:20:01:01:01 172.16.0.1/24 3000::a/64
ovn-nbctl lrp-set-gateway-chassis R1-PUB hv1 20

ovn-nbctl ls-add S0
ovn-nbctl lsp-add S0 S0-R1
ovn-nbctl lsp-set-type S0-R1 router
ovn-nbctl lsp-set-addresses S0-R1 02:ac:10:01:00:01
ovn-nbctl lsp-set-options S0-R1 router-port=R1-S0
ovn-nbctl lsp-add S0 S0-P0
ovn-nbctl lsp-set-addresses S0-P0 "50:54:00:00:00:03 10.0.0.3 1000::3"

ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.0.110 10.0.0.3 S0-P0 30:54:00:00:00:03
ovn-nbctl lr-nat-add R1 dnat_and_snat 3000::c 1000::3 S0-P0 40:54:00:00:00:03

ovn-sbctl dump-flows R1 > R1flows
AT_CAPTURE_FILE([R1flows])
AT_CHECK([grep "lr_in_arp_resolve" R1flows | grep priority=90 | sort], [0], [dnl
])

ovn-nbctl --wait=sb set logical_router_port R1-PUB options:redirect-type=bridged
ovn-sbctl dump-flows R1 > R1flows
AT_CAPTURE_FILE([R1flows])

AT_CHECK([grep "lr_in_arp_resolve" R1flows | grep priority=90 | sort], [0], [dnl
  table=17(lr_in_arp_resolve  ), priority=90   , match=(outport == "R1-PUB" && ip4.src == 10.0.0.3 && is_chassis_resident("S0-P0")), action=(get_arp(outport, reg0); next;)
  table=17(lr_in_arp_resolve  ), priority=90   , match=(outport == "R1-PUB" && ip6.src == 1000::3 && is_chassis_resident("S0-P0")), action=(get_nd(outport, xxreg0); next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check lb-affinity flows])
AT_KEYWORDS([lb-affinity-flows])
ovn_start

ovn-nbctl lr-add R1
ovn-nbctl set logical_router R1 options:chassis=hv1
ovn-nbctl lrp-add R1 R1-S0 02:ac:10:01:00:01 10.0.0.1/24
ovn-nbctl lrp-add R1 R1-S1 02:ac:10:01:01:01 20.0.0.1/24
ovn-nbctl lrp-add R1 R1-PUB 02:ac:20:01:01:01 172.16.0.1/24

ovn-nbctl ls-add S0
ovn-nbctl lsp-add S0 S0-R1
ovn-nbctl lsp-set-type S0-R1 router
ovn-nbctl lsp-set-addresses S0-R1 02:ac:10:01:00:01
ovn-nbctl lsp-set-options S0-R1 router-port=R1-S0

ovn-nbctl ls-add S1
ovn-nbctl lsp-add S1 S1-R1
ovn-nbctl lsp-set-type S1-R1 router
ovn-nbctl lsp-set-addresses S1-R1 02:ac:10:01:01:01
ovn-nbctl lsp-set-options S1-R1 router-port=R1-S1

# Add load balancers on the logical router R1
ovn-nbctl lb-add lb0 172.16.0.10:80 10.0.0.2:80,20.0.0.2:80 tcp
ovn-nbctl lr-lb-add R1 lb0
ovn-nbctl ls-lb-add S0 lb0
ovn-nbctl --wait=sb sync

ovn-sbctl dump-flows S0 > S0flows
ovn-sbctl dump-flows R1 > R1flows

AT_CAPTURE_FILE([S0flows])
AT_CAPTURE_FILE([R1flows])

AT_CHECK([grep "ls_in_lb_aff_check" S0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb_aff_check ), priority=0    , match=(1), action=(next;)
])
AT_CHECK([grep "ls_in_lb_aff_learn" S0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)
])

AT_CHECK([grep "lr_in_lb_aff_check" R1flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_lb_aff_check ), priority=0    , match=(1), action=(next;)
])
AT_CHECK([grep "lr_in_lb_aff_learn" R1flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)
])

ovn-nbctl --wait=sb set load_balancer lb0 options:affinity_timeout=60

AS_BOX([Test LS flows])
ovn-sbctl dump-flows S0 > S0flows
AT_CAPTURE_FILE([S0flows])

AT_CHECK([grep "ls_in_lb_aff_check" S0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb_aff_check ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_lb_aff_check ), priority=100  , match=(ct.new && ip4 && reg1 == 172.16.0.10 && reg2[[0..15]] == 80), action=(reg9[[6]] = chk_lb_aff(); next;)
])
AT_CHECK([grep "ls_in_lb " S0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb           ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_lb           ), priority=120  , match=(ct.new && ip4.dst == 172.16.0.10 && tcp.dst == 80), action=(reg0[[1]] = 0; ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80);)
  table=??(ls_in_lb           ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0[[1]] = 0; reg1 = 172.16.0.10; reg2[[0..15]] = 80; ct_lb_mark(backends=10.0.0.2:80);)
  table=??(ls_in_lb           ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0[[1]] = 0; reg1 = 172.16.0.10; reg2[[0..15]] = 80; ct_lb_mark(backends=20.0.0.2:80);)
])
AT_CHECK([grep "ls_in_lb_aff_learn" S0flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg1 == 172.16.0.10 && reg2[[0..15]] == 80 && ip4.dst == 10.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = "172.16.0.10:80", backend = "10.0.0.2:80", proto = tcp, timeout = 60); /* drop */)
  table=??(ls_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg1 == 172.16.0.10 && reg2[[0..15]] == 80 && ip4.dst == 20.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = "172.16.0.10:80", backend = "20.0.0.2:80", proto = tcp, timeout = 60); /* drop */)
])

AS_BOX([Test LR flows])
ovn-sbctl dump-flows R1 > R1flows
AT_CAPTURE_FILE([R1flows])

AT_CHECK([grep "lr_in_lb_aff_check" R1flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_lb_aff_check ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_lb_aff_check ), priority=100  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(reg0 = ip4.dst; reg9[[16..31]] = tcp.dst; reg9[[6]] = chk_lb_aff(); next;)
])
AT_CHECK([grep "lr_in_dnat " R1flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80);)
  table=??(lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; ct_lb_mark(backends=10.0.0.2:80);)
  table=??(lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; ct_lb_mark(backends=20.0.0.2:80);)
  table=??(lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=??(lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])
AT_CHECK([grep "lr_in_lb_aff_learn" R1flows | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_lb_aff_learn ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg0 == 172.16.0.10 && reg9[[16..31]] == 80 && ip4.dst == 10.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = "172.16.0.10:80", backend = "10.0.0.2:80", proto = tcp, timeout = 60); /* drop */)
  table=??(lr_in_lb_aff_learn ), priority=100  , match=(reg9[[6]] == 0 && ct.new && ip4 && reg0 == 172.16.0.10 && reg9[[16..31]] == 80 && ip4.dst == 20.0.0.2 && tcp.dst == 80), action=(commit_lb_aff(vip = "172.16.0.10:80", backend = "20.0.0.2:80", proto = tcp, timeout = 60); /* drop */)
])

AS_BOX([Test LR flows - skip_snat=true])
check ovn-nbctl --wait=sb set load_balancer lb0 options:skip_snat=true

ovn-sbctl dump-flows R1 > R1flows_skip_snat
AT_CAPTURE_FILE([R1flows_skip_snat])

AT_CHECK([grep "lr_in_dnat " R1flows_skip_snat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80; skip_snat);)
  table=??(lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80; skip_snat);)
  table=??(lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.skip_snat_for_lb = 1; ct_lb_mark(backends=20.0.0.2:80; skip_snat);)
  table=??(lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=??(lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

check ovn-nbctl remove load_balancer lb0 options skip_snat

AS_BOX([Test LR flows - lb_force_snat_ip="172.16.0.1"])
check ovn-nbctl --wait=sb set logical_router R1 options:lb_force_snat_ip="172.16.0.1"

ovn-sbctl dump-flows R1 > R1flows_force_snat
AT_CAPTURE_FILE([R1flows_force_snat])

AT_CHECK([grep "lr_in_dnat " R1flows_force_snat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80; force_snat);)
  table=??(lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.force_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80; force_snat);)
  table=??(lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.force_snat_for_lb = 1; ct_lb_mark(backends=20.0.0.2:80; force_snat);)
  table=??(lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=??(lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AS_BOX([Test LR flows - lb_force_snat_ip="172.16.0.1" + skip_snat=true])
check ovn-nbctl --wait=sb set logical_router R1 options:lb_force_snat_ip="172.16.0.1"
check ovn-nbctl --wait=sb set load_balancer lb0 options:skip_snat=true

ovn-sbctl dump-flows R1 > R1flows_force_skip_snat
AT_CAPTURE_FILE([R1flows_force_skip_snat])

AT_CHECK([grep "lr_in_dnat " R1flows_force_skip_snat | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_dnat         ), priority=120  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 172.16.0.10 && tcp && tcp.dst == 80), action=(flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80,20.0.0.2:80; skip_snat);)
  table=??(lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 10.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.skip_snat_for_lb = 1; ct_lb_mark(backends=10.0.0.2:80; skip_snat);)
  table=??(lr_in_dnat         ), priority=150  , match=(reg9[[6]] == 1 && ct.new && ip4 && reg4 == 20.0.0.2 && reg8[[0..15]] == 80), action=(reg0 = 172.16.0.10; flags.skip_snat_for_lb = 1; ct_lb_mark(backends=20.0.0.2:80; skip_snat);)
  table=??(lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=??(lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=??(lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Address set incremental processing])
ovn_start

# Create a few resources.
check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-p1 -- lsp-set-addresses sw0-p1 "02:ac:10:01:00:04 20.0.0.4"
check ovn-nbctl lsp-add sw0 sw0-p2 -- lsp-set-addresses sw0-p2 "02:ac:10:01:00:05 20.0.0.5"

fetch_column NB:Logical_Switch_Port _uuid name=sw0-p1

ovn-nbctl list logical_switch_port name=sw0-p1

p1_uuid=$(fetch_column nb:Logical_Switch_Port _uuid name=sw0-p1)
p2_uuid=$(fetch_column nb:Logical_Switch_Port _uuid name=sw0-p2)

echo "p1 uuid - $p1_uuid"
ovn-nbctl --wait=sb sync

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
foo_as_uuid=$(ovn-nbctl create address_set name=foo addresses=\"1.1.1.1\",\"1.1.1.2\")
wait_column '1.1.1.1 1.1.1.2' Address_Set addresses name=foo
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [1
])

rm -f northd/ovn-northd.log
check as northd ovn-appctl -t NORTHD_TYPE vlog/reopen
check as northd ovn-appctl -t NORTHD_TYPE vlog/set jsonrpc:dbg
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.3 -- \
                add address_set $foo_as_uuid addresses 1.1.2.1/4
wait_column '1.1.1.1 1.1.1.2 1.1.1.3 1.1.2.1/4' Address_Set addresses name=foo

# There should be no recompute of the sync_to_sb_addr_set engine node .
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [0
])
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AT_CHECK([grep transact northd/ovn-northd.log | grep Address_Set | \
grep -c mutate], [0], [1
])

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.4 -- \
                remove address_set $foo_as_uuid addresses 1.1.1.1 -- \
                remove address_set $foo_as_uuid addresses 1.1.2.1/4
wait_column '1.1.1.2 1.1.1.3 1.1.1.4' Address_Set addresses name=foo

# There should be no recompute of the sync_to_sb_addr_set engine node .
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [0
])
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AT_CHECK([grep transact northd/ovn-northd.log | grep Address_Set | \
grep -c mutate], [0], [2
])

# Pause ovn-northd and add/remove few addresses.  when it is resumed
# it should use mutate for updating the address sets.
check as northd ovn-appctl -t NORTHD_TYPE pause
check as northd-backup ovn-appctl -t NORTHD_TYPE pause

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.5
check ovn-nbctl add address_set $foo_as_uuid addresses 1.1.1.6
check ovn-nbctl remove address_set $foo_as_uuid addresses 1.1.1.2

check_column '1.1.1.2 1.1.1.3 1.1.1.4' Address_Set addresses name=foo

# Resume northd now
check as northd ovn-appctl -t NORTHD_TYPE resume
wait_column '1.1.1.3 1.1.1.4 1.1.1.5 1.1.1.6' Address_Set addresses name=foo
# There should be recompute of the sync_to_sb_addr_set engine node .
recompute_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute)
AT_CHECK([test $recompute_stat -ge 1])

AT_CHECK([grep transact northd/ovn-northd.log | grep Address_Set | \
grep -c mutate], [0], [3
])

# Create a port group. This should result in recompute of sb_to_sync_addr_set engine node.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl pg-add pg1
wait_column '' Address_Set addresses name=pg1_ip4
recompute_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute)
AT_CHECK([test $recompute_stat -ge 1])

# Add sw0-p1 to port group pg1
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl add port_group pg1 ports ${p1_uuid}
wait_column '20.0.0.4' Address_Set addresses name=pg1_ip4

# There should be no recompute of the sync_to_sb_addr_set engine node.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [0
])

# No change, no recompute
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb sync
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_addr_set recompute], [0], [0
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Port group incremental processing])
ovn_start

check ovn-nbctl ls-add sw1 \
  -- lsp-add sw1 sw1.1     \
  -- lsp-add sw1 sw1.2     \
  -- lsp-add sw1 sw1.3     \
  -- ls-add sw2            \
  -- lsp-add sw2 sw2.1     \
  -- lsp-add sw2 sw2.2     \
  -- lsp-add sw2 sw2.3

check ovn-nbctl --wait=sb sync
sw1_key=$(fetch_column Datapath_Binding tunnel_key external_ids:name=sw1)
sw2_key=$(fetch_column Datapath_Binding tunnel_key external_ids:name=sw2)

check_acl_lflows() {
AT_CHECK_UNQUOTED([ovn-sbctl lflow-list sw1 | grep ls_in_acl_eval | grep eth.src==41:41:41:41:41:41 -c], [ignore], [dnl
$1
])
AT_CHECK_UNQUOTED([ovn-sbctl lflow-list sw1 | grep ls_in_acl_eval | grep eth.src==42:42:42:42:42:42 -c], [ignore], [dnl
$2
])
AT_CHECK_UNQUOTED([ovn-sbctl lflow-list sw2 | grep ls_in_acl_eval | grep eth.src==41:41:41:41:41:41 -c], [ignore], [dnl
$3
])
AT_CHECK_UNQUOTED([ovn-sbctl lflow-list sw2 | grep ls_in_acl_eval | grep eth.src==42:42:42:42:42:42 -c], [ignore], [dnl
$4
])
}

AS_BOX([Create new PG1 and PG2])
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb -- pg-add pg1 -- pg-add pg2
dnl The northd node should not recompute, it should handle nb_global update
dnl though, therefore "compute: 1".
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd], [0], [dnl
Node: northd
- recompute:            0
- compute:              1
- abort:                0
])
dnl The port_group node recomputes every time a NB port group is added/deleted.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats port_group], [0], [dnl
Node: port_group
- recompute:            1
- compute:              0
- abort:                0
])
dnl The port_group node is an input for the lflow node.  Port_group
dnl recompute/compute triggers lflow recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow], [0], [dnl
Node: lflow
- recompute:            1
- compute:              0
- abort:                0
])
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AS_BOX([Add ACLs on PG1 and PG2])
check ovn-nbctl --wait=sb             \
  -- acl-add pg1 from-lport 1 eth.src==41:41:41:41:41:41 allow \
  -- acl-add pg2 from-lport 1 eth.src==42:42:42:42:42:42 allow
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AS_BOX([Add one port from the two switches to PG1])
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb         \
  -- pg-set-ports pg1 sw1.1 sw2.1
check_column "sw1.1" sb:Port_Group ports name="${sw1_key}_pg1"
check_column "sw2.1" sb:Port_Group ports name="${sw2_key}_pg1"

dnl The northd node should not recompute, it should handle nb_global update
dnl though, therefore "compute: 1".
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd], [0], [dnl
Node: northd
- recompute:            0
- compute:              1
- abort:                0
])
dnl The port_group node recomputes also every time a port from a new switch
dnl is added to the group.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats port_group], [0], [dnl
Node: port_group
- recompute:            1
- compute:              0
- abort:                0
])
dnl The port_group node is an input for the lflow node.  Port_group
dnl recompute/compute triggers lflow recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow], [0], [dnl
Node: lflow
- recompute:            1
- compute:              0
- abort:                0
])
dnl Expect ACL1 on sw1 and sw2
check_acl_lflows 1 0 1 0
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AS_BOX([Add one port from the two switches to PG2])
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb \
  -- pg-set-ports pg2 sw1.2 sw2.2
check_column "sw1.1" sb:Port_Group ports name="${sw1_key}_pg1"
check_column "sw2.1" sb:Port_Group ports name="${sw2_key}_pg1"
check_column "sw1.2" sb:Port_Group ports name="${sw1_key}_pg2"
check_column "sw2.2" sb:Port_Group ports name="${sw2_key}_pg2"

dnl The northd node should not recompute, it should handle nb_global update
dnl though, therefore "compute: 1".
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd], [0], [dnl
Node: northd
- recompute:            0
- compute:              1
- abort:                0
])
dnl The port_group node recomputes also every time a port from a new switch
dnl is added to the group.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats port_group], [0], [dnl
Node: port_group
- recompute:            1
- compute:              0
- abort:                0
])
dnl The port_group node is an input for the lflow node.  Port_group
dnl recompute/compute triggers lflow recompute (for ACLs).
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow], [0], [dnl
Node: lflow
- recompute:            1
- compute:              0
- abort:                0
])
dnl Expect both ACLs on sw1 and sw2
check_acl_lflows 1 1 1 1
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AS_BOX([Add one more port from the two switches to PG1 and PG2])
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb                     \
  -- pg-set-ports pg1 sw1.1 sw2.1 sw1.3 sw2.3 \
  -- pg-set-ports pg2 sw1.2 sw2.2 sw1.3 sw2.3
check_column "sw1.1 sw1.3" sb:Port_Group ports name="${sw1_key}_pg1"
check_column "sw2.1 sw2.3" sb:Port_Group ports name="${sw2_key}_pg1"
check_column "sw1.2 sw1.3" sb:Port_Group ports name="${sw1_key}_pg2"
check_column "sw2.2 sw2.3" sb:Port_Group ports name="${sw2_key}_pg2"

dnl The northd node should not recompute, it should handle nb_global update
dnl though, therefore "compute: 1".
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd], [0], [dnl
Node: northd
- recompute:            0
- compute:              1
- abort:                0
])
dnl We did not change the set of switches a pg is applied to, there should be
dnl no recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats port_group], [0], [dnl
Node: port_group
- recompute:            0
- compute:              1
- abort:                0
])
dnl We did not change the set of switches a pg is applied to, there should be
dnl no recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow], [0], [dnl
Node: lflow
- recompute:            0
- compute:              1
- abort:                0
])
dnl Expect both ACLs on sw1 and sw2
check_acl_lflows 1 1 1 1
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AS_BOX([Remove the last port from PG1 and PG2])
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb         \
  -- pg-set-ports pg1 sw1.1 sw2.1 \
  -- pg-set-ports pg2 sw1.2 sw2.2
check_column "sw1.1" sb:Port_Group ports name="${sw1_key}_pg1"
check_column "sw2.1" sb:Port_Group ports name="${sw2_key}_pg1"
check_column "sw1.2" sb:Port_Group ports name="${sw1_key}_pg2"
check_column "sw2.2" sb:Port_Group ports name="${sw2_key}_pg2"

dnl The northd node should not recompute, it should handle nb_global update
dnl though, therefore "compute: 1".
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd], [0], [dnl
Node: northd
- recompute:            0
- compute:              1
- abort:                0
])
dnl We did not change the set of switches a pg is applied to, there should be
dnl no recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats port_group], [0], [dnl
Node: port_group
- recompute:            0
- compute:              1
- abort:                0
])
dnl We did not change the set of switches a pg is applied to, there should be
dnl no recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow], [0], [dnl
Node: lflow
- recompute:            0
- compute:              1
- abort:                0
])
dnl Expect both ACLs on sw1 and sw2
check_acl_lflows 1 1 1 1
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AS_BOX([Remove the second port from PG2])
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb pg-set-ports pg2 sw1.2
check_column "sw1.1" sb:Port_Group ports name="${sw1_key}_pg1"
check_column "sw2.1" sb:Port_Group ports name="${sw2_key}_pg1"
check_column "sw1.2" sb:Port_Group ports name="${sw1_key}_pg2"
AT_CHECK([fetch_column sb:Port_Group ports name="${sw2_key}_pg2"], [0], [
])

dnl The northd node should not recompute, it should handle nb_global update
dnl though, therefore "compute: 1".
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd], [0], [dnl
Node: northd
- recompute:            0
- compute:              1
- abort:                0
])
dnl We changed the set of switches a pg is applied to, there should be
dnl a recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats port_group], [0], [dnl
Node: port_group
- recompute:            1
- compute:              0
- abort:                0
])
dnl We changed the set of switches a pg is applied to, there should be
dnl a recompute (for ACLs).
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow], [0], [dnl
Node: lflow
- recompute:            1
- compute:              0
- abort:                0
])
dnl Expect both ACLs on sw1 and only the first one on sw2.
check_acl_lflows 1 1 1 0
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AS_BOX([Remove the second port from PG1])
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb pg-set-ports pg1 sw1.1
check_column "sw1.1" sb:Port_Group ports name="${sw1_key}_pg1"
AT_CHECK([fetch_column sb:Port_Group ports name="${sw2_key}_pg1"], [0], [
])
check_column "sw1.2" sb:Port_Group ports name="${sw1_key}_pg2"
AT_CHECK([fetch_column sb:Port_Group ports name="${sw2_key}_pg2"], [0], [
])

dnl The northd node should not recompute, it should handle nb_global update
dnl though, therefore "compute: 1".
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd], [0], [dnl
Node: northd
- recompute:            0
- compute:              1
- abort:                0
])
dnl We changed the set of switches a pg is applied to, there should be
dnl a recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats port_group], [0], [dnl
Node: port_group
- recompute:            1
- compute:              0
- abort:                0
])
dnl We changed the set of switches a pg is applied to, there should be
dnl a recompute (for ACLs).
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow], [0], [dnl
Node: lflow
- recompute:            1
- compute:              0
- abort:                0
])
dnl Expect both ACLs on sw1 and not on sw2.
check_acl_lflows 1 1 0 0
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AS_BOX([Add second port to both PGs])
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb         \
  -- pg-set-ports pg1 sw1.1 sw2.1 \
  -- pg-set-ports pg2 sw1.2 sw2.2
check_column "sw1.1" sb:Port_Group ports name="${sw1_key}_pg1"
check_column "sw2.1" sb:Port_Group ports name="${sw2_key}_pg1"
check_column "sw1.2" sb:Port_Group ports name="${sw1_key}_pg2"
check_column "sw2.2" sb:Port_Group ports name="${sw2_key}_pg2"

dnl The northd node should not recompute, it should handle nb_global update
dnl though, therefore "compute: 1".
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd], [0], [dnl
Node: northd
- recompute:            0
- compute:              1
- abort:                0
])
dnl We changed the set of switches a pg is applied to, there should be a
dnl recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats port_group], [0], [dnl
Node: port_group
- recompute:            1
- compute:              0
- abort:                0
])
dnl We changed the set of switches a pg is applied to, there should be a
dnl recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow], [0], [dnl
Node: lflow
- recompute:            1
- compute:              0
- abort:                0
])
dnl Expect both ACLs on sw1 and sw2
check_acl_lflows 1 1 1 1
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AS_BOX([Remove second port from both PGs])
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb         \
  -- pg-set-ports pg1 sw1.1 \
  -- pg-set-ports pg2 sw1.2
check_column "sw1.1" sb:Port_Group ports name="${sw1_key}_pg1"
AT_CHECK([fetch_column sb:Port_Group ports name="${sw2_key}_pg1"], [0], [
])
check_column "sw1.2" sb:Port_Group ports name="${sw1_key}_pg2"
AT_CHECK([fetch_column sb:Port_Group ports name="${sw2_key}_pg2"], [0], [
])

dnl The northd node should not recompute, it should handle nb_global update
dnl though, therefore "compute: 1".
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd], [0], [dnl
Node: northd
- recompute:            0
- compute:              1
- abort:                0
])
dnl We changed the set of switches a pg is applied to, there should be a
dnl recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats port_group], [0], [dnl
Node: port_group
- recompute:            1
- compute:              0
- abort:                0
])
dnl We changed the set of switches a pg is applied to, there should be a
dnl recompute.
AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow], [0], [dnl
Node: lflow
- recompute:            1
- compute:              0
- abort:                0
])
dnl Expect both ACLs on sw1 and no ACLs on sw2
check_acl_lflows 1 1 0 0
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([Check default drop])
AT_KEYWORDS([drop])

ovn_start

# Check that there is an explicit drop lflow in for spoecified DP and table.
check_default_lflow() {
    dp=$1
    pipeline=$2

    table_len=$(ovn-sbctl --bare --columns table find logical_flow logical_datapath=$dp pipeline=$pipeline | sort | uniq | wc -l)
    table_len_default=$(ovn-sbctl --bare --columns table find logical_flow logical_datapath=$dp pipeline=$pipeline match=1 | sort | uniq | wc -l)

    echo "Checking if datapath $dp pipeline $pipeline has default actions"
    AT_CHECK([test $table_len -eq $table_len_default], [0], [ignore], [ignore], [echo "Datapath $dp pipeline $pipeline is missing some default action"])
}

# Create LS + LR
check ovn-nbctl --wait=sb \
                -- lr-add R1 \
                -- lrp-add R1 R1-S1 02:ac:10:01:00:01 172.16.1.1/24 \
                -- ls-add S1 \
                -- lsp-add S1 S1-R1 \
                -- lsp-set-type S1-R1 router \
                -- lsp-set-addresses S1-R1 02:ac:10:01:00:01 \
                -- lsp-set-options S1-R1 router-port=R1-S1 \
                -- lsp-add S1 p1 \
                -- lsp-set-addresses p1 "02:ac:10:01:00:0a 172.16.1.100"

ovn-sbctl dump-flows R1 > R1_flows
ovn-sbctl dump-flows R1 | grep "match=(1)" > R1_default_flows
ovn-sbctl dump-flows S1 > S1_flows
ovn-sbctl dump-flows S1 | grep "match=(1)" > S1_default_flows

AT_CAPTURE_FILE([R1_flows])
AT_CAPTURE_FILE([R1_default_flows])
AT_CAPTURE_FILE([S1_flows])
AT_CAPTURE_FILE([S1_default_flows])

lr_uuid=$(fetch_column datapath _uuid external_ids:name=R1)
ls_uuid=$(fetch_column datapath _uuid external_ids:name=S1)

check_default_lflow $lr_uuid ingress
check_default_lflow $lr_uuid egress

check_default_lflow $ls_uuid ingress
check_default_lflow $ls_uuid egress

# Add stateless ACL
check ovn-nbctl --wait=sb \
                -- acl-add S1 from-lport 100 'inport=p1 && ip4' allow-stateless

AT_CHECK([ovn-sbctl dump-flows | grep "ls_in_acl" | grep "match=(1)"  | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
])

check ovn-nbctl --wait=sb acl-del S1


# Add stateful ACL
check ovn-nbctl --wait=sb \
                -- acl-add S1 from-lport 2 "udp" allow-related

AT_CHECK([ovn-sbctl dump-flows | grep "ls_in_acl" | grep "match=(1)"  | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
])

check ovn-nbctl --wait=sb acl-del S1

# Add LB
check ovn-nbctl --wait=sb \
    -- lb-add lb "10.0.0.1" "10.0.0.2" \
    -- ls-lb-add S1 lb

AT_CHECK([ovn-sbctl dump-flows | grep "ls_in_acl" | grep "match=(1)"  | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
])


# Check LB + stateless ACL
check ovn-nbctl --wait=sb \
                -- acl-add S1 from-lport 100 'inport=p1 && ip4' allow-stateless

AT_CHECK([ovn-sbctl dump-flows | grep "ls_in_acl" | grep "match=(1)"  | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
])

check ovn-nbctl --wait=sb acl-del S1

# Check LB + statelful ACL
check ovn-nbctl --wait=sb \
                -- acl-add S1 from-lport 2 "udp" allow-related

AT_CHECK([ovn-sbctl dump-flows | grep "ls_in_acl" | grep "match=(1)"  | sed 's/table=../table=??/' | sort], [0], [dnl
  table=??(ls_in_acl_action   ), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_action), priority=0    , match=(1), action=(reg8[[16]] = 0; reg8[[17]] = 0; reg8[[18]] = 0; next;)
  table=??(ls_in_acl_after_lb_eval), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_eval     ), priority=0    , match=(1), action=(next;)
  table=??(ls_in_acl_hint     ), priority=0    , match=(1), action=(next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([NB to SB Chassis_Template_Var propagation])
AT_KEYWORDS([templates])
ovn_start

AT_CHECK([ovn-nbctl create Chassis_Template_Var chassis="hv1"], [0], [ignore])
AT_CHECK([ovn-nbctl create Chassis_Template_Var chassis="hv2"], [0], [ignore])

check ovn-nbctl set Chassis_Template_Var hv1 variables:tv=v1
check ovn-nbctl set Chassis_Template_Var hv2 variables:tv=v2

AS_BOX([Ensure values are propagated to SB])
check ovn-nbctl --wait=sb sync
check_column "tv=v1" sb:Chassis_Template_Var variables chassis="hv1"
check_column "tv=v2" sb:Chassis_Template_Var variables chassis="hv2"

AS_BOX([Ensure SB is reconciled])
check ovn-sbctl --all destroy Chassis_Template_Var
check ovn-nbctl --wait=sb sync
check_column "tv=v1" sb:Chassis_Template_Var variables chassis="hv1"
check_column "tv=v2" sb:Chassis_Template_Var variables chassis="hv2"

AS_BOX([Ensure SB is reconciled - deletion])
check ovn-nbctl destroy Chassis_Template_Var hv1
check ovn-nbctl --wait=sb sync
check_column "tv=v2" sb:Chassis_Template_Var variables chassis="hv2"

AS_BOX([Ensure SB is reconciled - cleanup])
check ovn-nbctl destroy Chassis_Template_Var hv2
check ovn-nbctl --wait=sb sync
check_row_count sb:Chassis_Template_Var 0

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Load balancer CT related backwards compatibility])
AT_KEYWORDS([lb])
ovn_start

check ovn-nbctl                                               \
  -- ls-add ls                                                \
  -- lr-add lr -- set logical_router lr options:chassis=local \
  -- lb-add lb-test 192.168.0.1 192.168.1.10                  \
  -- ls-lb-add ls lb-test                                     \
  -- lr-lb-add lr lb-test

m4_define([DUMP_FLOWS_SORTED], [sed 's/table=[[0-9]]\{1,2\}/table=?/' | sort])

AS_BOX([No chassis registered - CT related flows should be installed])
check ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows | DUMP_FLOWS_SORTED > lflows0

AT_CHECK([grep -e "lr_in_defrag" -e "lr_in_dnat" lflows0], [0], [dnl
  table=? (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=? (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 192.168.0.1), action=(ct_dnat;)
  table=? (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=? (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(ct_lb_mark(backends=192.168.1.10);)
  table=? (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=? (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep -e "ls_in_acl" -e "ls_out_acl" lflows0 | grep "priority=65532"], [0], [dnl
  table=? (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=?(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=?(ls_in_acl_after_lb_eval), priority=65532, match=(reg0[[17]] == 1), action=(reg8[[16]] = 1; next;)
])


AS_BOX([Chassis registered that doesn't support CT related])
check ovn-sbctl chassis-add hv geneve 127.0.0.1
check ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows | DUMP_FLOWS_SORTED > lflows1

AT_CHECK([grep -e "lr_in_defrag" -e "lr_in_dnat" lflows1], [0], [dnl
  table=? (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=? (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 192.168.0.1), action=(ct_dnat;)
  table=? (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=? (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(ct_lb(backends=192.168.1.10);)
  table=? (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted), action=(next;)
  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
])

check ovn-nbctl --wait=sb set logical_router lr options:lb_force_snat_ip="192.168.1.1"
AT_CHECK([ovn-sbctl lflow-list | grep lr_in_dnat], [0], [dnl
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(flags.force_snat_for_lb = 1; ct_lb(backends=192.168.1.10; force_snat);)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
])
check ovn-nbctl remove logical_router lr options lb_force_snat_ip

check ovn-nbctl --wait=sb set load_balancer lb-test options:skip_snat="true"
AT_CHECK([ovn-sbctl lflow-list | grep lr_in_dnat], [0], [dnl
  table=7 (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(flags.skip_snat_for_lb = 1; ct_lb(backends=192.168.1.10; skip_snat);)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted && ct_label.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=7 (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_label.natted), action=(next;)
  table=7 (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
])
check ovn-nbctl remove load_balancer lb-test options skip_snat

AT_CHECK([grep -e "ls_in_acl" -e "ls_out_acl" lflows1 | grep "priority=65532"], [0], [dnl
  table=? (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_label.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_label.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=?(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=?(ls_in_acl_after_lb_eval), priority=65532, match=(reg0[[17]] == 1), action=(reg8[[16]] = 1; next;)
])

AS_BOX([Chassis upgrades and supports CT related])
check ovn-sbctl set chassis hv other_config:ct-no-masked-label=true
check ovn-sbctl set chassis hv other_config:ovn-ct-lb-related=true
check ovn-nbctl --wait=sb sync
ovn-sbctl dump-flows | DUMP_FLOWS_SORTED > lflows2

AT_CHECK([grep -e "lr_in_defrag" -e "lr_in_dnat" lflows2], [0], [dnl
  table=? (lr_in_defrag       ), priority=0    , match=(1), action=(next;)
  table=? (lr_in_defrag       ), priority=100  , match=(ip && ip4.dst == 192.168.0.1), action=(ct_dnat;)
  table=? (lr_in_dnat         ), priority=0    , match=(1), action=(next;)
  table=? (lr_in_dnat         ), priority=110  , match=(ct.new && !ct.rel && ip4 && ip4.dst == 192.168.0.1), action=(ct_lb_mark(backends=192.168.1.10);)
  table=? (lr_in_dnat         ), priority=50   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted), action=(next;)
  table=? (lr_in_dnat         ), priority=50   , match=(ct.rel && !ct.est && !ct.new), action=(ct_commit_nat;)
  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; next;)
  table=? (lr_in_dnat         ), priority=70   , match=(ct.est && !ct.rel && !ct.new && ct_mark.natted && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; next;)
  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.force_snat == 1), action=(flags.force_snat_for_lb = 1; ct_commit_nat;)
  table=? (lr_in_dnat         ), priority=70   , match=(ct.rel && !ct.est && !ct.new && ct_mark.skip_snat == 1), action=(flags.skip_snat_for_lb = 1; ct_commit_nat;)
])

AT_CHECK([grep -e "ls_in_acl" -e "ls_out_acl" lflows2 | grep "priority=65532"], [0], [dnl
  table=? (ls_in_acl_eval     ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg0[[17]] = 1; reg8[[16]] = 1; ct_commit_nat;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg0[[9]] = 0; reg0[[10]] = 0; reg0[[17]] = 1; reg8[[16]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_in_acl_eval     ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(!ct.est && ct.rel && !ct.new && !ct.inv && ct_mark.blocked == 0), action=(reg8[[16]] = 1; ct_commit_nat;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.est && !ct.rel && !ct.new && !ct.inv && ct.rpl && ct_mark.blocked == 0), action=(reg8[[16]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(ct.inv || (ct.est && ct.rpl && ct_mark.blocked == 1)), action=(reg8[[17]] = 1; next;)
  table=? (ls_out_acl_eval    ), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=?(ls_in_acl_after_lb_eval), priority=65532, match=(nd || nd_ra || nd_rs || mldv1 || mldv2), action=(reg8[[16]] = 1; next;)
  table=?(ls_in_acl_after_lb_eval), priority=65532, match=(reg0[[17]] == 1), action=(reg8[[16]] = 1; next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Chassis-feature compatibitility - remote chassis])
ovn_start

AS_BOX([Local chassis])
check ovn-sbctl chassis-add hv1 geneve 127.0.0.1 \
  -- set chassis hv1 other_config:ct-no-masked-label=true \
  -- set chassis hv1 other_config:ovn-ct-lb-related=true \
  -- set chassis hv1 other_config:mac-binding-timestamp=true

check ovn-nbctl --wait=sb sync

AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE debug/chassis-features-list], [0], [dnl
ct_no_masked_label:    true
ct_lb_related:         true
mac_binding_timestamp: true
])

AS_BOX([Remote chassis])
check ovn-sbctl chassis-add hv2 geneve 127.0.0.2 \
  -- set chassis hv2 other_config:is-remote=true \
  -- set chassis hv2 other_config:ct-no-masked-label=false \
  -- set chassis hv2 other_config:ovn-ct-lb-related=false \
  -- set chassis hv2 other_config:mac-binding-timestamp=false

check ovn-nbctl --wait=sb sync

AT_CHECK([as northd ovn-appctl -t NORTHD_TYPE debug/chassis-features-list], [0], [dnl
ct_no_masked_label:    true
ct_lb_related:         true
mac_binding_timestamp: true
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check OVN QoS])
AT_KEYWORDS([OVN-QoS])
ovn_start

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls public
check ovn-nbctl lsp-set-type public localnet
check ovn-nbctl lsp-set-addresses public unknown

check_column "" sb:Port_Binding options logical_port=public

check ovn-nbctl --wait=sb set Logical_Switch_Port public options:qos_min_rate=200000
AT_CHECK([fetch_column sb:Port_Binding options logical_port=public |grep -q 'qos_min_rate=200000'])
AT_CHECK([fetch_column sb:Port_Binding options logical_port=public |grep -q 'qos_physical_network'],[1])

check ovn-nbctl --wait=sb set Logical_Switch_Port public options:qos_min_rate=200000 options:network_name=phys
AT_CHECK([fetch_column sb:Port_Binding options logical_port=public |grep -q 'qos_physical_network=phys'])

AT_CLEANUP
])

AT_SETUP([Tiered ACL logical flows])
AT_KEYWORDS([acl])

ovn_start

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls lsp
check ovn-nbctl pg-add pg lsp

m4_define([ACL_FLOWS], [grep -w $1 lflows | grep "$2" | sed 's/table=../table=??/' | sed "s/\($1[[^)]]*\)/$1/" | sort])

acl_test() {
    direction=$1
    options=$2
    thing=$3
    eval_stage=$4
    action_stage=$5
    eval_stage_table=$6

    if test "$direction" = "from-lport" ; then
        pipeline=ingress
    else
        pipeline=egress
    fi

    # Baseline test. Ensure that no ACL evaluation or tier-related flows are
    # installed.
    ovn-sbctl lflow-list ls > lflows
    AT_CHECK([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [])

    AT_CHECK([ACL_FLOWS([$action_stage], [priority=500])], [0], [])

    # Add an untiered ACL. Ensure that the ACL appears in the eval stage, and
    # that no tier-related flows appear in the action stage.
    check ovn-nbctl --wait=sb $options acl-add $thing $direction 1000 "ip4.addr == 80.111.111.112" drop
    acl1_uuid=$(ovn-nbctl --bare --columns _uuid find ACL priority=1000)

    ovn-sbctl lflow-list ls > lflows
    AT_CAPTURE_FILE([lflows])
    AT_CHECK_UNQUOTED([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [dnl
  table=??($eval_stage), priority=2000 , match=((ip4.addr == 80.111.111.112)), action=(reg8[[17]] = 1; next;)
])

    AT_CHECK([ACL_FLOWS([$action_stage], [priority=500])], [0], [])

    # Explicitly name the tier on the ACL to be tier 0. This should have no
    # effect on the logical flows.
    check ovn-nbctl --wait=sb set ACL $acl1_uuid tier=0
    ovn-sbctl lflow-list ls > lflows
    AT_CHECK_UNQUOTED([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [dnl
  table=??($eval_stage), priority=2000 , match=((ip4.addr == 80.111.111.112)), action=(reg8[[17]] = 1; next;)
])
    AT_CHECK([ACL_FLOWS([$action_stage], [priority=500])], [0], [])

    # Change the ACL to tier 1. Now we should see the tier as part of the ACL
    # match, and we should see a flow in the action stage to bump the tier
    # to 1 if there was no match on tier 0.
    check ovn-nbctl --wait=sb set ACL $acl1_uuid tier=1
    ovn-sbctl lflow-list ls > lflows
    AT_CHECK_UNQUOTED([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [dnl
  table=??($eval_stage), priority=2000 , match=(reg8[[30..31]] == 1 && (ip4.addr == 80.111.111.112)), action=(reg8[[17]] = 1; next;)
])

    AT_CHECK_UNQUOTED([ACL_FLOWS([$action_stage], [priority=500])], [0], [dnl
  table=??($action_stage), priority=500  , match=(reg8[[30..31]] == 0), action=(reg8[[30..31]] = 1; next(pipeline=$pipeline,table=$eval_stage_table);)
])

    # Change the ACL to tier 3. Ensure the tier match on the ACL has been
    # updated, and ensure we see three flows present for incrementing the
    # tier value in the action stage.
    check ovn-nbctl --wait=sb set ACL $acl1_uuid tier=3
    ovn-sbctl lflow-list ls > lflows
    AT_CHECK_UNQUOTED([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [dnl
  table=??($eval_stage), priority=2000 , match=(reg8[[30..31]] == 3 && (ip4.addr == 80.111.111.112)), action=(reg8[[17]] = 1; next;)
])

    AT_CHECK_UNQUOTED([ACL_FLOWS([$action_stage], [priority=500])], [0], [dnl
  table=??($action_stage), priority=500  , match=(reg8[[30..31]] == 0), action=(reg8[[30..31]] = 1; next(pipeline=$pipeline,table=$eval_stage_table);)
  table=??($action_stage), priority=500  , match=(reg8[[30..31]] == 1), action=(reg8[[30..31]] = 2; next(pipeline=$pipeline,table=$eval_stage_table);)
  table=??($action_stage), priority=500  , match=(reg8[[30..31]] == 2), action=(reg8[[30..31]] = 3; next(pipeline=$pipeline,table=$eval_stage_table);)
])

    # Add an untiered ACL. Ensure that it matches on tier 0, but otherwise,
    # nothing else should have changed in the logical flows.
    check ovn-nbctl --wait=sb $options acl-add $thing $direction 1000 "ip4.addr == 83.104.105.116" allow
    ovn-sbctl lflow-list ls > lflows
    AT_CHECK_UNQUOTED([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [dnl
  table=??($eval_stage), priority=2000 , match=(reg8[[30..31]] == 0 && (ip4.addr == 83.104.105.116)), action=(reg8[[16]] = 1; next;)
  table=??($eval_stage), priority=2000 , match=(reg8[[30..31]] == 3 && (ip4.addr == 80.111.111.112)), action=(reg8[[17]] = 1; next;)
])

    AT_CHECK_UNQUOTED([ACL_FLOWS([$action_stage], [priority=500])], [0], [dnl
  table=??($action_stage), priority=500  , match=(reg8[[30..31]] == 0), action=(reg8[[30..31]] = 1; next(pipeline=$pipeline,table=$eval_stage_table);)
  table=??($action_stage), priority=500  , match=(reg8[[30..31]] == 1), action=(reg8[[30..31]] = 2; next(pipeline=$pipeline,table=$eval_stage_table);)
  table=??($action_stage), priority=500  , match=(reg8[[30..31]] == 2), action=(reg8[[30..31]] = 3; next(pipeline=$pipeline,table=$eval_stage_table);)
])

    # Remove the tier 3 ACL. The remaining ACL is untiered, and there are no
    # other tiered ACLs. So we should go back to not checking the tier
    # number in the ACL match, and there should be no tier-related flows
    # in the action stage.
    check ovn-nbctl --wait=sb acl-del $thing $direction 1000 "ip4.addr == 80.111.111.112"
    ovn-sbctl lflow-list ls > lflows
    AT_CHECK_UNQUOTED([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [dnl
  table=??($eval_stage), priority=2000 , match=((ip4.addr == 83.104.105.116)), action=(reg8[[16]] = 1; next;)
])

    AT_CHECK([ACL_FLOWS([$action_stage], [priority=500])], [0], [])

    check ovn-nbctl --wait=sb acl-del $thing
    ovn-sbctl lflow-list ls > lflows

    AT_CHECK([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [])

    AT_CHECK([ACL_FLOWS([$action_stage], [priority=500])], [0], [])
}

acl_test from-lport "" ls ls_in_acl_eval ls_in_acl_action 8
acl_test from-lport "--apply-after-lb" ls ls_in_acl_after_lb_eval ls_in_acl_after_lb_action 18
acl_test to-lport "" ls ls_out_acl_eval ls_out_acl_action 4
acl_test from-lport "" pg ls_in_acl_eval ls_in_acl_action 8
acl_test from-lport "--apply-after-lb" pg ls_in_acl_after_lb_eval ls_in_acl_after_lb_action 18
acl_test to-lport "" pg ls_out_acl_eval ls_out_acl_action 4

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ACL "pass" logical flows])
AT_KEYWORDS([acl])

ovn_start
check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls lsp
check ovn-nbctl pg-add pg lsp

m4_define([ACL_FLOWS], [grep -w $1 lflows | grep "$2" | sed 's/table=../table=??/' | sed "s/\($1[[^)]]*\)/$1/" | sort])

acl_test() {
    direction=$1
    options=$2
    thing=$3
    eval_stage=$4

    # Baseline. Ensure no ACL eval flows are present.
    ovn-sbctl lflow-list ls > lflows
    AT_CHECK([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [])

    # Add an ACL with the "pass" verdict. Ensure that it is in the logical flow
    # table and that it simply moves to the next table without setting a specific
    # verdict bit.
    check ovn-nbctl --wait=sb $options acl-add $thing $direction 1000 "ip4.addr == 80.111.111.112" pass
    ovn-sbctl lflow-list ls > lflows
    AT_CHECK_UNQUOTED([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [dnl
  table=??($eval_stage), priority=2000 , match=((ip4.addr == 80.111.111.112)), action=(next;)
])

    # Remove the ACL with the "pass" verdict. Ensure that no eval flows are present.
    check ovn-nbctl --wait=sb acl-del $thing
    ovn-sbctl lflow-list ls > lflows
    AT_CHECK([ACL_FLOWS([$eval_stage], [priority=2000])], [0], [])
}

acl_test from-lport "" ls ls_in_acl_eval
acl_test from-lport "--apply-after-lb" ls ls_in_acl_after_lb_eval
acl_test to-lport "" ls ls_out_acl_eval
acl_test from-lport "" pg ls_in_acl_eval
acl_test from-lport "--apply-after-lb" pg ls_in_acl_after_lb_eval
acl_test to-lport "" pg ls_out_acl_eval

AT_CLEANUP
])

AT_SETUP([Localnet ports on LS with LB])
ovn_start
# In the past, traffic arriving on localnet ports has skipped conntrack.
# This test ensures that we still skip conntrack for localnet ports,
# *except* for the case where the logical switch has a load balancer
# configured. In this case, the localnet port will not skip conntrack,
# allowing for traffic to be load balanced on the localnet port.

check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw sw-ln
check ovn-nbctl lsp-set-type sw-ln localnet
check ovn-nbctl lsp-set-addresses sw-ln unknown
check ovn-nbctl --wait=sb sync

# Since this test is only concerned with logical flows, we don't need to
# configure anything else that we normally would with regards to localnet
# ports


# First, ensure that conntrack is skipped for the localnet port since there
# isn't a load balancer configured.

AT_CHECK([ovn-sbctl lflow-list sw | grep ls_in_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_pre_lb       ), priority=110  , match=(ip && inport == "sw-ln"), action=(next;)
])

AT_CHECK([ovn-sbctl lflow-list sw | grep ls_out_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_out_pre_lb      ), priority=110  , match=(ip && outport == "sw-ln"), action=(ct_clear; next;)
])

# Now add a load balancer and ensure that we no longer are skipping conntrack
# for the localnet port

check ovn-nbctl lb-add lb 10.0.0.1:80 10.0.0.100:8080 tcp
check ovn-nbctl ls-lb-add sw lb
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn-sbctl lflow-list sw | grep ls_in_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl
])

AT_CHECK([ovn-sbctl lflow-list sw | grep ls_out_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl
])

# And ensure that removing the load balancer from the switch results in skipping
# conntrack again
check ovn-nbctl ls-lb-del sw lb
check ovn-nbctl --wait=sb sync

AT_CHECK([ovn-sbctl lflow-list sw | grep ls_in_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_in_pre_lb       ), priority=110  , match=(ip && inport == "sw-ln"), action=(next;)
])

AT_CHECK([ovn-sbctl lflow-list sw | grep ls_out_pre_lb | grep priority=110 | grep sw-ln | sed 's/table=../table=??/'], [0], [dnl
  table=??(ls_out_pre_lb      ), priority=110  , match=(ip && outport == "sw-ln"), action=(ct_clear; next;)
])

AT_CLEANUP
])


# This test checks the compute/recompute stats of sync_to_sb_lb engine node
OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([sync_to_sb_lb incremental processing])
ovn_start

check ovn-nbctl ls-add sw
check ovn-nbctl lsp-add sw p1

check ovn-nbctl --wait=sb sync
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats

check ovn-nbctl --wait=sb lsp-set-options p1 foo=bar
sb_lb_recomp=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_lb recompute)
AT_CHECK([test x$sb_lb_recomp = x0])

check ovn-nbctl --wait=sb lsp-set-type p1 external
sb_lb_recomp=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_to_sb_lb recompute)
AT_CHECK([test x$sb_lb_recomp != x0])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([LSP incremental processing])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11

check_recompute_counter() {
    northd_recomp=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd recompute)
    AT_CHECK([test x$northd_recomp = x$1])

    lflow_recomp=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow recompute)
    AT_CHECK([test x$lflow_recomp = x$2])
}

check ovn-nbctl --wait=hv ls-add ls0

# Create a pilot port and wait it up to make sure we are ready for the real
# tests, so that the counters measured are accurate.
check ovn-nbctl --wait=hv lsp-add ls0 lsp-pilot -- lsp-set-addresses lsp-pilot "unknown"
ovs-vsctl add-port br-int lsp-pilot -- set interface lsp-pilot external_ids:iface-id=lsp-pilot
wait_for_ports_up
check ovn-nbctl --wait=hv sync

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=hv lsp-add ls0 lsp0-0 -- lsp-set-addresses lsp0-0 "unknown"
ovs-vsctl add-port br-int lsp0-0 -- set interface lsp0-0 external_ids:iface-id=lsp0-0
wait_for_ports_up
check ovn-nbctl --wait=hv sync
check_recompute_counter 5 5

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=hv lsp-add ls0 lsp0-1 -- lsp-set-addresses lsp0-1 "aa:aa:aa:00:00:01 192.168.0.11"
ovs-vsctl add-port br-int lsp0-1 -- set interface lsp0-1 external_ids:iface-id=lsp0-1
wait_for_ports_up
check ovn-nbctl --wait=hv sync
check_recompute_counter 0 0

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=hv lsp-add ls0 lsp0-2 -- lsp-set-addresses lsp0-2 "aa:aa:aa:00:00:02 192.168.0.12"
ovs-vsctl add-port br-int lsp0-2 -- set interface lsp0-2 external_ids:iface-id=lsp0-2
wait_for_ports_up
check ovn-nbctl --wait=hv sync
check_recompute_counter 0 0

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=hv lsp-del lsp0-1
check_recompute_counter 0 0

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=hv lsp-set-addresses lsp0-2 "aa:aa:aa:00:00:88 192.168.0.88"
check_recompute_counter 0 0

# Delete and re-add a LSP for several times continuously, to ensure
# frequent operations do not trigger recompute when there are in-flight
# transcations.
for i in $(seq 10); do
    # wait for sb but not wait for hv
    check ovn-nbctl --wait=sb lsp-del lsp0-2
    check ovn-nbctl --wait=sb lsp-add ls0 lsp0-2 -- lsp-set-addresses lsp0-2 "aa:aa:aa:00:00:02 192.168.0.12"

    # even without waiting for sb
    check ovn-nbctl lsp-del lsp0-2
    check ovn-nbctl lsp-add ls0 lsp0-2 -- lsp-set-addresses lsp0-2 "aa:aa:aa:00:00:02 192.168.0.12"
done
check_recompute_counter 0 0

# No change, no recompute
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb sync
check_recompute_counter 0 0

CHECK_NO_CHANGE_AFTER_RECOMPUTE

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([LSP incremental processing with only router ports before and after adding a VIF])
ovn_start

check_recompute_counter() {
    northd_recomp=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd recompute)
    AT_CHECK([test x$northd_recomp = x$1])

    lflow_recomp=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow recompute)
    AT_CHECK([test x$lflow_recomp = x$2])
}

check ovn-nbctl ls-add ls0
check ovn-nbctl --wait=sb lr-add lr0
ovn-nbctl lrp-add lr0 lr0-ls0 00:00:00:00:ff:01 192.168.0.1/24
ovn-nbctl lsp-add ls0 ls0-lr0
ovn-nbctl lsp-set-type ls0-lr0 router
ovn-nbctl lsp-set-addresses ls0-lr0 router
check ovn-nbctl --wait=sb lsp-set-options ls0-lr0 router-port=lr0-ls0
CHECK_NO_CHANGE_AFTER_RECOMPUTE

ovn-nbctl lb-add lb0 192.168.0.10:80 10.0.0.10:8080
check ovn-nbctl --wait=sb ls-lb-add ls0 lb0
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
# Add a lsp.  northd and lflow engine shouldn't recompute even though this is
# the first lsp added after the router ports.
check ovn-nbctl --wait=hv lsp-add ls0 lsp0-1 -- lsp-set-addresses lsp0-1 "aa:aa:aa:00:00:01 192.168.0.11"
check_recompute_counter 0 0
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Delete the lsp. northd and lflow engine shouldn't recompute even though
# the logical switch is now left with only router ports.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=hv lsp-del lsp0-1
check_recompute_counter 0 0
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([LSP incremental processing fallback to recompute])
ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.11

check ovn-nbctl --wait=hv ls-add ls0

# Add ports that should be incrementally processed
n=9
for i in $(seq $n); do
    check ovn-nbctl --wait=hv lsp-add ls0 lsp0-$i -- lsp-set-addresses lsp0-$i "aa:aa:aa:00:00:0$i 192.168.0.1$i"
    ovs-vsctl add-port br-int lsp0-$i -- set interface lsp0-$i external_ids:iface-id=lsp0-$i
done

# Add a port that should not be incrementally processed (because of the
# "unknown" that is not supported by i-p for now).
check ovn-nbctl --wait=hv lsp-add ls0 lsp0-foo -- lsp-set-addresses lsp0-foo "unknown"
ovs-vsctl add-port br-int lsp0-foo -- set interface lsp0-foo external_ids:iface-id=lsp0-foo

wait_for_ports_up
check ovn-nbctl --wait=hv sync
wait_row_count port_binding $(($n + 1))

# Delete multiple ports, and one of them not incrementally processible. This is
# to trigger partial I-P and then fall back to recompute.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
args="--wait=hv lsp-del lsp0-foo"
for i in $(seq $n); do
    args="$args -- lsp-del lsp0-$i"
done
check ovn-nbctl $args

wait_row_count Port_Binding 0
northd_recomp=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd recompute)
echo northd_recomp $northd_recomp
AT_CHECK([test $northd_recomp -ge 1])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([ACL/Meter incremental processing - no northd recompute])
ovn_start

check_recompute_counter() {
    northd_recomp=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats northd recompute)
    AT_CHECK([test x$northd_recomp = x$1])

    lflow_recomp=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats lflow recompute)
    AT_CHECK([test x$lflow_recomp = x$2])

    sync_meters_recomp=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats sync_meters recompute)
    AT_CHECK([test x$sync_meters_recomp = x$3])
}

check ovn-nbctl --wait=sb ls-add ls

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb meter-add m drop 1 pktps
check ovn-nbctl --wait=sb acl-add ls from-lport 1 1 allow
dnl Only triggers recompute of the sync_meters and lflow nodes.
check_recompute_counter 0 2 2
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb meter-del m
check ovn-nbctl --wait=sb acl-del ls
dnl Only triggers recompute of the sync_meters and lflow nodes.
check_recompute_counter 0 2 2
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([check fip and lb flows])
AT_KEYWORDS([fip-lb-flows])
ovn_start

check ovn-nbctl lr-add R1
check ovn-nbctl lrp-add R1 R1-S0 02:ac:10:01:00:01 10.0.0.1/24 1000::a/64
check ovn-nbctl lrp-add R1 R1-PUB 02:ac:20:01:01:01 172.16.0.1/24 3000::a/64
check ovn-nbctl lrp-set-gateway-chassis R1-PUB hv1 20

check ovn-nbctl ls-add S0
check ovn-nbctl lsp-add S0 S0-R1
check ovn-nbctl lsp-set-type S0-R1 router
check ovn-nbctl lsp-set-addresses S0-R1 02:ac:10:01:00:01
check ovn-nbctl lsp-set-options S0-R1 router-port=R1-S0
check ovn-nbctl lsp-add S0 S0-P0
check ovn-nbctl lsp-set-addresses S0-P0 "50:54:00:00:00:03 10.0.0.3 1000::3"

check ovn-nbctl lr-nat-add R1 dnat_and_snat 172.16.0.110 10.0.0.3 S0-P0 30:54:00:00:00:03
check ovn-nbctl --wait=sb lr-nat-add R1 dnat_and_snat 3000::c 1000::3 S0-P0 40:54:00:00:00:03

ovn-sbctl dump-flows R1 > R1flows
AT_CAPTURE_FILE([R1flows])

AT_CHECK([grep "lr_in_gw_redirect" R1flows | sed s'/table=../table=??/' |sort], [0], [dnl
  table=??(lr_in_gw_redirect  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_gw_redirect  ), priority=100  , match=(ip4.src == 10.0.0.3 && outport == "R1-PUB" && is_chassis_resident("S0-P0")), action=(eth.src = 30:54:00:00:00:03; reg1 = 172.16.0.110; next;)
  table=??(lr_in_gw_redirect  ), priority=100  , match=(ip6.src == 1000::3 && outport == "R1-PUB" && is_chassis_resident("S0-P0")), action=(eth.src = 40:54:00:00:00:03; xxreg1 = 3000::c; next;)
  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == "R1-PUB"), action=(outport = "cr-R1-PUB"; next;)
])

check ovn-nbctl lb-add lb_tcp4 172.16.0.100:50001 10.0.0.2:50001,10.0.0.3:50001,10.0.0.4:50001 tcp
check ovn-nbctl lb-add lb_tcp6 [[1000::1]]:50001 [[1000::3]]:8080
check ovn-nbctl --wait=sb lr-lb-add R1 lb_tcp4
check ovn-nbctl --wait=sb lr-lb-add R1 lb_tcp6

ovn-sbctl dump-flows R1 > R1flows
AT_CAPTURE_FILE([R1flows])
AT_CHECK([grep "lr_in_gw_redirect" R1flows |sed s'/table=../table=??/' |sort], [0], [dnl
  table=??(lr_in_gw_redirect  ), priority=0    , match=(1), action=(next;)
  table=??(lr_in_gw_redirect  ), priority=100  , match=(ip4.src == 10.0.0.3 && outport == "R1-PUB" && is_chassis_resident("S0-P0")), action=(eth.src = 30:54:00:00:00:03; reg1 = 172.16.0.110; next;)
  table=??(lr_in_gw_redirect  ), priority=100  , match=(ip6.src == 1000::3 && outport == "R1-PUB" && is_chassis_resident("S0-P0")), action=(eth.src = 40:54:00:00:00:03; xxreg1 = 3000::c; next;)
  table=??(lr_in_gw_redirect  ), priority=200  , match=(ip4 && ((ip4.src == 10.0.0.2 && tcp.src == 50001) || (ip4.src == 10.0.0.3 && tcp.src == 50001) || (ip4.src == 10.0.0.4 && tcp.src == 50001)) && outport == "R1-PUB"), action=(outport = "cr-R1-PUB"; next;)
  table=??(lr_in_gw_redirect  ), priority=200  , match=(ip6 && ((ip6.src == 1000::3 && tcp.src == 8080)) && outport == "R1-PUB"), action=(outport = "cr-R1-PUB"; next;)
  table=??(lr_in_gw_redirect  ), priority=50   , match=(outport == "R1-PUB"), action=(outport = "cr-R1-PUB"; next;)
])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Remote port binding])
AT_KEYWORDS([remote-port-binding])
ovn_start

check ovn-sbctl chassis-add remote-ch0 geneve 127.0.0.1
check ovn-sbctl set chassis remote-ch0 other_config:is-remote=true

check ovn-sbctl chassis-add local-ch0 geneve 127.0.0.2
wait_row_count Chassis 2

remote_chassis_uuid=$(fetch_column Chassis _uuid name=remote-ch0)
as northd ovn-appctl -t NORTHD_TYPE vlog/set dbg

check ovn-nbctl ls-add sw0
check ovn-nbctl lsp-add sw0 sw0-r1 -- lsp-set-type sw0-r1 remote
check ovn-nbctl lsp-set-options sw0-r1 requested-chassis=remote-ch0
wait_for_ports_up sw0-r1

# Make sure it is bound by remote-ch0
check_column $remote_chassis_uuid Port_Binding chassis logical_port=sw0-r1

check ovn-nbctl remove logical_switch_port sw0-r1 options requested-chassis
wait_row_count nb:Logical_Switch_Port 1 up=false name=sw0-r1

check_column '' Port_Binding chassis logical_port=sw0-r1

# Set the requested-chassis to local-ch0. ovn-northd should not
# bind it. But before that bind again to remote-ch0.  This becomes
# easier to test for the local-ch0 scenario.
check ovn-nbctl lsp-set-options sw0-r1 requested-chassis=remote-ch0
wait_for_ports_up sw0-r1
check_column $remote_chassis_uuid Port_Binding chassis logical_port=sw0-r1
check ovn-nbctl lsp-set-options sw0-r1 requested-chassis=local-ch0
wait_row_count nb:Logical_Switch_Port 1 up=false name=sw0-r1
check_column '' Port_Binding chassis logical_port=sw0-r1

# Set the requested-chassis to unknown chassis. ovn-northd should not
# bind it. But before that bind again to remote-ch0.  This becomes
# easier to test for the local-ch0 scenario.
check ovn-nbctl lsp-set-options sw0-r1 requested-chassis=remote-ch0
wait_for_ports_up sw0-r1
check_column $remote_chassis_uuid Port_Binding chassis logical_port=sw0-r1
check ovn-nbctl lsp-set-options sw0-r1 requested-chassis=foo
wait_row_count nb:Logical_Switch_Port 1 up=false name=sw0-r1
check_column '' Port_Binding chassis logical_port=sw0-r1

# Change the port type to normal and ovn-northd should not bind it.
check ovn-nbctl lsp-set-options sw0-r1 requested-chassis=remote-ch0
wait_for_ports_up sw0-r1
check_column $remote_chassis_uuid Port_Binding chassis logical_port=sw0-r1
check ovn-nbctl lsp-set-type sw0-r1 ''
wait_row_count nb:Logical_Switch_Port 1 up=false name=sw0-r1
check_column '' Port_Binding chassis logical_port=sw0-r1

# Change back to type to remote and ovn-northd should bind it.
check ovn-nbctl lsp-set-type sw0-r1 remote
wait_for_ports_up sw0-r1
check_column $remote_chassis_uuid Port_Binding chassis logical_port=sw0-r1

# Set the type to router and ovn-northd should not claim it.
check ovn-nbctl lsp-set-type sw0-r1 router
check_column '' Port_Binding chassis logical_port=sw0-r1

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD_NO_HV([
AT_SETUP([Load balancer incremental processing])
ovn_start

check_engine_stats() {
  node=$1
  recompute=$2
  compute=$3

  echo "__file__:__line__: Checking engine stats for node $node : recompute - \
$recompute : compute - $compute"

  node_stat=$(as northd ovn-appctl -t NORTHD_TYPE inc-engine/show-stats $node)
  # node_stat will be of this format :
  #     - Node: lflow - recompute: 3 - compute: 0 - abort: 0
  node_recompute_ct=$(echo $node_stat | cut -d '-' -f2 | cut -d ':' -f2)
  node_compute_ct=$(echo $node_stat | cut -d '-' -f3 | cut -d ':' -f2)

  if [[ "$recompute" == "norecompute" ]]; then
    # node should not be recomputed
    echo "Expecting $node recompute count - $node_recompute_ct to be 0"
    check test "$node_recompute_ct" -eq "0"
  else
    echo "Expecting $node recompute count - $node_recompute_ct not to be 0"
    check test "$node_recompute_ct" -ne "0"
  fi

  if [[ "$compute" == "nocompute" ]]; then
    # node should not be computed
    echo "Expecting $node compute count - $node_compute_ct to be 0"
    check test "$node_compute_ct" -eq "0"
  else
    echo "Expecting $node compute count - $node_compute_ct not to be 0"
    check test "$node_compute_ct" -ne "0"
  fi
}

# Test I-P for load balancers.
# Presently ovn-northd handles I-P for NB LBs in northd_lb_data engine node
# only.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-add lb1 10.0.0.10:80 10.0.0.3:80

check_engine_stats lb_data norecompute compute
check_engine_stats northd norecompute compute
check_engine_stats lflow recompute nocompute

CHECK_NO_CHANGE_AFTER_RECOMPUTE
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats

check ovn-nbctl --wait=sb set load_balancer . ip_port_mappings:10.0.0.3=sw0-p1:10.0.0.2
check_engine_stats lb_data norecompute compute
check_engine_stats northd norecompute compute
check_engine_stats lflow recompute nocompute

check ovn-nbctl --wait=sb set load_balancer . options:foo=bar
check_engine_stats lb_data norecompute compute
check_engine_stats northd norecompute compute
check_engine_stats lflow recompute nocompute

check ovn-nbctl --wait=sb -- lb-add lb2 20.0.0.10:80 20.0.0.20:80 -- lb-add lb3 30.0.0.10:80 30.0.0.20:80
check_engine_stats lb_data norecompute compute
check_engine_stats northd norecompute compute
check_engine_stats lflow recompute nocompute

CHECK_NO_CHANGE_AFTER_RECOMPUTE
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats

check ovn-nbctl --wait=sb -- lb-del lb2 -- lb-del lb3
check_engine_stats lb_data norecompute compute
check_engine_stats northd norecompute compute
check_engine_stats lflow recompute nocompute

CHECK_NO_CHANGE_AFTER_RECOMPUTE
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats

AT_CHECK([ovn-nbctl --wait=sb \
          -- --id=@hc create Load_Balancer_Health_Check vip="10.0.0.10\:80" \
             options:failure_count=100 \
          -- add Load_Balancer . health_check @hc | uuidfilt], [0], [<0>
])
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

# Any change to load balancer health check should also result in full recompute
# of northd node (but not northd_lb_data node)
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb set load_balancer_health_check . options:foo=bar1
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

# Delete the health check from the load balancer.  northd engine node should do a full recompute.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb clear Load_Balancer . health_check
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl ls-add sw0
check ovn-nbctl --wait=sb lr-add lr0
ovn-nbctl lrp-add lr0 lr0-sw0 00:00:00:00:ff:01 10.0.0.1/24
ovn-nbctl lsp-add sw0 sw0-lr0
ovn-nbctl lsp-set-type sw0-lr0 router
ovn-nbctl lsp-set-addresses sw0-lr0 00:00:00:00:ff:01
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
ovn-nbctl --wait=sb lsp-set-options sw0-lr0 router-port=lr0-sw0
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

# Associate lb1 to sw0. There should be a full recompute of northd engine node
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb ls-lb-add sw0 lb1
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

# Modify the backend of the lb1 vip
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb set load_balancer lb1 vips:'"10.0.0.10:80"'='"10.0.0.100:80"'
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Cleanup the vip of lb1.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb clear load_Balancer lb1 vips
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Set the vips of lb1 back
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-add lb1 10.0.0.10:80 10.0.0.3:80
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Add another vip to lb1
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-add lb1 10.0.0.20:80 10.0.0.30:8080
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Disassociate lb1 from sw0. There should be a full recompute of northd engine node.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb ls-lb-del sw0 lb1
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Add lb1 to lr0 and then disassociate
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lr-lb-add lr0 lb1
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Modify the backend of the lb1 vip
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb set load_balancer lb1 vips:'"10.0.0.10:80"'='"10.0.0.100:80"'
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Cleanup the vip of lb1.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb clear load_Balancer lb1 vips
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Set the vips of lb1 back
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-add lb1 10.0.0.10:80 10.0.0.3:80
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Add another vip to lb1
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-add lb1 10.0.0.20:80 10.0.0.30:8080
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lr-lb-del lr0 lb1
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Test load balancer group now
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
lbg1_uuid=$(ovn-nbctl create load_balancer_group name=lbg1)
check_engine_stats lb_data norecompute compute
check_engine_stats northd norecompute compute
check_engine_stats lflow recompute nocompute

CHECK_NO_CHANGE_AFTER_RECOMPUTE
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats

lb1_uuid=$(fetch_column nb:Load_Balancer _uuid)

# Add lb to the lbg1 group
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl add load_balancer_group . load_Balancer $lb1_uuid
check_engine_stats lb_data norecompute compute
check_engine_stats northd norecompute compute
check_engine_stats lflow recompute nocompute

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl clear load_balancer_group . load_Balancer
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

# Add back lb to the lbg1 group
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl add load_balancer_group . load_Balancer $lb1_uuid
check_engine_stats lb_data norecompute compute
check_engine_stats northd norecompute compute
check_engine_stats lflow recompute nocompute

CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl add logical_switch sw0 load_balancer_group $lbg1_uuid
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

# Update lb and this should result in recompute
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb set load_balancer . options:bar=foo
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

# Modify the backend of the lb1 vip
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb set load_balancer lb1 vips:'"10.0.0.10:80"'='"10.0.0.100:80"'
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Cleanup the vip of lb1.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb clear load_Balancer lb1 vips
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Set the vips of lb1 back
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-add lb1 10.0.0.10:80 10.0.0.3:80
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Add another vip to lb1
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-add lb1 10.0.0.20:80 10.0.0.30:8080
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl clear logical_switch sw0 load_balancer_group
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl add logical_router lr0 load_balancer_group $lbg1_uuid
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Modify the backend of the lb1 vip
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb set load_balancer lb1 vips:'"10.0.0.10:80"'='"10.0.0.100:80"'
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Cleanup the vip of lb1.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb clear load_Balancer lb1 vips
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Set the vips of lb1 back
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-add lb1 10.0.0.10:80 10.0.0.3:80
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Add another vip to lb1
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-add lb1 10.0.0.20:80 10.0.0.30:8080
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl clear logical_router lr0 load_balancer_group
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

# Add back lb group to logical switch and then delete it.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl add logical_switch sw0 load_balancer_group $lbg1_uuid
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl clear logical_switch sw0 load_balancer_group -- \
    destroy load_balancer_group $lbg1_uuid
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute

CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Test the scenario where a load balancer is associated to
# a logical switch sw0 and also to a lb group lbg1 and lbg1
# is also associated to the logical switch sw0 and logical
# router lr1

check ovn-nbctl lr-add lr1
check ovn-nbctl lb-add lb2 20.0.0.20:80 30.0.0.30:8080
check ovn-nbctl lb-add lb3 30.0.0.20:80 30.0.0.30:8080
check ovn-nbctl --wait=sb lb-add lb4 40.0.0.20:80 30.0.0.30:8080

lb2_uuid=$(fetch_column nb:Load_Balancer _uuid name=lb2)
lb3_uuid=$(fetch_column nb:Load_Balancer _uuid name=lb3)
lb4_uuid=$(fetch_column nb:Load_Balancer _uuid name=lb4)

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
lbg1_uuid=$(ovn-nbctl create load_balancer_group name=lbg1)
check_engine_stats lb_data norecompute compute
check_engine_stats northd norecompute compute
check_engine_stats lflow recompute nocompute

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl set load_balancer_group . load_balancer="$lb2_uuid,$lb3_uuid,$lb4_uuid"
check_engine_stats lb_data norecompute compute
check_engine_stats northd norecompute compute
check_engine_stats lflow recompute nocompute

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl set logical_switch sw0 load_balancer_group=$lbg1_uuid
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl set logical_router lr1 load_balancer_group=$lbg1_uuid
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb ls-lb-add sw0 lb2
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb ls-lb-add sw0 lb3
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lr-lb-add lr1 lb1
check ovn-nbctl --wait=sb lr-lb-add lr1 lb2
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb ls-lb-del sw0 lb2
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lr-lb-del lr1 lb2
check_engine_stats lb_data norecompute nocompute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Deleting lb4 should not result in lflow recompute as it is
# only associated with logical switch sw0.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-del lb4
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

# Deleting lb2 should result in lflow recompute as it is
# associated with logical router lr1 through lb group.
check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb lb-del lb2
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

check as northd ovn-appctl -t NORTHD_TYPE inc-engine/clear-stats
check ovn-nbctl --wait=sb remove load_balancer_group . load_balancer $lb3_uuid
check_engine_stats lb_data norecompute compute
check_engine_stats northd recompute nocompute
check_engine_stats lflow recompute nocompute
CHECK_NO_CHANGE_AFTER_RECOMPUTE

AT_CLEANUP
])
