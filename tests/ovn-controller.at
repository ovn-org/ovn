AT_BANNER([ovn-controller])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - ovn-bridge-mappings])
AT_KEYWORDS([ovn])
ovn_start
net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

# Waits until the OVS database contains exactly the specified patch ports.
# Each argument should be of the form BRIDGE PORT PEER.
check_patches () {
    # Generate code to check that the set of patch ports is exactly as
    # specified.
    echo 'ovs-vsctl -f csv -d bare --no-headings --columns=name find Interface type=patch | sort' > query
    for patch
    do
        echo $patch
    done | cut -d' ' -f 2 | sort > expout

    # Generate code to verify that the configuration of each patch
    # port is correct.
    for patch
    do
        set $patch; bridge=$1 port=$2 peer=$3
        echo >>query "ovs-vsctl iface-to-br $port -- get Interface $port type options"
        echo >>expout "$bridge
patch
{peer=$peer}"
    done

    # Run the query until we get the expected result (or until a timeout).
    #
    # (We use sed to drop all "s from output because ovs-vsctl quotes some
    # of the port names but not others.)
    AT_CAPTURE_FILE([query])
    AT_CAPTURE_FILE([expout])
    AT_CAPTURE_FILE([stdout])
    OVS_WAIT_UNTIL([. ./query | sed 's/"//g' > stdout #"
                    diff -u stdout expout >/dev/null])
}

# Make sure that the configured bridge mappings in the Open_vSwitch db
# is mirrored into the Chassis record in the OVN_Southbound db.
check_bridge_mappings () {
    local_mappings=$1
    sysid=$(ovs-vsctl get Open_vSwitch . external_ids:system-id)
    OVS_WAIT_UNTIL([test x"${local_mappings}" = x$(ovn-sbctl get Chassis ${sysid} other_config:ovn-bridge-mappings | sed -e 's/\"//g')])
}

# NOTE: This test originally ran with only the SB-DB and no northd. For the
# test to be successfull with SSL+RBAC we need to initially run northd to get
# the RBAC rules programmed into the SB-DB. The test instruments the SB-DB
# directly and we need to stop northd to avoid overwriting the instrumentation.
kill `cat northd/ovn-northd.pid`
kill `cat ovn-nb/ovsdb-server.pid`

# Initially there should be no patch ports.
check_patches

# Configure two ovn-bridge mappings, but no patch ports should be created yet
AT_CHECK([ovs-vsctl set Open_vSwitch . external-ids:ovn-bridge-mappings=physnet1:br-eth0,physnet2:br-eth1])
check_bridge_mappings "physnet1:br-eth0,physnet2:br-eth1"
check_patches

# Create a localnet port, but we should still have no patch ports, as they
# won't be created until there's a localnet port on a logical switch with
# another logical port bound to this chassis.
ovn-sbctl \
    -- --id=@dp101 create Datapath_Binding tunnel_key=101 \
    -- create Port_Binding datapath=@dp101 logical_port=localnet1 tunnel_key=1 \
        type=localnet options:network_name=physnet1
check_patches

# Create a localnet port on a logical switch with a port bound to this chassis.
# Now we should get some patch ports created.
ovn-sbctl \
    -- --id=@dp102 create Datapath_Binding tunnel_key=102 \
    -- create Port_Binding datapath=@dp102 logical_port=localnet2 tunnel_key=1 \
        type=localnet options:network_name=physnet1 \
    -- create Port_Binding datapath=@dp102 logical_port=localvif2 tunnel_key=2
ovs-vsctl add-port br-int localvif2 -- set Interface localvif2 external_ids:iface-id=localvif2
check_patches \
    'br-int  patch-br-int-to-localnet2 patch-localnet2-to-br-int' \
    'br-eth0 patch-localnet2-to-br-int patch-br-int-to-localnet2'

# Add logical patch ports to connect new logical datapath.
#
# OVN no longer uses OVS patch ports to implement logical patch ports, so
# the set of OVS patch ports doesn't change.
AT_CHECK([ovn-sbctl \
    -- --id=@dp1 create Datapath_Binding tunnel_key=1 \
    -- --id=@dp2 create Datapath_Binding tunnel_key=2 \
    -- create Port_Binding datapath=@dp1 logical_port=foo tunnel_key=1 type=patch options:peer=bar \
    -- create Port_Binding datapath=@dp2 logical_port=bar tunnel_key=2 type=patch options:peer=foo \
    -- create Port_Binding datapath=@dp1 logical_port=dp1vif tunnel_key=3 \
| uuidfilt], [0], [<0>
<1>
<2>
<3>
<4>
])
ovs-vsctl add-port br-int dp1vif -- set Interface dp1vif external_ids:iface-id=dp1vif
check_patches \
    'br-int  patch-br-int-to-localnet2 patch-localnet2-to-br-int' \
    'br-eth0 patch-localnet2-to-br-int patch-br-int-to-localnet2'

# Delete the mapping and the ovn-bridge-mapping patch ports should go away.
check ovn-appctl -t ovn-controller debug/ignore-startup-delay
AT_CHECK([ovs-vsctl remove Open_vSwitch . external-ids ovn-bridge-mappings])
check_bridge_mappings
check_patches

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

# Checks that ovn-controller populates datapath-type and iface-types
# correctly in the Chassis other_config column.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - Chassis other_config])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

sysid=$(ovs-vsctl get Open_vSwitch . external_ids:system-id)

# Make sure that the datapath_type set in the Bridge table
# is mirrored into the Chassis record in the OVN_Southbound db.
check_datapath_type () {
    datapath_type=$1
    chassis_datapath_type=$(ovn-sbctl get Chassis ${sysid} other_config:datapath-type | sed -e 's/"//g') #"
    ovs_datapath_type=$(ovs-vsctl get Bridge br-int datapath-type)
    test "${datapath_type}" = "${chassis_datapath_type}" && test "${datapath_type}" = "${ovs_datapath_type}"
}

OVS_WAIT_UNTIL([check_datapath_type system])

ovs-vsctl set Bridge br-int datapath-type=foo
OVS_WAIT_UNTIL([check_datapath_type foo])

# Change "ovn-bridge-mappings" value. It should not change the "datapath-type".
ovs-vsctl set Open_vSwitch . external_ids:ovn-bridge-mappings=foo-mapping
AT_CHECK([check_datapath_type foo])

ovs-vsctl set Bridge br-int datapath-type=bar
OVS_WAIT_UNTIL([check_datapath_type bar])

ovs-vsctl set Bridge br-int datapath-type=\"\"
OVS_WAIT_UNTIL([check_datapath_type system])

# Set the datapath_type in external_ids:ovn-bridge-datapath-type.
ovs-vsctl set Open_vSwitch . external_ids:ovn-bridge-datapath-type=foo
OVS_WAIT_UNTIL([check_datapath_type foo])

# Change the br-int's datapath type to bar.
# It should be reset to foo since ovn-bridge-datapath-type is configured.
ovs-vsctl set Bridge br-int datapath-type=bar
OVS_WAIT_UNTIL([check_datapath_type foo])

ovs-vsctl set Open_vSwitch . external_ids:ovn-bridge-datapath-type=foobar
OVS_WAIT_UNTIL([check_datapath_type foobar])

expected_iface_types=$(ovs-vsctl get Open_vSwitch . iface_types | tr -d '[[]] ""')
echo "expected_iface_types = ${expected_iface_types}"
chassis_iface_types=$(ovn-sbctl get Chassis ${sysid} other_config:iface-types | sed -e 's/\"//g')
echo "chassis_iface_types = ${chassis_iface_types}"
AT_CHECK([test "${expected_iface_types}" = "${chassis_iface_types}"])

# Change the value of other_config:iface-types using ovn-sbctl.
# ovn-controller should again set it back to proper one.
ovn-sbctl set Chassis ${sysid} other_config:iface-types="foo"
OVS_WAIT_UNTIL([
    chassis_iface_types=$(ovn-sbctl get Chassis ${sysid} other_config:iface-types | sed -e 's/\"//g')
    echo "chassis_iface_types = ${chassis_iface_types}"
    test "${expected_iface_types}" = "${chassis_iface_types}"
])

# Change the value of external_ids:system-id.
# This requires operator intervention and removal of the stale chassis and
# chassis_private records.  Until that happens ovn-controller fails to
# create the records due to constraint violation on the Encap table.
sysid=${sysid}-foo
current_remote=`ovs-vsctl get Open_vSwitch . external-ids:ovn-remote`
if test X$HAVE_OPENSSL = Xyes; then
    # To change chassis name we need to change certificate with matching CN
    ovs-vsctl set-ssl \
        $PKIDIR/testpki-${sysid}-privkey.pem \
        $PKIDIR/testpki-${sysid}-cert.pem \
        $PKIDIR/testpki-cacert.pem
    # force reconnect which makes OVN controller read the new certificates
    # TODO implement check for change of certificates in ovn-controller
    # and remove this workaround.
    ovs-vsctl set Open_vSwitch . external-ids:ovn-remote=unix:/dev/null
    # Make sure that the ovn-remote change is handled by ovn-controller.
    # Without this, ovn-controller could handle both this change and next ovn-remote change within the same loop,
    # resulting in no change.
    # Use 2 ovn-appctl to guarentee that ovn-controller run the full loop, and not just the unixctl handling
    OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) = "xrunning"])
    OVS_WAIT_UNTIL([test x$(ovn-appctl -t ovn-controller debug/status) = "xrunning"])

fi
ovs-vsctl -- set Open_vSwitch . external-ids:hostname="${sysid}" \
          -- set Open_vSwitch . external-ids:system-id="${sysid}" \
          -- set Open_vSwitch . external-ids:ovn-remote="${current_remote}"

OVS_WAIT_UNTIL([
    grep -q 'Transaction causes multiple rows in \\"Encap\\" table to have identical values' hv/ovn-controller.log
])

# Destroy the stale entries manually and ovn-controller should now be able
# to create new ones.
check ovn-sbctl destroy chassis_private . -- destroy chassis .

wait_row_count Chassis_Private 1 name=${sysid}
wait_row_count Chassis 1 name=${sysid}

# Only one Chassis_Private/Chassis record should exist.
wait_row_count Chassis_Private 1
wait_row_count Chassis 1

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

# Checks that ovn-controller correctly maintains the mapping from the Encap
# table in the Southbound database to OVS in the face of changes on both sides
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - change Encap properties])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

check_tunnel_property () {
    test "`ovs-vsctl get interface ovn-fakech-0 $1`" = "$2"
}

# create "empty" chassis. vxlan is used here as a stub
ovn-sbctl chassis-add fakechassis vxlan 192.168.0.2

# See if we switch to Geneve as the first choice when it is available
# With multi-VTEP support we support tunnels with different IPs to the
# same chassis, and hence use the IP to annotate the tunnel (along with
# the chassis-id in ovn-chassis-id); if we supply a different IP here
# we won't be able to co-relate this to the tunnel port that was created
# in the previous step and, as a result, will end up creating another tunnel,
# ie. we can't just lookup using "ovn-fakech-0". So, need to use the same IP
# as above, i.e 192.168.0.2, here.
encap_uuid=$(ovn-sbctl add chassis fakechassis encaps @encap -- --id=@encap create encap type=geneve ip="192.168.0.2")
OVS_WAIT_UNTIL([check_tunnel_property type geneve])

# change geneve to stt and check that tun interface was deleted and there is
# no stt encap on the second chassis, only vxlan
ovn-sbctl set encap ${encap_uuid} type=stt
OVS_WAIT_WHILE([check_tunnel_property type stt])
OVS_WAIT_UNTIL([check_tunnel_property type vxlan])

# change back to geneve
ovn-sbctl set encap ${encap_uuid} type=geneve

# Check that changes within an encap row are propagated
ovn-sbctl set encap ${encap_uuid} ip=192.168.0.2
OVS_WAIT_UNTIL([check_tunnel_property options:remote_ip "\"192.168.0.2\""])

# Change the type on the OVS side and check than OVN fixes it
ovs-vsctl set interface ovn-fakech-0 type=vxlan
OVS_WAIT_UNTIL([check_tunnel_property type geneve])

# Delete the port entirely and it should be resurrected
ovs-vsctl del-port ovn-fakech-0
OVS_WAIT_UNTIL([check_tunnel_property type geneve])

# set `ovn-set-local-ip` option to true and check if tunnel parameters
OVS_WAIT_WHILE([check_tunnel_property options:local_ip "\"192.168.0.1\""])
ovs-vsctl set open . external_ids:ovn-set-local-ip=true
OVS_WAIT_UNTIL([check_tunnel_property options:local_ip "\"192.168.0.1\""])

# Change the local_ip on the OVS side and check than OVN fixes it
ovs-vsctl set interface ovn-fakech-0 options:local_ip="1.1.1.1"
OVS_WAIT_UNTIL([check_tunnel_property options:local_ip "\"192.168.0.1\""])

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

# Check ovn-controller connection status to Southbound database
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - check sbdb connection])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

check_sbdb_connection () {
    test "$(ovs-appctl -t ovn-controller connection-status)" = "$1"
}

OVS_WAIT_UNTIL([check_sbdb_connection connected])

ovs-vsctl set open . external_ids:ovn-remote=tcp:192.168.0.10:6642
OVS_WAIT_UNTIL([check_sbdb_connection 'not connected'])

# reset the remote for clean-up
ovs-vsctl set open . external_ids:ovn-remote=unix:$ovs_base/ovn-sb/ovn-sb.sock
# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

# Checks that ovn-controller recreates its chassis record when deleted externally.
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - Chassis self record])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])
# Delete the chassis "hv"
ovn-sbctl chassis-del hv
# ovn-controller should recreate its chassis row.
OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP

# Checks that ovn-controller increments the nb_cfg value in the Chassis_Private table
AT_SETUP([ovn-controller - Bump Chassis_Private nb_cfg value])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])

# Bump the NB_Global nb_cfg value
nb_global_id=$(ovn-nbctl --columns _uuid --bare find nb_global)
ovn-nbctl set NB_Global ${nb_global_id} nb_cfg=999

# ovn-controller should bump the nb_cfg in the chassis_private table
OVS_WAIT_UNTIL([test x999 = x`ovn-sbctl --columns nb_cfg --bare find chassis_private`])

# Assert that the the nb_cfg from the Chassis table was not incremented
OVS_WAIT_UNTIL([test x0 = x`ovn-sbctl --columns nb_cfg --bare find chassis`])

OVN_CLEANUP([hv])
AT_CLEANUP
])

# check that nb_cfg overflow cases handled properly
AT_SETUP([ovn-controller - overflow the nb_cfg value across the tables])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl --wait=hv sync

# overflow the NB_Global nb_cfg value
check ovn-nbctl set NB_Global . nb_cfg=9223372036854775806

# nb_cfg must be set to zero if it exceed the value of LLONG_MAX
# the command below will try incress the value of nb_cfg to be greater than LLONG_MAX and
# expect zero as a return value
check ovn-nbctl --wait=hv sync
check ovn-nbctl --wait=hv sync

# nb_cfg should be set to 1 in the chassis_private/nb_global/sb_global table
check_column 1 chassis_private nb_cfg
check_column 1 sb_global nb_cfg
check_column 1 nb:nb_global nb_cfg
check_column 0 chassis nb_cfg

OVN_CLEANUP([hv])
AT_CLEANUP

# Test unix command: debug/delay-nb-cfg-report
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - debug/delay-nb-cfg-report])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

OVS_WAIT_UNTIL([test xhv = x`ovn-sbctl --columns name --bare find chassis`])

AT_CHECK([ovn-appctl -t ovn-controller debug/delay-nb-cfg-report 2], [0],
         [delay nb_cfg report for 2 seconds.
])

AT_FAIL_IF([ovn-nbctl --timeout=1 --wait=hv sync])

# sleep another 1 sec so that the original 2 sec sleep is done in ovn-controller
sleep 1

AT_CHECK([ovn-nbctl --timeout=3 --wait=hv sync])

AT_CHECK([ovn-appctl -t ovn-controller debug/delay-nb-cfg-report 0], [0],
         [no delay for nb_cfg report.
])

AT_CHECK([ovn-nbctl --timeout=1 --wait=hv sync])

OVN_CLEANUP([hv])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([nb_cfg sync to OVS])
ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Wait for ovn-controller to register in the SB.
wait_row_count Chassis 1

# Increment nb_cfg.
check ovn-nbctl --wait=hv sync

# And check that it gets propagated to br-int external_ids.
as hv1
OVS_WAIT_FOR_OUTPUT([ovs-vsctl get Bridge br-int external_ids:ovn-nb-cfg], [0], ["1"
])

nb_cfg_ts=$(fetch_column Chassis_Private nb_cfg_timestamp name=hv1)
as hv1
AT_CHECK_UNQUOTED([ovs-vsctl get Bridge br-int external_ids:ovn-nb-cfg-ts], [0], [dnl
"${nb_cfg_ts}"
])

# This might fail in some corner cases (e.g., timestamp overflows, time moving
# backwards) but those should be very rare.
startup_ts=$(as hv1 ovs-vsctl get Bridge br-int external_ids:ovn-startup-ts | xargs)
AT_CHECK([test "${nb_cfg_ts}" -ge "${startup_ts}"])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([features])
AT_KEYWORDS([features])
ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

# Wait for ovn-controller to register in the SB.
OVS_WAIT_UNTIL([
    test "$(ovn-sbctl get chassis hv1 other_config:port-up-notif)" = '"true"'
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# Test that changes of a port binding from one type to another doesn'that
# result in any ovn-controller asserts or crashes.
AT_SETUP([ovn-controller - port binding type change handling])
AT_KEYWORDS([ovn])
AT_KEYWORDS([slowtest])
ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl ls-add ls1 -- lsp-add ls1 lsp1

as hv1
check ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1

# ovn-controller should bind the interface.
wait_for_ports_up
hv_uuid=$(fetch_column Chassis _uuid name=hv1)
check_column "$hv_uuid" Port_Binding chassis logical_port=lsp1

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[1]]
primary lport : [[lsp1]]
----------------------------------------
])

# Set the port type to localport
check ovn-nbctl --wait=hv lsp-set-type lsp1 localport
check as hv1 ovs-vsctl set open . external_ids:ovn-cms-options=localport
OVS_WAIT_UNTIL([test localport = $(ovn-sbctl get chassis . other_config:ovn-cms-options)])

AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[1]]
localport lport : [[lsp1]]
----------------------------------------
])

# pause ovn-northd
check as northd ovn-appctl -t ovn-northd pause

as northd ovn-appctl -t ovn-northd status

pb_types=(patch chassisredirect l3gateway localnet localport l2gateway
          virtual external remote vtep)
for type in ${pb_types[[@]]}
do
    for update_type in ${pb_types[[@]]}
    do
        check ovn-sbctl set port_binding lsp1 type=$type
        check as hv1 ovs-vsctl set open . external_ids:ovn-cms-options=$type
        OVS_WAIT_UNTIL([test $type = $(ovn-sbctl get chassis . other_config:ovn-cms-options)])

        if [[ "$type" == "localport" ]]; then
            AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[1]]
localport lport : [[lsp1]]
----------------------------------------
])
        else
            AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[0]]
----------------------------------------
])
        fi

        echo "Updating to $update_type from $type"
        check ovn-sbctl set port_binding lsp1 type=$update_type
        check as hv1 ovs-vsctl set open . external_ids:ovn-cms-options=$update_type
        OVS_WAIT_UNTIL([test $update_type = $(ovn-sbctl get chassis . other_config:ovn-cms-options)])

        if [[ "$update_type" == "localport" ]]; then
            AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[1]]
localport lport : [[lsp1]]
----------------------------------------
])
        else
            AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[0]]
----------------------------------------
])
        fi

        # Set the port binding type back to VIF.
        check ovn-sbctl set port_binding lsp1 type=\"\"
        check as hv1 ovs-vsctl set open . external_ids:ovn-cms-options=foo
        OVS_WAIT_UNTIL([test foo = $(ovn-sbctl get chassis . other_config:ovn-cms-options)])

        AT_CHECK([as hv1 ovn-appctl -t ovn-controller debug/dump-local-bindings], [0], [dnl
Local bindings:
name: [[lsp1]], OVS interface name : [[vif1]], num binding lports : [[1]]
primary lport : [[lsp1]]
----------------------------------------
])
    done
done

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - ssl files change when using command line options])
AT_KEYWORDS([ovn])
AT_SKIP_IF([test "$HAVE_OPENSSL" = no])
PKIDIR="$(cd $abs_top_builddir/tests && pwd)"
AT_SKIP_IF([expr "$PKIDIR" : ".*[[ 	'\"
\\]]"])
ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

key=testpki-hv1-privkey.pem
cert=testpki-hv1-cert.pem
cacert=testpki-cacert.pem

key2=testpki-hv2-privkey.pem
cert3=testpki-hv3-cert.pem

# Use mismatched key and cert when restarting ovn-controller
cp $PKIDIR/$key2 $key
cp $PKIDIR/$cert3 $cert
cp $PKIDIR/$cacert $cacert

# Restart ovn-controller using command line options for SSL parameters
OVS_APP_EXIT_AND_WAIT([ovn-controller])
check ovs-vsctl del-ssl
start_daemon ovn-controller -p $key -c $cert -C $cacert

# SSL should not connect because of key and cert mismatch
OVS_WAIT_FOR_OUTPUT([ovn-appctl -t ovn-controller connection-status], [0], [not connected
])

# Modify the files with the correct key and cert, and reconnect should succeed
cp $PKIDIR/$key $key
cp $PKIDIR/$cert $cert

OVS_WAIT_FOR_OUTPUT([ovn-appctl -t ovn-controller connection-status], [0], [connected
])

# Remove the files and expect the connection to drop
rm $key $cert
OVS_WAIT_FOR_OUTPUT([ovn-appctl -t ovn-controller connection-status], [0], [not connected
])

# Restore the files again and expect the connection to recover
cp $PKIDIR/$key $key
cp $PKIDIR/$cert $cert
OVS_WAIT_FOR_OUTPUT([ovn-appctl -t ovn-controller connection-status], [0], [connected
])

cat hv1/ovn-controller.log

OVN_CLEANUP([hv1])
AT_CLEANUP

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - ovn action metering])
AT_KEYWORDS([action-metering])

ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl lr-add lr1 \
    -- lrp-add lr1 rp-ls1 00:00:01:01:02:03 192.168.1.254/24
check ovn-nbctl ls-add ls1 \
    -- lsp-add ls1 lsp1 \
    -- lsp-set-addresses lsp1 "00:00:00:00:00:01 192.168.1.1" \
    -- lsp-add ls1 ls1-rp \
    -- set Logical_Switch_Port ls1-rp type=router options:router-port=rp-ls1 \
    -- lsp-set-addresses ls1-rp router

as hv1
check ovs-vsctl \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1

check ovn-nbctl --event lb-add lb1 192.168.1.100:80 ""
check ovn-nbctl ls-lb-add ls1 lb1

# controller-event metering
check ovn-nbctl meter-add event-elb drop 100 pktps 10
check ovn-nbctl --wait=hv copp-add copp0 event-elb event-elb
check ovn-nbctl --wait=hv ls-copp-add copp0 ls1

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep controller | grep userdata=00.00.00.0f | grep -q meter_id=1])

check ovn-nbctl copp-del copp0
AT_CHECK([ovn-nbctl copp-list copp0], [0], [dnl
])
check ovn-nbctl meter-del event-elb

# reject metering
check ovn-nbctl meter-add acl-meter drop 1 pktps 0
check ovn-nbctl --wait=hv copp-add copp1 reject acl-meter
check ovn-nbctl ls-copp-add copp1 ls1
check ovn-nbctl --wait=hv acl-add ls1 from-lport 1002 'inport == "lsp1" && ip && udp' reject

AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep controller | grep userdata=00.00.00.16 | grep -q meter_id=1])

# arp metering
check ovn-nbctl meter-add arp-meter drop 200 pktps 0
check ovn-nbctl --wait=hv copp-add copp2 arp-resolve arp-meter
check ovn-nbctl --wait=hv lr-copp-add copp2 lr1
AT_CHECK([as hv1 ovs-ofctl dump-flows br-int | grep controller | grep userdata=00.00.00.00 | grep -q meter_id=2])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

# Checks that ovn-controller honors the change to tunnel interface if we
# set ovn-encap-tos option
OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - change Encap ToS option])
AT_KEYWORDS([ovn])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

check_tunnel_property () {
    test "`ovs-vsctl get interface ovn-fakech-0 $1`" = "$2"
}

# without any tos options
no_tos_options="{csum=\"true\", key=flow, remote_ip=\"192.168.0.2\"}"

#
# Start off with a remote chassis supporting geneve
ovn-sbctl chassis-add fakechassis geneve 192.168.0.2
OVS_WAIT_UNTIL([check_tunnel_property type geneve])

tos_option=$(ovs-vsctl get interface ovn-fakech-0 options)
AT_CHECK([test "$tos_option" = "$no_tos_options"], [0], [])

expected_tos_option="inherit"
as hv
ovs-vsctl \
    -- set Open_vSwitch . external-ids:ovn-encap-tos="$expected_tos_option"

# now, wait for a sec
sleep 1

tos_option=$(ovs-vsctl get interface ovn-fakech-0 options:tos)
AT_CHECK([test "$tos_option" = "$expected_tos_option"], [0], [])

# Try another value
expected_tos_option="61"
as hv
ovs-vsctl \
    -- set Open_vSwitch . external-ids:ovn-encap-tos="$expected_tos_option"

# now, wait for a sec
sleep 1

tos_option=$(ovs-vsctl get interface ovn-fakech-0 options:tos)
AT_CHECK([test "$tos_option" = "\"$expected_tos_option\""], [0], [])

# Remove tos option and check if we are back to the original state
as hv
ovs-vsctl \
    -- remove Open_vSwitch . external-ids column ovn-encap-tos

# now, wait for a sec
sleep 1

tos_option=$(ovs-vsctl get interface ovn-fakech-0 options)
AT_CHECK([test "$tos_option" = "$no_tos_options"], [0], [])

# Gracefully terminate daemons
OVN_CLEANUP_SBOX([hv])
OVN_CLEANUP_VSWITCH([main])
as ovn-sb
OVS_APP_EXIT_AND_WAIT([ovsdb-server])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - ovn IP check path ports])
AT_KEYWORDS([ovn-ip-patch-ports])

ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

check ovn-nbctl lr-add lr0 \
    -- lrp-add lr0 rp-ls0 00:00:01:01:02:02 192.168.0.254/24 \
    -- ls-add ls0 \
    -- lsp-add ls0 ls0-rp \
    -- lsp-set-type ls0-rp router \
    -- lsp-set-addresses ls0-rp router \
    -- lsp-set-options ls0-rp router-port=rp-ls0 \
    -- lsp-add ls0 lsp0 \
    -- lsp-set-addresses lsp0 "00:11:00:00:00:01 192.168.0.1" \
    -- ls-add ls1 \
    -- lsp-add ls1 ls1-rp \
    -- lsp-set-type ls1-rp router \
    -- lsp-set-addresses ls1-rp router \
    -- lsp-set-options ls1-rp router-port=rp-ls1 \
    -- lsp-add ls1 lsp1 \
    -- lsp-set-addresses lsp1 "00:00:00:00:00:01 192.168.1.1"

as hv1
check ovs-vsctl \
    -- add-port br-int vif0 \
    -- set Interface vif0 external_ids:iface-id=lsp0 \
    -- add-port br-int vif1 \
    -- set Interface vif1 external_ids:iface-id=lsp1

wait_for_ports_up

meta=$(ovn-sbctl get datapath ls1 tunnel_key)
port=$(ovn-sbctl get port_binding ls1-rp tunnel_key)
check ovn-nbctl lrp-add lr0 rp-ls1 00:00:01:01:02:03 192.168.1.254/24

OVS_WAIT_UNTIL([as hv1 ovs-ofctl dump-flows br-int | grep table=40 | grep -q "reg15=0x${port},metadata=0x${meta}"])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

AT_SETUP([ovn-controller - I-P for address set update: no conjunction])
AT_KEYWORDS([as-i-p])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

dp_key=$(printf "%x" $(fetch_column datapath tunnel_key external_ids:name=ls1))
port_key=$(printf "%x" $(fetch_column port_binding tunnel_key logical_port=ls1-lp1))

read_counter() {
    ovn-appctl -t ovn-controller coverage/read-counter $1
}

ovn-nbctl create address_set name=as1
check ovn-nbctl --wait=hv acl-add ls1 to-lport 100 'outport == "ls1-lp1" && ip4.src == $as1' drop

# Add IPs to as1 for 10 times, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    check ovn-nbctl add address_set as1 addresses 10.0.0.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,ip,reg15=0x1,metadata=0x1,nw_src=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x1,metadata=0x1,nw_src=10.0.0.2 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x1,metadata=0x1,nw_src=10.0.0.3 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    fi
    AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$i
])
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

# Remove the IPs from as1, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    check ovn-nbctl remove address_set as1 addresses 10.0.0.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 9; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}'], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.10 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    fi
    if test "$i" = 10; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep "priority=1100"], [1], [ignore])
    else
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((10 - $i))
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
# when the old/new AS size is smaller than 2, fallback to reprocessing, so
# there are still 2 reprocessing when the AS size is below 2.
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

# Add IPs to as1 for 10 times, 2 IPs each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    check ovn-nbctl add address_set as1 addresses 10.0.0.$i,10.0.1.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.1.1 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.1.2 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.1.3 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    fi
    AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$(($i * 2))
])
done

reprocess_count_new=$(read_counter consider_logical_flow)
# When change from 0 to 2, still reprocessing.
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [1
])

# Add and remove IPs at the same time.

# Add 2 and remove 1
reprocess_count_old=$(read_counter consider_logical_flow)

check ovn-nbctl add address_set as1 addresses 10.0.0.21,10.0.0.22 -- \
                remove address_set as1 addresses 10.0.0.10
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.21], [0], [1
])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.22], [0], [1
])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.10], [1], [ignore])

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [0
])

# Add 1 and remove 2
reprocess_count_old=$(read_counter consider_logical_flow)

check ovn-nbctl remove address_set as1 addresses 10.0.0.21,10.0.0.22 -- \
                add address_set as1 addresses 10.0.0.10
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.21], [1], [ignore])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.22], [1], [ignore])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.10], [0], [1
])

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [0
])

# Add 1 and remove 1
reprocess_count_old=$(read_counter consider_logical_flow)

check ovn-nbctl add address_set as1 addresses 10.0.0.21 -- \
                remove address_set as1 addresses 10.0.0.10
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.21], [0], [1
])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.10], [1], [ignore])

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [0
])

# Add 2 and remove 2
reprocess_count_old=$(read_counter consider_logical_flow)

check ovn-nbctl add address_set as1 addresses 10.0.0.22,10.0.0.23 -- \
                remove address_set as1 addresses 10.0.0.9,10.0.0.8
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.22], [0], [1
])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.23], [0], [1
])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.8], [1], [ignore])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.9], [1], [ignore])

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [0
])

OVN_CLEANUP([hv1])
AT_CLEANUP

# This is similar to the above test but to test conjunction
AT_SETUP([ovn-controller - I-P for address set update: with conjunction])
AT_KEYWORDS([as-i-p])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

dp_key=$(printf "%x" $(fetch_column datapath tunnel_key external_ids:name=ls1))
port_key=$(printf "%x" $(fetch_column port_binding tunnel_key logical_port=ls1-lp1))

read_counter() {
    ovn-appctl -t ovn-controller coverage/read-counter $1
}

ovn-nbctl create address_set name=as1
check ovn-nbctl --wait=hv acl-add ls1 to-lport 100 'outport == "ls1-lp1" && ip4.src == $as1 && tcp && tcp.dst == {111, 222, 333}' drop

# Add IPs to as1 for 10 times, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    check ovn-nbctl add address_set as1 addresses 10.0.0.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 1; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1,tp_dst=111 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1,tp_dst=222 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1,tp_dst=333 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    else
        # (1 conj_id flow + 3 tp_dst flows) = 4 extra flows
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$(($i + 4))
])
    fi

    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | \
            sed -r 's/conjunction.*,/conjunction,/' | \
            sed -r 's/conj_id=.*,metadata/conj_id=,metadata/' | sort], [0], [dnl
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=111 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=222 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=333 actions=conjunction,2/2)
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

# Remove the IPs from as1, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    check ovn-nbctl remove address_set as1 addresses 10.0.0.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 10; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep "priority=1100"], [1], [ignore])
    elif test "$i" = 9; then
        # no conjunction left
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.10,tp_dst=111 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.10,tp_dst=222 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.10,tp_dst=333 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    else
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((14 - $i))
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

# Add IPs to as1 for 10 times, 2 IPs each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    check ovn-nbctl add address_set as1 addresses 10.0.0.$i,10.0.1.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | \
            sed -r 's/conjunction.*,/conjunction,/' | \
            sed -r 's/conj_id=.*,metadata/conj_id=,metadata/' | sort], [0], [dnl
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.1.1 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.1.2 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.1.3 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=111 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=222 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=333 actions=conjunction,2/2)
])
    fi
    AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$(($i * 2 + 4))
])
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [1
])

# Add and remove IPs at the same time.

# Add 2 and remove 1
reprocess_count_old=$(read_counter consider_logical_flow)

check ovn-nbctl add address_set as1 addresses 10.0.0.21,10.0.0.22 -- \
                remove address_set as1 addresses 10.0.0.10
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.21], [0], [1
])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.22], [0], [1
])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.10], [1], [ignore])

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [0
])

# Add 1 and remove 2
reprocess_count_old=$(read_counter consider_logical_flow)

check ovn-nbctl remove address_set as1 addresses 10.0.0.21,10.0.0.22 -- \
                add address_set as1 addresses 10.0.0.10
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.21], [1], [ignore])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.22], [1], [ignore])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.10], [0], [1
])

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [0
])

# Add 1 and remove 1
reprocess_count_old=$(read_counter consider_logical_flow)

check ovn-nbctl add address_set as1 addresses 10.0.0.21 -- \
                remove address_set as1 addresses 10.0.0.10
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.21], [0], [1
])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.10], [1], [ignore])

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [0
])

# Add 2 and remove 2
reprocess_count_old=$(read_counter consider_logical_flow)

check ovn-nbctl add address_set as1 addresses 10.0.0.22,10.0.0.23 -- \
                remove address_set as1 addresses 10.0.0.9,10.0.0.8
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.22], [0], [1
])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c 10\.0\.0\.23], [0], [1
])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.8], [1], [ignore])
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep 10\.0\.0\.9], [1], [ignore])

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [0
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - I-P for address set update: multiple ASes used by same lflow])
AT_KEYWORDS([as-i-p])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

dp_key=$(printf "%x" $(fetch_column datapath tunnel_key external_ids:name=ls1))
port_key=$(printf "%x" $(fetch_column port_binding tunnel_key logical_port=ls1-lp1))

read_counter() {
    ovn-appctl -t ovn-controller coverage/read-counter $1
}

ovn-nbctl create address_set name=as1
ovn-nbctl create address_set name=as2
check ovn-nbctl --wait=hv acl-add ls1 to-lport 100 'outport == "ls1-lp1" && ip4.src == $as1 && ip4.dst == $as2' drop

# Add IPs to as1 and as2, with some of the IPs overlapping
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    j=$(($i + 5))
    check ovn-nbctl add address_set as1 addresses 10.0.0.$i -- \
                    add address_set as2 addresses 10.0.0.$j
    check ovn-nbctl --wait=hv sync
    if test "$i" = 1; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1,nw_dst=10.0.0.6 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    else
        # (1 conj_id + nw_src * i + nw_dst * i) = 1 + i*2 flows
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$(($i*2 + 1))
])
    fi

    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | \
            sed -r 's/conjunction.*,/conjunction,/' | \
            sed -r 's/conj_id=.*,metadata/conj_id=,metadata/' | sort], [0], [dnl
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.6 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.7 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.8 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3 actions=conjunction,2/2)
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

# Remove the IPs from as1 and as2, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    j=$(($i + 5))
    check ovn-nbctl remove address_set as1 addresses 10.0.0.$i -- \
                    remove address_set as2 addresses 10.0.0.$j
    check ovn-nbctl --wait=hv sync
    if test "$i" = 10; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep "priority=1100"], [1], [ignore])
    elif test "$i" = 9; then
        # no conjunction left
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.10,nw_dst=10.0.0.15 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    else
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((21 - $i*2))
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

# Add 1 IP back to both ASes
check ovn-nbctl add address_set as1 addresses 10.0.0.1 -- \
                add address_set as2 addresses 10.0.0.6
check ovn-nbctl --wait=hv sync

# Add IPs to as1 only
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 2 10); do
    check ovn-nbctl add address_set as1 addresses 10.0.0.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1,nw_dst=10.0.0.6 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2,nw_dst=10.0.0.6 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3,nw_dst=10.0.0.6 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    fi
    AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$i
])
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [1
])

# Add 1 more IP back to as2
check ovn-nbctl add address_set as2 addresses 10.0.0.7
check ovn-nbctl --wait=hv sync

# Remove IPs from as1 only
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    check ovn-nbctl remove address_set as1 addresses 10.0.0.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 9; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}'], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.10,nw_dst=10.0.0.6 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.10,nw_dst=10.0.0.7 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    elif test "$i" = 10; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep "priority=1100"], [1], [ignore])
    else
        # 2 dst + (10 - i) src + 1 conj_id
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((10 - $i + 3))
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - I-P for address set update: OR on multiple ASes, different fields])
AT_KEYWORDS([as-i-p])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

dp_key=$(printf "%x" $(fetch_column datapath tunnel_key external_ids:name=ls1))
port_key=$(printf "%x" $(fetch_column port_binding tunnel_key logical_port=ls1-lp1))

read_counter() {
    ovn-appctl -t ovn-controller coverage/read-counter $1
}

ovn-nbctl create address_set name=as1
ovn-nbctl create address_set name=as2

# OR on different fields
check ovn-nbctl --wait=hv acl-add ls1 to-lport 100 'outport == "ls1-lp1" && (ip4.src == $as1 || ip4.dst == $as2)' drop

# Add IPs to as1 and as2, with some of the IPs overlapping
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    j=$(($i + 5))
    check ovn-nbctl add address_set as1 addresses 10.0.0.$i -- \
                    add address_set as2 addresses 10.0.0.$j
    check ovn-nbctl --wait=hv sync
    if test "$i" = 1; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.6 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    else
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$(($i*2))
])
    fi

    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | \
            sed -r 's/conjunction.*,/conjunction,/' | \
            sed -r 's/conj_id=.*,/conj_id=,/' | sort], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.6 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.7 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.8 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [10
])

# Remove the IPs from as1 and as2, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    j=$(($i + 5))
    check ovn-nbctl remove address_set as1 addresses 10.0.0.$i -- \
                    remove address_set as2 addresses 10.0.0.$j
    check ovn-nbctl --wait=hv sync
    if test "$i" = 10; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep "priority=1100"], [1], [ignore])
    else
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((20 - $i*2))
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
# In this case the two sub expr for as1 and as2 are merged, so we lose track of
# address set information - can't handle deletion incrementally.
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [10
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - I-P for address set update: OR on multiple ASes, same field])
AT_KEYWORDS([as-i-p])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

dp_key=$(printf "%x" $(fetch_column datapath tunnel_key external_ids:name=ls1))
port_key=$(printf "%x" $(fetch_column port_binding tunnel_key logical_port=ls1-lp1))

read_counter() {
    ovn-appctl -t ovn-controller coverage/read-counter $1
}

ovn-nbctl create address_set name=as1
ovn-nbctl create address_set name=as2

# OR on the same field
check ovn-nbctl --wait=hv acl-add ls1 to-lport 100 'outport == "ls1-lp1" && ip4.src == {$as1, $as2}' drop

# Add IPs to as1 and as2, with some of the IPs overlapping
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    j=$(($i + 5))
    check ovn-nbctl add address_set as1 addresses 10.0.0.$i -- \
                    add address_set as2 addresses 10.0.0.$j
    check ovn-nbctl --wait=hv sync
    if test "$i" = 1; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.6 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    elif test "$i" -lt 6; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$(($i*2))
])
    else
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((5 + $i))
])
    fi

    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | \
            sed -r 's/conjunction.*,/conjunction,/' | \
            sed -r 's/conj_id=.*,/conj_id=,/' | sort], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.6 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.7 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.8 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [10
])

# Remove the IPs from as1 and as2, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    j=$(($i + 5))
    check ovn-nbctl remove address_set as1 addresses 10.0.0.$i -- \
                    remove address_set as2 addresses 10.0.0.$j
    check ovn-nbctl --wait=hv sync
    if test "$i" = 10; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep "priority=1100"], [1], [ignore])
    elif test "$i" -lt 6; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((15 - $i))
])
    else
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((10 - ($i - 5)*2))
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
# In this case the as1 and as2 are merged to a single OR expr, so we lose track of
# address set information - can't handle deletion incrementally.
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [10
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - I-P for address set update: same AS used twice in same lflow])
AT_KEYWORDS([as-i-p])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

dp_key=$(printf "%x" $(fetch_column datapath tunnel_key external_ids:name=ls1))
port_key=$(printf "%x" $(fetch_column port_binding tunnel_key logical_port=ls1-lp1))

read_counter() {
    ovn-appctl -t ovn-controller coverage/read-counter $1
}

ovn-nbctl create address_set name=as1
check ovn-nbctl --wait=hv acl-add ls1 to-lport 100 'outport == "ls1-lp1" && ip4.src == $as1 && ip4.dst == $as1' drop

# Add IPs to as1 for 10 times, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    check ovn-nbctl add address_set as1 addresses 10.0.0.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 1; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1,nw_dst=10.0.0.1 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    else
        # (1 conj_id + nw_src * i + nw_dst * i) = 1 + i*2 flows
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$(($i*2 + 1))
])
    fi

    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | \
            sed -r 's/conjunction.*,/conjunction,/' | \
            sed -r 's/conj_id=.*,metadata/conj_id=,metadata/' | sort], [0], [dnl
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.1 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.2 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.3 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3 actions=conjunction,2/2)
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

# Remove the IPs from as1, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    check ovn-nbctl remove address_set as1 addresses 10.0.0.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 10; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep "priority=1100"], [1], [ignore])
    elif test "$i" = 9; then
        # no conjunction left
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.10,nw_dst=10.0.0.10 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    else
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((21 - $i*2))
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

# Add IPs to as1 for 10 times, 2 IPs each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 10); do
    check ovn-nbctl add address_set as1 addresses 10.0.0.$i,10.0.1.$i
    check ovn-nbctl --wait=hv sync
    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | \
            sed -r 's/conjunction.*,/conjunction,/' | \
            sed -r 's/conj_id=.*,metadata/conj_id=,metadata/' | sort], [0], [dnl
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.1 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.2 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.3 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.1.1 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.1.2 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.1.3 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.1.1 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.1.2 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.1.3 actions=conjunction,2/2)
])
    fi
    AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$(($i * 4 + 1))
])
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [1
])

# Test the case when there are two references to the same AS but one of the
# references is combined with another IP.
check ovn-nbctl acl-del ls1
check ovn-nbctl acl-add ls1 to-lport 100 'outport == "ls1-lp1" && ip4.src == {$as1, 10.10.10.10} && ip4.dst == $as1' drop

# Reset as1 to 3 IPs
check ovn-nbctl set address_set as1 addresses=10.0.0.1,10.0.0.2,10.0.0.3
check ovn-nbctl --wait=hv sync

# Add 2 IPs
reprocess_count_old=$(read_counter consider_logical_flow)
check ovn-nbctl add address_set as1 addresses 10.0.0.4,10.0.0.5
check ovn-nbctl --wait=hv sync
AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
    grep -v reply | awk '{print $7, $8}' | \
    sed -r 's/conjunction.*,/conjunction,/' | \
    sed -r 's/conj_id=.*,metadata/conj_id=,metadata/' | sort], [0], [dnl
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.1 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.2 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.3 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.4 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.5 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.4 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.5 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.10.10.10 actions=conjunction,2/2)
])
reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [1
])

# Delete 2 IPs
reprocess_count_old=$(read_counter consider_logical_flow)
check ovn-nbctl --wait=hv remove address_set as1 addresses 10.0.0.4,10.0.0.5
AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
    grep -v reply | awk '{print $7, $8}' | \
    sed -r 's/conjunction.*,/conjunction,/' | \
    sed -r 's/conj_id=.*,metadata/conj_id=,metadata/' | sort], [0], [dnl
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.1 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.2 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_dst=10.0.0.3 actions=conjunction,1/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.1 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.2 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.3 actions=conjunction,2/2)
priority=1100,ip,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.10.10.10 actions=conjunction,2/2)
])
reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [1
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - I-P for address set update: conjunctions overlaping with other lflows])
AT_KEYWORDS([as-i-p])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

dp_key=$(printf "%x" $(fetch_column datapath tunnel_key external_ids:name=ls1))
port_key=$(printf "%x" $(fetch_column port_binding tunnel_key logical_port=ls1-lp1))

read_counter() {
    ovn-appctl -t ovn-controller coverage/read-counter $1
}

# Initial state:
# 2 ASes, each has 3 IPs, no overlapping.
# 2 ACLs, each should generate a conjunction, and 1 overlapping tcp.dst
# generating a flow with combined conjunctions.
ovn-nbctl create address_set name=as1 addresses=10.0.0.11,10.0.0.12,10.0.0.13
ovn-nbctl create address_set name=as2 addresses=10.0.0.21,10.0.0.22,10.0.0.23
check ovn-nbctl acl-add ls1 to-lport 100 'outport == "ls1-lp1" && ip4.src == $as1 && tcp && tcp.dst == {101, 102}' drop
check ovn-nbctl acl-add ls1 to-lport 100 'outport == "ls1-lp1" && ip4.src == $as2 && tcp && tcp.dst == {201, 202}' drop

check ovn-nbctl --wait=hv sync
AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
    grep -v reply | awk '{print $7, $8}' | \
    sed -r 's/conjunction.[[0-9]]*,/conjunction,/g' | \
    sed -r 's/conj_id=.*,metadata/conj_id=,metadata/' | sort], [0], [dnl
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.11 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.12 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.13 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.21 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.22 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.23 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=101 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=102 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=201 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=202 actions=conjunction,2/2)
])

# Add 2 IPs to each AS, one of the IPs overlapping, should generate combined
# conjunctions
reprocess_count_old=$(read_counter consider_logical_flow)

check ovn-nbctl add address_set as1 addresses 10.0.0.14,10.0.0.33 -- \
                add address_set as2 addresses 10.0.0.24,10.0.0.33
check ovn-nbctl --wait=hv sync
AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
    grep -v reply | awk '{print $7, $8}' | \
    sed -r 's/conjunction.[[0-9]]*,/conjunction,/g' | \
    sed -r 's/conj_id=.*,metadata/conj_id=,metadata/' | sort], [0], [dnl
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.11 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.12 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.13 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.14 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.21 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.22 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.23 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.24 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.33 actions=conjunction,1/2),conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=101 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=102 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=201 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=202 actions=conjunction,2/2)
])

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [0
])

# Remove those 2 IPs from each AS, should return to the initial state
reprocess_count_old=$(read_counter consider_logical_flow)

check ovn-nbctl remove address_set as1 addresses 10.0.0.14,10.0.0.33 -- \
                remove address_set as2 addresses 10.0.0.24,10.0.0.33
check ovn-nbctl --wait=hv sync
AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
    grep -v reply | awk '{print $7, $8}' | \
    sed -r 's/conjunction.[[0-9]]*,/conjunction,/g' | \
    sed -r 's/conj_id=.*,metadata/conj_id=,metadata/' | sort], [0], [dnl
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,conj_id=,metadata=0x$dp_key actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.11 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.12 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.13 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.21 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.22 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,nw_src=10.0.0.23 actions=conjunction,1/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=101 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=102 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=201 actions=conjunction,2/2)
priority=1100,tcp,reg15=0x$port_key,metadata=0x$dp_key,tp_dst=202 actions=conjunction,2/2)
])

reprocess_count_new=$(read_counter consider_logical_flow)
# Because of the combined conjunction, AS cannot be tracked for the flow for
# 10.0.0.33, so removing would trigger reprocessing.
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - I-P for address set update: mac])
AT_KEYWORDS([as-i-p])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

dp_key=$(printf "%x" $(fetch_column datapath tunnel_key external_ids:name=ls1))
port_key=$(printf "%x" $(fetch_column port_binding tunnel_key logical_port=ls1-lp1))

read_counter() {
    ovn-appctl -t ovn-controller coverage/read-counter $1
}

ovn-nbctl create address_set name=as1
check ovn-nbctl --wait=hv acl-add ls1 to-lport 100 'outport == "ls1-lp1" && eth.src == $as1' drop

# Add MACs to as1 for 5 times.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 5); do
    check ovn-nbctl add address_set as1 addresses "aa\:aa\:aa\:aa\:aa\:0$i"
    check ovn-nbctl --wait=hv sync
    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,reg15=0x$port_key,metadata=0x$dp_key,dl_src=aa:aa:aa:aa:aa:01 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,reg15=0x$port_key,metadata=0x$dp_key,dl_src=aa:aa:aa:aa:aa:02 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,reg15=0x$port_key,metadata=0x$dp_key,dl_src=aa:aa:aa:aa:aa:03 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    fi
    AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$i
])
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

# Remove the MACs from as1.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 5); do
    check ovn-nbctl remove address_set as1 addresses "aa\:aa\:aa\:aa\:aa\:0$i"
    check ovn-nbctl --wait=hv sync
    ovs-ofctl dump-flows br-int table=46 | grep "priority=1100"
    if test "$i" = 4; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}'], [0], [dnl
priority=1100,reg15=0x$port_key,metadata=0x$dp_key,dl_src=aa:aa:aa:aa:aa:05 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    fi
    if test "$i" = 5; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep "priority=1100"], [1], [ignore])
    else
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((5 - $i))
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - I-P for address set update: ipv6])
AT_KEYWORDS([as-i-p])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

dp_key=$(printf "%x" $(fetch_column datapath tunnel_key external_ids:name=ls1))
port_key=$(printf "%x" $(fetch_column port_binding tunnel_key logical_port=ls1-lp1))

read_counter() {
    ovn-appctl -t ovn-controller coverage/read-counter $1
}

ovn-nbctl create address_set name=as1
check ovn-nbctl --wait=hv acl-add ls1 to-lport 100 'outport == "ls1-lp1" && ip6.src == $as1' drop

# Add IPs to as1 for 5 times, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 5); do
    check ovn-nbctl add address_set as1 addresses "ff\:\:0$i"
    check ovn-nbctl --wait=hv sync
    if test "$i" = 3; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}' | sort], [0], [dnl
priority=1100,ipv6,reg15=0x$port_key,metadata=0x$dp_key,ipv6_src=ff::1 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ipv6,reg15=0x$port_key,metadata=0x$dp_key,ipv6_src=ff::2 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
priority=1100,ipv6,reg15=0x$port_key,metadata=0x$dp_key,ipv6_src=ff::3 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    fi
    AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$i
])
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

# Remove the IPs from as1, 1 IP each time.
reprocess_count_old=$(read_counter consider_logical_flow)

for i in $(seq 5); do
    check ovn-nbctl remove address_set as1 addresses "ff\:\:0$i"
    check ovn-nbctl --wait=hv sync
    if test "$i" = 4; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46,reg15=0x$port_key | \
            grep -v reply | awk '{print $7, $8}'], [0], [dnl
priority=1100,ipv6,reg15=0x$port_key,metadata=0x$dp_key,ipv6_src=ff::5 actions=load:0x1->OXM_OF_PKT_REG4[[49]],resubmit(,47)
])
    fi
    if test "$i" = 5; then
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep "priority=1100"], [1], [ignore])
    else
        AT_CHECK_UNQUOTED([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [$((5 - $i))
])
    fi
done

reprocess_count_new=$(read_counter consider_logical_flow)
AT_CHECK([echo $(($reprocess_count_new - $reprocess_count_old))], [0], [2
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - address set del-and-add])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

ovn-nbctl create address_set name=as1 addresses=8.8.8.8
check ovn-nbctl acl-add ls1 to-lport 100 'outport == "ls1-lp1" && ip4.src == $as1' drop
check ovn-nbctl --wait=hv sync
AT_CHECK([ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100"], [0], [1
])

# pause ovn-northd
check as northd ovn-appctl -t ovn-northd pause

# Simulate a SB address set "del and add" notification to ovn-controller in the
# same IDL iteration. The flows programmed by ovn-controller should reflect the
# newly added address set. In reality it can happen when CMS deletes an
# address-set and immediately creates a new address-set with the same name
# (with same or different content). The notification of the changes can come to
# ovn-controller in one shot and the order of the "del" and "add" in the IDL is
# undefined. This test runs the scenario ten times to make sure different
# orders are covered and handled properly.

flow_count=$(ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100")
for i in $(seq 10); do
    # Delete and recreate the SB address set with same name and an extra IP.
    addrs_=$(fetch_column address_set addresses name=as1)
    addrs=${addrs_// /,}
    AT_CHECK([ovn-sbctl destroy address_set as1 -- create address_set name=as1 addresses=$addrs,1.1.1.$i], [0], [ignore])
    OVS_WAIT_UNTIL([test $(as hv1 ovs-ofctl dump-flows br-int table=46 | grep -c "priority=1100") = "$(($i + 1))"])
done

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - I-P handle lb_hairpin_use_ct_mark change])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01"

wait_for_ports_up
ovn-appctl -t ovn-controller vlog/set file:dbg

read_counter() {
    ovn-appctl -t ovn-controller coverage/read-counter $1
}

# nb_cfg update in sb_global shouldn't trigger lflow_run.
lflow_run_old=$(read_counter lflow_run)
check ovn-nbctl --wait=hv sync
lflow_run_new=$(read_counter lflow_run)
AT_CHECK([echo $(($lflow_run_new - $lflow_run_old))], [0], [0
])

# lb_hairpin_use_ct_mark update in sb_global:options should trigger lflow_run.
# The below steps should cause lb_hairpin_use_ct_mark change twice. One by
# ovn-sbctl, and the other by ovn-northd to change it back.

# In some cases, both changes are catched by ovn-controller in the same run,
# ending up in no change.

OVS_WAIT_UNTIL([
    lflow_run_old=$(read_counter lflow_run)
    check ovn-sbctl set SB_Global . options:lb_hairpin_use_ct_mark=false
    check ovn-nbctl --wait=hv sync
    lflow_run_new=$(read_counter lflow_run)
    test x"$(($lflow_run_new - $lflow_run_old))" = x2
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - ofctrl wait before clearing flows])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=ls1-lp1

check ovn-nbctl ls-add ls1

check ovn-nbctl lsp-add ls1 ls1-lp1 \
-- lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.1.2.3"

check ovn-nbctl lb-add lb1 1.1.1.1 10.1.2.3 \
-- ls-lb-add ls1 lb1

check ovn-nbctl lb-add lb2 2.2.2.2 10.1.2.4 \
-- ls-lb-add ls1 lb2

check ovn-nbctl --wait=hv sync
# There should be 2 group IDs allocated
AT_CHECK([ovn-appctl -t ovn-controller group-table-list | awk '{print $2}' | sort | uniq | wc -l], [0], [2
])

# Stop ovn-controller
OVS_APP_EXIT_AND_WAIT([ovn-controller])

# Set 5 seconds wait time before clearing OVS flows.
check ovs-vsctl set open . external_ids:ovn-ofctrl-wait-before-clear=5000

# The old OVS flows should remain (this is regardless of the configuration)
AT_CHECK([ovs-ofctl dump-flows br-int | grep -F 10.1.2.3], [0], [ignore])

# We should have 2 flows with groups.
AT_CHECK([ovs-ofctl dump-flows br-int | grep group -c], [0], [2
])

# Make a change to the ls1-lp1's IP
check ovn-nbctl --wait=sb lsp-set-addresses ls1-lp1 "f0:00:00:00:00:01 10.1.2.4"

# Start ovn-controller, which should compute new flows but not apply them
# until the wait time is completed.
start_daemon ovn-controller

# Wait for octrl to run - it will handle the wait-before-clear
OVS_WAIT_UNTIL([grep -q 'wait-before-clear' hv1/ovn-controller.log])

# Check that there is no flow using 10.1.2.4 except the lb one (using 2.2.2.2)
OVS_WAIT_UNTIL([test 0 = $(ovs-ofctl dump-flows br-int | grep -F 10.1.2.4 | grep -cvF 2.2.2.2)])

# Check in the middle of the wait.
lflow_run_1=$(ovn-appctl -t ovn-controller coverage/read-counter lflow_run)
AT_CHECK([ovs-ofctl dump-flows br-int | grep -F 10.1.2.3], [0], [ignore])

# We should have 2 flows with groups.
AT_CHECK([ovs-ofctl dump-flows br-int | grep group -c], [0], [2
])

sleep 5

# Check after the wait
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep -F 10.1.2.4 | grep -vF 2.2.2.2])

# We should have 2 flows with groups.
AT_CHECK([ovs-ofctl dump-flows br-int | grep group -c], [0], [2
])
lflow_run_2=$(ovn-appctl -t ovn-controller coverage/read-counter lflow_run)

# Verify that the flow compute completed during the wait (after the wait it
# merely installs the new flows).
AT_CHECK_UNQUOTED([echo $lflow_run_1], [0], [$lflow_run_2
])

# Restart OVS this time. Flows should be reinstalled without waiting.
# Set the wait-before-clear to a large value (60s) to make the test more reliable.
check ovs-vsctl set open . external_ids:ovn-ofctrl-wait-before-clear=60000
check ovn-nbctl --wait=hv sync

OVS_APP_EXIT_AND_WAIT([ovs-vswitchd])
start_daemon ovs-vswitchd --enable-dummy=system -vvconn -vofproto_dpif -vunixctl

# Flow should be installed without waiting for another 60s.
OVS_WAIT_UNTIL([ovs-ofctl dump-flows br-int | grep -F 10.1.2.4 | grep -vF 2.2.2.2])

check ovn-nbctl --wait=hv lb-add lb3 3.3.3.3 10.1.2.5 \
-- ls-lb-add ls1 lb3

# There should be 3 group IDs allocated (this is to ensure the group ID
# allocation is correct after ofctrl state reset.
AT_CHECK([ovn-appctl -t ovn-controller group-table-list | awk '{print $2}' | sort | uniq | wc -l], [0], [3
])

# We should have 3 flows with groups.
AT_CHECK([ovs-ofctl dump-flows br-int | grep group -c], [0], [3
])

OVN_CLEANUP([hv1])
AT_CLEANUP


AT_SETUP([ovn-controller - check ovn-chassis-mac-mappings])

ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

pid=$(cat hv1/ovn-controller.pid)

# Add chassis with some ovn-chassis-mac-mappings
AT_CHECK([ovn-sbctl chassis-add foo geneve 127.0.0.2])
AT_CHECK([ovn-sbctl set chassis foo other_config:ovn-chassis-mac-mappings="invalid1,invalid2,br1:00:00:00:00:00:00"])
AT_CHECK([ovn-nbctl --wait=hv sync])

# Check if ovn-controller is still alive
AT_CHECK([ps $pid], [0], [ignore])
# Check if we got warnings for invalid
AT_CHECK([grep "Parsing of ovn-chassis-mac-mappings failed" hv1/ovn-controller.log | grep -q invalid1])
AT_CHECK([grep "Parsing of ovn-chassis-mac-mappings failed" hv1/ovn-controller.log | grep -q invalid2])
AT_CHECK([grep "Parsing of ovn-chassis-mac-mappings failed" hv1/ovn-controller.log | grep -q br1], [1])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - localport can be recreated])

ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

port_binding_cookie() {
    name=$1
    ovn-sbctl --bare --columns _uuid find port_binding logical_port=$name |\
    cut -d '-' -f 1 | tr -d '\n' | sed 's/^0\{0,8\}//'
}

create_localport() {
    AT_CHECK([ovn-nbctl lsp-add ls0 metadata])
    AT_CHECK([ovn-nbctl lsp-set-type metadata localport])
    AT_CHECK([ovn-nbctl lsp-set-addresses metadata "00:00:00:00:10:25 192.168.10.25"])
}

bind_ports() {
    AT_CHECK([ovs-vsctl add-port br-int vm0 -- set interface vm0 type=internal external_ids:iface-id=vm0])
    AT_CHECK([ovs-vsctl add-port br-int metadata -- set interface metadata type=internal external_ids:iface-id=metadata])
}

# Create one VIF and localport and bind it to chassis
AT_CHECK([ovn-nbctl ls-add ls0])
AT_CHECK([ovn-nbctl lsp-add ls0 vm0])
AT_CHECK([ovn-nbctl lsp-set-addresses vm0 "00:00:00:00:10:10 192.168.10.10"])
create_localport
bind_ports

# Check that localport has all physical flows defined
OVS_WAIT_UNTIL([test 6 = $(as hv1 ovs-ofctl dump-flows br-int | grep -c $(port_binding_cookie metadata))])

# Remove ls0 from local datapaths
AT_CHECK([ovs-vsctl del-port br-int vm0])
AT_CHECK([ovn-appctl inc-engine/recompute])

# Check that localports physical flows are removed
OVS_WAIT_UNTIL([test 0 = $(as hv1 ovs-ofctl dump-flows br-int | grep -c $(port_binding_cookie metadata))])

# The order is impotant, if the port is removed first, the bug wouldn't be triggered
AT_CHECK([ovn-nbctl lsp-del metadata])
AT_CHECK([ovs-vsctl del-port br-int metadata])
create_localport
bind_ports

# Check that localport has all physical flows re-defined
OVS_WAIT_UNTIL([test 6 = $(as hv1 ovs-ofctl dump-flows br-int | grep -c $(port_binding_cookie metadata))])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - restart should not delete patch ports])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=lsp1
check ovs-vsctl add-br br-ext -- \
    set open . external-ids:ovn-bridge-mappings=extnet:br-ext

# Create logical topology so that lsp1 has multiple hops to a localnet port,
# which would require multiple iterations to download the related datapaths and
# port_bindings from SB DB during startup.
#
# lsp1@hv1 -- ls1 -- lr1 -- ls2 -- lr2 -- ls-ext -- lsp-ext (localnet)

check ovn-appctl -t ovn-controller vlog/set file:dbg
check ovn-nbctl ls-add ls1 \
    -- lsp-add ls1 lsp1 \
    -- lsp-set-addresses lsp1 "f0:00:00:00:00:01 10.0.1.2"
check ovn-nbctl lr-add lr1 \
    -- lrp-add lr1 lrp-lr1-ls1 f0:00:aa:00:01:01 10.0.1.1/24 \
    -- lsp-add ls1 lsp-ls1-lr1 \
    -- lsp-set-type lsp-ls1-lr1 router \
    -- lsp-set-options lsp-ls1-lr1 router-port=lrp-lr1-ls1 \
    -- lsp-set-addresses lsp-ls1-lr1 router
check ovn-nbctl ls-add ls2 \
    -- lrp-add lr1 lrp-lr1-ls2 f0:00:aa:00:01:02 10.0.2.1/24 \
    -- lsp-add ls2 lsp-ls2-lr1 \
    -- lsp-set-type lsp-ls2-lr1 router \
    -- lsp-set-options lsp-ls2-lr1 router-port=lrp-lr1-ls2 \
    -- lsp-set-addresses lsp-ls2-lr1 router
check ovn-nbctl lr-add lr2 \
    -- lrp-add lr2 lrp-lr2-ls2 f0:00:aa:00:02:02 10.0.2.2/24 \
    -- lsp-add ls2 lsp-ls2-lr2 \
    -- lsp-set-type lsp-ls2-lr2 router \
    -- lsp-set-options lsp-ls2-lr2 router-port=lrp-lr2-ls2 \
    -- lsp-set-addresses lsp-ls2-lr2 router
check ovn-nbctl ls-add ls-ext \
    -- lrp-add lr2 lrp-lr2-ext f0:00:aa:00:02:03 10.0.3.1/24 \
    -- lsp-add ls-ext lsp-ext-lr2 \
    -- lsp-set-type lsp-ext-lr2 router \
    -- lsp-set-options lsp-ext-lr2 router-port=lrp-lr2-ext \
    -- lsp-set-addresses lsp-ext-lr2 router
check ovn-nbctl lsp-add ls-ext lsp-ext \
    -- lsp-set-type lsp-ext localnet \
    -- lsp-set-options lsp-ext network_name=extnet \
    -- lsp-set-addresses lsp-ext unknown
check ovn-nbctl --wait=hv sync

AT_CHECK([ovs-vsctl list-ports br-int | grep patch-br-int-to-lsp-ext], [0], [ignore])

# Stop ovn-controller
OVS_APP_EXIT_AND_WAIT([ovn-controller])

# Start ovn-controller, which shouldn't cause any patch interface
# deletion/recreation
start_daemon ovn-controller
for i in $(seq 20); do
    check ovn-nbctl --wait=hv sync
done

AT_CHECK([grep "deleted interface patch" hv1/ovs-vswitchd.log], [1], [ignore])
OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - resolve CT zone conflicts from ovsdb])

ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

get_zone_num () {
    output=$1
    name=$2
    printf "$output" | grep $name | cut -d ' ' -f 2
}

check_ovsdb_zone() {
    name=$1
    ct_zone=$2
    db_zone=$(ovs-vsctl get Bridge br-int external_ids:ct-zone-${name} | sed -e 's/^"//' -e 's/"$//')
    test $ct_zone -eq $db_zone
}

check ovs-vsctl add-port br-int ls0-hv1 -- set Interface ls0-hv1 external-ids:iface-id=ls0-hv1
check ovs-vsctl add-port br-int ls0-hv2 -- set Interface ls0-hv2 external-ids:iface-id=ls0-hv2

check ovn-nbctl lr-add lr0

check ovn-nbctl ls-add ls0
check ovn-nbctl lsp-add ls0 ls0-lr0
check ovn-nbctl lsp-set-type ls0-lr0 router
check ovn-nbctl lsp-set-addresses ls0-lr0 router
check ovn-nbctl lrp-add lr0 lr0-ls0 00:00:00:00:00:01 10.0.0.1

check ovn-nbctl lsp-add ls0 ls0-hv1
check ovn-nbctl lsp-set-addresses ls0-hv1 "00:00:00:00:00:02 10.0.0.2"

check ovn-nbctl lsp-add ls0 ls0-hv2
check ovn-nbctl lsp-set-addresses ls0-hv2 "00:00:00:00:00:03 10.0.0.3"

check ovn-nbctl lrp-add lr0 lrp-gw 01:00:00:00:00:01 172.16.0.1
check ovn-nbctl lrp-set-gateway-chassis lrp-gw hv1

check ovn-nbctl --wait=hv sync

ct_zones=$(ovn-appctl -t ovn-controller ct-zone-list)
echo "$ct_zones"

port1_zone=$(get_zone_num "$ct_zones" ls0-hv1)
port2_zone=$(get_zone_num "$ct_zones" ls0-hv2)

snat_zone=$(get_zone_num "$ct_zones" lr0_snat)
echo "snat_zone is $snat_zone"

check test "$port1_zone" -ne "$port2_zone"
check test "$port2_zone" -ne "$snat_zone"
check test "$port1_zone" -ne "$snat_zone"

OVS_WAIT_UNTIL([check_ovsdb_zone ls0-hv1 $port1_zone])
OVS_WAIT_UNTIL([check_ovsdb_zone ls0-hv2 $port2_zone])
OVS_WAIT_UNTIL([check_ovsdb_zone lr0_snat $snat_zone])

# Now purposely request an SNAT zone for lr0 that conflicts with a zone
# currently assigned to a logical port

snat_req_zone=$port1_zone
check ovn-nbctl set Logical_Router lr0 options:snat-ct-zone=$snat_req_zone
ovn-nbctl --wait=hv sync

ct_zones=$(ovn-appctl -t ovn-controller ct-zone-list)
echo "$ct_zones"

port1_zone=$(get_zone_num "$ct_zones" ls0-hv1)
port2_zone=$(get_zone_num "$ct_zones" ls0-hv2)
snat_zone=$(get_zone_num "$ct_zones" lr0_snat)

check test "$snat_zone" -eq "$snat_req_zone"
check test "$port1_zone" -ne "$port2_zone"
check test "$port2_zone" -ne "$snat_zone"
check test "$port1_zone" -ne "$snat_zone"

OVS_WAIT_UNTIL([check_ovsdb_zone ls0-hv1 $port1_zone])
OVS_WAIT_UNTIL([check_ovsdb_zone ls0-hv2 $port2_zone])
OVS_WAIT_UNTIL([check_ovsdb_zone lr0_snat $snat_zone])

# Now create a conflict in the OVSDB and restart ovn-controller.

ovs-vsctl set bridge br-int external_ids:ct-zone-ls0-hv1="$snat_req_zone"
ovs-vsctl set bridge br-int external_ids:ct-zone-ls0-hv2="$snat_req_zone"

ovn-appctl -t ovn-controller inc-engine/recompute

ct_zones=$(ovn-appctl -t ovn-controller ct-zone-list)
echo "$ct_zones"

port1_zone=$(get_zone_num "$ct_zones" ls0-hv1)
port2_zone=$(get_zone_num "$ct_zones" ls0-hv2)
snat_zone=$(get_zone_num "$ct_zones" lr0_snat)

check test "$snat_zone" -eq "$snat_req_zone"
check test "$port1_zone" -ne "$port2_zone"
check test "$port2_zone" -ne "$snat_zone"
check test "$port1_zone" -ne "$snat_zone"

OVS_WAIT_UNTIL([check_ovsdb_zone ls0-hv1 $port1_zone])
OVS_WAIT_UNTIL([check_ovsdb_zone ls0-hv2 $port2_zone])
OVS_WAIT_UNTIL([check_ovsdb_zone lr0_snat $snat_zone])

OVN_CLEANUP([hv1])
AT_CLEANUP

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - Local Chassis_Template_Var updates])
AT_KEYWORDS([templates])
ovn_start

net_add n1
sim_add hv
as hv
ovs-vsctl \
    -- add-br br-phys \
    -- add-br br-eth0 \
    -- add-br br-eth1 \
    -- add-br br-eth2
ovn_attach n1 br-phys 192.168.0.1

m4_define([GET_LOCAL_TEMPLATE_VARS],
    [ovn-appctl debug/dump-local-template-vars | grep -v 'Local template vars'])

dnl Expect no local vars initially.
AT_CHECK([GET_LOCAL_TEMPLATE_VARS], [1], [])

AT_CHECK([ovn-nbctl --wait=hv create Chassis_Template_Var chassis="hv"], [0], [ignore])
AT_CHECK([GET_LOCAL_TEMPLATE_VARS], [1], [])

dnl Expect new vars to be handled properly.
check ovn-nbctl --wait=hv set Chassis_Template_Var hv variables:foo=foo-hv variables:bar=bar-hv
AT_CHECK([GET_LOCAL_TEMPLATE_VARS], [0], [dnl
name: 'bar' value: 'bar-hv'
name: 'foo' value: 'foo-hv'
])

dnl Expect var updates to be handled properly.
check ovn-nbctl --wait=hv set Chassis_Template_Var hv variables:bar=bar-new-hv
AT_CHECK([GET_LOCAL_TEMPLATE_VARS], [0], [dnl
name: 'bar' value: 'bar-new-hv'
name: 'foo' value: 'foo-hv'
])

dnl Expect var deletions to be handled properly.
check ovn-nbctl --wait=hv remove Chassis_Template_Var hv variables bar
AT_CHECK([GET_LOCAL_TEMPLATE_VARS], [0], [dnl
name: 'foo' value: 'foo-hv'
])

check ovn-nbctl --wait=hv remove Chassis_Template_Var hv variables foo
AT_CHECK([GET_LOCAL_TEMPLATE_VARS], [1], [])

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - Requested SNAT Zone in router creation transaction])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

dnl This is key. Add the snat-ct-zone when creating the logical router and then
dnl do not make any further changes to the logical router settings.
check ovn-nbctl lr-add lr0 -- set Logical_Router lr0 options:snat-ct-zone=666
check ovn-nbctl lrp-add lr0 lrp-gw 01:00:00:00:00:01 172.16.0.1
check ovn-nbctl lrp-set-gateway-chassis lrp-gw hv1

check ovn-nbctl --wait=hv sync

ct_zones=$(ovn-appctl -t ovn-controller ct-zone-list)
zone_num=$(printf "$ct_zones" | grep lr0_snat | cut -d ' ' -f 2)

check test "$zone_num" -eq 666

AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - check unsupported chassis options removal])

ovn_start

net_add n1
sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1

ovn-nbctl --wait=sb sync
wait_row_count Chassis 1 name=hv1

chassis_id=$(fetch_column Chassis _uuid name=hv1)
check ovn-sbctl set chassis $chassis_id other_config:unsupported="value"

OVS_WAIT_UNTIL([grep -q 'Removing unsupported key "unsupported" from chassis record.' hv1/ovn-controller.log])

AT_CHECK([ovn-sbctl get chassis $chassis_id other_config:unsupported], [1], [ignore], [ignore])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

OVN_FOR_EACH_NORTHD([
AT_SETUP([ovn-controller - ovs iface change ofport])
AT_KEYWORDS([ovn])
ovn_start

net_add n1

sim_add hv1
as hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
ovs-vsctl -- add-port br-int hv1-vif1 -- \
    set interface hv1-vif1 external-ids:iface-id=sw0-p1 \
    options:tx_pcap=hv1/vif1-tx.pcap \
    options:rxq_pcap=hv1/vif1-rx.pcap \
    ofport-request=1


ovn-nbctl ls-add sw0

check ovn-nbctl lsp-add sw0 sw0-p1
check ovn-nbctl lsp-set-addresses sw0-p1 "50:54:00:00:00:03 10.0.0.3 1000::3"

wait_for_ports_up
ovn-nbctl --wait=hv sync

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=0 | grep -c in_port=1], [0],[dnl
1
])

# update the ovs interface ofport from 1 to 24
check as hv1 ovs-vsctl set Interface hv1-vif1 ofport-request=24
OVS_WAIT_UNTIL([test x`as hv1 ovs-vsctl get Interface hv1-vif1 ofport` = x24])

OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=0 | grep -c in_port=24], [0],[dnl
1
])
OVS_WAIT_FOR_OUTPUT([as hv1 ovs-ofctl dump-flows br-int table=0 | grep -c in_port=1], [1],[dnl
0
])

OVN_CLEANUP([hv1])
AT_CLEANUP
])

AT_SETUP([ovn-controller - ssl ciphers using command line options])
AT_KEYWORDS([ovn])
AT_SKIP_IF([test "$HAVE_OPENSSL" = no])
ovn_start

net_add n1
sim_add hv1
ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.20

# Set cipher and and it should connect
OVS_APP_EXIT_AND_WAIT([ovn-controller])
start_daemon ovn-controller --ssl-ciphers='HIGH:!aNULL:!MD5:@SECLEVEL=1' --ssl-protocols='TLSv1,TLSv1.1,TLSv1.2'

OVS_WAIT_FOR_OUTPUT([ovn-appctl -t ovn-controller connection-status], [0], [connected
])

OVN_CLEANUP([hv1])
AT_CLEANUP

AT_SETUP([ovn-controller - LB remove after disconnect])
ovn_start

net_add n1
sim_add hv1
as hv1
check ovs-vsctl add-br br-phys
ovn_attach n1 br-phys 192.168.0.1
check ovs-vsctl -- add-port br-int vif1 -- \
    set interface vif1 external-ids:iface-id=lsp

check ovs-vsctl set Open_vSwitch . external-ids:ovn-remote-probe-interval="5000"

check ovn-nbctl ls-add ls
check ovn-nbctl lsp-add ls lsp \
-- lsp-set-addresses lsp "f0:00:00:00:00:01 172.16.0.10"

check ovn-nbctl lb-add lb 192.168.100.100 172.16.0.10
check ovn-nbctl ls-lb-add ls lb

wait_for_ports_up
check ovn-nbctl --wait=hv sync

sleep_sb
OVS_WAIT_UNTIL([grep -q 'OVNSB commit failed' hv1/ovn-controller.log])

sleep_controller hv1
wake_up_sb

ovn-nbctl lb-del lb

wake_up_controller hv1
check ovn-nbctl --wait=hv sync

OVN_CLEANUP([hv1
/no response to inactivity probe after .* seconds, disconnecting/d])
AT_CLEANUP
